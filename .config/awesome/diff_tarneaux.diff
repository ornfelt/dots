diff --git a/README.rst b/README.rst
new file mode 100644
index 0000000..7fa6263
--- /dev/null
+++ b/README.rst
@@ -0,0 +1,182 @@
+Awesome WM Copycats
+===================
+
+-------------------------
+Themes for Awesome WM 4.x
+-------------------------
+
+:Author: Luca CPZ
+:Version: git
+:License: BY-SA_
+:Source: https://github.com/lcpz/awesome-copycats
+
+Description
+===========
+
+A set of themes for the Awesome_ window manager, version 4.x.
+
+See branches_ for previous versions.
+
+Purpose
+=======
+
+The main purpose of this repository is to spread ready to use configurations, which can also serve as a cookbook for customisation.
+
+A secondary aim is to add new themes only when they constitute different UI/UX designs.
+
+Features
+========
+
+- Modularity
+- Autohide widgets
+- Autostart windowless processes
+- Fast MPD and volume shortcuts (first time this trick has been used in Awesome)
+- Shortcuts for copying to the clipboard, toggle wiboxes, widgets popups, screenshots capture, moving and magnifying clients
+- Quake drop-down terminal
+- Calendar with current day highlighted and months switch with a click/scroll
+- Notifications for new mails, current song, volume level, hdd critical state, low battery
+- OpenWeatherMap integration
+- Net carrier status notifier
+- Symbolic tag names
+- DWM-like textual layoutbox
+- Cairo wibar
+- Custom layouts
+- No borders when there's only one visible client
+- Freedesktop.org compliant menu and desktop icons
+- Vi-like client focus
+- Non-empty tag browsing
+- On-the-fly useless gaps resize
+- Dynamic tagging
+
+Gallery
+=======
+
+**Multicolor**, inspired by lucamanni_
+
+.. image:: http://dotshare.it/public/images/uploads/650.png
+
+**Powerarrow**, porting of romockee_'s
+
+.. image:: http://dotshare.it/public/images/uploads/1453.png
+
+**Powerarrow Dark**
+
+.. image:: http://dotshare.it/public/images/uploads/649.jpg
+
+**Steamburn**, porting of ok100_'s dwm
+
+.. image:: http://dotshare.it/public/images/uploads/648.png
+
+**Blackburn**
+
+.. image:: http://dotshare.it/public/images/uploads/553.png
+
+**Dremora**
+
+.. image:: http://dotshare.it/public/images/uploads/652.png
+
+**Rainbow**
+
+.. image:: http://dotshare.it/public/images/uploads/606.png
+
+**Holo**, requested by amouly_
+
+.. image:: http://dotshare.it/public/images/uploads/651.jpg
+
+**Copland**, inspired by foozer_
+
+.. image:: http://dotshare.it/public/images/uploads/655.png
+
+**Vertex**, requested by swordfischer_
+
+.. image:: http://dotshare.it/public/images/uploads/1432.jpg
+
+Installation
+============
+
+.. code-block:: shell
+
+    git clone --recurse-submodules --remote-submodules --depth 1 -j 2 https://github.com/lcpz/awesome-copycats.git
+    mkdir -p ~/.config/awesome && mv -bv awesome-copycats/{*,.[^.]*} ~/.config/awesome &&  rm -rf awesome-copycats
+
+In case you do not want the Git files, use the following as the second command:
+
+.. code-block:: shell
+
+    mv -bv awesome-copycats/* ~/.config/awesome; rm -rf awesome-copycats
+
+Usage
+=====
+
+The modular structure allows to
+
+* set variables
+* define startup processes
+* change keybindings and layouts
+* set client properties
+
+in ``rc.lua``, and
+
+* configure widgets
+* define wiboxes and screen settings
+
+in ``theme.lua``, so that you just need to change ``chosen_theme`` variable in ``rc.lua`` to preserve your preferences *and* switch the theme, instead of having file redundancy.
+
+Just do the following:
+
+.. code-block:: shell
+
+    $ cd ~/.config/awesome
+    $ cp rc.lua.template rc.lua
+
+Then, set the variable ``chosen_theme`` in ``rc.lua`` to your preferred theme, do your settings, and restart Awesome (``Mod4 + ctrl + r``).
+
+To customize a theme, head over to ``themes/$chosen_theme/theme.lua``.
+
+Otherwise, if you want to be synced with upstream, modify the theme path in ``rc.lua`` like this:
+
+.. code-block:: diff
+
+    -beautiful.init(string.format("%s/.config/awesome/themes/%s/theme.lua", os.getenv("HOME"), chosen_theme))
+    +beautiful.init(string.format("%s/.config/awesome/themes/%s/theme-personal.lua", os.getenv("HOME"), chosen_theme))
+
+then, copy ``theme.lua`` to ``theme-personal.lua`` and do your customizations there.
+
+This way, you can safely ``git pull`` anytime.
+
+Notes
+=====
+
+Complements are provided by lain_ and freedesktop_. **Be sure** to satisfy their dependencies_. In particular, mail_ and weather_ widgets have **mandatory** arguments.
+
+The fonts used in the screenshots are: Terminus_ (Multicolor, Powerarrow, Powerarrow Dark), Roboto_ (Holo, Vertex) and Tamzen_ (other ones).
+
+As taglist font, Blackburn and Dremora use Icons_, Vertex uses FontAwesome_: be sure to have bitmaps enabled if running under Debian or Ubuntu_.
+
+Every theme has a colorscheme_.
+
+Additional default software used: ::
+
+    amixer dmenu librewolf mpc mpd scrot unclutter xbacklight xsel slock
+
+.. _BY-SA: https://creativecommons.org/licenses/by-sa/4.0
+.. _Awesome: http://github.com/awesomeWM/awesome
+.. _branches: https://github.com/lcpz/awesome-copycats/branches
+.. _lucamanni: https://github.com/lucamanni/awesome
+.. _romockee: https://github.com/romockee/powerarrow
+.. _ok100: http://ok100.deviantart.com/art/DWM-January-2013-348656846
+.. _amouly: https://bbs.archlinux.org/viewtopic.php?pid=1307158#p1307158
+.. _swordfischer: https://github.com/lcpz/awesome-copycats/issues/53
+.. _foozer: http://dotshare.it/dots/499
+.. _lain: https://github.com/lcpz/lain
+.. _freedesktop: https://github.com/lcpz/awesome-freedesktop
+.. _Terminus: http://terminus-font.sourceforge.net
+.. _Roboto: https://fonts.google.com/specimen/Roboto
+.. _Tamzen: https://github.com/sunaku/tamzen-font
+.. _Icons: https://github.com/lcpz/dots/tree/master/.fonts
+.. _FontAwesome: https://github.com/FortAwesome/Font-Awesome
+.. _Ubuntu: https://wiki.ubuntu.com/Fonts#Enabling_Bitmapped_Fonts
+.. _colorscheme: https://github.com/lcpz/dots/tree/master/.colors
+.. _dependencies: https://github.com/lcpz/lain/wiki#dependencies
+.. _mail: https://github.com/lcpz/lain/wiki/mail
+.. _weather: https://github.com/lcpz/lain/wiki/weather
diff --git a/bar/bar.lua b/bar/bar.lua
deleted file mode 100755
index dece062..0000000
--- a/bar/bar.lua
+++ /dev/null
@@ -1,68 +0,0 @@
-local awful = require("awful")
-local beautiful = require("beautiful")
-local wibox = require("wibox")
-
-local taglist = require("bar/widgets/taglist")
-local clock = require("bar/widgets/clock")
-local vpn = require("bar/widgets/vpn")
-local spacer = require("bar/widgets/spacer")
-local layout = require("bar/widgets/layout")
-local battery = require("bar/widgets/battery")
-local unison = require("bar/widgets/unison")
-local togglekeyboard = require("bar/widgets/togglekeyboard")
-local playing = require("bar/widgets/playing")
-
-
-local bar = function(s)
-    local wb = awful.wibar {
-        position = "top",
-        height = beautiful.bar_height,
-        screen = s,
-        bg = beautiful.background
-    }
-    wb:setup {
-        {
-            {
-                layout = wibox.layout.align.horizontal,
-                {
-                    layout = wibox.layout.align.horizontal,
-                    taglist(s),
-                    layout(s)
-                },
-                nil,
-                {
-                    layout = wibox.layout.align.horizontal,
-                    {
-                        layout = wibox.layout.align.horizontal,
-                        playing,
-                        spacer,
-                        battery,
-                    },
-					{
-						layout = wibox.layout.align.horizontal,
-                        spacer,
-						unison,
-						spacer,
-					},
-                    {
-                        layout = wibox.layout.align.horizontal,
-                        togglekeyboard,
-                        spacer,
-                        vpn,
-                    }
-                }
-            },
-            widget = wibox.container.margin,
-            right = 5,
-            left = 5
-        },
-        {
-            layout = wibox.container.place,
-            halign = "center",
-            clock
-        },
-        layout = wibox.layout.stack,
-    }
-end
-
-return bar
diff --git a/bar/widgets/battery.lua b/bar/widgets/battery.lua
deleted file mode 100644
index 8902f57..0000000
--- a/bar/widgets/battery.lua
+++ /dev/null
@@ -1,97 +0,0 @@
-local wibox = require("wibox")
-local awful = require("awful")
-local gears = require("gears")
-
-local level_icons = {
-    "  ",
-    "  ",
-    "  ",
-    "  ",
-    "  "
-}
-
-local charging_icon = ""
-
-local notification_shown = 100
-
-local icon_widget = wibox.widget.textbox()
-icon_widget:set_text("")
-
-local charging_widget = wibox.widget.textbox()
-charging_widget:set_text("")
-
-local percentage_widget = wibox.widget.textbox()
-percentage_widget:set_text("")
-
-local combo_widget = wibox.widget {
-    charging_widget,
-    {
-        icon_widget,
-        left = 5,
-        widget = wibox.container.margin
-    },
-    percentage_widget,
-    layout = wibox.layout.fixed.horizontal
-}
-
-local function update_icon_and_percentage_widgets(upower_output)
-    local percentage = tonumber(upower_output:match("percentage:%s*(%d+)")) or 0
-
-    -- Round to the nearest 20 to get the icon index
-    -- The +0.5 is to round to the nearest integer instead of the floor
-    local level = math.floor(percentage/25 + 0.5)
-    local icon = level_icons[level+1]
-
-    -- is_red is for alternating the color of the percentage widget
-    -- (blinking red/white)
-    if percentage <= 15 then
-        percentage_widget.markup = "<span color='red'>" .. percentage .. "%</span>"
-        icon_widget.markup = "<span color='red'>" .. icon .. "</span>"
-        if notification_shown - percentage >= 10 then
-            awful.spawn.with_shell(
-                "notify-send -u critical 'Battery Low' 'Battery is at " .. percentage .. "%'"
-            )
-            -- Avoid sending another notification until the next 5% step
-            -- (5, 10, 15)
-            notification_shown = math.ceil(percentage/5) * 5
-        end
-    else
-        percentage_widget.markup = percentage .. "%"
-        icon_widget.markup = icon
-        notification_shown = 100 -- Reset
-    end
-end
-
-local update_charging_widget = function(upower_output)
-    local charging = upower_output:match("state:%s*(%a+)")
-    if charging == "charging" then
-        charging_widget:set_text(charging_icon)
-    else
-        charging_widget:set_text("")
-    end
-end
-
-local function check_laptop_and_update()
-    awful.spawn.easy_async_with_shell(
-        "upower -i /org/freedesktop/UPower/devices/battery_BAT1",
-        function(output)
-            if output:match("(should be ignored)") then
-                -- No battery found!
-                combo_widget.visible = false
-                return
-            end
-            update_icon_and_percentage_widgets(output)
-            update_charging_widget(output)
-        end
-    )
-end
-
-gears.timer {
-    timeout = 1,    -- It's good to update the charging status often for quick 
-                    -- feedback
-    autostart = true,
-    call_now = true,
-    callback = check_laptop_and_update
-}
-
-return combo_widget
diff --git a/bar/widgets/clock.lua b/bar/widgets/clock.lua
deleted file mode 100755
index f9e3f4a..0000000
--- a/bar/widgets/clock.lua
+++ /dev/null
@@ -1,10 +0,0 @@
-local wibox = require("wibox")
-local gears = require("gears")
-local beautiful = require("beautiful")
-
-local clock = wibox.widget {
-        format = "%a %d %b %H:%M",
-        widget = wibox.widget.textclock,
-}
-
-return clock
diff --git a/bar/widgets/layout.lua b/bar/widgets/layout.lua
deleted file mode 100644
index afd5216..0000000
--- a/bar/widgets/layout.lua
+++ /dev/null
@@ -1,23 +0,0 @@
-local awful = require("awful")
-local gears = require("gears")
-
-local function layoutbox(s)
-    local widget = awful.widget.layoutbox(s)
-    widget:buttons(gears.table.join(
-        awful.button({}, 1, function()
-            awful.layout.inc(1)
-        end),
-        awful.button({}, 3, function()
-            awful.layout.inc(-1)
-        end),
-        awful.button({}, 4, function()
-            awful.layout.inc(1)
-        end),
-        awful.button({}, 5, function()
-            awful.layout.inc(-1)
-        end)
-    ))
-    return widget
-end
-
-return layoutbox
diff --git a/bar/widgets/playing.lua b/bar/widgets/playing.lua
deleted file mode 100755
index b8e29da..0000000
--- a/bar/widgets/playing.lua
+++ /dev/null
@@ -1,62 +0,0 @@
-local awful = require("awful")
-local wibox = require("wibox")
-local gears = require("gears")
-
-local icon = wibox.widget.textbox("󰝚 ")
-local title = wibox.widget.textbox()
-local cover = wibox.widget {
-    resize = true,
-    forced_height = 300,
-    forced_width = 300,
-    clip_shape = gears.shape.rounded_rect,
-    widget = wibox.widget.imagebox
-}
-
-local function daemon ()
-    awful.spawn.easy_async_with_shell(
-        'mpc current --format "%artist% - %title%"',
-        function(stdout)
-            -- Remove all lines after the first one
-            stdout = stdout:gsub("\n.*", "")
-            if stdout ~= "" and stdout ~= " - " then
-                title:set_text(stdout)
-            else
-                title:set_text("Not playing")
-            end
-        end
-    )
-end
-
-title:connect_signal("button::press", function(_, _, _, button)
-    if button == 1 then
-        awful.spawn.with_shell('mpc toggle')
-    end
-end)
-
-gears.timer {
-    timeout = 1,
-    call_now = true,
-    autostart = true,
-    callback = daemon
-}
-
--- Put the title in a container to allow for scrolling when the text is too
--- long (like this comment :-)).
-local scrolling_title = wibox.widget {
-   layout = wibox.container.scroll.horizontal,
-   max_size = 300,
-   step_function = wibox.container.scroll.step_functions
-                   .waiting_nonlinear_back_and_forth,
-   speed = 100,
-   title
-}
-
-scrolling_title:set_fps(60)
-
-local main = wibox.widget {
-    icon,
-    scrolling_title,
-    layout = wibox.layout.fixed.horizontal
-}
-
-return main
diff --git a/bar/widgets/spacer.lua b/bar/widgets/spacer.lua
deleted file mode 100644
index fb8e879..0000000
--- a/bar/widgets/spacer.lua
+++ /dev/null
@@ -1,6 +0,0 @@
-local wibox = require("wibox")
-
-local spacer = wibox.widget.textbox()
-spacer:set_text(" ")
-
-return spacer
diff --git a/bar/widgets/taglist.lua b/bar/widgets/taglist.lua
deleted file mode 100755
index 1c0c542..0000000
--- a/bar/widgets/taglist.lua
+++ /dev/null
@@ -1,28 +0,0 @@
-local awful = require("awful")
-local gears = require("gears")
-
-
-return function(s)
-    local taglist_buttons = gears.table.join(
-        awful.button({ }, 1, function(t) t:view_only() end),
-        awful.button({ modkey }, 1, function(t)
-            if client.focus then
-                client.focus:move_to_tag(t)
-            end
-        end),
-        awful.button({ }, 3, awful.tag.viewtoggle),
-        awful.button({ modkey }, 3, function(t)
-            if client.focus then
-                client.focus:toggle_tag(t)
-            end
-        end),
-        awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
-        awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
-    )
-
-    return awful.widget.taglist {
-        screen  = s,
-        filter  = awful.widget.taglist.filter.all,
-        buttons = taglist_buttons,
-    }
-end
diff --git a/bar/widgets/togglekeyboard.lua b/bar/widgets/togglekeyboard.lua
deleted file mode 100644
index 4c54613..0000000
--- a/bar/widgets/togglekeyboard.lua
+++ /dev/null
@@ -1,54 +0,0 @@
-local internal_keyboard = "AT Translated Set 2 keyboard"
-
-local awful = require("awful")
-local wibox = require("wibox")
-local gears = require("gears")
-
-local widget = wibox.widget.textbox()
-
-local function get_enabled (callback)
-    awful.spawn.easy_async_with_shell('xinput list-props "' .. internal_keyboard ..  '" | grep "Device Enabled" | awk \'{print $4}\'', function (stdout, stderr)
-        callback(stdout == "1\n")
-    end)
-end
-
-local function daemon ()
-    get_enabled(function(status)
-        if status then
-            widget:set_text("  on")
-        else
-            widget:set_text("  off")
-        end
-    end)
-end
-
-local function toggle ()
-    get_enabled(function(status)
-        local new
-        if status then
-            new = 0
-        else
-            new = 1
-        end
-
-        awful.spawn.easy_async_with_shell('xinput set-prop "' .. internal_keyboard .. '" "Device Enabled" ' .. new, function()
-            daemon()
-            awful.spawn.easy_async_with_shell("~/.config/scripts/manage-keyboards")
-        end)
-    end)
-end
-
-widget:connect_signal("button::press", function(_, _, _, button)
-    if button == 1 then
-        toggle()
-    end
-end)
-
-gears.timer {
-    timeout = 1,
-    call_now = true,
-    autostart = true,
-    callback = daemon
-}
-
-return widget
diff --git a/bar/widgets/unison.lua b/bar/widgets/unison.lua
deleted file mode 100755
index 330fcb4..0000000
--- a/bar/widgets/unison.lua
+++ /dev/null
@@ -1,29 +0,0 @@
-local awful = require("awful")
-local wibox = require("wibox")
-local gears = require("gears")
-
-local widget = wibox.widget.textbox()
-
-local icon = " "
-
-local function daemon ()
-    awful.spawn.easy_async_with_shell('pgrep unison', function(stdout)
-		-- Check we have at least 4 unison processes (4 lines)
-		local _, process_count = stdout:gsub('\n', '\n')
-		if process_count >= 4 then
-			widget:set_markup(icon .. "OK")
-		else
-			widget:set_markup("<span color='#FF0000'>" .. icon .. "DOWN</span>")
-		end
-    end)
-end
-
-
-gears.timer {
-    timeout = 1,
-    call_now = true,
-    autostart = true,
-    callback = daemon
-}
-
-return widget
diff --git a/bar/widgets/vpn.lua b/bar/widgets/vpn.lua
deleted file mode 100755
index e51c865..0000000
--- a/bar/widgets/vpn.lua
+++ /dev/null
@@ -1,66 +0,0 @@
-local awful = require("awful")
-local wibox = require("wibox")
-local gears = require("gears")
--- local lain = require("lain")
-
-local widget = wibox.widget.textbox()
-
-local function get_vpn_status (callback)
-    awful.spawn.easy_async_with_shell('ip a | grep -q "scope global vpn"', function(_, _, _, exit_code)
-        if exit_code == 0 then
-            callback(true)
-        else
-            callback(false)
-        end
-    end)
-end
-
-local function daemon ()
-    get_vpn_status(function(status)
-        if status then
-            widget:set_text("󰌾 ")
-        else
-            widget:set_text("󰿆 ")
-        end
-    end)
-end
-
--- local function toggle ()
---     get_vpn_status(function(status)
---         local new
---         if status then
---             new = "down"
---         else
---             new = "up"
---         end
-
---         local quake = lain.util.quake({
---             app = "alacritty --class VpnQuake",
---             argname = "--title %s -e sudo wg-quick " .. new .. " vpn",
---             followtag = true,
---             height = 0.3,
---             width = 0.3,
---             vert = "center",
---             horiz = "center",
---             border = 2,
---             name = "VpnQuake",
---             settings = function(c) c.sticky = true end
---         })
---         quake:toggle()
---     end)
--- end
-
--- widget:connect_signal("button::press", function(_, _, _, button)
---     if button == 1 then
---         toggle()
---     end
--- end)
-
-gears.timer {
-    timeout = 1,
-    call_now = true,
-    autostart = true,
-    callback = daemon
-}
-
-return widget
diff --git a/error_handling.lua b/error_handling.lua
deleted file mode 100755
index cd3ca77..0000000
--- a/error_handling.lua
+++ /dev/null
@@ -1,25 +0,0 @@
-local naughty = require("naughty")
-
-
--- Check if awesome encountered an error during startup and fell back to
--- another config (This code will only ever execute for the fallback config)
-if awesome.startup_errors then
-    naughty.notify({ preset = naughty.config.presets.critical,
-                     title = "Oops, there were errors during startup!",
-                     text = awesome.startup_errors })
-end
-
--- Handle runtime errors after startup
-do
-    local in_error = false
-    awesome.connect_signal("debug::error", function (err)
-        -- Make sure we don't go into an endless error loop
-        if in_error then return end
-        in_error = true
-
-        naughty.notify({ preset = naughty.config.presets.critical,
-                         title = "Oops, an error happened!",
-                         text = tostring(err) })
-        in_error = false
-    end)
-end
diff --git a/freedesktop/README.rst b/freedesktop/README.rst
new file mode 100644
index 0000000..16ca579
--- /dev/null
+++ b/freedesktop/README.rst
@@ -0,0 +1,51 @@
+Awesome-Freedesktop
+===================
+
+-------------------------------------------------------------------
+Freedesktop.org menu and desktop icons support for Awesome WM 4.x
+-------------------------------------------------------------------
+
+:First author: Antonio Terceiro
+:Maintainer: Luca CPZ
+:Version: git
+:License: GNU-GPL2_
+:Source: https://github.com/lcpz/awesome-freedesktop
+
+Description
+-----------
+
+A port of awesome-freedesktop_ to Awesome_ 4.x.
+
+See branches_ for previous versions.
+
+Since the introduction of Menubar_ as a core library to provide Freedesktop.org
+functionalities in Awesome, we can now avoid the dirty work by simply exploiting
+``menubar.utils``.
+
+At the moment, the menu is complete, while the desktop icons are rather simple. Our goal
+is to add the following features:
+
+- A better way to handle desktop icons path.
+- Ability to drag and line up icons.
+- Event-based signals, in particular:
+    - Updating trash icon according to its status.
+    - Dynamic update (no need to restart Awesome to see changes on the desktop).
+
+Screenshot
+----------
+
+.. image:: screenshot.png
+    :align: center
+    :alt: Showcase of Freedesktop.org support in Awesome, using Adwaita icons
+
+Installation and usage
+----------------------
+
+Read the wiki_.
+
+.. _GNU-GPL2: http://www.gnu.org/licenses/gpl-2.0.html
+.. _awesome-freedesktop: https://github.com/terceiro/awesome-freedesktop
+.. _Awesome: https://github.com/awesomeWM/awesome
+.. _branches: https://github.com/lcpz/awesome-freedesktop/branches
+.. _Menubar: https://github.com/awesomeWM/awesome/tree/master/lib/menubar
+.. _wiki: https://github.com/lcpz/awesome-freedesktop/wiki
diff --git a/freedesktop/awesome-freedesktop-scm-1.rockspec b/freedesktop/awesome-freedesktop-scm-1.rockspec
new file mode 100644
index 0000000..0dde608
--- /dev/null
+++ b/freedesktop/awesome-freedesktop-scm-1.rockspec
@@ -0,0 +1,19 @@
+package = "awesome-freedesktop"
+version = "scm-1"
+source = {
+   url = "git+https://github.com/lcpz/awesome-freedesktop.git",
+   tag = "master",
+}
+description = {
+   summary = "Freedesktop.org menu and desktop icons support for Awesome WM",
+   homepage = "https://github.com/lcpz/awesome-freedesktop",
+   license = "GPL-2.0"
+}
+dependencies = {
+   "lua >= 5.3",
+}
+supported_platforms = { "linux" }
+build = {
+   type = "builtin",
+   modules = { freedesktop = "init.lua" }
+}
diff --git a/freedesktop/desktop.lua b/freedesktop/desktop.lua
new file mode 100644
index 0000000..676ebdb
--- /dev/null
+++ b/freedesktop/desktop.lua
@@ -0,0 +1,259 @@
+--[[
+
+     Awesome-Freedesktop
+     Freedesktop.org compliant desktop entries and menu
+
+     Desktop section
+
+     Licensed under GNU General Public License v2
+      * (c) 2016,      Luke Bonham
+      * (c) 2009-2015, Antonio Terceiro
+
+--]]
+
+local awful  = require("awful")
+local theme  = require("beautiful")
+local utils  = require("menubar.utils")
+local wibox  = require("wibox")
+
+local io     = io
+local ipairs = ipairs
+local mouse  = mouse
+local os     = os
+local string = string
+local screen = screen
+local table  = table
+
+-- Desktop icons
+-- freedesktop.desktop
+local desktop = {
+    -- Default desktop basic icons
+    baseicons = {
+        [1] = {
+            label = "This PC",
+            icon  = "computer",
+            onclick = "computer://"
+        },
+        [2] = {
+            label = "Home",
+            icon  = "user-home",
+            onclick = os.getenv("HOME")
+        },
+        [3] = {
+            label = "Trash",
+            icon  = "user-trash",
+            onclick = "trash://"
+        }
+    },
+    -- Default parameters
+    iconsize   = { width = 48,  height = 48 },
+    labelsize  = { width = 140, height = 20 },
+    margin     = { x = 20, y = 20 },
+}
+
+-- MIME types list
+local mime_types = {}
+
+-- Icons positioning
+desktop.current_pos = {}
+
+-- @return iterator on input pipe
+local function pipelines(...)
+    local f = assert(io.popen(...))
+    return function ()
+        local data = f:read()
+        if data == nil then f:close() end
+        return data
+    end
+end
+
+-- Adds an icon to desktop
+-- @param args settings from desktop.add_icons
+-- @param label icon string label
+-- @param icon icon string file path
+-- @param onclick function to execute on click
+function desktop.add_single_icon(args, label, icon, onclick)
+    local s = args.screen
+    local dcp = desktop.current_pos
+
+    -- define icon dimensions and position
+    if not dcp[s] then
+        dcp[s] = { x = (screen[s].geometry.x + args.iconsize.width + args.margin.x), y = screen[s].geometry.y + 20 + args.margin.y  }
+    end
+
+    local tot_height = (icon and args.iconsize.height or 0) + (label and args.labelsize.height or 0)
+    if tot_height == 0 then return end
+
+    if dcp[s].y + tot_height > screen[s].geometry.y + screen[s].geometry.height - 20 - args.margin.y then
+        dcp[s].x = dcp[s].x + args.labelsize.width + args.iconsize.width + args.margin.x
+        dcp[s].y = 20 + args.margin.y
+    end
+
+    local common = { screen = s, bg = "#00000000", visible = true, type = "desktop" }
+
+    -- create icon container
+    if icon then
+        common.width = args.iconsize.width
+        common.height = args.iconsize.height
+        common.x = dcp[s].x
+        common.y = dcp[s].y
+
+        icon = wibox.widget {
+            image = icon,
+            resize = false,
+            widget = wibox.widget.imagebox
+        }
+
+        icon:buttons(awful.button({ }, 1, nil, onclick))
+
+        icon_container = wibox(common)
+        icon_container:set_widget(icon)
+
+        dcp[s].y = dcp[s].y + args.iconsize.height + 5
+    end
+
+    -- create label container
+    if label then
+        common.width = args.labelsize.width
+        common.height = args.labelsize.height
+        common.x = dcp[s].x - (args.labelsize.width/2) + args.iconsize.width/2
+        common.y = dcp[s].y
+
+        caption = wibox.widget {
+            text          = label,
+            align         = "center",
+            forced_width  = common.width,
+            forced_height = common.height,
+            ellipsize     = "middle",
+            widget        = wibox.widget.textbox
+        }
+
+        caption:buttons(awful.button({ }, 1, onclick))
+        caption_container = wibox(common)
+        caption_container:set_widget(caption)
+    end
+
+    dcp[s].y = dcp[s].y + args.labelsize.height + args.margin.y
+
+    desktop.current_pos = dcp
+
+    return dcp
+end
+
+-- Adds base icons (This PC, Trash, etc) to desktop
+-- @param args settings from desktop.add_icons
+function desktop.add_base_icons(args)
+    for _,base in ipairs(args.baseicons) do
+        desktop.add_single_icon(args, base.label, utils.lookup_icon(base.icon), function()
+            awful.spawn(string.format("%s '%s'", args.open_with, base.onclick))
+        end)
+    end
+end
+
+-- Looks up a suitable icon for filename
+-- @param filename string file name
+-- @return icon file path (string)
+function desktop.lookup_file_icon(filename)
+    -- load system MIME types
+    if #mime_types == 0 then
+        for line in io.lines("/etc/mime.types") do
+            if not line:find("^#") then
+                local parsed = {}
+                for w in line:gmatch("[^%s]+") do
+                    table.insert(parsed, w)
+                end
+                if #parsed > 1 then
+                    for i = 2, #parsed do
+                        mime_types[parsed[i]] = parsed[1]:gsub("/", "-")
+                    end
+                end
+            end
+        end
+    end
+
+    -- try to search a possible icon among standards
+    local extension = filename:match("%a+$")
+    local mime = mime_types[extension] or ""
+    local mime_family = mime:match("^%a+") or ""
+
+    local possible_filenames = {
+        mime, "gnome-mime-" .. mime,
+        mime_family, "gnome-mime-" .. mime_family,
+        extension
+    }
+
+    for i, filename in ipairs(possible_filenames) do
+        local icon = utils.lookup_icon(filename)
+        if icon then return icon end
+    end
+
+    -- if we don"t find ad icon, then pretend is a plain text file
+    return utils.lookup_icon("text-x-generic")
+end
+
+-- Parse subdirectories and files list from input directory
+-- @input dir directory to parse (string)
+-- @return files table with found entries
+function desktop.parse_dirs_and_files(dir)
+    local files = {}
+    local paths = pipelines('find '..dir..' -maxdepth 1 -type d |sort|tail -n +1')
+    for path in paths do
+        if path:match("[^/]+$") then
+            local file = {}
+            file.filename = path:match("[^/]+$")
+            file.path = path
+            file.show = true
+            file.icon = utils.lookup_icon("folder")
+            table.insert(files, file)
+        end
+    end
+    local paths = pipelines('find '..dir..' -maxdepth 1 -type f')
+    for path in paths do
+        if not path:find("%.desktop$") then
+            local file = {}
+            file.filename = path:match("[^/]+$")
+            file.path = path
+            file.show = true
+            file.icon = desktop.lookup_file_icon(file.filename)
+            table.insert(files, file)
+        end
+    end
+    return files
+end
+
+-- Adds subdirectories and files icons from args.dir
+-- @param args settings from desktop.add_icons
+function desktop.add_dirs_and_files_icons(args)
+    for _, file in ipairs(desktop.parse_dirs_and_files(args.dir)) do
+        if file.show then
+            local label = args.showlabels and file.filename or nil
+            local onclick = function () awful.spawn(string.format("%s '%s'", args.open_with, file.path)) end
+            desktop.add_single_icon(args, label, file.icon, onclick)
+        end
+    end
+end
+
+-- Main function, adds base, directory and files icons
+-- @param args user defined settings, with fallback on defaults
+function desktop.add_icons(args)
+    args            = args or {}
+    args.screen     = args.screen or mouse.screen
+    args.dir        = args.dir or os.getenv("HOME") .. "/Desktop"
+    args.showlabels = args.showlabel or true
+    args.open_with  = args.open_with or "xdg_open"
+    args.baseicons  = args.baseicons or desktop.baseicons
+    args.iconsize   = args.iconsize or desktop.iconsize
+    args.labelsize  = args.labelsize or desktop.labelsize
+    args.margin     = args.margin or desktop.margin
+
+    -- trying to fallback on Adwaita if theme.icon_theme is not defined
+    -- if Adwaita is missing too, no icons will be shown
+    if not theme.icon_theme then
+        theme.icon_theme = args.icon_theme or "Adwaita"
+    end
+
+    desktop.add_base_icons(args)
+    desktop.add_dirs_and_files_icons(args)
+end
+
+return desktop
diff --git a/freedesktop/init.lua b/freedesktop/init.lua
new file mode 100644
index 0000000..9350b44
--- /dev/null
+++ b/freedesktop/init.lua
@@ -0,0 +1,15 @@
+--[[
+
+     Awesome-Freedesktop
+     Freedesktop.org compliant desktop entries and menu
+
+     Licensed under GNU General Public License v2
+      * (c) 2016,      Luke Bonham
+      * (c) 2009-2015, Antonio Terceiro
+
+--]]
+
+return {
+    desktop  = require("freedesktop.desktop"),
+    menu     = require("freedesktop.menu")
+}
diff --git a/freedesktop/menu.lua b/freedesktop/menu.lua
new file mode 100644
index 0000000..fed6e6b
--- /dev/null
+++ b/freedesktop/menu.lua
@@ -0,0 +1,121 @@
+
+--[[
+
+     Awesome-Freedesktop
+     Freedesktop.org compliant desktop entries and menu
+
+     Menu section
+
+     Licensed under GNU General Public License v2
+      * (c) 2016, Luke Bonham
+      * (c) 2014, Harvey Mittens
+
+--]]
+
+local Gio        = require("lgi").Gio
+local awful_menu = require("awful.menu")
+local menu_gen   = require("menubar.menu_gen")
+local menu_utils = require("menubar.utils")
+
+local io, pairs, string, table, os = io, pairs, string, table, os
+
+-- Expecting a wm_name of awesome omits too many applications and tools
+menu_utils.wm_name = ""
+
+-- Menu
+-- freedesktop.menu
+local menu = {}
+
+-- Check if a path is a directory.
+-- @tparam string path The directory path
+-- @treturn boolean True if path exists and is a directory
+function menu.is_dir(path)
+    return Gio.File.new_for_path(path):query_file_type({}) == "DIRECTORY"
+end
+
+-- Remove non existent paths in order to avoid issues
+local existent_paths = {}
+for k,v in pairs(menu_gen.all_menu_dirs) do
+    if menu.is_dir(v) then
+        table.insert(existent_paths, v)
+    end
+end
+menu_gen.all_menu_dirs = existent_paths
+
+-- Determines whether an table includes a certain element
+-- @param tab a given table
+-- @param val the element to search for
+-- @return true if the given string is found within the search table; otherwise, false if not
+function menu.has_value (tab, val)
+    for index, value in pairs(tab) do
+        if val:find(value) then
+            return true
+        end
+    end
+    return false
+end
+
+-- Use MenuBar parsing utils to build a menu for Awesome
+-- @return awful.menu
+function menu.build(args)
+    local args       = args or {}
+    local before     = args.before or {}
+    local after      = args.after or {}
+    local skip_items = args.skip_items or {}
+    local sub_menu   = args.sub_menu or false
+
+    local result     = {}
+    local _menu      = awful_menu({ items = before })
+
+    menu_gen.generate(function(entries)
+        -- Add category icons
+        for k, v in pairs(menu_gen.all_categories) do
+            table.insert(result, { k, {}, v.icon })
+        end
+
+        -- Get items table
+        for k, v in pairs(entries) do
+            for _, cat in pairs(result) do
+                if cat[1] == v.category then
+                    if not menu.has_value(skip_items, v.name) then
+                        table.insert(cat[2], { v.name, v.cmdline, v.icon })
+                    end
+                    break
+                end
+            end
+        end
+
+        -- Cleanup things a bit
+        for i = #result, 1, -1 do
+            local v = result[i]
+            if #v[2] == 0 then
+                -- Remove unused categories
+                table.remove(result, i)
+            else
+                --Sort entries alphabetically (by name)
+                table.sort(v[2], function (a, b) return string.byte(a[1]) < string.byte(b[1]) end)
+                -- Replace category name with nice name
+                v[1] = menu_gen.all_categories[v[1]].name
+            end
+        end
+
+        -- Sort categories alphabetically also
+        table.sort(result, function(a, b) return string.byte(a[1]) < string.byte(b[1]) end)
+
+        -- Add menu item to hold the generated menu
+        if sub_menu then
+            result = {{sub_menu, result}}
+        end
+
+        -- Add items to menu
+        for _, v in pairs(result) do _menu:add(v) end
+        for _, v in pairs(after)  do _menu:add(v) end
+    end)
+
+    -- Hold the menu in the module
+    menu.menu = _menu
+
+    return _menu
+end
+
+return menu
diff --git a/freedesktop/screenshot.png b/freedesktop/screenshot.png
new file mode 100644
index 0000000..bf254ac
Binary files /dev/null and b/freedesktop/screenshot.png differ
diff --git a/keys.lua b/keys.lua
deleted file mode 100755
index 5175fb3..0000000
--- a/keys.lua
+++ /dev/null
@@ -1,241 +0,0 @@
--- This file configures the keybindings of awesome.
--- I have made it so that it matches my keyboard layout (colemak).
--- This means that you may have to change some shortcuts.
--- arstdhneio is the whole colemak home row, from left to right. Change those keys to match your keyboard layout.
--- Remember that almost all the keys are bound to something, so changing one you might need to change another.
-
-local awful = require("awful")
-local gears = require("gears")
-local naughty = require("naughty")
-require("awful.hotkeys_popup.keys")
-
--- local lain = require("lain")
-
--- local org_quake = lain.util.quake({ app = "alacritty --class OrgQuake", argname = "--title %s -e nvim org/fast.org", followtag = true, height = 0.9, width = 0.9, vert = "center", horiz = "center", border = 2, name = "OrgQuake", settings = function(c) c.sticky = true end })
-
--- local weechat_quake = lain.util.quake({ app = "alacritty --class WeechatQuake", argname = "--title %s -e ssh cocinero-tarneo -t \"tmux a -t weechat\"", followtag = true, height = 0.9, width = 0.9, vert = "center", horiz = "center", border = 2, name = "WeechatQuake", settings = function(c) c.sticky = true end })
-
-ModKey = "Mod4"
-
-local previous_layout = nil
-
-local globalkeys = gears.table.join(
-    -- Applications launcher: dmenu. Archlinux package: dmenu
-    awful.key({ ModKey,           }, "p", function() awful.spawn.with_shell("dmenu_run") end),
-    -- Dmscripts (my own scripts): see the dotfile's README for more info
-    awful.key({ ModKey,           }, "y", function() awful.spawn.with_shell("bash ~/.config/dmscripts/main.sh") end),
-    -- Qutebrowser (web browser). You can change this to match your browser (don't use chrome, opera, vivaldi, brave, firefox, etc.)
-    -- nice alternatives include GNU icecat and librewolf.
-    awful.key({ ModKey,           }, "b", function() awful.spawn.with_shell("qutebrowser") end),
-    -- Emacs: I use emacsclient to open emacs. You can change this to match your editor, or just remove it.
-    awful.key({ ModKey,           }, "g", function() awful.spawn.with_shell("emacs") end),
-    -- Zathura: PDF viewer. Archlinux package: zathura.
-    awful.key({ ModKey,           }, "z", function() awful.spawn.with_shell("zathura") end),
-    -- Open org quake terminal
-    -- awful.key({ ModKey,           }, "j", function() org_quake:toggle() end),
-    -- Open weechat quake terminal
-    -- awful.key({ ModKey,           }, "k", function() weechat_quake:toggle() end),
-    -- ncmpcpp: terminal music player/mpd frontend. Archlinux package: ncmpcpp.
-    awful.key({ ModKey,           }, "slash", function() awful.spawn.with_shell(TerminalCmd .. " ncmpcpp") end),
-
-    -- Open terminal (I use alacritty)
-    awful.key({ ModKey,           }, "Return", function () awful.spawn.with_shell(Terminal) end),
-
-    -- Open tmux on server
-    awful.key({ ModKey, "Shift" }, "Return", function () awful.spawn.with_shell(TerminalCmd .. " ssh risitas@cocinero -t \"tmux a -t services\"") end),
-
-    -- Reload awesomewm. This is useful when you change the config file.
-    awful.key({ ModKey,  }, "q", awesome.restart),
-
-    -- Open BWmenu (Bitwarden dmenu script)
-    awful.key({ ModKey            }, "m", function() awful.spawn.with_shell("~/.config/scripts/bwmenu") end),
-
-    -- Open qobuz (music streaming service) when pressing XF86AudioMedia (F12 key on framework laptop)
-    awful.key({ }, "XF86AudioMedia", function() awful.spawn.with_shell("xdg-open https://play.qobuz.com") end),
-
-    -- Shutdown the computer
-    -- awful.key({ ModKey, "Control" }, "q", function() awful.spawn.with_shell("sudo shutdown now") end),
-
-    -- Hibernate the computer: you need some configuration for this to work. See the archwiki, page on hibernation.
-    awful.key({ ModKey, "Control" }, "q", function() awful.spawn.with_shell("systemctl hibernate") end),
-
-    -- change brightness. Only works on my laptop (asus something)
-    awful.key({ }, "XF86MonBrightnessDown", function ()
-        awful.spawn.with_shell("brightnessctl -d amdgpu_bl0 set 10%-") end),
-    awful.key({ }, "XF86MonBrightnessUp", function ()
-        awful.spawn.with_shell("brightnessctl -d amdgpu_bl0 set +10%") end),
-
-    ----------------
-    -- Media keys --
-    ----------------
-
-    -- Volume control
-    awful.key({}, "XF86AudioRaiseVolume", function ()   awful.spawn.with_shell("pamixer -i 2")   end),
-    awful.key({}, "XF86AudioLowerVolume", function ()   awful.spawn.with_shell("pamixer -d 2")   end),
-    awful.key({}, "XF86AudioMute", function ()          awful.spawn.with_shell("pamixer -t")  end),
-
-    -- Playerctl control (incompatible with mpd below)
-    awful.key({}, "XF86AudioNext", function () awful.spawn.with_shell("playerctl next -p $(playerctl -l | grep mpd | head -n 1)")       end),
-    awful.key({}, "XF86AudioPrev", function () awful.spawn.with_shell("playerctl previous -p $(playerctl -l | grep mpd | head -n 1)")   end),
-    awful.key({}, "XF86AudioPlay", function () awful.spawn.with_shell("playerctl play-pause -p $(playerctl -l | grep mpd | head -n 1)") end),
-
-    -- MPD control (incompatible with playerctl above)
-    -- awful.key({}, "XF86AudioNext", function ()          awful.spawn.with_shell("mpc next")                      end),
-    -- awful.key({}, "XF86AudioPrev", function ()          awful.spawn.with_shell("mpc prev")                      end),
-    -- awful.key({}, "XF86AudioPlay", function ()          awful.spawn.with_shell("mpc toggle")                    end),
-
-
-    -- Focus (colemak hjkl=neio)
-    awful.key({ ModKey,           }, "i",
-        function ()
-            awful.client.focus.byidx( 1)
-        end
-    ),
-    awful.key({ ModKey,           }, "e",
-        function ()
-            awful.client.focus.byidx(-1)
-        end
-    ),
-
-    -- Layout manipulation (still colemak keys)
-    awful.key({ ModKey, "Shift"   }, "i",     function () awful.client.swap.byidx(  1)        end), -- Swap with next client
-    awful.key({ ModKey, "Shift"   }, "e",     function () awful.client.swap.byidx( -1)        end), -- Swap with previous client
-    awful.key({ ModKey, "Shift"   }, "o",     function () awful.tag.incmwfact( 0.05)          end), -- Increase master width factor
-    awful.key({ ModKey, "Shift"   }, "n",     function () awful.tag.incmwfact(-0.05)          end), -- Decrease master width factor
-    awful.key({ ModKey,           }, "n",     function () awful.tag.incnmaster( 1, nil, true) end), -- Increase the number of master clients
-    awful.key({ ModKey,           }, "o",     function () awful.tag.incnmaster(-1, nil, true) end), -- Decrease the number of master clients
-    awful.key({ ModKey, "Shift"   }, "m",     function () awful.tag.incncol( 1, nil, true)    end), -- Increase the number of columns
-    awful.key({ ModKey, "Shift"   }, "/",     function () awful.tag.incncol(-1, nil, true)    end), -- Decrease the number of columns
-
-    -- Change layout
-    awful.key({ ModKey,           }, ",", function () awful.layout.inc( 1)                end),
-
-    -- Toggle maximized layout
-    -- This will just crash if you set the default layout to maximized, but else it works well.
-    awful.key({ ModKey,           }, ".", function ()
-        local screen = awful.screen.focused()
-        local tag = screen.selected_tag
-        local current_layout = tag.layout
-
-        local toggled_layout = awful.layout.suit.max
-
-        if current_layout.name == toggled_layout.name then
-            awful.layout.set(previous_layout, tag)
-        else
-            previous_layout = current_layout
-            awful.layout.set(toggled_layout, tag)
-        end
-    end),
-
-    -- Restore last minimized client
-    awful.key({ ModKey, }, "u",
-              function ()
-                  local c = awful.client.restore()
-                  -- Focus restored client
-                  if c then
-                    c:emit_signal(
-                        "request::activate", "key.unminimize", {raise = true}
-                    )
-                  end
-              end)
-
-    -- Switch focus to next screen
-    -- awful.key({ ModKey }, "h", function () awful.screen.focus_relative(1) end)
-)
-
--- Keys for clients (windows)
-ClientKeys = gears.table.join(
-    -- Toggle fullscreen = no borders, bar, titlebar, or gaps
-    awful.key({ ModKey,           }, "f",
-        function (c)
-            c.fullscreen = not c.fullscreen
-            c:raise()
-        end),
-    -- Close client
-    awful.key({ ModKey,           }, "w",      function (c) c:kill()                         end),
-    -- Toggle floating
-    awful.key({ ModKey            }, "c",  awful.client.floating.toggle                     ),
-    -- Toggle maximized
-    awful.key({ ModKey, "Shift"   }, "f",  function (c) c.maximized = not c.maximized end),
-    -- Minimize client
-    awful.key({ ModKey,           }, "l",
-        function (c)
-            -- The client currently has the input focus, so it cannot be
-            -- minimized, since minimized clients can't have the focus.
-            c.minimized = true
-        end),
-    -- Take screenshot
-    awful.key({}, "Print", function (c)
-        local filename = os.getenv("HOME") .. "/Downloads/Screenshot_" .. os.date("%Y-%m-%d_%H:%M:%S") .. ".png"
-        awful.screenshot{auto_save_delay = 3, client = c, file_path = filename}
-        awful.spawn.with_shell("xclip -selection clipboard -t image/png " .. filename)
-        naughty.notify({text = "Screenshot saved to " .. filename .. " and copied to clipboard"})
-    end)
-    -- Move client to next screen
-    -- awful.key({ ModKey, "Shift"   }, "h",      function (c) c:move_to_screen()               end)
-)
-
--- Bind all key numbers to tags.
--- Colemak's "arstd" = qwerty's "asdfg"
-local tagkeys = { "a", "r", "s", "t", "d", "h"}
--- Here change the number 5 to the number of buttons you set just above.
-for i = 1, 6 do
-    globalkeys = gears.table.join(globalkeys,
-        -- View tag only.
-        awful.key({ ModKey }, tagkeys[i],
-                  function ()
-                        local screen = awful.screen.focused()
-                        local tag = screen.tags[i]
-                        if tag then
-                           tag:view_only()
-                        end
-                  end),
-        -- Toggle tag display. (in awesomewm you can view multiple tags at once)
-        awful.key({ ModKey, "Control" }, tagkeys[i],
-                  function ()
-                      local screen = awful.screen.focused()
-                      local tag = screen.tags[i]
-                      if tag then
-                         awful.tag.viewtoggle(tag)
-                      end
-                  end),
-        -- Move client to tag.
-        awful.key({ ModKey, "Shift" }, tagkeys[i],
-                  function ()
-                      if client.focus then
-                          local tag = client.focus.screen.tags[i]
-                          if tag then
-                              client.focus:move_to_tag(tag)
-                          end
-                     end
-                  end),
-        -- Toggle tag on focused client. (clients/windows can be tagged with multiple tags)
-        awful.key({ ModKey, "Control", "Shift" }, tagkeys[i],
-                  function ()
-                      if client.focus then
-                          local tag = client.focus.screen.tags[i]
-                          if tag then
-                              client.focus:toggle_tag(tag)
-                          end
-                      end
-                  end)
-    )
-end
-
--- Mouse bindings. You shouldn't need to change these.
-ClientButtons = gears.table.join(
-    awful.button({ }, 1, function (c)
-        c:emit_signal("request::activate", "mouse_click", {raise = true})
-    end),
-    awful.button({ ModKey }, 1, function (c)
-        c:emit_signal("request::activate", "mouse_click", {raise = true})
-        awful.mouse.client.move(c)
-    end),
-    awful.button({ ModKey }, 3, function (c)
-        c:emit_signal("request::activate", "mouse_click", {raise = true})
-        awful.mouse.client.resize(c)
-    end)
-)
-
--- Set keys. Without this line all of this file is useless!
-root.keys(globalkeys)
diff --git a/lain/ISSUE_TEMPLATE.md b/lain/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000..e9dcc0b
--- /dev/null
+++ b/lain/ISSUE_TEMPLATE.md
@@ -0,0 +1,33 @@
+# Please, read me!
+
+So that I can help you quickly and without having to redirect you here.
+
+# If you have an issue
+
+**Please read the [wiki](https://github.com/lcpz/lain/wiki) and search the [Issues section](https://github.com/lcpz/lain/issues) first.**
+
+If you can't find a solution there, then go ahead and provide:
+
+* output of `awesome -v` and `lua -v`
+* expected behavior and actual behavior
+* steps to reproduce the problem
+* X error log
+
+# How to provide X error log
+
+There are two ways:
+
+* (Physically) Restart X like this:
+  ```shell
+  startx -- -keeptty -nolisten tcp > $HOME/.xorg.log 2>&1
+  ```
+  the error log will be output into `$HOME/.xorg.log`.
+
+* (Virtually) Use [Xephyr](https://wikipedia.org/wiki/Xephyr):
+  ```shell
+  # set screen size as you like
+  Xephyr :1 -screen 1280x800 2> stdout.txt & DISPLAY=:1 awesome
+  ```
+  the error log will be output in the file `stdout.txt`.
+
+Before reporting, read the log and see if you can solve it yourself.
diff --git a/lain/README.rst b/lain/README.rst
new file mode 100644
index 0000000..616c7cd
--- /dev/null
+++ b/lain/README.rst
@@ -0,0 +1,40 @@
+Lain
+====
+
+.. image:: https://github.com/lcpz/lain/actions/workflows/main.yml/badge.svg
+
+-------------------------------------------------
+Layouts, widgets and utilities for Awesome WM 4.x
+-------------------------------------------------
+
+:Author: Luca CPZ
+:Version: git
+:License: GNU-GPL2_
+:Source: https://github.com/lcpz/lain
+
+Description
+-----------
+
+Successor of awesome-vain_, this module provides alternative layouts, asynchronous widgets and utility functions for Awesome_.
+
+Contributions
+-------------
+
+Constructive criticism and suggestions are welcome.
+
+If you want to create a pull request, make sure that:
+
+- Your code fits with the general style of the module. In particular, you should use the same indentation pattern that the code uses, and also avoid adding space at the ends of lines.
+
+- Your code its easy to understand, maintainable, and modularized. You should also avoid code duplication wherever possible by adding functions to or using lain.helpers_. If something is unclear, or you can not write it in such a way that it will be clear, explain it with a comment.
+
+- You test your changes before submitting to make sure that your code works and does not break other parts of the module.
+
+- You update ``wiki`` submodule with a thorough section, if necessary.
+
+Contributed widgets have to be put in ``widget/contrib``.
+
+.. _GNU-GPL2: http://www.gnu.org/licenses/gpl-2.0.html
+.. _awesome-vain: https://github.com/vain/awesome-vain
+.. _Awesome: https://github.com/awesomeWM/awesome
+.. _lain.helpers: https://github.com/lcpz/lain/blob/master/helpers.lua
diff --git a/lain/helpers.lua b/lain/helpers.lua
new file mode 100644
index 0000000..ef9e08b
--- /dev/null
+++ b/lain/helpers.lua
@@ -0,0 +1,203 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+
+--]]
+
+local spawn  = require("awful.spawn")
+local timer  = require("gears.timer")
+local debug  = require("debug")
+local io     = { lines = io.lines,
+                 open  = io.open }
+local pairs  = pairs
+local rawget = rawget
+local tsort  = table.sort
+local unpack = unpack or table.unpack -- lua 5.1 retro-compatibility
+
+-- Lain helper functions for internal use
+-- lain.helpers
+local helpers = {}
+
+helpers.lain_dir    = debug.getinfo(1, 'S').source:match[[^@(.*/).*$]]
+helpers.icons_dir   = helpers.lain_dir .. 'icons/'
+helpers.scripts_dir = helpers.lain_dir .. 'scripts/'
+
+-- {{{ Modules loader
+
+function helpers.wrequire(t, k)
+    return rawget(t, k) or require(t._NAME .. '.' .. k)
+end
+
+-- }}}
+
+-- {{{ File operations
+
+-- check if the file exists and is readable
+function helpers.file_exists(path)
+    local file = io.open(path, "rb")
+    if file then file:close() end
+    return file ~= nil
+end
+
+-- get a table with all lines from a file
+function helpers.lines_from(path)
+    local lines = {}
+    for line in io.lines(path) do
+        lines[#lines + 1] = line
+    end
+    return lines
+end
+
+-- get a table with all lines from a file matching regexp
+function helpers.lines_match(regexp, path)
+    local lines = {}
+    for line in io.lines(path) do
+        if string.match(line, regexp) then
+            lines[#lines + 1] = line
+        end
+    end
+    return lines
+end
+
+-- get first line of a file
+function helpers.first_line(path)
+    local file, first = io.open(path, "rb"), nil
+    if file then
+        first = file:read("*l")
+        file:close()
+    end
+    return first
+end
+
+-- get first non empty line from a file
+function helpers.first_nonempty_line(path)
+    for line in io.lines(path) do
+        if #line then return line end
+    end
+    return nil
+end
+
+-- }}}
+
+-- {{{ Timer maker
+
+helpers.timer_table = {}
+
+function helpers.newtimer(name, timeout, fun, nostart, stoppable)
+    if not name or #name == 0 then return end
+    name = (stoppable and name) or timeout
+    if not helpers.timer_table[name] then
+        helpers.timer_table[name] = timer({ timeout = timeout })
+        helpers.timer_table[name]:start()
+    end
+    helpers.timer_table[name]:connect_signal("timeout", fun)
+    if not nostart then
+        helpers.timer_table[name]:emit_signal("timeout")
+    end
+    return stoppable and helpers.timer_table[name]
+end
+
+-- }}}
+
+-- {{{ Pipe operations
+
+-- run a command and execute a function on its output (asynchronous pipe)
+-- @param cmd the input command
+-- @param callback function to execute on cmd output
+-- @return cmd PID
+function helpers.async(cmd, callback)
+    return spawn.easy_async(cmd,
+    function (stdout, _, _, exit_code)
+        callback(stdout, exit_code)
+    end)
+end
+
+-- like above, but call spawn.easy_async with a shell
+function helpers.async_with_shell(cmd, callback)
+    return spawn.easy_async_with_shell(cmd,
+    function (stdout, _, _, exit_code)
+        callback(stdout, exit_code)
+    end)
+end
+
+-- run a command and execute a function on its output line by line
+function helpers.line_callback(cmd, callback)
+    return spawn.with_line_callback(cmd, {
+        stdout = function (line)
+            callback(line)
+        end,
+    })
+end
+
+-- }}}
+
+-- {{{ A map utility
+
+helpers.map_table = {}
+
+function helpers.set_map(element, value)
+    helpers.map_table[element] = value
+end
+
+function helpers.get_map(element)
+    return helpers.map_table[element]
+end
+
+-- }}}
+
+-- {{{ Misc
+
+-- check if an element exist on a table
+function helpers.element_in_table(element, tbl)
+    for _, i in pairs(tbl) do
+        if i == element then
+            return true
+        end
+    end
+    return false
+end
+
+-- iterate over table of records sorted by keys
+function helpers.spairs(t)
+    -- collect the keys
+    local keys = {}
+    for k in pairs(t) do keys[#keys+1] = k end
+
+    tsort(keys)
+
+    -- return the iterator function
+    local i = 0
+    return function()
+        i = i + 1
+        if keys[i] then
+            return keys[i], t[keys[i]]
+        end
+    end
+end
+
+-- create the partition of singletons of a given set
+-- example: the trivial partition set of {a, b, c}, is {{a}, {b}, {c}}
+function helpers.trivial_partition_set(set)
+    local ss = {}
+    for _,e in pairs(set) do
+        ss[#ss+1] = {e}
+    end
+    return ss
+end
+
+-- create the powerset of a given set
+function helpers.powerset(s)
+    if not s then return {} end
+    local t = {{}}
+    for i = 1, #s do
+        for j = 1, #t do
+            t[#t+1] = {s[i],unpack(t[j])}
+        end
+    end
+    return t
+end
+
+-- }}}
+
+return helpers
diff --git a/lain/icons/cal/black/1.png b/lain/icons/cal/black/1.png
new file mode 100644
index 0000000..d2fb62e
Binary files /dev/null and b/lain/icons/cal/black/1.png differ
diff --git a/lain/icons/cal/black/10.png b/lain/icons/cal/black/10.png
new file mode 100644
index 0000000..507b079
Binary files /dev/null and b/lain/icons/cal/black/10.png differ
diff --git a/lain/icons/cal/black/11.png b/lain/icons/cal/black/11.png
new file mode 100644
index 0000000..336141b
Binary files /dev/null and b/lain/icons/cal/black/11.png differ
diff --git a/lain/icons/cal/black/12.png b/lain/icons/cal/black/12.png
new file mode 100644
index 0000000..c589729
Binary files /dev/null and b/lain/icons/cal/black/12.png differ
diff --git a/lain/icons/cal/black/13.png b/lain/icons/cal/black/13.png
new file mode 100644
index 0000000..377518b
Binary files /dev/null and b/lain/icons/cal/black/13.png differ
diff --git a/lain/icons/cal/black/14.png b/lain/icons/cal/black/14.png
new file mode 100644
index 0000000..6f4a9fe
Binary files /dev/null and b/lain/icons/cal/black/14.png differ
diff --git a/lain/icons/cal/black/15.png b/lain/icons/cal/black/15.png
new file mode 100644
index 0000000..1a271c1
Binary files /dev/null and b/lain/icons/cal/black/15.png differ
diff --git a/lain/icons/cal/black/16.png b/lain/icons/cal/black/16.png
new file mode 100644
index 0000000..5e65835
Binary files /dev/null and b/lain/icons/cal/black/16.png differ
diff --git a/lain/icons/cal/black/17.png b/lain/icons/cal/black/17.png
new file mode 100644
index 0000000..f3fa0a9
Binary files /dev/null and b/lain/icons/cal/black/17.png differ
diff --git a/lain/icons/cal/black/18.png b/lain/icons/cal/black/18.png
new file mode 100644
index 0000000..7acb37a
Binary files /dev/null and b/lain/icons/cal/black/18.png differ
diff --git a/lain/icons/cal/black/19.png b/lain/icons/cal/black/19.png
new file mode 100644
index 0000000..a557957
Binary files /dev/null and b/lain/icons/cal/black/19.png differ
diff --git a/lain/icons/cal/black/2.png b/lain/icons/cal/black/2.png
new file mode 100644
index 0000000..17b33e0
Binary files /dev/null and b/lain/icons/cal/black/2.png differ
diff --git a/lain/icons/cal/black/20.png b/lain/icons/cal/black/20.png
new file mode 100644
index 0000000..558d111
Binary files /dev/null and b/lain/icons/cal/black/20.png differ
diff --git a/lain/icons/cal/black/21.png b/lain/icons/cal/black/21.png
new file mode 100644
index 0000000..0bbedc8
Binary files /dev/null and b/lain/icons/cal/black/21.png differ
diff --git a/lain/icons/cal/black/22.png b/lain/icons/cal/black/22.png
new file mode 100644
index 0000000..762d262
Binary files /dev/null and b/lain/icons/cal/black/22.png differ
diff --git a/lain/icons/cal/black/23.png b/lain/icons/cal/black/23.png
new file mode 100644
index 0000000..a39dcee
Binary files /dev/null and b/lain/icons/cal/black/23.png differ
diff --git a/lain/icons/cal/black/24.png b/lain/icons/cal/black/24.png
new file mode 100644
index 0000000..c00dbca
Binary files /dev/null and b/lain/icons/cal/black/24.png differ
diff --git a/lain/icons/cal/black/25.png b/lain/icons/cal/black/25.png
new file mode 100644
index 0000000..dc9243c
Binary files /dev/null and b/lain/icons/cal/black/25.png differ
diff --git a/lain/icons/cal/black/26.png b/lain/icons/cal/black/26.png
new file mode 100644
index 0000000..50bb182
Binary files /dev/null and b/lain/icons/cal/black/26.png differ
diff --git a/lain/icons/cal/black/27.png b/lain/icons/cal/black/27.png
new file mode 100644
index 0000000..0fbf9fc
Binary files /dev/null and b/lain/icons/cal/black/27.png differ
diff --git a/lain/icons/cal/black/28.png b/lain/icons/cal/black/28.png
new file mode 100644
index 0000000..def6ab2
Binary files /dev/null and b/lain/icons/cal/black/28.png differ
diff --git a/lain/icons/cal/black/29.png b/lain/icons/cal/black/29.png
new file mode 100644
index 0000000..531923c
Binary files /dev/null and b/lain/icons/cal/black/29.png differ
diff --git a/lain/icons/cal/black/3.png b/lain/icons/cal/black/3.png
new file mode 100644
index 0000000..98b552d
Binary files /dev/null and b/lain/icons/cal/black/3.png differ
diff --git a/lain/icons/cal/black/30.png b/lain/icons/cal/black/30.png
new file mode 100644
index 0000000..ca58151
Binary files /dev/null and b/lain/icons/cal/black/30.png differ
diff --git a/lain/icons/cal/black/31.png b/lain/icons/cal/black/31.png
new file mode 100644
index 0000000..6e8da21
Binary files /dev/null and b/lain/icons/cal/black/31.png differ
diff --git a/lain/icons/cal/black/4.png b/lain/icons/cal/black/4.png
new file mode 100644
index 0000000..4335979
Binary files /dev/null and b/lain/icons/cal/black/4.png differ
diff --git a/lain/icons/cal/black/5.png b/lain/icons/cal/black/5.png
new file mode 100644
index 0000000..576ec11
Binary files /dev/null and b/lain/icons/cal/black/5.png differ
diff --git a/lain/icons/cal/black/6.png b/lain/icons/cal/black/6.png
new file mode 100644
index 0000000..56fa8ab
Binary files /dev/null and b/lain/icons/cal/black/6.png differ
diff --git a/lain/icons/cal/black/7.png b/lain/icons/cal/black/7.png
new file mode 100644
index 0000000..7c90b3a
Binary files /dev/null and b/lain/icons/cal/black/7.png differ
diff --git a/lain/icons/cal/black/8.png b/lain/icons/cal/black/8.png
new file mode 100644
index 0000000..9d1f28e
Binary files /dev/null and b/lain/icons/cal/black/8.png differ
diff --git a/lain/icons/cal/black/9.png b/lain/icons/cal/black/9.png
new file mode 100644
index 0000000..00d0933
Binary files /dev/null and b/lain/icons/cal/black/9.png differ
diff --git a/lain/icons/cal/white/1.png b/lain/icons/cal/white/1.png
new file mode 100644
index 0000000..a0faa20
Binary files /dev/null and b/lain/icons/cal/white/1.png differ
diff --git a/lain/icons/cal/white/10.png b/lain/icons/cal/white/10.png
new file mode 100644
index 0000000..7d9343b
Binary files /dev/null and b/lain/icons/cal/white/10.png differ
diff --git a/lain/icons/cal/white/11.png b/lain/icons/cal/white/11.png
new file mode 100644
index 0000000..7af5e99
Binary files /dev/null and b/lain/icons/cal/white/11.png differ
diff --git a/lain/icons/cal/white/12.png b/lain/icons/cal/white/12.png
new file mode 100644
index 0000000..b164f85
Binary files /dev/null and b/lain/icons/cal/white/12.png differ
diff --git a/lain/icons/cal/white/13.png b/lain/icons/cal/white/13.png
new file mode 100644
index 0000000..fef74f3
Binary files /dev/null and b/lain/icons/cal/white/13.png differ
diff --git a/lain/icons/cal/white/14.png b/lain/icons/cal/white/14.png
new file mode 100644
index 0000000..d747a6b
Binary files /dev/null and b/lain/icons/cal/white/14.png differ
diff --git a/lain/icons/cal/white/15.png b/lain/icons/cal/white/15.png
new file mode 100644
index 0000000..64418a6
Binary files /dev/null and b/lain/icons/cal/white/15.png differ
diff --git a/lain/icons/cal/white/16.png b/lain/icons/cal/white/16.png
new file mode 100644
index 0000000..8b86700
Binary files /dev/null and b/lain/icons/cal/white/16.png differ
diff --git a/lain/icons/cal/white/17.png b/lain/icons/cal/white/17.png
new file mode 100644
index 0000000..033b5ff
Binary files /dev/null and b/lain/icons/cal/white/17.png differ
diff --git a/lain/icons/cal/white/18.png b/lain/icons/cal/white/18.png
new file mode 100644
index 0000000..0cf1c24
Binary files /dev/null and b/lain/icons/cal/white/18.png differ
diff --git a/lain/icons/cal/white/19.png b/lain/icons/cal/white/19.png
new file mode 100644
index 0000000..bfd3530
Binary files /dev/null and b/lain/icons/cal/white/19.png differ
diff --git a/lain/icons/cal/white/2.png b/lain/icons/cal/white/2.png
new file mode 100644
index 0000000..e7f3fa4
Binary files /dev/null and b/lain/icons/cal/white/2.png differ
diff --git a/lain/icons/cal/white/20.png b/lain/icons/cal/white/20.png
new file mode 100644
index 0000000..9a5a1fb
Binary files /dev/null and b/lain/icons/cal/white/20.png differ
diff --git a/lain/icons/cal/white/21.png b/lain/icons/cal/white/21.png
new file mode 100644
index 0000000..266ab9f
Binary files /dev/null and b/lain/icons/cal/white/21.png differ
diff --git a/lain/icons/cal/white/22.png b/lain/icons/cal/white/22.png
new file mode 100644
index 0000000..f486289
Binary files /dev/null and b/lain/icons/cal/white/22.png differ
diff --git a/lain/icons/cal/white/23.png b/lain/icons/cal/white/23.png
new file mode 100644
index 0000000..244dceb
Binary files /dev/null and b/lain/icons/cal/white/23.png differ
diff --git a/lain/icons/cal/white/24.png b/lain/icons/cal/white/24.png
new file mode 100644
index 0000000..0ce1c75
Binary files /dev/null and b/lain/icons/cal/white/24.png differ
diff --git a/lain/icons/cal/white/25.png b/lain/icons/cal/white/25.png
new file mode 100644
index 0000000..48d279c
Binary files /dev/null and b/lain/icons/cal/white/25.png differ
diff --git a/lain/icons/cal/white/26.png b/lain/icons/cal/white/26.png
new file mode 100644
index 0000000..7535855
Binary files /dev/null and b/lain/icons/cal/white/26.png differ
diff --git a/lain/icons/cal/white/27.png b/lain/icons/cal/white/27.png
new file mode 100644
index 0000000..2aa9074
Binary files /dev/null and b/lain/icons/cal/white/27.png differ
diff --git a/lain/icons/cal/white/28.png b/lain/icons/cal/white/28.png
new file mode 100644
index 0000000..0201976
Binary files /dev/null and b/lain/icons/cal/white/28.png differ
diff --git a/lain/icons/cal/white/29.png b/lain/icons/cal/white/29.png
new file mode 100644
index 0000000..9305b9b
Binary files /dev/null and b/lain/icons/cal/white/29.png differ
diff --git a/lain/icons/cal/white/3.png b/lain/icons/cal/white/3.png
new file mode 100644
index 0000000..f1eb5de
Binary files /dev/null and b/lain/icons/cal/white/3.png differ
diff --git a/lain/icons/cal/white/30.png b/lain/icons/cal/white/30.png
new file mode 100644
index 0000000..1ba61aa
Binary files /dev/null and b/lain/icons/cal/white/30.png differ
diff --git a/lain/icons/cal/white/31.png b/lain/icons/cal/white/31.png
new file mode 100644
index 0000000..e9a873b
Binary files /dev/null and b/lain/icons/cal/white/31.png differ
diff --git a/lain/icons/cal/white/4.png b/lain/icons/cal/white/4.png
new file mode 100644
index 0000000..ee1ed6a
Binary files /dev/null and b/lain/icons/cal/white/4.png differ
diff --git a/lain/icons/cal/white/5.png b/lain/icons/cal/white/5.png
new file mode 100644
index 0000000..466aa71
Binary files /dev/null and b/lain/icons/cal/white/5.png differ
diff --git a/lain/icons/cal/white/6.png b/lain/icons/cal/white/6.png
new file mode 100644
index 0000000..0a7bf4d
Binary files /dev/null and b/lain/icons/cal/white/6.png differ
diff --git a/lain/icons/cal/white/7.png b/lain/icons/cal/white/7.png
new file mode 100644
index 0000000..e971951
Binary files /dev/null and b/lain/icons/cal/white/7.png differ
diff --git a/lain/icons/cal/white/8.png b/lain/icons/cal/white/8.png
new file mode 100644
index 0000000..cb03d0b
Binary files /dev/null and b/lain/icons/cal/white/8.png differ
diff --git a/lain/icons/cal/white/9.png b/lain/icons/cal/white/9.png
new file mode 100644
index 0000000..fca554a
Binary files /dev/null and b/lain/icons/cal/white/9.png differ
diff --git a/lain/icons/layout/default/cascade.png b/lain/icons/layout/default/cascade.png
new file mode 100644
index 0000000..292a057
Binary files /dev/null and b/lain/icons/layout/default/cascade.png differ
diff --git a/lain/icons/layout/default/cascadetile.png b/lain/icons/layout/default/cascadetile.png
new file mode 100644
index 0000000..ba30f43
Binary files /dev/null and b/lain/icons/layout/default/cascadetile.png differ
diff --git a/lain/icons/layout/default/cascadetilew.png b/lain/icons/layout/default/cascadetilew.png
new file mode 100644
index 0000000..d15eb70
Binary files /dev/null and b/lain/icons/layout/default/cascadetilew.png differ
diff --git a/lain/icons/layout/default/cascadew.png b/lain/icons/layout/default/cascadew.png
new file mode 100644
index 0000000..da64bd6
Binary files /dev/null and b/lain/icons/layout/default/cascadew.png differ
diff --git a/lain/icons/layout/default/centerfair.png b/lain/icons/layout/default/centerfair.png
new file mode 100644
index 0000000..188c243
Binary files /dev/null and b/lain/icons/layout/default/centerfair.png differ
diff --git a/lain/icons/layout/default/centerfairw.png b/lain/icons/layout/default/centerfairw.png
new file mode 100644
index 0000000..ed4bcf5
Binary files /dev/null and b/lain/icons/layout/default/centerfairw.png differ
diff --git a/lain/icons/layout/default/centerwork.png b/lain/icons/layout/default/centerwork.png
new file mode 100644
index 0000000..51e06bc
Binary files /dev/null and b/lain/icons/layout/default/centerwork.png differ
diff --git a/lain/icons/layout/default/centerworkh.png b/lain/icons/layout/default/centerworkh.png
new file mode 100644
index 0000000..c59092f
Binary files /dev/null and b/lain/icons/layout/default/centerworkh.png differ
diff --git a/lain/icons/layout/default/centerworkhw.png b/lain/icons/layout/default/centerworkhw.png
new file mode 100644
index 0000000..7820f8c
Binary files /dev/null and b/lain/icons/layout/default/centerworkhw.png differ
diff --git a/lain/icons/layout/default/centerworkw.png b/lain/icons/layout/default/centerworkw.png
new file mode 100644
index 0000000..85e6996
Binary files /dev/null and b/lain/icons/layout/default/centerworkw.png differ
diff --git a/lain/icons/layout/default/termfair.png b/lain/icons/layout/default/termfair.png
new file mode 100644
index 0000000..06226c1
Binary files /dev/null and b/lain/icons/layout/default/termfair.png differ
diff --git a/lain/icons/layout/default/termfairw.png b/lain/icons/layout/default/termfairw.png
new file mode 100644
index 0000000..0a8b576
Binary files /dev/null and b/lain/icons/layout/default/termfairw.png differ
diff --git a/lain/icons/layout/zenburn/cascade.png b/lain/icons/layout/zenburn/cascade.png
new file mode 100644
index 0000000..fbe4fac
Binary files /dev/null and b/lain/icons/layout/zenburn/cascade.png differ
diff --git a/lain/icons/layout/zenburn/cascadetile.png b/lain/icons/layout/zenburn/cascadetile.png
new file mode 100644
index 0000000..2e03a80
Binary files /dev/null and b/lain/icons/layout/zenburn/cascadetile.png differ
diff --git a/lain/icons/layout/zenburn/centerfair.png b/lain/icons/layout/zenburn/centerfair.png
new file mode 100644
index 0000000..75dc993
Binary files /dev/null and b/lain/icons/layout/zenburn/centerfair.png differ
diff --git a/lain/icons/layout/zenburn/centerwork.png b/lain/icons/layout/zenburn/centerwork.png
new file mode 100644
index 0000000..af7a863
Binary files /dev/null and b/lain/icons/layout/zenburn/centerwork.png differ
diff --git a/lain/icons/layout/zenburn/centerworkh.png b/lain/icons/layout/zenburn/centerworkh.png
new file mode 100644
index 0000000..88019b3
Binary files /dev/null and b/lain/icons/layout/zenburn/centerworkh.png differ
diff --git a/lain/icons/layout/zenburn/termfair.png b/lain/icons/layout/zenburn/termfair.png
new file mode 100644
index 0000000..f7640b5
Binary files /dev/null and b/lain/icons/layout/zenburn/termfair.png differ
diff --git a/lain/icons/mail.png b/lain/icons/mail.png
new file mode 100644
index 0000000..9c0c7a3
Binary files /dev/null and b/lain/icons/mail.png differ
diff --git a/lain/icons/no_net.png b/lain/icons/no_net.png
new file mode 100644
index 0000000..3613372
Binary files /dev/null and b/lain/icons/no_net.png differ
diff --git a/lain/icons/openweathermap/01d.png b/lain/icons/openweathermap/01d.png
new file mode 100644
index 0000000..569965e
Binary files /dev/null and b/lain/icons/openweathermap/01d.png differ
diff --git a/lain/icons/openweathermap/01n.png b/lain/icons/openweathermap/01n.png
new file mode 100644
index 0000000..ce5b135
Binary files /dev/null and b/lain/icons/openweathermap/01n.png differ
diff --git a/lain/icons/openweathermap/02d.png b/lain/icons/openweathermap/02d.png
new file mode 100644
index 0000000..2ba9799
Binary files /dev/null and b/lain/icons/openweathermap/02d.png differ
diff --git a/lain/icons/openweathermap/02n.png b/lain/icons/openweathermap/02n.png
new file mode 100644
index 0000000..12e4283
Binary files /dev/null and b/lain/icons/openweathermap/02n.png differ
diff --git a/lain/icons/openweathermap/03d.png b/lain/icons/openweathermap/03d.png
new file mode 100644
index 0000000..1cf0e9d
Binary files /dev/null and b/lain/icons/openweathermap/03d.png differ
diff --git a/lain/icons/openweathermap/03n.png b/lain/icons/openweathermap/03n.png
new file mode 100644
index 0000000..89a42b8
Binary files /dev/null and b/lain/icons/openweathermap/03n.png differ
diff --git a/lain/icons/openweathermap/04d.png b/lain/icons/openweathermap/04d.png
new file mode 100644
index 0000000..e7fb67f
Binary files /dev/null and b/lain/icons/openweathermap/04d.png differ
diff --git a/lain/icons/openweathermap/04n.png b/lain/icons/openweathermap/04n.png
new file mode 120000
index 0000000..b9a83df
--- /dev/null
+++ b/lain/icons/openweathermap/04n.png
@@ -0,0 +1 @@
+04d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/09d.png b/lain/icons/openweathermap/09d.png
new file mode 100644
index 0000000..cfa066a
Binary files /dev/null and b/lain/icons/openweathermap/09d.png differ
diff --git a/lain/icons/openweathermap/09n.png b/lain/icons/openweathermap/09n.png
new file mode 120000
index 0000000..cca1f5d
--- /dev/null
+++ b/lain/icons/openweathermap/09n.png
@@ -0,0 +1 @@
+09d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/10d.png b/lain/icons/openweathermap/10d.png
new file mode 100644
index 0000000..712d0c8
Binary files /dev/null and b/lain/icons/openweathermap/10d.png differ
diff --git a/lain/icons/openweathermap/10n.png b/lain/icons/openweathermap/10n.png
new file mode 120000
index 0000000..6e01227
--- /dev/null
+++ b/lain/icons/openweathermap/10n.png
@@ -0,0 +1 @@
+10d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/11d.png b/lain/icons/openweathermap/11d.png
new file mode 100644
index 0000000..3b62f7c
Binary files /dev/null and b/lain/icons/openweathermap/11d.png differ
diff --git a/lain/icons/openweathermap/11n.png b/lain/icons/openweathermap/11n.png
new file mode 120000
index 0000000..b227917
--- /dev/null
+++ b/lain/icons/openweathermap/11n.png
@@ -0,0 +1 @@
+11d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/13d.png b/lain/icons/openweathermap/13d.png
new file mode 100644
index 0000000..e265b01
Binary files /dev/null and b/lain/icons/openweathermap/13d.png differ
diff --git a/lain/icons/openweathermap/13n.png b/lain/icons/openweathermap/13n.png
new file mode 120000
index 0000000..94e5a52
--- /dev/null
+++ b/lain/icons/openweathermap/13n.png
@@ -0,0 +1 @@
+13d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/50d.png b/lain/icons/openweathermap/50d.png
new file mode 100644
index 0000000..905ace3
Binary files /dev/null and b/lain/icons/openweathermap/50d.png differ
diff --git a/lain/icons/openweathermap/50n.png b/lain/icons/openweathermap/50n.png
new file mode 120000
index 0000000..e3ba961
--- /dev/null
+++ b/lain/icons/openweathermap/50n.png
@@ -0,0 +1 @@
+50d.png
\ No newline at end of file
diff --git a/lain/icons/openweathermap/README.md b/lain/icons/openweathermap/README.md
new file mode 100644
index 0000000..f908fbd
--- /dev/null
+++ b/lain/icons/openweathermap/README.md
@@ -0,0 +1,3 @@
+[Plain Weather Icons](http://merlinthered.deviantart.com/art/plain-weather-icons-157162192), created by [MerlinTheRed](http://merlinthered.deviantart.com/).
+
+<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/"><img src="http://i.creativecommons.org/l/by-nc-sa/2.5/80x15.png" align="right"></a>
diff --git a/lain/icons/openweathermap/na.png b/lain/icons/openweathermap/na.png
new file mode 100644
index 0000000..1cc5132
Binary files /dev/null and b/lain/icons/openweathermap/na.png differ
diff --git a/lain/icons/taskwarrior.png b/lain/icons/taskwarrior.png
new file mode 100644
index 0000000..c64fe86
Binary files /dev/null and b/lain/icons/taskwarrior.png differ
diff --git a/lain/init.lua b/lain/init.lua
new file mode 100644
index 0000000..b59d5dd
--- /dev/null
+++ b/lain/init.lua
@@ -0,0 +1,15 @@
+--[[
+
+     Lain
+     Layouts, widgets and utilities for Awesome WM
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+
+--]]
+
+return {
+    layout = require("lain.layout"),
+    util   = require("lain.util"),
+    widget = require("lain.widget")
+}
diff --git a/lain/lain-scm-1.rockspec b/lain/lain-scm-1.rockspec
new file mode 100644
index 0000000..70b0f43
--- /dev/null
+++ b/lain/lain-scm-1.rockspec
@@ -0,0 +1,22 @@
+package = "lain"
+version = "scm-1"
+source = {
+   url = "git+https://github.com/lcpz/lain.git",
+   tag = "master"
+}
+description = {
+   summary = "Layout, widgets and utilities for Awesome WM",
+   detailed = "Alternative layouts, asynchronous widgets and utility functions for Awesome WM. Non-Lua dependency: curl (for IMAP, MPD and weather widgets).",
+   homepage = "https://github.com/lcpz/lain",
+   license = "GPL2"
+}
+dependencies = {
+   "lua >= 5.3",
+   "dkjson >= 2.6-1"
+}
+supported_platforms = { "linux" }
+build = {
+   type = "builtin",
+   modules = { lain = "init.lua" }
+}
+
diff --git a/lain/layout/cascade.lua b/lain/layout/cascade.lua
new file mode 100644
index 0000000..cbc3877
--- /dev/null
+++ b/lain/layout/cascade.lua
@@ -0,0 +1,172 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2014,      projektile
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local floor  = math.floor
+local screen = screen
+
+local cascade = {
+    name     = "cascade",
+    nmaster  = 0,
+    offset_x = 32,
+    offset_y = 8,
+    tile     = {
+        name          = "cascadetile",
+        nmaster       = 0,
+        ncol          = 0,
+        mwfact        = 0,
+        offset_x      = 5,
+        offset_y      = 32,
+        extra_padding = 0
+    }
+}
+
+local function do_cascade(p, tiling)
+    local t = p.tag or screen[p.screen].selected_tag
+    local wa = p.workarea
+    local cls = p.clients
+
+    if #cls == 0 then return end
+
+    if not tiling then
+        -- Cascade windows.
+
+        local num_c
+        if cascade.nmaster > 0 then
+            num_c = cascade.nmaster
+        else
+            num_c = t.master_count
+        end
+
+        -- Opening a new window will usually force all existing windows to
+        -- get resized. This wastes a lot of CPU time. So let's set a lower
+        -- bound to "how_many": This wastes a little screen space but you'll
+        -- get a much better user experience.
+        local how_many = (#cls >= num_c and #cls) or num_c
+
+        local current_offset_x = cascade.offset_x * (how_many - 1)
+        local current_offset_y = cascade.offset_y * (how_many - 1)
+
+        -- Iterate.
+        for i = 1,#cls,1 do
+            local c = cls[i]
+            local g = {}
+
+            g.x      = wa.x + (how_many - i) * cascade.offset_x
+            g.y      = wa.y + (i - 1) * cascade.offset_y
+            g.width  = wa.width - current_offset_x
+            g.height = wa.height - current_offset_y
+
+            if g.width  < 1 then g.width  = 1 end
+            if g.height < 1 then g.height = 1 end
+
+            p.geometries[c] = g
+        end
+    else
+        -- Layout with one fixed column meant for a master window. Its
+        -- width is calculated according to mwfact. Other clients are
+        -- cascaded or "tabbed" in a slave column on the right.
+
+        --         (1)                 (2)                 (3)                 (4)
+        --   +----------+---+    +----------+---+    +----------+---+    +----------+---+
+        --   |          |   |    |          | 3 |    |          | 4 |    |         +---+|
+        --   |          |   | -> |          |   | -> |         +---++ -> |        +---+|+
+        --   |  1       | 2 |    |  1      +---++    |  1      | 3 ||    |  1    +---+|+|
+        --   |          |   |    |         | 2 ||    |        +---++|    |      +---+|+ |
+        --   |          |   |    |         |   ||    |        | 2 | |    |      | 2 |+  |
+        --   +----------+---+    +---------+---++    +--------+---+-+    +------+---+---+
+
+        local mwfact
+        if cascade.tile.mwfact > 0 then
+            mwfact = cascade.tile.mwfact
+        else
+            mwfact = t.master_width_factor
+        end
+
+        -- Make slave windows overlap main window? Do this if ncol is 1.
+        local overlap_main
+        if cascade.tile.ncol > 0 then
+            overlap_main = cascade.tile.ncol
+        else
+            overlap_main = t.column_count
+        end
+
+        -- Minimum space for slave windows? See cascade.tile.lua.
+        local num_c
+        if cascade.tile.nmaster > 0 then
+            num_c = cascade.tile.nmaster
+        else
+            num_c = t.master_count
+        end
+
+        local how_many = (#cls - 1 >= num_c and (#cls - 1)) or num_c
+
+        local current_offset_x = cascade.tile.offset_x * (how_many - 1)
+        local current_offset_y = cascade.tile.offset_y * (how_many - 1)
+
+        if #cls <= 0 then return end
+
+        -- Main column, fixed width and height.
+        local c = cls[1]
+        local g = {}
+        -- Rounding is necessary to prevent the rendered size of slavewid
+        -- from being 1 pixel off when the result is not an integer.
+        local mainwid = floor(wa.width * mwfact)
+        local slavewid = wa.width - mainwid
+
+        if overlap_main == 1 then
+            g.width = wa.width
+
+            -- The size of the main window may be reduced a little bit.
+            -- This allows you to see if there are any windows below the
+            -- main window.
+            -- This only makes sense, though, if the main window is
+            -- overlapping everything else.
+            g.width = g.width - cascade.tile.extra_padding
+        else
+            g.width = mainwid
+        end
+
+        g.height = wa.height
+        g.x = wa.x
+        g.y = wa.y
+
+        if g.width < 1  then g.width  = 1 end
+        if g.height < 1 then g.height = 1 end
+
+        p.geometries[c] = g
+
+        -- Remaining clients stacked in slave column, new ones on top.
+        if #cls <= 1 then return end
+        for i = 2,#cls do
+            c = cls[i]
+            g = {}
+
+            g.width  = slavewid - current_offset_x
+            g.height = wa.height - current_offset_y
+
+            g.x = wa.x + mainwid + (how_many - (i - 1)) * cascade.tile.offset_x
+            g.y = wa.y + (i - 2) * cascade.tile.offset_y
+
+            if g.width < 1  then g.width  = 1 end
+            if g.height < 1 then g.height = 1 end
+
+            p.geometries[c] = g
+        end
+    end
+end
+
+function cascade.tile.arrange(p)
+    return do_cascade(p, true)
+end
+
+function cascade.arrange(p)
+    return do_cascade(p, false)
+end
+
+return cascade
diff --git a/lain/layout/centerwork.lua b/lain/layout/centerwork.lua
new file mode 100644
index 0000000..c105676
--- /dev/null
+++ b/lain/layout/centerwork.lua
@@ -0,0 +1,276 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2018,      Eugene Pakhomov
+      * (c) 2016,      Henrik Antonsson
+      * (c) 2015,      Joerg Jaspert
+      * (c) 2014,      projektile
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local floor = math.floor
+local max = math.max
+local mouse = mouse
+local mousegrabber = mousegrabber
+local screen = screen
+
+local centerwork = {
+    name       = "centerwork",
+    horizontal = { name = "centerworkh" }
+}
+
+local function arrange(p, layout)
+    local t   = p.tag or screen[p.screen].selected_tag
+    local wa  = p.workarea
+    local cls = p.clients
+
+    if #cls == 0 then return end
+
+    local g = {}
+
+    -- Main column, fixed width and height
+    local mwfact          = t.master_width_factor
+    local mainhei         = floor(wa.height * mwfact)
+    local mainwid         = floor(wa.width * mwfact)
+    local slavewid        = wa.width - mainwid
+    local slaveLwid       = floor(slavewid / 2)
+    local slaveRwid       = slavewid - slaveLwid
+    local slavehei        = wa.height - mainhei
+    local slaveThei       = floor(slavehei / 2)
+    local slaveBhei       = slavehei - slaveThei
+    local nbrFirstSlaves  = floor(#cls / 2)
+    local nbrSecondSlaves = floor((#cls - 1) / 2)
+
+    local slaveFirstDim, slaveSecondDim = 0, 0
+
+    if layout.name == "centerwork" then -- vertical
+        if nbrFirstSlaves  > 0 then slaveFirstDim  = floor(wa.height / nbrFirstSlaves) end
+        if nbrSecondSlaves > 0 then slaveSecondDim = floor(wa.height / nbrSecondSlaves) end
+
+        g.height = wa.height
+        g.width  = mainwid
+
+        g.x = wa.x + slaveLwid
+        g.y = wa.y
+    else -- horizontal
+        if nbrFirstSlaves  > 0 then slaveFirstDim  = floor(wa.width / nbrFirstSlaves) end
+        if nbrSecondSlaves > 0 then slaveSecondDim = floor(wa.width / nbrSecondSlaves) end
+
+        g.height  = mainhei
+        g.width = wa.width
+
+        g.x = wa.x
+        g.y = wa.y + slaveThei
+    end
+
+    g.width  = max(g.width, 1)
+    g.height = max(g.height, 1)
+
+    p.geometries[cls[1]] = g
+
+    -- Auxiliary clients
+    if #cls <= 1 then return end
+    for i = 2, #cls do
+        g = {}
+        local idxChecker, dimToAssign
+
+        local rowIndex = floor(i/2)
+
+        if layout.name == "centerwork" then
+            if i % 2 == 0 then -- left slave
+                g.x     = wa.x
+                g.y     = wa.y + (rowIndex - 1) * slaveFirstDim
+                g.width = slaveLwid
+
+                idxChecker, dimToAssign = nbrFirstSlaves, slaveFirstDim
+            else -- right slave
+                g.x     = wa.x + slaveLwid + mainwid
+                g.y     = wa.y + (rowIndex - 1) * slaveSecondDim
+                g.width = slaveRwid
+
+                idxChecker, dimToAssign = nbrSecondSlaves, slaveSecondDim
+            end
+
+            -- if last slave in row, use remaining space for it
+            if rowIndex == idxChecker then
+                g.height = wa.y + wa.height - g.y
+            else
+                g.height = dimToAssign
+            end
+        else
+            if i % 2 == 0 then -- top slave
+                g.x      = wa.x + (rowIndex - 1) * slaveFirstDim
+                g.y      = wa.y
+                g.height = slaveThei
+
+                idxChecker, dimToAssign = nbrFirstSlaves, slaveFirstDim
+            else -- bottom slave
+                g.x      = wa.x + (rowIndex - 1) * slaveSecondDim
+                g.y      = wa.y + slaveThei + mainhei
+                g.height = slaveBhei
+
+                idxChecker, dimToAssign = nbrSecondSlaves, slaveSecondDim
+            end
+
+            -- if last slave in row, use remaining space for it
+            if rowIndex == idxChecker then
+                g.width = wa.x + wa.width - g.x
+            else
+                g.width = dimToAssign
+            end
+        end
+
+        g.width  = max(g.width, 1)
+        g.height = max(g.height, 1)
+
+        p.geometries[cls[i]] = g
+    end
+end
+
+local function mouse_resize_handler(c, _, _, _, orientation)
+    local wa     = c.screen.workarea
+    local mwfact = c.screen.selected_tag.master_width_factor
+    local g      = c:geometry()
+    local offset = 0
+    local cursor = "cross"
+
+    local corner_coords
+
+    if orientation == 'vertical' then
+        if g.height + 15 >= wa.height then
+            offset = g.height * .5
+            cursor = "sb_h_double_arrow"
+        elseif g.y + g.height + 15 <= wa.y + wa.height then
+            offset = g.height
+        end
+        corner_coords = { x = wa.x + wa.width * (1 - mwfact) / 2, y = g.y + offset }
+    else
+        if g.width + 15 >= wa.width then
+            offset = g.width * .5
+            cursor = "sb_v_double_arrow"
+        elseif g.x + g.width + 15 <= wa.x + wa.width then
+            offset = g.width
+        end
+        corner_coords = { y = wa.y + wa.height * (1 - mwfact) / 2, x = g.x + offset }
+    end
+
+    mouse.coords(corner_coords)
+
+    local prev_coords = {}
+
+    mousegrabber.run(function(m)
+        if not c.valid then return false end
+        for _, v in ipairs(m.buttons) do
+            if v then
+                prev_coords = { x = m.x, y = m.y }
+                local new_mwfact
+                if orientation == 'vertical' then
+                    new_mwfact = 1 - (m.x - wa.x) / wa.width * 2
+                else
+                    new_mwfact = 1 - (m.y - wa.y) / wa.height * 2
+                end
+                c.screen.selected_tag.master_width_factor = math.min(math.max(new_mwfact, 0.01), 0.99)
+                return true
+            end
+        end
+        return prev_coords.x == m.x and prev_coords.y == m.y
+    end, cursor)
+end
+
+function centerwork.arrange(p)
+    return arrange(p, centerwork)
+end
+
+function centerwork.horizontal.arrange(p)
+    return arrange(p, centerwork.horizontal)
+end
+
+function centerwork.mouse_resize_handler(c, corner, x, y)
+    return mouse_resize_handler(c, corner, x, y, 'vertical')
+end
+
+function centerwork.horizontal.mouse_resize_handler(c, corner, x, y)
+    return mouse_resize_handler(c, corner, x, y, 'horizontal')
+end
+
+
+--[[
+Make focus.byidx and swap.byidx behave more consistently with other layouts.
+--]]
+
+local awful = require("awful")
+local gears = require("gears")
+local client = client
+
+local function compare_position(a, b)
+    if a.x == b.x then
+        return a.y < b.y
+    else
+        return a.x < b.x
+    end
+end
+
+local function clients_by_position()
+    local this = client.focus
+    if this then
+        local sorted = {}
+        for _, c in ipairs(client.focus.first_tag:clients()) do
+            if not c.minimized then sorted[#sorted+1] = c end
+        end
+        table.sort(sorted, compare_position)
+
+        local idx = 0
+        for i, that in ipairs(sorted) do
+            if this.window == that.window then
+                idx = i
+            end
+        end
+
+        if idx > 0 then
+            return { sorted = sorted, idx = idx }
+        end
+    end
+    return {}
+end
+
+local function in_centerwork()
+    return client.focus and client.focus.first_tag.layout.name == "centerwork"
+end
+
+centerwork.focus = {}
+
+
+--[[
+Drop in replacements for awful.client.focus.byidx and awful.client.swap.byidx
+that behaves consistently with other layouts.
+--]]
+
+function centerwork.focus.byidx(i)
+    if in_centerwork() then
+        local cls = clients_by_position()
+        if cls.idx then
+            local target = cls.sorted[gears.math.cycle(#cls.sorted, cls.idx + i)]
+            awful.client.focus.byidx(0, target)
+        end
+    else
+        awful.client.focus.byidx(i)
+    end
+end
+
+centerwork.swap = {}
+
+function centerwork.swap.byidx(i)
+    if in_centerwork() then
+        local cls = clients_by_position()
+        if cls.idx then
+            local target = cls.sorted[gears.math.cycle(#cls.sorted, cls.idx + i)]
+            client.focus:swap(target)
+        end
+    else
+        awful.client.swap.byidx(i)
+    end
+end
+
+return centerwork
diff --git a/lain/layout/init.lua b/lain/layout/init.lua
new file mode 100644
index 0000000..6478b06
--- /dev/null
+++ b/lain/layout/init.lua
@@ -0,0 +1,19 @@
+--[[
+
+     Lain
+     Layouts, widgets and utilities for Awesome WM
+
+     Layouts section
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local wrequire     = require("lain.helpers").wrequire
+local setmetatable = setmetatable
+
+local layout       = { _NAME = "lain.layout" }
+
+return setmetatable(layout, { __index = wrequire })
diff --git a/lain/layout/termfair.lua b/lain/layout/termfair.lua
new file mode 100644
index 0000000..cf018ef
--- /dev/null
+++ b/lain/layout/termfair.lua
@@ -0,0 +1,282 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2014,      projektile
+      * (c) 2013,      Luca CPZ
+      * (c) 2010,      Nicolas Estibals
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local math     = math
+local screen   = screen
+local tonumber = tonumber
+
+local termfair  = { name = "termfair" }
+termfair.center = { name = "centerfair" }
+termfair.stable = { name = "stablefair" }
+
+local function do_fair(p, orientation)
+    local t = p.tag or screen[p.screen].selected_tag
+    local wa = p.workarea
+    local cls = p.clients
+
+    if #cls == 0 then return end
+
+    -- How many vertical columns? Read from nmaster on the tag.
+    local num_x = tonumber(termfair.nmaster) or t.master_count
+    local ncol  = tonumber(termfair.ncol) or t.column_count
+    if num_x <= 2 then num_x = 2 end
+    if ncol  <= 1 then ncol  = 1 end
+    local width = math.floor(wa.width/num_x)
+
+    if orientation == "west" then
+        -- Layout with fixed number of vertical columns (read from nmaster).
+        -- New windows align from left to right. When a row is full, a new
+        -- one above it is created. Like this:
+
+        --        (1)                (2)                (3)
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+        --   |   |   |   |      |   |   |   |      |   |   |   |
+        --   | 1 |   |   |  ->  | 1 | 2 |   |  ->  | 1 | 2 | 3 |  ->
+        --   |   |   |   |      |   |   |   |      |   |   |   |
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+
+        --        (4)                (5)                (6)
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+        --   | 1 |   |   |      | 1 | 2 |   |      | 1 | 2 | 3 |
+        --   +---+---+---+  ->  +---+---+---+  ->  +---+---+---+
+        --   | 2 | 3 | 4 |      | 3 | 4 | 5 |      | 4 | 5 | 6 |
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+
+        local num_y     = math.max(math.ceil(#cls / num_x), ncol)
+        local height    = math.floor(wa.height/num_y)
+        local cur_num_x = num_x
+        local at_x      = 0
+        local at_y      = 0
+
+        local remaining_clients = #cls
+
+        -- We start the first row. Left-align by limiting the number of
+        -- available slots.
+        if remaining_clients < num_x then
+            cur_num_x = remaining_clients
+        end
+
+        -- Iterate in reversed order.
+        for i = #cls,1,-1 do
+            -- Get x and y position.
+            local c = cls[i]
+            local this_x = cur_num_x - at_x - 1
+            local this_y = num_y - at_y - 1
+
+            -- Calculate geometry.
+            local g = {}
+            if this_x == (num_x - 1) then
+                g.width = wa.width - (num_x - 1)*width
+            else
+                g.width = width
+            end
+
+            if this_y == (num_y - 1) then
+                g.height = wa.height - (num_y - 1)*height
+            else
+                g.height = height
+            end
+
+            g.x = wa.x + this_x*width
+            g.y = wa.y + this_y*height
+
+            if g.width  < 1 then g.width  = 1 end
+            if g.height < 1 then g.height = 1 end
+
+            p.geometries[c] = g
+
+            remaining_clients = remaining_clients - 1
+
+            -- Next grid position.
+            at_x = at_x + 1
+            if at_x == num_x then
+                -- Row full, create a new one above it.
+                at_x = 0
+                at_y = at_y + 1
+
+                -- We start a new row. Left-align.
+                if remaining_clients < num_x then
+                    cur_num_x = remaining_clients
+                end
+            end
+        end
+    elseif orientation == "stable" then
+        -- Layout with fixed number of vertical columns (read from nmaster).
+        -- New windows align from left to right. When a row is full, a new
+        -- one below it is created. Like this:
+
+        --        (1)                (2)                (3)
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+        --   |   |   |   |      |   |   |   |      |   |   |   |
+        --   | 1 |   |   |  ->  | 1 | 2 |   |  ->  | 1 | 2 | 3 |  ->
+        --   |   |   |   |      |   |   |   |      |   |   |   |
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+
+        --        (4)                (5)                (6)
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+        --   | 1 | 2 | 3 |      | 1 | 2 | 3 |      | 1 | 2 | 3 |
+        --   +---+---+---+      +---+---+---+      +---+---+---+
+        --   | 4 |   |   |      | 4 | 5 |   |      | 4 | 5 | 6 |
+        --   +---+---+---+  ->  +---+---+---+  ->  +---+---+---+
+
+        local num_y     = math.max(math.ceil(#cls / num_x), ncol)
+        local height    = math.floor(wa.height/num_y)
+
+        for i = #cls,1,-1 do
+            -- Get x and y position.
+            local c = cls[i]
+            local this_x = (i - 1) % num_x
+            local this_y = math.floor((i - this_x - 1) / num_x)
+
+            -- Calculate geometry.
+            local g = {}
+            if this_x == (num_x - 1) then
+                g.width = wa.width - (num_x - 1)*width
+            else
+                g.width = width
+            end
+
+            if this_y == (num_y - 1) then
+                g.height = wa.height - (num_y - 1)*height
+            else
+                g.height = height
+            end
+
+            g.x = wa.x + this_x*width
+            g.y = wa.y + this_y*height
+
+            if g.width  < 1 then g.width  = 1 end
+            if g.height < 1 then g.height = 1 end
+
+            p.geometries[c] = g
+        end
+    elseif orientation == "center" then
+        -- Layout with fixed number of vertical columns (read from nmaster).
+        -- Cols are centerded until there is nmaster columns, then windows
+        -- are stacked in the slave columns, with at most ncol clients per
+        -- column if possible.
+
+        -- with nmaster=3 and ncol=1 you'll have
+        --        (1)                (2)                (3)
+        --   +---+---+---+      +-+---+---+-+      +---+---+---+
+        --   |   |   |   |      | |   |   | |      |   |   |   |
+        --   |   | 1 |   |  ->  | | 1 | 2 | | ->   | 1 | 2 | 3 |  ->
+        --   |   |   |   |      | |   |   | |      |   |   |   |
+        --   +---+---+---+      +-+---+---+-+      +---+---+---+
+
+        --        (4)                (5)
+        --   +---+---+---+      +---+---+---+
+        --   |   |   | 3 |      |   | 2 | 4 |
+        --   + 1 + 2 +---+  ->  + 1 +---+---+
+        --   |   |   | 4 |      |   | 3 | 5 |
+        --   +---+---+---+      +---+---+---+
+
+        if #cls < num_x then
+            -- Less clients than the number of columns, let's center it!
+            local offset_x = wa.x + (wa.width - #cls*width) / 2
+            for i = 1, #cls do
+                local g = { y = wa.y }
+                g.width  = width
+                g.height = wa.height
+                if g.width < 1 then g.width = 1 end
+                if g.height < 1 then g.height = 1 end
+                g.x = offset_x + (i - 1) * width
+                p.geometries[cls[i]] = g
+            end
+        else
+            -- More clients than the number of columns, let's arrange it!
+            -- Master client deserves a special treatement
+            local g = {}
+            g.width = wa.width - (num_x - 1)*width
+            g.height = wa.height
+            if g.width < 1 then g.width = 1 end
+            if g.height < 1 then g.height = 1 end
+            g.x = wa.x
+            g.y = wa.y
+            p.geometries[cls[1]] = g
+
+            -- Treat the other clients
+
+            -- Compute distribution of clients among columns
+            local num_y = {}
+            local remaining_clients = #cls-1
+            local ncol_min = math.ceil(remaining_clients/(num_x-1))
+
+            if ncol >= ncol_min then
+                for i = (num_x-1), 1, -1 do
+                    if (remaining_clients-i+1) < ncol then
+                        num_y[i] = remaining_clients-i + 1
+                    else
+                        num_y[i] = ncol
+                    end
+                    remaining_clients = remaining_clients - num_y[i]
+                end
+            else
+                local rem = remaining_clients % (num_x-1)
+                if rem == 0 then
+                    for i = 1, num_x-1 do
+                        num_y[i] = ncol_min
+                    end
+                else
+                    for i = 1, num_x-1 do
+                        num_y[i] = ncol_min - 1
+                    end
+                    for i = 0, rem-1 do
+                        num_y[num_x-1-i] = num_y[num_x-1-i] + 1
+                    end
+                end
+            end
+
+            -- Compute geometry of the other clients
+            local nclient = 2 -- we start with the 2nd client
+            local wx = g.x + g.width
+            for i = 1, (num_x-1) do
+                local height = math.floor(wa.height / num_y[i])
+                local wy = wa.y
+                for _ = 0, (num_y[i]-2) do
+                    g = {}
+                    g.x = wx
+                    g.y = wy
+                    g.height = height
+                    g.width = width
+                    if g.width < 1 then g.width = 1 end
+                    if g.height < 1 then g.height = 1 end
+                    p.geometries[cls[nclient]] = g
+                    nclient = nclient + 1
+                    wy = wy + height
+                end
+                g = {}
+                g.x = wx
+                g.y = wy
+                g.height = wa.height - (num_y[i] - 1)*height
+                g.width = width
+                if g.width < 1 then g.width = 1 end
+                if g.height < 1 then g.height = 1 end
+                p.geometries[cls[nclient]] = g
+                nclient = nclient + 1
+                wx = wx + width
+            end
+        end
+    end
+end
+
+function termfair.center.arrange(p)
+    return do_fair(p, "center")
+end
+
+function termfair.stable.arrange(p)
+    return do_fair(p, "stable")
+end
+
+function termfair.arrange(p)
+    return do_fair(p, "west")
+end
+
+return termfair
diff --git a/lain/util/dkjson.lua b/lain/util/dkjson.lua
new file mode 100644
index 0000000..61cccb9
--- /dev/null
+++ b/lain/util/dkjson.lua
@@ -0,0 +1,747 @@
+-- Module options:
+local always_use_lpeg = false
+local register_global_module_table = false
+local global_module_name = 'json'
+
+--[==[
+
+David Kolf's JSON module for Lua 5.1 - 5.4
+
+Version 2.6
+
+
+For the documentation see the corresponding readme.txt or visit
+<http://dkolf.de/src/dkjson-lua.fsl/>.
+
+You can contact the author by sending an e-mail to 'david' at the
+domain 'dkolf.de'.
+
+
+Copyright (C) 2010-2021 David Heiko Kolf
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+--]==]
+
+-- global dependencies:
+local pairs, type, tostring, tonumber, getmetatable, setmetatable =
+      pairs, type, tostring, tonumber, getmetatable, setmetatable
+local error, require, pcall, select = error, require, pcall, select
+local floor, huge = math.floor, math.huge
+local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =
+      string.rep, string.gsub, string.sub, string.byte, string.char,
+      string.find, string.len, string.format
+local strmatch = string.match
+local concat = table.concat
+
+local json = { version = "dkjson 2.6" }
+
+local jsonlpeg = {}
+
+if register_global_module_table then
+  if always_use_lpeg then
+    _G[global_module_name] = jsonlpeg
+  else
+    _G[global_module_name] = json
+  end
+end
+
+_ENV = nil -- blocking globals in Lua 5.2 and later
+
+pcall (function()
+  -- Enable access to blocked metatables.
+  -- Don't worry, this module doesn't change anything in them.
+  local debmeta = require "debug".getmetatable
+  if debmeta then getmetatable = debmeta end
+end)
+
+json.null = setmetatable ({}, {
+  __tojson = function () return "null" end
+})
+
+local function isarray (tbl)
+  local max, n, arraylen = 0, 0, 0
+  for k,v in pairs (tbl) do
+    if k == 'n' and type(v) == 'number' then
+      arraylen = v
+      if v > max then
+        max = v
+      end
+    else
+      if type(k) ~= 'number' or k < 1 or floor(k) ~= k then
+        return false
+      end
+      if k > max then
+        max = k
+      end
+      n = n + 1
+    end
+  end
+  if max > 10 and max > arraylen and max > n * 2 then
+    return false -- don't create an array with too many holes
+  end
+  return true, max
+end
+
+local escapecodes = {
+  ["\""] = "\\\"", ["\\"] = "\\\\", ["\b"] = "\\b", ["\f"] = "\\f",
+  ["\n"] = "\\n",  ["\r"] = "\\r",  ["\t"] = "\\t"
+}
+
+local function escapeutf8 (uchar)
+  local value = escapecodes[uchar]
+  if value then
+    return value
+  end
+  local a, b, c, d = strbyte (uchar, 1, 4)
+  a, b, c, d = a or 0, b or 0, c or 0, d or 0
+  if a <= 0x7f then
+    value = a
+  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then
+    value = (a - 0xc0) * 0x40 + b - 0x80
+  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then
+    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80
+  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then
+    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80
+  else
+    return ""
+  end
+  if value <= 0xffff then
+    return strformat ("\\u%.4x", value)
+  elseif value <= 0x10ffff then
+    -- encode as UTF-16 surrogate pair
+    value = value - 0x10000
+    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)
+    return strformat ("\\u%.4x\\u%.4x", highsur, lowsur)
+  else
+    return ""
+  end
+end
+
+local function fsub (str, pattern, repl)
+  -- gsub always builds a new string in a buffer, even when no match
+  -- exists. First using find should be more efficient when most strings
+  -- don't contain the pattern.
+  if strfind (str, pattern) then
+    return gsub (str, pattern, repl)
+  else
+    return str
+  end
+end
+
+local function quotestring (value)
+  -- based on the regexp "escapable" in https://github.com/douglascrockford/JSON-js
+  value = fsub (value, "[%z\1-\31\"\\\127]", escapeutf8)
+  if strfind (value, "[\194\216\220\225\226\239]") then
+    value = fsub (value, "\194[\128-\159\173]", escapeutf8)
+    value = fsub (value, "\216[\128-\132]", escapeutf8)
+    value = fsub (value, "\220\143", escapeutf8)
+    value = fsub (value, "\225\158[\180\181]", escapeutf8)
+    value = fsub (value, "\226\128[\140-\143\168-\175]", escapeutf8)
+    value = fsub (value, "\226\129[\160-\175]", escapeutf8)
+    value = fsub (value, "\239\187\191", escapeutf8)
+    value = fsub (value, "\239\191[\176-\191]", escapeutf8)
+  end
+  return "\"" .. value .. "\""
+end
+json.quotestring = quotestring
+
+local function replace(str, o, n)
+  local i, j = strfind (str, o, 1, true)
+  if i then
+    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)
+  else
+    return str
+  end
+end
+
+-- locale independent num2str and str2num functions
+local decpoint, numfilter
+
+local function updatedecpoint ()
+  decpoint = strmatch(tostring(0.5), "([^05+])")
+  -- build a filter that can be used to remove group separators
+  numfilter = "[^0-9%-%+eE" .. gsub(decpoint, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%0") .. "]+"
+end
+
+updatedecpoint()
+
+local function num2str (num)
+  return replace(fsub(tostring(num), numfilter, ""), decpoint, ".")
+end
+
+local function str2num (str)
+  local num = tonumber(replace(str, ".", decpoint))
+  if not num then
+    updatedecpoint()
+    num = tonumber(replace(str, ".", decpoint))
+  end
+  return num
+end
+
+local function addnewline2 (level, buffer, buflen)
+  buffer[buflen+1] = "\n"
+  buffer[buflen+2] = strrep ("  ", level)
+  buflen = buflen + 2
+  return buflen
+end
+
+function json.addnewline (state)
+  if state.indent then
+    state.bufferlen = addnewline2 (state.level or 0,
+                           state.buffer, state.bufferlen or #(state.buffer))
+  end
+end
+
+local encode2 -- forward declaration
+
+local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)
+  local kt = type (key)
+  if kt ~= 'string' and kt ~= 'number' then
+    return nil, "type '" .. kt .. "' is not supported as a key by JSON."
+  end
+  if prev then
+    buflen = buflen + 1
+    buffer[buflen] = ","
+  end
+  if indent then
+    buflen = addnewline2 (level, buffer, buflen)
+  end
+  buffer[buflen+1] = quotestring (key)
+  buffer[buflen+2] = ":"
+  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)
+end
+
+local function appendcustom(res, buffer, state)
+  local buflen = state.bufferlen
+  if type (res) == 'string' then
+    buflen = buflen + 1
+    buffer[buflen] = res
+  end
+  return buflen
+end
+
+local function exception(reason, value, state, buffer, buflen, defaultmessage)
+  defaultmessage = defaultmessage or reason
+  local handler = state.exception
+  if not handler then
+    return nil, defaultmessage
+  else
+    state.bufferlen = buflen
+    local ret, msg = handler (reason, value, state, defaultmessage)
+    if not ret then return nil, msg or defaultmessage end
+    return appendcustom(ret, buffer, state)
+  end
+end
+
+function json.encodeexception(_reason, _value, _state, defaultmessage)
+  return quotestring("<" .. defaultmessage .. ">")
+end
+
+encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)
+  local valtype = type (value)
+  local valmeta = getmetatable (value)
+  valmeta = type (valmeta) == 'table' and valmeta -- only tables
+  local valtojson = valmeta and valmeta.__tojson
+  if valtojson then
+    if tables[value] then
+      return exception('reference cycle', value, state, buffer, buflen)
+    end
+    tables[value] = true
+    state.bufferlen = buflen
+    local ret, msg = valtojson (value, state)
+    if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end
+    tables[value] = nil
+    buflen = appendcustom(ret, buffer, state)
+  elseif value == nil then
+    buflen = buflen + 1
+    buffer[buflen] = "null"
+  elseif valtype == 'number' then
+    local s
+    if value ~= value or value >= huge or -value >= huge then
+      -- This is the behaviour of the original JSON implementation.
+      s = "null"
+    else
+      s = num2str (value)
+    end
+    buflen = buflen + 1
+    buffer[buflen] = s
+  elseif valtype == 'boolean' then
+    buflen = buflen + 1
+    buffer[buflen] = value and "true" or "false"
+  elseif valtype == 'string' then
+    buflen = buflen + 1
+    buffer[buflen] = quotestring (value)
+  elseif valtype == 'table' then
+    if tables[value] then
+      return exception('reference cycle', value, state, buffer, buflen)
+    end
+    tables[value] = true
+    level = level + 1
+    local isa, n = isarray (value)
+    if n == 0 and valmeta and valmeta.__jsontype == 'object' then
+      isa = false
+    end
+    local msg
+    if isa then -- JSON array
+      buflen = buflen + 1
+      buffer[buflen] = "["
+      for i = 1, n do
+        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)
+        if not buflen then return nil, msg end
+        if i < n then
+          buflen = buflen + 1
+          buffer[buflen] = ","
+        end
+      end
+      buflen = buflen + 1
+      buffer[buflen] = "]"
+    else -- JSON object
+      local prev = false
+      buflen = buflen + 1
+      buffer[buflen] = "{"
+      local order = valmeta and valmeta.__jsonorder or globalorder
+      if order then
+        local used = {}
+        n = #order
+        for i = 1, n do
+          local k = order[i]
+          local v = value[k]
+          if v ~= nil then
+            used[k] = true
+            buflen, _msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
+            prev = true -- add a seperator before the next element
+          end
+        end
+        for k,v in pairs (value) do
+          if not used[k] then
+            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
+            if not buflen then return nil, msg end
+            prev = true -- add a seperator before the next element
+          end
+        end
+      else -- unordered
+        for k,v in pairs (value) do
+          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
+          if not buflen then return nil, msg end
+          prev = true -- add a seperator before the next element
+        end
+      end
+      if indent then
+        buflen = addnewline2 (level - 1, buffer, buflen)
+      end
+      buflen = buflen + 1
+      buffer[buflen] = "}"
+    end
+    tables[value] = nil
+  else
+    return exception ('unsupported type', value, state, buffer, buflen,
+      "type '" .. valtype .. "' is not supported by JSON.")
+  end
+  return buflen
+end
+
+function json.encode (value, state)
+  state = state or {}
+  local oldbuffer = state.buffer
+  local buffer = oldbuffer or {}
+  state.buffer = buffer
+  updatedecpoint()
+  local ret, msg = encode2 (value, state.indent, state.level or 0,
+                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)
+  if not ret then
+    error (msg, 2)
+  elseif oldbuffer == buffer then
+    state.bufferlen = ret
+    return true
+  else
+    state.bufferlen = nil
+    state.buffer = nil
+    return concat (buffer)
+  end
+end
+
+local function loc (str, where)
+  local line, pos, linepos = 1, 1, 0
+  while true do
+    pos = strfind (str, "\n", pos, true)
+    if pos and pos < where then
+      line = line + 1
+      linepos = pos
+      pos = pos + 1
+    else
+      break
+    end
+  end
+  return "line " .. line .. ", column " .. (where - linepos)
+end
+
+local function unterminated (str, what, where)
+  return nil, strlen (str) + 1, "unterminated " .. what .. " at " .. loc (str, where)
+end
+
+local function scanwhite (str, pos)
+  while true do
+    pos = strfind (str, "%S", pos)
+    if not pos then return nil end
+    local sub2 = strsub (str, pos, pos + 1)
+    if sub2 == "\239\187" and strsub (str, pos + 2, pos + 2) == "\191" then
+      -- UTF-8 Byte Order Mark
+      pos = pos + 3
+    elseif sub2 == "//" then
+      pos = strfind (str, "[\n\r]", pos + 2)
+      if not pos then return nil end
+    elseif sub2 == "/*" then
+      pos = strfind (str, "*/", pos + 2)
+      if not pos then return nil end
+      pos = pos + 2
+    else
+      return pos
+    end
+  end
+end
+
+local escapechars = {
+  ["\""] = "\"", ["\\"] = "\\", ["/"] = "/", ["b"] = "\b", ["f"] = "\f",
+  ["n"] = "\n", ["r"] = "\r", ["t"] = "\t"
+}
+
+local function unichar (value)
+  if value < 0 then
+    return nil
+  elseif value <= 0x007f then
+    return strchar (value)
+  elseif value <= 0x07ff then
+    return strchar (0xc0 + floor(value/0x40),
+                    0x80 + (floor(value) % 0x40))
+  elseif value <= 0xffff then
+    return strchar (0xe0 + floor(value/0x1000),
+                    0x80 + (floor(value/0x40) % 0x40),
+                    0x80 + (floor(value) % 0x40))
+  elseif value <= 0x10ffff then
+    return strchar (0xf0 + floor(value/0x40000),
+                    0x80 + (floor(value/0x1000) % 0x40),
+                    0x80 + (floor(value/0x40) % 0x40),
+                    0x80 + (floor(value) % 0x40))
+  else
+    return nil
+  end
+end
+
+local function scanstring (str, pos)
+  local lastpos = pos + 1
+  local buffer, n = {}, 0
+  while true do
+    local nextpos = strfind (str, "[\"\\]", lastpos)
+    if not nextpos then
+      return unterminated (str, "string", pos)
+    end
+    if nextpos > lastpos then
+      n = n + 1
+      buffer[n] = strsub (str, lastpos, nextpos - 1)
+    end
+    if strsub (str, nextpos, nextpos) == "\"" then
+      lastpos = nextpos + 1
+      break
+    else
+      local escchar = strsub (str, nextpos + 1, nextpos + 1)
+      local value
+      if escchar == "u" then
+        value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)
+        if value then
+          local value2
+          if 0xD800 <= value and value <= 0xDBff then
+            -- we have the high surrogate of UTF-16. Check if there is a
+            -- low surrogate escaped nearby to combine them.
+            if strsub (str, nextpos + 6, nextpos + 7) == "\\u" then
+              value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)
+              if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then
+                value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000
+              else
+                value2 = nil -- in case it was out of range for a low surrogate
+              end
+            end
+          end
+          value = value and unichar (value)
+          if value then
+            if value2 then
+              lastpos = nextpos + 12
+            else
+              lastpos = nextpos + 6
+            end
+          end
+        end
+      end
+      if not value then
+        value = escapechars[escchar] or escchar
+        lastpos = nextpos + 2
+      end
+      n = n + 1
+      buffer[n] = value
+    end
+  end
+  if n == 1 then
+    return buffer[1], lastpos
+  elseif n > 1 then
+    return concat (buffer), lastpos
+  else
+    return "", lastpos
+  end
+end
+
+local scanvalue -- forward declaration
+
+local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)
+  local tbl, n = {}, 0
+  local pos = startpos + 1
+  if what == 'object' then
+    setmetatable (tbl, objectmeta)
+  else
+    setmetatable (tbl, arraymeta)
+  end
+  while true do
+    pos = scanwhite (str, pos)
+    if not pos then return unterminated (str, what, startpos) end
+    local char = strsub (str, pos, pos)
+    if char == closechar then
+      return tbl, pos + 1
+    end
+    local val1, err
+    val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)
+    if err then return nil, pos, err end
+    pos = scanwhite (str, pos)
+    if not pos then return unterminated (str, what, startpos) end
+    char = strsub (str, pos, pos)
+    if char == ":" then
+      if val1 == nil then
+        return nil, pos, "cannot use nil as table index (at " .. loc (str, pos) .. ")"
+      end
+      pos = scanwhite (str, pos + 1)
+      if not pos then return unterminated (str, what, startpos) end
+      local val2
+      val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)
+      if err then return nil, pos, err end
+      tbl[val1] = val2
+      pos = scanwhite (str, pos)
+      if not pos then return unterminated (str, what, startpos) end
+      char = strsub (str, pos, pos)
+    else
+      n = n + 1
+      tbl[n] = val1
+    end
+    if char == "," then
+      pos = pos + 1
+    end
+  end
+end
+
+scanvalue = function (str, pos, nullval, objectmeta, arraymeta)
+  pos = pos or 1
+  pos = scanwhite (str, pos)
+  if not pos then
+    return nil, strlen (str) + 1, "no valid JSON value (reached the end)"
+  end
+  local char = strsub (str, pos, pos)
+  if char == "{" then
+    return scantable ('object', "}", str, pos, nullval, objectmeta, arraymeta)
+  elseif char == "[" then
+    return scantable ('array', "]", str, pos, nullval, objectmeta, arraymeta)
+  elseif char == "\"" then
+    return scanstring (str, pos)
+  else
+    local pstart, pend = strfind (str, "^%-?[%d%.]+[eE]?[%+%-]?%d*", pos)
+    if pstart then
+      local number = str2num (strsub (str, pstart, pend))
+      if number then
+        return number, pend + 1
+      end
+    end
+    pstart, pend = strfind (str, "^%a%w*", pos)
+    if pstart then
+      local name = strsub (str, pstart, pend)
+      if name == "true" then
+        return true, pend + 1
+      elseif name == "false" then
+        return false, pend + 1
+      elseif name == "null" then
+        return nullval, pend + 1
+      end
+    end
+    return nil, pos, "no valid JSON value at " .. loc (str, pos)
+  end
+end
+
+local function optionalmetatables(...)
+  if select("#", ...) > 0 then
+    return ...
+  else
+    return {__jsontype = 'object'}, {__jsontype = 'array'}
+  end
+end
+
+function json.decode (str, pos, nullval, ...)
+  local objectmeta, arraymeta = optionalmetatables(...)
+  return scanvalue (str, pos, nullval, objectmeta, arraymeta)
+end
+
+function json.use_lpeg ()
+  local g = require ("lpeg")
+
+  if g.version() == "0.11" then
+    error "due to a bug in LPeg 0.11, it cannot be used for JSON matching"
+  end
+
+  local pegmatch = g.match
+  local P, S, R = g.P, g.S, g.R
+
+  local function ErrorCall (str, pos, msg, state)
+    if not state.msg then
+      state.msg = msg .. " at " .. loc (str, pos)
+      state.pos = pos
+    end
+    return false
+  end
+
+  local function Err (msg)
+    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)
+  end
+
+  local function ErrorUnterminatedCall (str, pos, what, state)
+    return ErrorCall (str, pos - 1, "unterminated " .. what, state)
+  end
+
+  local SingleLineComment = P"//" * (1 - S"\n\r")^0
+  local MultiLineComment = P"/*" * (1 - P"*/")^0 * P"*/"
+  local Space = (S" \n\r\t" + P"\239\187\191" + SingleLineComment + MultiLineComment)^0
+
+  local function ErrUnterminated (what)
+    return g.Cmt (g.Cc (what) * g.Carg (2), ErrorUnterminatedCall)
+  end
+
+  local PlainChar = 1 - S"\"\\\n\r"
+  local EscapeSequence = (P"\\" * g.C (S"\"\\/bfnrt" + Err "unsupported escape sequence")) / escapechars
+  local HexDigit = R("09", "af", "AF")
+  local function UTF16Surrogate (_match, _pos, high, low)
+    high, low = tonumber (high, 16), tonumber (low, 16)
+    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then
+      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)
+    else
+      return false
+    end
+  end
+  local function UTF16BMP (hex)
+    return unichar (tonumber (hex, 16))
+  end
+  local U16Sequence = (P"\\u" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))
+  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP
+  local Char = UnicodeEscape + EscapeSequence + PlainChar
+  local String = P"\"" * (g.Cs (Char ^ 0) * P"\"" + ErrUnterminated "string")
+  local Integer = P"-"^(-1) * (P"0" + (R"19" * R"09"^0))
+  local Fractal = P"." * R"09"^0
+  local Exponent = (S"eE") * (S"+-")^(-1) * R"09"^1
+  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num
+  local Constant = P"true" * g.Cc (true) + P"false" * g.Cc (false) + P"null" * g.Carg (1)
+  local SimpleValue = Number + String + Constant
+  local ArrayContent, ObjectContent
+
+  -- The functions parsearray and parseobject parse only a single value/pair
+  -- at a time and store them directly to avoid hitting the LPeg limits.
+  local function parsearray (str, pos, nullval, state)
+    local obj, cont
+    local start = pos
+    local npos
+    local t, nt = {}, 0
+    repeat
+      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)
+      if cont == 'end' then
+        return ErrorUnterminatedCall (str, start, "array", state)
+      end
+      pos = npos
+      if cont == 'cont' or cont == 'last' then
+        nt = nt + 1
+        t[nt] = obj
+      end
+    until cont ~= 'cont'
+    return pos, setmetatable (t, state.arraymeta)
+  end
+
+  local function parseobject (str, pos, nullval, state)
+    local obj, key, cont
+    local start = pos
+    local npos
+    local t = {}
+    repeat
+      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)
+      if cont == 'end' then
+        return ErrorUnterminatedCall (str, start, "object", state)
+      end
+      pos = npos
+      if cont == 'cont' or cont == 'last' then
+        t[key] = obj
+      end
+    until cont ~= 'cont'
+    return pos, setmetatable (t, state.objectmeta)
+  end
+
+  local Array = P"[" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray)
+  local Object = P"{" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject)
+  local Value = Space * (Array + Object + SimpleValue)
+  local ExpectedValue = Value + Space * Err "value expected"
+  local ExpectedKey = String + Err "key expected"
+  local End = P(-1) * g.Cc'end'
+  local ErrInvalid = Err "invalid JSON"
+  ArrayContent = (Value * Space * (P"," * g.Cc'cont' + P"]" * g.Cc'last'+ End + ErrInvalid)  + g.Cc(nil) * (P"]" * g.Cc'empty' + End  + ErrInvalid)) * g.Cp()
+  local Pair = g.Cg (Space * ExpectedKey * Space * (P":" + Err "colon expected") * ExpectedValue)
+  ObjectContent = (g.Cc(nil) * g.Cc(nil) * P"}" * g.Cc'empty' + End + (Pair * Space * (P"," * g.Cc'cont' + P"}" * g.Cc'last' + End + ErrInvalid) + ErrInvalid)) * g.Cp()
+  local DecodeValue = ExpectedValue * g.Cp ()
+
+  jsonlpeg.version = json.version
+  jsonlpeg.encode = json.encode
+  jsonlpeg.null = json.null
+  jsonlpeg.quotestring = json.quotestring
+  jsonlpeg.addnewline = json.addnewline
+  jsonlpeg.encodeexception = json.encodeexception
+  jsonlpeg.using_lpeg = true
+
+  function jsonlpeg.decode (str, pos, nullval, ...)
+    local state = {}
+    state.objectmeta, state.arraymeta = optionalmetatables(...)
+    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)
+    if state.msg then
+      return nil, state.pos, state.msg
+    else
+      return obj, retpos
+    end
+  end
+
+  -- cache result of this function:
+  json.use_lpeg = function () return jsonlpeg end
+  jsonlpeg.use_lpeg = json.use_lpeg
+
+  return jsonlpeg
+end
+
+if always_use_lpeg then
+  return json.use_lpeg()
+end
+
+return json
+
diff --git a/lain/util/init.lua b/lain/util/init.lua
new file mode 100644
index 0000000..5ae0523
--- /dev/null
+++ b/lain/util/init.lua
@@ -0,0 +1,190 @@
+--[[
+
+     Lain
+     Layouts, widgets and utilities for Awesome WM
+
+     Utilities section
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local awful        = require("awful")
+local sqrt         = math.sqrt
+local pairs        = pairs
+local client       = client
+local tonumber     = tonumber
+local wrequire     = require("lain.helpers").wrequire
+local setmetatable = setmetatable
+
+-- Lain utilities submodule
+-- lain.util
+local util = { _NAME = "lain.util" }
+
+-- Like awful.menu.clients, but only show clients of currently selected tags
+function util.menu_clients_current_tags(menu, args)
+    -- List of currently selected tags.
+    local cls_tags = awful.screen.focused().selected_tags
+
+    if cls_tags == nil then return nil end
+
+    -- Final list of menu items.
+    local cls_t = {}
+
+    -- For each selected tag get all clients of that tag and add them to
+    -- the menu. A click on a menu item will raise that client.
+    for i = 1,#cls_tags do
+        local t   = cls_tags[i]
+        local cls = t:clients()
+
+        for _, c in pairs(cls) do
+            cls_t[#cls_t + 1] = { awful.util.escape(c.name) or "",
+                                  function ()
+                                      c.minimized = false
+                                      client.focus = c
+                                      c:raise()
+                                  end,
+                                  c.icon }
+        end
+    end
+
+    -- No clients? Then quit.
+    if #cls_t <= 0 then return nil end
+
+    -- menu may contain some predefined values, otherwise start with a
+    -- fresh menu.
+    if not menu then menu = {} end
+
+    -- Set the list of items and show the menu.
+    menu.items = cls_t
+    local m = awful.menu(menu)
+    m:show(args)
+
+    return m
+end
+
+-- Magnify a client: set it to "float" and resize it.
+function util.magnify_client(c, width_f, height_f)
+    if c and not c.floating then
+        util.magnified_client = c
+        util.mc(c, width_f, height_f)
+    else
+        util.magnified_client = nil
+        c.floating = false
+    end
+end
+
+-- https://github.com/lcpz/lain/issues/195
+function util.mc(c, width_f, height_f)
+    c = c or util.magnified_client
+    if not c then return end
+
+    c.floating   = true
+    local s      = awful.screen.focused()
+    local mg     = s.workarea
+    local g      = {}
+    local mwfact = width_f or s.selected_tag.master_width_factor or 0.5
+    g.width      = sqrt(mwfact) * mg.width
+    g.height     = sqrt(height_f or mwfact) * mg.height
+    g.x          = mg.x + (mg.width - g.width) / 2
+    g.y          = mg.y + (mg.height - g.height) / 2
+
+    if c then c:geometry(g) end -- if c is still a valid object
+end
+
+-- Non-empty tag browsing
+-- direction in {-1, 1} <-> {previous, next} non-empty tag
+function util.tag_view_nonempty(direction,sc)
+    direction  = direction or 1
+    local s    = sc or awful.screen.focused()
+    local tags = s.tags
+    local sel  = s.selected_tag
+
+    local i = sel.index
+    repeat
+        i = i + direction
+
+        -- Wrap around when we reach one of the bounds
+        if i > #tags then
+            i = i - #tags
+        end
+        if i < 1 then
+            i = i + #tags
+        end
+
+        local t = tags[i]
+
+        -- Stop when we get back to where we started
+        if t == sel then
+            break
+        end
+
+        -- If it's The One, view it.
+        if #t:clients() > 0 then
+            t:view_only()
+            return
+        end
+    until false
+end
+
+-- {{{ Dynamic tagging
+
+-- Add a new tag
+function util.add_tag(layout)
+    awful.prompt.run {
+        prompt       = "New tag name: ",
+        textbox      = awful.screen.focused().mypromptbox.widget,
+        exe_callback = function(name)
+            if not name or #name == 0 then return end
+            awful.tag.add(name, { screen = awful.screen.focused(), layout = layout or awful.layout.suit.tile }):view_only()
+        end
+    }
+end
+
+-- Rename current tag
+function util.rename_tag()
+    awful.prompt.run {
+        prompt       = "Rename tag: ",
+        textbox      = awful.screen.focused().mypromptbox.widget,
+        exe_callback = function(new_name)
+            if not new_name or #new_name == 0 then return end
+            local t = awful.screen.focused().selected_tag
+            if t then
+                t.name = new_name
+            end
+        end
+    }
+end
+
+-- Move current tag
+-- pos in {-1, 1} <-> {previous, next} tag position
+function util.move_tag(pos)
+    local tag = awful.screen.focused().selected_tag
+    if tonumber(pos) <= -1 then
+        awful.tag.move(tag.index - 1, tag)
+    else
+        awful.tag.move(tag.index + 1, tag)
+    end
+end
+
+-- Delete current tag
+-- Any rule set on the tag shall be broken
+function util.delete_tag()
+    local t = awful.screen.focused().selected_tag
+    if not t then return end
+    t:delete()
+end
+
+-- }}}
+
+-- On the fly useless gaps change
+function util.useless_gaps_resize(thatmuch, s, t)
+    local scr = s or awful.screen.focused()
+    local tag = t or scr.selected_tag
+    tag.gap = tag.gap + tonumber(thatmuch)
+    awful.layout.arrange(scr)
+end
+
+return setmetatable(util, { __index = wrequire })
diff --git a/lain/util/markup.lua b/lain/util/markup.lua
new file mode 100644
index 0000000..63f9486
--- /dev/null
+++ b/lain/util/markup.lua
@@ -0,0 +1,66 @@
+--[[
+
+     Licensed under MIT License
+      * (c) 2013, Luca CPZ
+      * (c) 2009, Uli Schlachter
+      * (c) 2009, Majic
+
+--]]
+
+local format = string.format
+local setmetatable = setmetatable
+
+-- Lain markup util submodule
+-- lain.util.markup
+local markup = { fg = {}, bg = {} }
+
+-- Convenience tags
+function markup.bold(text)      return format("<b>%s</b>",         text) end
+function markup.italic(text)    return format("<i>%s</i>",         text) end
+function markup.strike(text)    return format("<s>%s</s>",         text) end
+function markup.underline(text) return format("<u>%s</u>",         text) end
+function markup.monospace(text) return format("<tt>%s</tt>",       text) end
+function markup.big(text)       return format("<big>%s</big>",     text) end
+function markup.small(text)     return format("<small>%s</small>", text) end
+
+-- Set the font
+function markup.font(font, text)
+    return format("<span font='%s'>%s</span>", font, text)
+end
+
+-- Set the foreground
+function markup.fg.color(color, text)
+    return format("<span foreground='%s'>%s</span>", color, text)
+end
+
+-- Set the background
+function markup.bg.color(color, text)
+    return format("<span background='%s'>%s</span>", color, text)
+end
+
+-- Set foreground and background
+function markup.color(fg, bg, text)
+    return format("<span foreground='%s' background='%s'>%s</span>", fg, bg, text)
+end
+
+-- Set font and foreground
+function markup.fontfg(font, fg, text)
+    return format("<span font='%s' foreground='%s'>%s</span>", font, fg, text)
+end
+
+-- Set font and background
+function markup.fontbg(font, bg, text)
+    return format("<span font='%s' background='%s'>%s</span>", font, bg, text)
+end
+
+-- Set font, foreground and background
+function markup.fontcolor(font, fg, bg, text)
+    return format("<span font='%s' foreground='%s' background='%s'>%s</span>", font, fg, bg, text)
+end
+
+-- link markup.{fg,bg}(...) calls to markup.{fg,bg}.color(...)
+setmetatable(markup.fg, { __call = function(_, ...) return markup.fg.color(...) end })
+setmetatable(markup.bg, { __call = function(_, ...) return markup.bg.color(...) end })
+
+-- link markup(...) calls to markup.fg.color(...)
+return setmetatable(markup, { __call = function(_, ...) return markup.fg.color(...) end })
diff --git a/lain/util/menu_iterator.lua b/lain/util/menu_iterator.lua
new file mode 100644
index 0000000..d457473
--- /dev/null
+++ b/lain/util/menu_iterator.lua
@@ -0,0 +1,144 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2017, Simon Désaulniers <sim.desaulniers@gmail.com>
+      * (c) 2017, Uli Schlachter
+      * (c) 2017, Jeferson Siqueira <jefersonlsiq@gmail.com>
+
+--]]
+
+-- Menu iterator with Naughty notifications
+-- lain.util.menu_iterator
+
+local naughty = require("naughty")
+local helpers = require("lain.helpers")
+local atable  = require("awful.util").table
+local assert  = assert
+local pairs   = pairs
+local tconcat = table.concat
+local unpack = unpack or table.unpack -- lua 5.1 retro-compatibility
+
+local state = { cid = nil }
+
+local function naughty_destroy_callback(reason)
+    local closed = naughty.notificationClosedReason
+    if reason == closed.expired or reason == closed.dismissedByUser then
+        local actions = state.index and state.menu[state.index - 1][2]
+        if actions then
+            for _,action in pairs(actions) do
+                -- don't try to call nil callbacks
+                if action then action() end
+            end
+            state.index = nil
+        end
+    end
+end
+
+-- Iterates over a menu.
+-- After the timeout, callbacks associated to the last visited choice are
+-- executed. Inputs:
+-- * menu:    a list of {label, {callbacks}} pairs
+-- * timeout: time to wait before confirming the menu selection
+-- * icon:    icon to display in the notification of the chosen label
+local function iterate(menu, timeout, icon)
+    timeout = timeout or 4 -- default timeout for each menu entry
+    icon    = icon or nil  -- icon to display on the menu
+
+    -- Build the list of choices
+    if not state.index then
+        state.menu = menu
+        state.index = 1
+    end
+
+    -- Select one and display the appropriate notification
+    local label
+    local next = state.menu[state.index]
+    state.index = state.index + 1
+
+    if not next then
+        label = "Cancel"
+        state.index = nil
+    else
+        label, _ = unpack(next)
+    end
+
+    state.cid = naughty.notify({
+        text        = label,
+        icon        = icon,
+        timeout     = timeout,
+        screen      = mouse.screen,
+        replaces_id = state.cid,
+        destroy     = naughty_destroy_callback
+    }).id
+end
+
+-- Generates a menu compatible with the first argument of `iterate` function and
+-- suitable for the following cases:
+-- * all possible choices individually (partition of singletons);
+-- * all possible subsets of the set of choices (powerset).
+--
+-- Inputs:
+-- * args: an array containing the following members:
+--   * choices:       Array of choices (string) on which the menu will be
+--                    generated.
+--   * name:          Displayed name of the menu (in the form "name: choices").
+--   * selected_cb:   Callback to execute for each selected choice. Takes
+--                    the choice as a string argument. Can be `nil` (no action
+--                    to execute).
+--   * rejected_cb:   Callback to execute for each rejected choice (possible
+--                    choices which are not selected). Takes the choice as a
+--                    string argument. Can be `nil` (no action to execute).
+--   * extra_choices: An array of extra { choice_str, callback_fun } pairs to be
+--                    added to the menu. Each callback_fun can be `nil`.
+--   * combination:   The combination of choices to generate. Possible values:
+--                    "powerset" and "single" (default).
+-- Output:
+-- * m: menu to be iterated over.
+local function menu(args)
+    local choices       = assert(args.choices or args[1])
+    local name          = assert(args.name or args[2])
+    local selected_cb   = args.selected_cb
+    local rejected_cb   = args.rejected_cb
+    local extra_choices = args.extra_choices or {}
+
+    local ch_combinations = args.combination == "powerset" and helpers.powerset(choices) or helpers.trivial_partition_set(choices)
+
+    for _, c in pairs(extra_choices) do
+        ch_combinations = atable.join(ch_combinations, {{c[1]}})
+    end
+
+    local m = {} -- the menu
+
+    for _,c in pairs(ch_combinations) do
+        if #c > 0 then
+            local cbs = {}
+
+            -- selected choices
+            for _,ch in pairs(c) do
+                if atable.hasitem(choices, ch) then
+                    cbs[#cbs + 1] = selected_cb and function() selected_cb(ch) end or nil
+                end
+            end
+
+            -- rejected choices
+            for _,ch in pairs(choices) do
+                if not atable.hasitem(c, ch) and atable.hasitem(choices, ch) then
+                    cbs[#cbs + 1] = rejected_cb and function() rejected_cb(ch) end or nil
+                end
+            end
+
+            -- add user extra choices (like the choice "None" for example)
+            for _,x in pairs(extra_choices) do
+                if x[1] == c[1] then
+                    cbs[#cbs + 1] = x[2]
+                end
+            end
+
+            m[#m + 1] = { name .. ": " .. tconcat(c, " + "), cbs }
+        end
+    end
+
+    return m
+end
+
+return { iterate = iterate, menu = menu }
diff --git a/lain/util/quake.lua b/lain/util/quake.lua
new file mode 100644
index 0000000..8bc68a7
--- /dev/null
+++ b/lain/util/quake.lua
@@ -0,0 +1,179 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2016, Luca CPZ
+      * (c) 2015, unknown
+
+--]]
+
+local awful        = require("awful")
+local capi         = { client = client }
+local math         = math
+local string       = string
+local pairs        = pairs
+local screen       = screen
+local setmetatable = setmetatable
+
+-- Quake-like Dropdown application spawn
+local quake = {}
+
+-- If you have a rule like "awful.client.setslave" for your terminals,
+-- ensure you use an exception for QuakeDD. Otherwise, you may
+-- run into problems with focus.
+
+function quake:display()
+    if self.followtag then self.screen = awful.screen.focused() end
+
+    -- First, we locate the client
+    local client = nil
+    local i = 0
+    for c in awful.client.iterate(function (c)
+        -- c.name may be changed!
+        return c.instance == self.name
+    end)
+    do
+        i = i + 1
+        if i == 1 then
+            client = c
+        else
+            -- Additional matching clients, let's remove the sticky bit
+            -- which may persist between awesome restarts. We don't close
+            -- them as they may be valuable. They will just turn into
+            -- normal clients.
+            c.sticky = false
+            c.ontop = false
+            c.above = false
+        end
+    end
+
+    if not client and not self.visible then return end
+
+    if not client then
+        -- The client does not exist, we spawn it
+        local cmd = string.format("%s %s %s", self.app,
+              string.format(self.argname, self.name), self.extra)
+        awful.spawn(cmd, { tag = self.screen.selected_tag })
+        return
+    end
+
+    -- Set geometry
+    client.floating = true
+    client.border_width = self.border
+    client.size_hints_honor = false
+    local maximized = client.maximized
+    local fullscreen = client.fullscreen
+    client:geometry(self.geometry[self.screen.index] or self:compute_size())
+
+    -- Set not sticky and on top
+    client.sticky = false
+    client.ontop = true
+    client.above = true
+    client.skip_taskbar = true
+
+    -- Additional user settings
+    if self.settings then self.settings(client) end
+
+    -- Toggle display
+    if self.visible then
+        client.hidden = false
+        client.maximized = self.maximized
+        client.fullscreen = self.fullscreen
+        client:raise()
+        self.last_tag = self.screen.selected_tag
+        client:tags({self.screen.selected_tag})
+        capi.client.focus = client
+    else
+        self.maximized = maximized
+        self.fullscreen = fullscreen
+        client.maximized = false
+        client.fullscreen = false
+        client.hidden = true
+        local ctags = client:tags()
+        for j, _ in pairs(ctags) do
+            ctags[j] = nil
+        end
+        client:tags(ctags)
+    end
+
+    return client
+end
+
+function quake:compute_size()
+    -- skip if we already have a geometry for this screen
+    if not self.geometry[self.screen.index] then
+        local geom
+        if not self.overlap then
+            geom = screen[self.screen.index].workarea
+        else
+            geom = screen[self.screen.index].geometry
+        end
+        local width, height = self.width, self.height
+        if width  <= 1 then width = math.floor(geom.width * width) - 2 * self.border end
+        if height <= 1 then height = math.floor(geom.height * height) end
+        local x, y
+        if     self.horiz == "left"  then x = geom.x
+        elseif self.horiz == "right" then x = geom.width + geom.x - width
+        else   x = geom.x + (geom.width - width)/2 end
+        if     self.vert == "top"    then y = geom.y
+        elseif self.vert == "bottom" then y = geom.height + geom.y - height
+        else   y = geom.y + (geom.height - height)/2 end
+        self.geometry[self.screen.index] = { x = x, y = y, width = width, height = height }
+    end
+    return self.geometry[self.screen.index]
+end
+
+function quake:toggle()
+     if self.followtag then self.screen = awful.screen.focused() end
+     local current_tag = self.screen.selected_tag
+     if current_tag and self.last_tag ~= current_tag and self.visible then
+         local c=self:display()
+         if c then
+            c:move_to_tag(current_tag)
+        end
+     else
+         self.visible = not self.visible
+         self:display()
+     end
+end
+
+function quake.new(conf)
+    conf = conf or {}
+
+    conf.app        = conf.app       or "xterm"    -- application to spawn
+    conf.name       = conf.name      or "QuakeDD"  -- window name
+    conf.argname    = conf.argname   or "-name %s" -- how to specify window name
+    conf.extra      = conf.extra     or ""         -- extra arguments
+    conf.border     = conf.border    or 1          -- client border width
+    conf.visible    = conf.visible   or false      -- initially not visible
+    conf.followtag  = conf.followtag or false      -- spawn on currently focused screen
+    conf.overlap    = conf.overlap   or false      -- overlap wibox
+    conf.screen     = conf.screen    or awful.screen.focused()
+    conf.settings   = conf.settings
+
+    -- If width or height <= 1 this is a proportion of the workspace
+    conf.height     = conf.height    or 0.25       -- height
+    conf.width      = conf.width     or 1          -- width
+    conf.vert       = conf.vert      or "top"      -- top, bottom or center
+    conf.horiz      = conf.horiz     or "left"     -- left, right or center
+    conf.geometry   = {}                           -- internal use
+
+    conf.maximized = false
+    conf.fullscreen = false
+
+    local dropdown = setmetatable(conf, { __index = quake })
+
+    capi.client.connect_signal("manage", function(c)
+        if c.instance == dropdown.name and c.screen == dropdown.screen then
+            dropdown:display()
+        end
+    end)
+    capi.client.connect_signal("unmanage", function(c)
+        if c.instance == dropdown.name and c.screen == dropdown.screen then
+            dropdown.visible = false
+        end
+     end)
+
+    return dropdown
+end
+
+return setmetatable(quake, { __call = function(_, ...) return quake.new(...) end })
diff --git a/lain/util/separators.lua b/lain/util/separators.lua
new file mode 100644
index 0000000..04402bb
--- /dev/null
+++ b/lain/util/separators.lua
@@ -0,0 +1,118 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2015, Luca CPZ
+      * (c) 2015, plotnikovanton
+
+--]]
+
+local wibox = require("wibox")
+local gears = require("gears")
+local beautiful = require("beautiful")
+
+-- Lain Cairo separators util submodule
+-- lain.util.separators
+local separators = { height = beautiful.separators_height or 0, width = beautiful.separators_width or 9 }
+
+-- [[ Arrow
+
+-- Right
+function separators.arrow_right(col1, col2)
+    local widget = wibox.widget.base.make_widget()
+    widget.col1 = col1
+    widget.col2 = col2
+
+    widget.fit = function(_, _, _)
+        return separators.width, separators.height
+    end
+
+    widget.update = function(_, _)
+        widget.col1 = col1
+        widget.col2 = col2
+        widget:emit_signal("widget::redraw_needed")
+    end
+
+    widget.draw = function(_, _, cr, width, height)
+        if widget.col2 ~= "alpha" then
+            cr:set_source_rgba(gears.color.parse_color(widget.col2))
+            cr:new_path()
+            cr:move_to(0, 0)
+            cr:line_to(width, height/2)
+            cr:line_to(width, 0)
+            cr:close_path()
+            cr:fill()
+
+            cr:new_path()
+            cr:move_to(0, height)
+            cr:line_to(width, height/2)
+            cr:line_to(width, height)
+            cr:close_path()
+            cr:fill()
+        end
+
+        if widget.col1 ~= "alpha" then
+            cr:set_source_rgba(gears.color.parse_color(widget.col1))
+            cr:new_path()
+            cr:move_to(0, 0)
+            cr:line_to(width, height/2)
+            cr:line_to(0, height)
+            cr:close_path()
+            cr:fill()
+        end
+   end
+
+   return widget
+end
+
+-- Left
+function separators.arrow_left(col1, col2)
+    local widget = wibox.widget.base.make_widget()
+    widget.col1 = col1
+    widget.col2 = col2
+
+    widget.fit = function(_,  _, _)
+        return separators.width, separators.height
+    end
+
+    widget.update = function(c1, c2)
+        widget.col1 = c1
+        widget.col2 = c2
+        widget:emit_signal("widget::redraw_needed")
+    end
+
+    widget.draw = function(_, _, cr, width, height)
+        if widget.col1 ~= "alpha" then
+            cr:set_source_rgba(gears.color.parse_color(widget.col1))
+            cr:new_path()
+            cr:move_to(width, 0)
+            cr:line_to(0, height/2)
+            cr:line_to(0, 0)
+            cr:close_path()
+            cr:fill()
+
+            cr:new_path()
+            cr:move_to(width, height)
+            cr:line_to(0, height/2)
+            cr:line_to(0, height)
+            cr:close_path()
+            cr:fill()
+        end
+
+        if widget.col2 ~= "alpha" then
+            cr:new_path()
+            cr:move_to(width, 0)
+            cr:line_to(0, height/2)
+            cr:line_to(width, height)
+            cr:close_path()
+
+            cr:set_source_rgba(gears.color.parse_color(widget.col2))
+            cr:fill()
+        end
+   end
+
+   return widget
+end
+
+-- ]]
+
+return separators
diff --git a/lain/widget/alsa.lua b/lain/widget/alsa.lua
new file mode 100644
index 0000000..202dc98
--- /dev/null
+++ b/lain/widget/alsa.lua
@@ -0,0 +1,54 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+      * (c) 2010, Adrian C. <anrxc@sysphere.org>
+
+--]]
+
+local helpers = require("lain.helpers")
+local shell   = require("awful.util").shell
+local wibox   = require("wibox")
+local string  = string
+
+-- ALSA volume
+-- lain.widget.alsa
+
+local function factory(args)
+    args           = args or {}
+    local alsa     = { widget = args.widget or wibox.widget.textbox() }
+    local timeout  = args.timeout or 5
+    local settings = args.settings or function() end
+
+    alsa.cmd           = args.cmd or "amixer"
+    alsa.channel       = args.channel or "Master"
+    alsa.togglechannel = args.togglechannel
+
+    local format_cmd = string.format("%s get %s", alsa.cmd, alsa.channel)
+
+    if alsa.togglechannel then
+        format_cmd = { shell, "-c", string.format("%s get %s; %s get %s",
+        alsa.cmd, alsa.channel, alsa.cmd, alsa.togglechannel) }
+    end
+
+    alsa.last = {}
+
+    function alsa.update()
+        helpers.async(format_cmd, function(mixer)
+            local l,s = string.match(mixer, "([%d]+)%%.*%[([%l]*)")
+            l = tonumber(l)
+            if alsa.last.level ~= l or alsa.last.status ~= s then
+                volume_now = { level = l, status = s }
+                widget = alsa.widget
+                settings()
+                alsa.last = volume_now
+            end
+        end)
+    end
+
+    helpers.newtimer(string.format("alsa-%s-%s", alsa.cmd, alsa.channel), timeout, alsa.update)
+
+    return alsa
+end
+
+return factory
diff --git a/lain/widget/alsabar.lua b/lain/widget/alsabar.lua
new file mode 100644
index 0000000..8e8cd3a
--- /dev/null
+++ b/lain/widget/alsabar.lua
@@ -0,0 +1,166 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+      * (c) 2013, Rman
+
+--]]
+
+local helpers  = require("lain.helpers")
+local awful    = require("awful")
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local math     = math
+local string   = string
+local type     = type
+local tonumber = tonumber
+
+-- ALSA volume bar
+-- lain.widget.alsabar
+
+local function factory(args)
+    local alsabar = {
+        colors = {
+            background = "#000000",
+            mute       = "#EB8F8F",
+            unmute     = "#A4CE8A"
+        },
+
+        _current_level = 0,
+        _playback      = "off"
+    }
+
+    args             = args or {}
+
+    local timeout    = args.timeout or 5
+    local settings   = args.settings or function() end
+    local width      = args.width or 63
+    local height     = args.height or 1
+    local margins    = args.margins or 1
+    local ticks      = args.ticks or false
+    local ticks_size = args.ticks_size or 7
+    local tick       = args.tick or "|"
+    local tick_pre   = args.tick_pre or "["
+    local tick_post  = args.tick_post or "]"
+    local tick_none  = args.tick_none or " "
+
+    alsabar.cmd                 = args.cmd or "amixer"
+    alsabar.channel             = args.channel or "Master"
+    alsabar.togglechannel       = args.togglechannel
+    alsabar.colors              = args.colors or alsabar.colors
+    alsabar.followtag           = args.followtag or false
+    alsabar.notification_preset = args.notification_preset
+
+    if not alsabar.notification_preset then
+        alsabar.notification_preset = { font = "Monospace 10" }
+    end
+
+    local format_cmd = string.format("%s get %s", alsabar.cmd, alsabar.channel)
+
+    if alsabar.togglechannel then
+        format_cmd = { awful.util.shell, "-c", string.format("%s get %s; %s get %s",
+        alsabar.cmd, alsabar.channel, alsabar.cmd, alsabar.togglechannel) }
+    end
+
+    alsabar.bar = wibox.widget {
+        color            = alsabar.colors.unmute,
+        background_color = alsabar.colors.background,
+        forced_height    = height,
+        forced_width     = width,
+        margins          = margins,
+        paddings         = margins,
+        ticks            = ticks,
+        ticks_size       = ticks_size,
+        widget           = wibox.widget.progressbar
+    }
+
+    alsabar.tooltip = awful.tooltip({ objects = { alsabar.bar } })
+
+    function alsabar.update(callback)
+        helpers.async(format_cmd, function(mixer)
+            local vol, playback = string.match(mixer, "([%d]+)%%.*%[([%l]*)")
+
+            if not vol or not playback then return end
+
+            if vol ~= alsabar._current_level or playback ~= alsabar._playback then
+                alsabar._current_level = tonumber(vol)
+                alsabar.bar:set_value(alsabar._current_level / 100)
+                if alsabar._current_level == 0 or playback == "off" then
+                    alsabar._playback = playback
+                    alsabar.tooltip:set_text("[Muted]")
+                    alsabar.bar.color = alsabar.colors.mute
+                else
+                    alsabar._playback = "on"
+                    alsabar.tooltip:set_text(string.format("%s: %s", alsabar.channel, vol))
+                    alsabar.bar.color = alsabar.colors.unmute
+                end
+
+                volume_now = {
+                    level  = alsabar._current_level,
+                    status = alsabar._playback
+                }
+
+                settings()
+
+                if type(callback) == "function" then callback() end
+            end
+        end)
+    end
+
+    function alsabar.notify()
+        alsabar.update(function()
+            local preset = alsabar.notification_preset
+
+            preset.title = string.format("%s - %s%%", alsabar.channel, alsabar._current_level)
+
+            if alsabar._playback == "off" then
+                preset.title = preset.title .. " Muted"
+            end
+
+            -- tot is the maximum number of ticks to display in the notification
+            local tot = alsabar.notification_preset.max_ticks
+
+            if not tot then
+                local wib = awful.screen.focused().mywibox
+                -- if we can grab mywibox, tot is defined as its height if
+                -- horizontal, or width otherwise
+                if wib then
+                    if wib.position == "left" or wib.position == "right" then
+                        tot = wib.width
+                    else
+                        tot = wib.height
+                    end
+                -- fallback: default horizontal wibox height
+                else
+                    tot = 20
+                end
+            end
+
+            local int = math.modf((alsabar._current_level / 100) * tot)
+            preset.text = string.format(
+                "%s%s%s%s",
+                tick_pre,
+                string.rep(tick, int),
+                string.rep(tick_none, tot - int),
+                tick_post
+            )
+
+            if alsabar.followtag then preset.screen = awful.screen.focused() end
+
+            if not alsabar.notification then
+                alsabar.notification = naughty.notify {
+                    preset  = preset,
+                    destroy = function() alsabar.notification = nil end
+                }
+            else
+                naughty.replace_text(alsabar.notification, preset.title, preset.text)
+            end
+        end)
+    end
+
+    helpers.newtimer(string.format("alsabar-%s-%s", alsabar.cmd, alsabar.channel), timeout, alsabar.update)
+
+    return alsabar
+end
+
+return factory
diff --git a/lain/widget/bat.lua b/lain/widget/bat.lua
new file mode 100644
index 0000000..260f4b9
--- /dev/null
+++ b/lain/widget/bat.lua
@@ -0,0 +1,236 @@
+--[[
+
+	 Licensed under GNU General Public License v2
+	  * (c) 2013,      Luca CPZ
+	  * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local helpers  = require("lain.helpers")
+local fs       = require("gears.filesystem")
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local math     = math
+local string   = string
+local ipairs   = ipairs
+local tonumber = tonumber
+
+-- Battery infos
+-- lain.widget.bat
+
+local function factory(args)
+    local pspath = args.pspath or "/sys/class/power_supply/"
+
+    if not fs.is_dir(pspath) then
+        naughty.notify { text = "lain.widget.bat: invalid power supply path", timeout = 0 }
+        return
+    end
+
+    args              = args or {}
+
+    local bat         = { widget = args.widget or wibox.widget.textbox() }
+    local timeout     = args.timeout or 30
+    local notify      = args.notify or "on"
+    local full_notify = args.full_notify or notify
+    local n_perc      = args.n_perc or { 5, 15 }
+    local batteries   = args.batteries or (args.battery and {args.battery}) or {}
+    local ac          = args.ac or "AC0"
+    local settings    = args.settings or function() end
+
+    function bat.get_batteries()
+        helpers.line_callback("ls -1 " .. pspath, function(line)
+            local bstr =  string.match(line, "BAT%w+")
+            if bstr then
+                batteries[#batteries + 1] = bstr
+            else
+                ac = string.match(line, "A%w+") or ac
+            end
+        end)
+    end
+
+    if #batteries == 0 then bat.get_batteries() end
+
+    bat_notification_critical_preset = {
+        title   = "Battery exhausted",
+        text    = "Shutdown imminent",
+        timeout = 15,
+        fg      = "#000000",
+        bg      = "#FFFFFF"
+    }
+
+    bat_notification_low_preset = {
+        title   = "Battery low",
+        text    = "Plug the cable!",
+        timeout = 15,
+        fg      = "#202020",
+        bg      = "#CDCDCD"
+    }
+
+    bat_notification_charged_preset = {
+        title   = "Battery full",
+        text    = "You can unplug the cable",
+        timeout = 15,
+        fg      = "#202020",
+        bg      = "#CDCDCD"
+    }
+
+    bat_now = {
+        status    = "N/A",
+        ac_status = "N/A",
+        perc      = "N/A",
+        time      = "N/A",
+        watt      = "N/A",
+        capacity  = "N/A"
+    }
+
+    bat_now.n_status   = {}
+    bat_now.n_perc     = {}
+    bat_now.n_capacity = {}
+    for i = 1, #batteries do
+        bat_now.n_status[i] = "N/A"
+        bat_now.n_perc[i] = 0
+        bat_now.n_capacity[i] = 0
+    end
+
+    -- used to notify full charge only once before discharging
+    local fullnotification = false
+
+    function bat.update()
+        -- luacheck: globals bat_now
+        local sum_rate_current  = 0
+        local sum_rate_voltage  = 0
+        local sum_rate_power    = 0
+        local sum_rate_energy   = 0
+        local sum_energy_now    = 0
+        local sum_energy_full   = 0
+        local sum_charge_full   = 0
+        local sum_charge_design = 0
+
+        for i, battery in ipairs(batteries) do
+            local bstr    = pspath .. battery
+            local present = helpers.first_line(bstr .. "/present")
+
+            if tonumber(present) == 1 then
+                -- current_now(I)[uA], voltage_now(U)[uV], power_now(P)[uW]
+                local rate_current = tonumber(helpers.first_line(bstr .. "/current_now"))
+                local rate_voltage = tonumber(helpers.first_line(bstr .. "/voltage_now"))
+                local rate_power   = tonumber(helpers.first_line(bstr .. "/power_now"))
+                local charge_full  = tonumber(helpers.first_line(bstr .. "/charge_full"))
+                local charge_design = tonumber(helpers.first_line(bstr .. "/charge_full_design"))
+
+                -- energy_now(P)[uWh], charge_now(I)[uAh]
+                local energy_now = tonumber(helpers.first_line(bstr .. "/energy_now") or
+                                   helpers.first_line(bstr .. "/charge_now"))
+
+                -- energy_full(P)[uWh], charge_full(I)[uAh]
+                local energy_full = tonumber(helpers.first_line(bstr .. "/energy_full") or
+                                    charge_full)
+
+                local energy_percentage = tonumber(helpers.first_line(bstr .. "/capacity")) or
+                                          math.floor((energy_now / energy_full) * 100)
+
+                bat_now.n_status[i] = helpers.first_line(bstr .. "/status") or "N/A"
+                bat_now.n_perc[i]   = energy_percentage or bat_now.n_perc[i]
+
+                if not charge_design or charge_design == 0 then
+                    bat_now.n_capacity[i] = 0
+                else
+                    bat_now.n_capacity[i] = math.floor((charge_full / charge_design) * 100)
+                end
+
+                sum_rate_current  = sum_rate_current + (rate_current or 0)
+                sum_rate_voltage  = sum_rate_voltage + (rate_voltage or 0)
+                sum_rate_power    = sum_rate_power + (rate_power or 0)
+                sum_rate_energy   = sum_rate_energy + (rate_power or (((rate_voltage or 0) * (rate_current or 0)) / 1e6))
+                sum_energy_now    = sum_energy_now + (energy_now or 0)
+                sum_energy_full   = sum_energy_full + (energy_full or 0)
+                sum_charge_full   = sum_charge_full + (charge_full or 0)
+                sum_charge_design = sum_charge_design + (charge_design or 0)
+            end
+        end
+
+        bat_now.capacity = math.floor(math.min(100, (sum_charge_full / sum_charge_design) * 100))
+
+        -- When one of the battery is charging, others' status are either
+        -- "Full", "Unknown" or "Charging". When the laptop is not plugged in,
+        -- one or more of the batteries may be full, but only one battery
+        -- discharging suffices to set global status to "Discharging".
+        bat_now.status = bat_now.n_status[1] or "N/A"
+        for _,status in ipairs(bat_now.n_status) do
+            if status == "Discharging" or status == "Charging" then
+                bat_now.status = status
+            end
+        end
+        bat_now.ac_status = tonumber(helpers.first_line(string.format("%s%s/online", pspath, ac))) or "N/A"
+
+        if bat_now.status ~= "N/A" then
+            if bat_now.status ~= "Full" and sum_rate_power == 0 and bat_now.ac_status == 1 then
+                bat_now.perc  = math.floor(math.min(100, (sum_energy_now / sum_energy_full) * 100))
+                bat_now.time  = "00:00"
+                bat_now.watt  = 0
+
+            -- update {perc,time,watt} iff battery not full and rate > 0
+            elseif bat_now.status ~= "Full" then
+                local rate_time = 0
+                -- Calculate time and watt if rates are greater then 0
+                if (sum_rate_power > 0 or sum_rate_current > 0) then
+                    local div = (sum_rate_power > 0 and sum_rate_power) or sum_rate_current
+
+                    if bat_now.status == "Charging" then
+                        rate_time = (sum_energy_full - sum_energy_now) / div
+                    else -- Discharging
+                        rate_time = sum_energy_now / div
+                    end
+
+                    if 0 < rate_time and rate_time < 0.01 then -- check for magnitude discrepancies (#199)
+                        rate_time_magnitude = math.abs(math.floor(math.log10(rate_time)))
+                        rate_time = rate_time * 10^(rate_time_magnitude - 2)
+                    end
+                 end
+
+                local hours   = math.floor(rate_time)
+                local minutes = math.floor((rate_time - hours) * 60)
+                bat_now.perc  = math.floor(math.min(100, (sum_energy_now / sum_energy_full) * 100))
+                bat_now.time  = string.format("%02d:%02d", hours, minutes)
+                bat_now.watt  = tonumber(string.format("%.2f", sum_rate_energy / 1e6))
+            elseif bat_now.status == "Full" then
+                bat_now.perc  = 100
+                bat_now.time  = "00:00"
+                bat_now.watt  = 0
+            end
+        end
+
+        widget = bat.widget
+        settings()
+
+        -- notifications for critical, low, and full levels
+        if notify == "on" then
+            if bat_now.status == "Discharging" then
+                if tonumber(bat_now.perc) <= n_perc[1] then
+                    bat.id = naughty.notify({
+                        preset = bat_notification_critical_preset,
+                        replaces_id = bat.id
+                    }).id
+                elseif tonumber(bat_now.perc) <= n_perc[2] then
+                    bat.id = naughty.notify({
+                        preset = bat_notification_low_preset,
+                        replaces_id = bat.id
+                    }).id
+                end
+                fullnotification = false
+            elseif bat_now.status == "Full" and full_notify == "on" and not fullnotification then
+                bat.id = naughty.notify({
+                    preset = bat_notification_charged_preset,
+                    replaces_id = bat.id
+                }).id
+                fullnotification = true
+            end
+        end
+    end
+
+    helpers.newtimer("batteries", timeout, bat.update)
+
+    return bat
+end
+
+return factory
diff --git a/lain/widget/cal.lua b/lain/widget/cal.lua
new file mode 100644
index 0000000..7543684
--- /dev/null
+++ b/lain/widget/cal.lua
@@ -0,0 +1,190 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2018, Luca CPZ
+
+--]]
+
+local helpers  = require("lain.helpers")
+local markup   = require("lain.util.markup")
+local awful    = require("awful")
+local naughty  = require("naughty")
+local floor    = math.floor
+local os       = os
+local pairs    = pairs
+local string   = string
+local tconcat  = table.concat
+local type     = type
+local tonumber = tonumber
+local tostring = tostring
+local utf8     = utf8
+
+-- Calendar notification
+-- lain.widget.cal
+
+local function factory(args)
+    args = args or {}
+    local cal = {
+        attach_to           = args.attach_to or {},
+        week_start          = args.week_start or 2,
+        three               = args.three or false,
+        followtag           = args.followtag or false,
+        week_number         = args.week_number or "none",
+        week_number_format  = args.week_number_format or args.week_number == "left" and "%3d | " or "| %-3d",
+        icons               = args.icons or helpers.icons_dir .. "cal/white/",
+        notification_preset = args.notification_preset or {
+            font = "Monospace 10", fg = "#FFFFFF", bg = "#000000"
+        }
+    }
+
+    function cal.get_week_number(m, st_day, x)
+        local date = os.date("*t", m)
+
+        local week_step = (x ~= 0 and floor((x + st_day) / 7) - 1 or 0);
+
+        local display_time = os.time {
+            year = date.year, month = date.month, day = date.day + 7 * week_step
+        }
+
+        return string.format(cal.week_number_format, os.date("%V", display_time))
+    end
+
+    function cal.sum_week_days(x, y)
+        return (x + y) % 7
+    end
+
+    function cal.build(month, year)
+        local current_month, current_year = tonumber(os.date("%m")), tonumber(os.date("%Y"))
+        local is_current_month = (not month or not year) or (month == current_month and year == current_year)
+        local today = is_current_month and tonumber(os.date("%d")) -- otherwise nil and not highlighted
+        local t = os.time { year = year or current_year, month = month and month+1 or current_month+1, day = 0 }
+        local d = os.date("*t", t)
+        local mth_days, st_day, this_month = d.day, (d.wday-d.day-cal.week_start+1)%7, os.date("%B %Y", t)
+        local notifytable = { [1] = string.format("%s%s\n", string.rep(" ", floor((28 - this_month:len())/2)), markup.bold(this_month)) }
+        for x = 0,6 do notifytable[#notifytable+1] = os.date("%a", os.time { year=2006, month=1, day=x+cal.week_start }):sub(1, utf8.offset(1, 3)) .. " " end
+        notifytable[#notifytable] = string.format("%s\n%s", notifytable[#notifytable]:sub(1, -2), string.rep(" ", st_day*4))
+        local strx
+        for x = 1,mth_days do
+            strx = x
+            if x == today then
+                if x < 10 then x = " " .. x end
+                strx = markup.bold(markup.color(cal.notification_preset.bg, cal.notification_preset.fg, x) .. " ")
+            end
+            strx = string.format("%s%s", string.rep(" ", 3 - tostring(x):len()), strx)
+            notifytable[#notifytable+1] = string.format("%-4s%s", strx, (x+st_day)%7==0 and x ~= mth_days and "\n" or "")
+        end
+        if string.len(cal.icons or "") > 0 and today then cal.icon = cal.icons .. today .. ".png" end
+        cal.month, cal.year = d.month, d.year
+
+        if cal.week_number ~= "none" then
+            local m = os.time { year = year or current_year, month = month and month or current_month, day = 1 }
+            local head_prepend = string.rep(" ", tostring(string.format(cal.week_number_format, 0)):len())
+
+            if cal.week_number == "left" then
+                notifytable[1] = head_prepend .. notifytable[1] -- month-year row
+                notifytable[2] = head_prepend .. notifytable[2] -- weekdays row
+                notifytable[8] = notifytable[8]:gsub("\n", "\n" .. cal.get_week_number(m, st_day, 0)) -- first week of the month
+
+                for x = 10,#notifytable do
+                    if cal.sum_week_days(st_day, x) == 2 then
+                        notifytable[x] = cal.get_week_number(m, st_day, x) .. notifytable[x]
+                    end
+                end
+            elseif cal.week_number == "right" then
+                notifytable[8] = notifytable[8]:gsub("\n", head_prepend .. "\n") -- weekdays row
+                for x = 9,#notifytable do
+                    if cal.sum_week_days(st_day, x) == 1 then
+                        notifytable[x] = notifytable[x]:gsub("\n", cal.get_week_number(m, st_day, x - 7) .. "\n")
+                    end
+                end
+                -- last week of the month
+                local end_days = cal.sum_week_days(st_day, mth_days)
+                if end_days ~= 0 then end_days = 7 - end_days end
+                notifytable[#notifytable] = notifytable[#notifytable] .. string.rep(" ", 4 * end_days) .. cal.get_week_number(m, st_day, mth_days + end_days)
+            end
+        end
+
+        return notifytable
+    end
+
+    function cal.getdate(month, year, offset)
+        if not month or not year then
+            month = tonumber(os.date("%m"))
+            year  = tonumber(os.date("%Y"))
+        end
+
+        month = month + offset
+
+        while month > 12 do
+            month = month - 12
+            year = year + 1
+        end
+
+        while month < 1 do
+            month = month + 12
+            year = year - 1
+        end
+
+        return month, year
+    end
+
+    function cal.hide()
+        if not cal.notification then return end
+        naughty.destroy(cal.notification)
+        cal.notification = nil
+    end
+
+    function cal.show(seconds, month, year, scr)
+        local text = tconcat(cal.build(month, year))
+
+        if cal.three then
+            local current_month, current_year = cal.month, cal.year
+            local prev_month, prev_year = cal.getdate(cal.month, cal.year, -1)
+            local next_month, next_year = cal.getdate(cal.month, cal.year,  1)
+            text = string.format("%s\n\n%s\n\n%s",
+            tconcat(cal.build(prev_month, prev_year)), text,
+            tconcat(cal.build(next_month, next_year)))
+            cal.month, cal.year = current_month, current_year
+        end
+
+        if cal.notification then
+            local title = cal.notification_preset.title or nil
+            naughty.replace_text(cal.notification, title, text)
+            return
+        end
+
+        cal.notification = naughty.notify {
+            preset  = cal.notification_preset,
+            screen  = cal.followtag and awful.screen.focused() or scr or 1,
+            icon    = cal.icon,
+            timeout = type(seconds) == "number" and seconds or cal.notification_preset.timeout or 5,
+            text    = text
+        }
+    end
+
+    function cal.hover_on() cal.show(0) end
+    function cal.move(offset)
+        offset = offset or 0
+        cal.month, cal.year = cal.getdate(cal.month, cal.year, offset)
+        cal.show(0, cal.month, cal.year)
+    end
+    function cal.prev() cal.move(-1) end
+    function cal.next() cal.move( 1) end
+
+    function cal.attach(widget)
+        widget:connect_signal("mouse::enter", cal.hover_on)
+        widget:connect_signal("mouse::leave", cal.hide)
+        widget:buttons(awful.util.table.join(
+                    awful.button({}, 1, cal.prev),
+                    awful.button({}, 3, cal.next),
+                    awful.button({}, 2, cal.hover_on),
+                    awful.button({}, 5, cal.prev),
+                    awful.button({}, 4, cal.next)))
+    end
+
+    for _, widget in pairs(cal.attach_to) do cal.attach(widget) end
+
+    return cal
+end
+
+return factory
diff --git a/lain/widget/contrib/init.lua b/lain/widget/contrib/init.lua
new file mode 100644
index 0000000..9e863a5
--- /dev/null
+++ b/lain/widget/contrib/init.lua
@@ -0,0 +1,18 @@
+--[[
+
+     Lain
+     Layouts, widgets and utilities for Awesome WM
+
+     Users contributed widgets section
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+
+--]]
+
+local wrequire     = require("lain.helpers").wrequire
+local setmetatable = setmetatable
+
+local widget = { _NAME = "lain.widget.contrib" }
+
+return setmetatable(widget, { __index = wrequire })
diff --git a/lain/widget/contrib/moc.lua b/lain/widget/contrib/moc.lua
new file mode 100644
index 0000000..ad6452e
--- /dev/null
+++ b/lain/widget/contrib/moc.lua
@@ -0,0 +1,97 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2014, anticlockwise <http://github.com/anticlockwise>
+
+--]]
+
+local helpers      = require("lain.helpers")
+local shell        = require("awful.util").shell
+local focused      = require("awful.screen").focused
+local escape_f     = require("awful.util").escape
+local naughty      = require("naughty")
+local wibox        = require("wibox")
+local os           = os
+local string       = string
+
+-- MOC audio player
+-- lain.widget.contrib.moc
+
+local function factory(args)
+    args                = args or {}
+
+    local moc           = { widget = args.widget or wibox.widget.textbox() }
+    local timeout       = args.timeout or 2
+    local music_dir     = args.music_dir or os.getenv("HOME") .. "/Music"
+    local cover_pattern = args.cover_pattern or "*\\.(jpg|jpeg|png|gif)$"
+    local cover_size    = args.cover_size or 100
+    local default_art   = args.default_art or ""
+    local followtag     = args.followtag or false
+    local settings      = args.settings or function() end
+
+    moc_notification_preset = { title = "Now playing", timeout = 6 }
+
+    helpers.set_map("current moc track", nil)
+
+    function moc.update()
+        helpers.async("mocp -i", function(f)
+            moc_now = {
+                state   = "N/A",
+                file    = "N/A",
+                artist  = "N/A",
+                title   = "N/A",
+                album   = "N/A",
+                elapsed = "N/A",
+                total   = "N/A"
+            }
+
+            for line in string.gmatch(f, "[^\n]+") do
+                for k, v in string.gmatch(line, "([%w]+):[%s](.*)$") do
+                    if     k == "State"       then moc_now.state   = v
+                    elseif k == "File"        then moc_now.file    = v
+                    elseif k == "Artist"      then moc_now.artist  = escape_f(v)
+                    elseif k == "SongTitle"   then moc_now.title   = escape_f(v)
+                    elseif k == "Album"       then moc_now.album   = escape_f(v)
+                    elseif k == "CurrentTime" then moc_now.elapsed = escape_f(v)
+                    elseif k == "TotalTime"   then moc_now.total   = escape_f(v)
+                    end
+                end
+            end
+
+            moc_notification_preset.text = string.format("%s (%s) - %s\n%s", moc_now.artist,
+                                           moc_now.album, moc_now.total, moc_now.title)
+            widget = moc.widget
+            settings()
+
+            if moc_now.state == "PLAY" then
+                if moc_now.title ~= helpers.get_map("current moc track") then
+                    helpers.set_map("current moc track", moc_now.title)
+
+                    if followtag then moc_notification_preset.screen = focused() end
+
+                    local common =  {
+                        preset      = moc_notification_preset,
+                        icon        = default_art,
+                        icon_size   = cover_size,
+                        replaces_id = moc.id,
+                    }
+
+                    local path   = string.format("%s/%s", music_dir, string.match(moc_now.file, ".*/"))
+                    local cover  = string.format("find '%s' -maxdepth 1 -type f | egrep -i -m1 '%s'", path, cover_pattern)
+                    helpers.async({ shell, "-c", cover }, function(current_icon)
+                        common.icon = current_icon:gsub("\n", "")
+                        moc.id = naughty.notify(common).id
+                    end)
+                end
+            elseif  moc_now.state ~= "PAUSE" then
+                helpers.set_map("current moc track", nil)
+            end
+        end)
+    end
+
+    moc.timer = helpers.newtimer("moc", timeout, moc.update, true, true)
+
+    return moc
+end
+
+return factory
diff --git a/lain/widget/contrib/redshift.lua b/lain/widget/contrib/redshift.lua
new file mode 100644
index 0000000..d91d941
--- /dev/null
+++ b/lain/widget/contrib/redshift.lua
@@ -0,0 +1,54 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2017, Luca CPZ
+      * (c) 2014, blueluke <http://github.com/blueluke>
+
+--]]
+
+local async   = require("lain.helpers").async
+local awful   = require("awful")
+local execute = os.execute
+local type    = type
+
+-- Redshift
+-- lain.widget.contrib.redshift
+local redshift = { active = false, pid = nil }
+
+function redshift.start()
+    execute("pkill redshift")
+    awful.spawn.with_shell("redshift -x") -- clear adjustments
+    redshift.pid = awful.spawn.with_shell("redshift")
+    redshift.active = true
+    if type(redshift.update_fun) == "function" then
+        redshift.update_fun(redshift.active)
+    end
+end
+
+function redshift.toggle()
+    async({ awful.util.shell, "-c", string.format("ps -p %d -o pid=", redshift.pid) }, function(f)
+        if f and #f > 0 then -- redshift is running
+            -- Sending -USR1 toggles redshift (See project website)
+            execute("pkill -USR1 redshift")
+            redshift.active = not redshift.active
+        else -- not started or killed, (re)start it
+            redshift.start()
+        end
+        redshift.update_fun(redshift.active)
+    end)
+end
+
+-- Attach to a widget
+-- Provides a button which toggles redshift on/off on click
+-- @param widget:  Widget to attach to.
+-- @param fun:     Function to be run each time redshift is toggled (optional).
+--                 Use it to update widget text or icons on status change.
+function redshift.attach(widget, fun)
+    redshift.update_fun = fun or function() end
+    if not redshift.pid then redshift.start() end
+    if widget then
+        widget:buttons(awful.util.table.join(awful.button({}, 1, function () redshift.toggle() end)))
+    end
+end
+
+return redshift
diff --git a/lain/widget/contrib/task.lua b/lain/widget/contrib/task.lua
new file mode 100644
index 0000000..2311996
--- /dev/null
+++ b/lain/widget/contrib/task.lua
@@ -0,0 +1,92 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Jan Xie
+
+--]]
+
+local helpers = require("lain.helpers")
+local markup  = require("lain.util").markup
+local awful   = require("awful")
+local naughty = require("naughty")
+local mouse   = mouse
+
+-- Taskwarrior notification
+-- lain.widget.contrib.task
+local task = {}
+
+function task.hide()
+    if not task.notification then return end
+    naughty.destroy(task.notification)
+    task.notification = nil
+end
+
+function task.show(scr)
+    task.notification_preset.screen = task.followtag and awful.screen.focused() or scr or 1
+
+    helpers.async({ awful.util.shell, "-c", task.show_cmd }, function(f)
+        local widget_focused = true
+
+        if mouse.current_widgets then
+            widget_focused = false
+            for _,v in ipairs(mouse.current_widgets) do
+                if task.widget == v then
+                    widget_focused = true
+                    break
+                end
+            end
+        end
+
+        if widget_focused then
+            task.hide()
+            task.notification = naughty.notify {
+                preset = task.notification_preset,
+                title  = "task next",
+                text   = markup.font(task.notification_preset.font,
+                         awful.util.escape(f:gsub("\n*$", "")))
+            }
+        end
+    end)
+end
+
+function task.prompt()
+    awful.prompt.run {
+        prompt       = task.prompt_text,
+        textbox      = awful.screen.focused().mypromptbox.widget,
+        exe_callback = function(t)
+            helpers.async(t, function(f)
+                naughty.notify {
+                    preset = task.notification_preset,
+                    title  = t,
+                    text   = markup.font(task.notification_preset.font,
+                             awful.util.escape(f:gsub("\n*$", "")))
+                }
+            end)
+        end,
+        history_path = awful.util.getdir("cache") .. "/history_task"
+    }
+end
+
+function task.attach(widget, args)
+    args                     = args or {}
+
+    task.show_cmd            = args.show_cmd or "task next"
+    task.prompt_text         = args.prompt_text or "Enter task command: "
+    task.followtag           = args.followtag or false
+    task.notification_preset = args.notification_preset
+    task.widget              = widget
+
+    if not task.notification_preset then
+        task.notification_preset = {
+            font = "Monospace 10",
+            icon = helpers.icons_dir .. "/taskwarrior.png"
+        }
+    end
+
+    if widget then
+        widget:connect_signal("mouse::enter", function () task.show() end)
+        widget:connect_signal("mouse::leave", function () task.hide() end)
+    end
+end
+
+return task
diff --git a/lain/widget/contrib/tp_smapi.lua b/lain/widget/contrib/tp_smapi.lua
new file mode 100644
index 0000000..87c5e51
--- /dev/null
+++ b/lain/widget/contrib/tp_smapi.lua
@@ -0,0 +1,147 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2018, Luca CPZ
+      * (c) 2013, Conor Heine
+
+--]]
+
+local helpers = require("lain.helpers")
+local focused = require("awful.screen").focused
+local naughty = require("naughty")
+local wibox   = require("wibox")
+local string  = string
+local type    = type
+
+-- ThinkPad battery infos and widget creator
+-- http://www.thinkwiki.org/wiki/Tp_smapi
+-- lain.widget.contrib.tp_smapi
+
+local function factory(apipath)
+    local tp_smapi = {
+        path = apipath or "/sys/devices/platform/smapi"
+    }
+
+    function tp_smapi.get(batid, feature)
+        return helpers.first_line(string.format("%s/%s/%s", tp_smapi.path, batid or "BAT0", feature or ""))
+    end
+
+    function tp_smapi.installed(batid)
+        return tp_smapi.get(batid, "installed") == "1"
+    end
+
+    function tp_smapi.status(batid)
+        return tp_smapi.get(batid, "state")
+    end
+
+    function tp_smapi.percentage(batid)
+        return tp_smapi.get(batid, "remaining_percent")
+    end
+
+    -- either running or charging time
+    function tp_smapi.time(batid)
+        local status = tp_smapi.status(batid)
+        local mins_left = tp_smapi.get(batid, string.match(string.lower(status), "discharging") and "remaining_running_time" or "remaining_charging_time")
+        if not string.find(mins_left, "^%d+") then return "N/A" end
+        return string.format("%02d:%02d", math.floor(mins_left / 60), mins_left % 60) -- HH:mm
+    end
+
+    function tp_smapi.hide()
+        if not tp_smapi.notification then return end
+        naughty.destroy(tp_smapi.notification)
+        tp_smapi.notification = nil
+    end
+
+    function tp_smapi.show(batid, seconds, scr)
+        if not tp_smapi.installed(batid) then return end
+
+        local mfgr   = tp_smapi.get(batid, "manufacturer") or "no_mfgr"
+        local model  = tp_smapi.get(batid, "model") or "no_model"
+        local chem   = tp_smapi.get(batid, "chemistry") or "no_chem"
+        local status = tp_smapi.get(batid, "state")
+        local time   = tp_smapi.time(batid)
+        local msg
+
+        if status and status ~= "idle" then
+            msg = string.format("[%s] %s %s", status, time ~= "N/A" and time or "unknown remaining time",
+                  string.lower(status):gsub(" ", ""):gsub("\n", "") == "charging" and " until charged" or " remaining")
+        else
+            msg = "On AC power"
+        end
+
+        tp_smapi.hide()
+        tp_smapi.notification = naughty.notify {
+            title   = string.format("%s: %s %s (%s)", batid, mfgr, model, chem),
+            text    = msg,
+            timeout = type(seconds) == "number" and seconds or 0,
+            screen  = scr or focused()
+        }
+    end
+
+    function tp_smapi.create_widget(args)
+        args            = args or {}
+
+        local pspath    = args.pspath or "/sys/class/power_supply/"
+        local batteries = args.batteries or (args.battery and {args.battery}) or {}
+        local timeout   = args.timeout or 30
+        local settings  = args.settings or function() end
+
+        if #batteries == 0 then
+            helpers.line_callback("ls -1 " .. pspath, function(line)
+                local bstr = string.match(line, "BAT%w+")
+                if bstr then batteries[#batteries + 1] = bstr end
+            end)
+        end
+
+        local all_batteries_installed = true
+
+        for _, battery in ipairs(batteries) do
+            if not tp_smapi.installed(battery) then
+                naughty.notify {
+                    preset = naughty.config.critical,
+                    title  = "tp_smapi: error while creating widget",
+                    text   = string.format("battery %s is not installed", battery)
+                }
+                all_batteries_installed = false
+                break
+            end
+        end
+
+        if not all_batteries_installed then return end
+
+        tpbat = {
+            batteries = batteries,
+            widget    = args.widget or wibox.widget.textbox()
+        }
+
+        function tpbat.update()
+            tpbat_now = {
+                n_status = {},
+                n_perc   = {},
+                n_time   = {},
+                status   = "N/A"
+            }
+
+            for i = 1, #batteries do
+                tpbat_now.n_status[i] = tp_smapi.status(batteries[i]) or "N/A"
+                tpbat_now.n_perc[i] = tp_smapi.percentage(batteries[i])
+                tpbat_now.n_time[i] = tp_smapi.time(batteries[i]) or "N/A"
+
+                if not tpbat_now.n_status[i]:lower():match("full") then
+                    tpbat_now.status = tpbat_now.n_status[i]
+                end
+            end
+
+            widget = tpbat.widget -- backwards compatibility
+            settings()
+        end
+
+        helpers.newtimer("thinkpad-batteries", timeout, tpbat.update)
+
+        return tpbat
+    end
+
+    return tp_smapi
+end
+
+return factory
diff --git a/lain/widget/cpu.lua b/lain/widget/cpu.lua
new file mode 100644
index 0000000..6c51115
--- /dev/null
+++ b/lain/widget/cpu.lua
@@ -0,0 +1,75 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local helpers  = require("lain.helpers")
+local wibox    = require("wibox")
+local math     = math
+local string   = string
+
+-- CPU usage
+-- lain.widget.cpu
+
+local function factory(args)
+    args           = args or {}
+
+    local cpu      = { core = {}, widget = args.widget or wibox.widget.textbox() }
+    local timeout  = args.timeout or 2
+    local settings = args.settings or function() end
+
+    function cpu.update()
+        -- Read the amount of time the CPUs have spent performing
+        -- different kinds of work. Read the first line of /proc/stat
+        -- which is the sum of all CPUs.
+        for index,time in pairs(helpers.lines_match("cpu","/proc/stat")) do
+            local coreid = index - 1
+            local core   = cpu.core[coreid] or
+                           { last_active = 0 , last_total = 0, usage = 0 }
+            local at     = 1
+            local idle   = 0
+            local total  = 0
+
+            for field in string.gmatch(time, "[%s]+([^%s]+)") do
+                -- 4 = idle, 5 = ioWait. Essentially, the CPUs have done
+                -- nothing during these times.
+                if at == 4 or at == 5 then
+                    idle = idle + field
+                end
+                total = total + field
+                at = at + 1
+            end
+
+            local active = total - idle
+
+            if core.last_active ~= active or core.last_total ~= total then
+                -- Read current data and calculate relative values.
+                local dactive = active - core.last_active
+                local dtotal  = total - core.last_total
+                local usage   = math.ceil(math.abs((dactive / dtotal) * 100))
+
+                core.last_active = active
+                core.last_total  = total
+                core.usage       = usage
+
+                -- Save current data for the next run.
+                cpu.core[coreid] = core
+            end
+        end
+
+        cpu_now = cpu.core
+        cpu_now.usage = cpu_now[0].usage
+        widget = cpu.widget
+
+        settings()
+    end
+
+    helpers.newtimer("cpu", timeout, cpu.update)
+
+    return cpu
+end
+
+return factory
diff --git a/lain/widget/fs.lua b/lain/widget/fs.lua
new file mode 100644
index 0000000..b3a2dad
--- /dev/null
+++ b/lain/widget/fs.lua
@@ -0,0 +1,156 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2018, Uli Schlacter
+      * (c) 2018, Otto Modinos
+      * (c) 2013, Luca CPZ
+
+--]]
+
+local helpers    = require("lain.helpers")
+local Gio        = require("lgi").Gio
+local focused    = require("awful.screen").focused
+local wibox      = require("wibox")
+local naughty    = require("naughty")
+local gears      = require("gears")
+local math       = math
+local string     = string
+local tconcat    = table.concat
+local type       = type
+local query_size = Gio.FILE_ATTRIBUTE_FILESYSTEM_SIZE
+local query_free = Gio.FILE_ATTRIBUTE_FILESYSTEM_FREE
+local query_used = Gio.FILE_ATTRIBUTE_FILESYSTEM_USED
+local query      = query_size .. "," .. query_free .. "," .. query_used
+
+-- File systems info
+-- lain.widget.fs
+
+local function factory(args)
+    args     = args or {}
+
+    local fs = {
+        widget = args.widget or wibox.widget.textbox(),
+        units = {
+            [1] = "Kb", [2] = "Mb", [3] = "Gb",
+            [4] = "Tb", [5] = "Pb", [6] = "Eb",
+            [7] = "Zb", [8] = "Yb"
+        }
+    }
+
+    function fs.hide()
+        if not fs.notification then return end
+        naughty.destroy(fs.notification)
+        fs.notification = nil
+    end
+
+    function fs.show(seconds, scr)
+        fs.hide()
+        fs.update(function()
+            fs.notification_preset.screen = fs.followtag and focused() or scr or 1
+            fs.notification = naughty.notify {
+                preset  = fs.notification_preset,
+                timeout = type(seconds) == "number" and seconds or 5
+            }
+        end)
+    end
+
+    local timeout   = args.timeout or 600
+    local partition = args.partition
+    local threshold = args.threshold or 99
+    local showpopup = args.showpopup or "on"
+    local settings  = args.settings or function() end
+
+    fs.followtag           = args.followtag or false
+    fs.notification_preset = args.notification_preset
+
+    if not fs.notification_preset then
+        fs.notification_preset = {
+            font = "Monospace 10",
+            fg   = "#FFFFFF",
+            bg   = "#000000"
+        }
+    end
+
+    local function update_synced()
+        local pathlen = 10
+        fs_now = {}
+
+        local notifypaths = {}
+        for _, mount in ipairs(Gio.unix_mounts_get()) do
+            local path = Gio.unix_mount_get_mount_path(mount)
+            local root = Gio.File.new_for_path(path)
+            local info = root:query_filesystem_info(query)
+
+            if info then
+                local size = info:get_attribute_uint64(query_size)
+                local used = info:get_attribute_uint64(query_used)
+                local free = info:get_attribute_uint64(query_free)
+
+                if size > 0 then
+                    local units = math.floor(math.log(size)/math.log(1024))
+
+                    fs_now[path] = {
+                        units      = fs.units[units],
+                        percentage = math.floor(100 * used / size), -- used percentage
+                        size       = size / math.pow(1024, units),
+                        used       = used / math.pow(1024, units),
+                        free       = free / math.pow(1024, units)
+                    }
+
+                    if fs_now[path].percentage > 0 then -- don't notify unused file systems
+                        notifypaths[#notifypaths+1] = path
+
+                        if #path > pathlen then
+                            pathlen = #path
+                        end
+                    end
+                end
+            end
+        end
+
+        widget = fs.widget
+        settings()
+
+        if partition and fs_now[partition] and fs_now[partition].percentage >= threshold then
+            if not helpers.get_map(partition) then
+                naughty.notify {
+                    preset = naughty.config.presets.critical,
+                    title  = "Warning",
+                    text   = string.format("%s is above %d%% (%d%%)", partition, threshold, fs_now[partition].percentage)
+                }
+                helpers.set_map(partition, true)
+            else
+                helpers.set_map(partition, false)
+            end
+        end
+
+        local fmt = "%-" .. tostring(pathlen) .. "s %4s\t%6s\t%6s\n"
+        local notifytable = { [1] = string.format(fmt, "path", "used", "free", "size") }
+        fmt = "\n%-" .. tostring(pathlen) .. "s %3s%%\t%6.2f\t%6.2f %s"
+        for _, path in ipairs(notifypaths) do
+            notifytable[#notifytable+1] = string.format(fmt, path, fs_now[path].percentage, fs_now[path].free, fs_now[path].size, fs_now[path].units)
+        end
+
+        fs.notification_preset.text = tconcat(notifytable)
+    end
+
+    function fs.update(callback)
+        Gio.Async.start(gears.protected_call.call)(function()
+            update_synced()
+            if type(callback) == "function" and callback then
+                callback()
+            end
+        end)
+    end
+
+    if showpopup == "on" then
+       fs.widget:connect_signal('mouse::enter', function () fs.show(0) end)
+       fs.widget:connect_signal('mouse::leave', function () fs.hide() end)
+    end
+
+    helpers.newtimer(partition or "fs", timeout, fs.update)
+
+    return fs
+end
+
+return factory
diff --git a/lain/widget/imap.lua b/lain/widget/imap.lua
new file mode 100644
index 0000000..e3f7baa
--- /dev/null
+++ b/lain/widget/imap.lua
@@ -0,0 +1,94 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+
+--]]
+
+local helpers  = require("lain.helpers")
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local awful    = require("awful")
+local string   = string
+local type     = type
+local tonumber = tonumber
+
+-- Mail IMAP check
+-- lain.widget.imap
+
+local function factory(args)
+    args             = args or {}
+
+    local imap       = { widget = args.widget or wibox.widget.textbox() }
+    local server     = args.server
+    local mail       = args.mail
+    local password   = args.password
+    local port       = args.port or 993
+    local timeout    = args.timeout or 60
+    local pwdtimeout = args.pwdtimeout or 10
+    local is_plain   = args.is_plain or false
+    local followtag  = args.followtag or false
+    local notify     = args.notify or "on"
+    local settings   = args.settings or function() end
+
+    local head_command = "curl --connect-timeout 3 -fsm 3"
+    local request = "-X 'STATUS INBOX (MESSAGES RECENT UNSEEN)'"
+
+    if not server or not mail or not password then return end
+
+    mail_notification_preset = {
+        icon     = helpers.icons_dir .. "mail.png",
+        position = "top_left"
+    }
+
+    helpers.set_map(mail, 0)
+
+    if not is_plain then
+        if type(password) == "string" or type(password) == "table" then
+            helpers.async(password, function(f) password = f:gsub("\n", "") end)
+        elseif type(password) == "function" then
+            imap.pwdtimer = helpers.newtimer(mail .. "-password", pwdtimeout, function()
+                local retrieved_password, try_again = password()
+                if not try_again then
+                    imap.pwdtimer:stop() -- stop trying to retrieve
+                    password = retrieved_password or "" -- failsafe
+                end
+            end, true, true)
+        end
+    end
+
+    function imap.update()
+        -- do not update if the password has not been retrieved yet
+        if type(password) ~= "string" then return end
+
+        local curl = string.format("%s --url imaps://%s:%s/INBOX -u %s:'%s' %s -k",
+                     head_command, server, port, mail, password, request)
+
+        helpers.async(curl, function(f)
+            imap_now = { ["MESSAGES"] = 0, ["RECENT"] = 0, ["UNSEEN"] = 0 }
+
+            for s,d in f:gmatch("(%w+)%s+(%d+)") do imap_now[s] = tonumber(d) end
+            mailcount = imap_now["UNSEEN"] -- backwards compatibility
+            widget = imap.widget
+
+            settings()
+
+            if notify == "on" and mailcount and mailcount >= 1 and mailcount > helpers.get_map(mail) then
+                if followtag then mail_notification_preset.screen = awful.screen.focused() end
+                naughty.notify {
+                    preset = mail_notification_preset,
+                    text   = string.format("%s has <b>%d</b> new message%s", mail, mailcount, mailcount == 1 and "" or "s")
+                }
+            end
+
+            helpers.set_map(mail, imap_now["UNSEEN"])
+        end)
+
+    end
+
+    imap.timer = helpers.newtimer(mail, timeout, imap.update, true, true)
+
+    return imap
+end
+
+return factory
diff --git a/lain/widget/init.lua b/lain/widget/init.lua
new file mode 100644
index 0000000..57b86bb
--- /dev/null
+++ b/lain/widget/init.lua
@@ -0,0 +1,19 @@
+--[[
+
+     Lain
+     Layouts, widgets and utilities for Awesome WM
+
+     Widgets section
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local wrequire     = require("lain.helpers").wrequire
+local setmetatable = setmetatable
+
+local widget = { _NAME = "lain.widget" }
+
+return setmetatable(widget, { __index = wrequire })
diff --git a/lain/widget/mem.lua b/lain/widget/mem.lua
new file mode 100644
index 0000000..0318494
--- /dev/null
+++ b/lain/widget/mem.lua
@@ -0,0 +1,51 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local helpers              = require("lain.helpers")
+local wibox                = require("wibox")
+local gmatch, lines, floor = string.gmatch, io.lines, math.floor
+
+-- Memory usage (ignoring caches)
+-- lain.widget.mem
+
+local function factory(args)
+    args           = args or {}
+
+    local mem      = { widget = args.widget or wibox.widget.textbox() }
+    local timeout  = args.timeout or 2
+    local settings = args.settings or function() end
+
+    function mem.update()
+        mem_now = {}
+        for line in lines("/proc/meminfo") do
+            for k, v in gmatch(line, "([%a]+):[%s]+([%d]+).+") do
+                if     k == "MemTotal"     then mem_now.total = floor(v / 1024 + 0.5)
+                elseif k == "MemFree"      then mem_now.free  = floor(v / 1024 + 0.5)
+                elseif k == "Buffers"      then mem_now.buf   = floor(v / 1024 + 0.5)
+                elseif k == "Cached"       then mem_now.cache = floor(v / 1024 + 0.5)
+                elseif k == "SwapTotal"    then mem_now.swap  = floor(v / 1024 + 0.5)
+                elseif k == "SwapFree"     then mem_now.swapf = floor(v / 1024 + 0.5)
+                elseif k == "SReclaimable" then mem_now.srec  = floor(v / 1024 + 0.5)
+                end
+            end
+        end
+
+        mem_now.used = mem_now.total - mem_now.free - mem_now.buf - mem_now.cache - mem_now.srec
+        mem_now.swapused = mem_now.swap - mem_now.swapf
+        mem_now.perc = math.floor(mem_now.used / mem_now.total * 100)
+
+        widget = mem.widget
+        settings()
+    end
+
+    helpers.newtimer("mem", timeout, mem.update)
+
+    return mem
+end
+
+return factory
diff --git a/lain/widget/mpd.lua b/lain/widget/mpd.lua
new file mode 100644
index 0000000..55d3649
--- /dev/null
+++ b/lain/widget/mpd.lua
@@ -0,0 +1,135 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+      * (c) 2010, Adrian C. <anrxc@sysphere.org>
+
+--]]
+
+local helpers  = require("lain.helpers")
+local shell    = require("awful.util").shell
+local escape_f = require("awful.util").escape
+local focused  = require("awful.screen").focused
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local os       = os
+local string   = string
+
+-- MPD infos
+-- lain.widget.mpd
+
+local function factory(args)
+    args                = args or {}
+
+    local mpd           = { widget = args.widget or wibox.widget.textbox() }
+    local timeout       = args.timeout or 2
+    local password      = (args.password and #args.password > 0 and string.format("password %s\\n", args.password)) or ""
+    local host          = args.host or os.getenv("MPD_HOST") or "127.0.0.1"
+    local port          = args.port or os.getenv("MPD_PORT") or "6600"
+    local music_dir     = args.music_dir or os.getenv("HOME") .. "/Music"
+    local cover_pattern = args.cover_pattern or "*\\.(jpg|jpeg|png|gif)$"
+    local cover_size    = args.cover_size or 100
+    local default_art   = args.default_art
+    local notify        = args.notify or "on"
+    local followtag     = args.followtag or false
+    local settings      = args.settings or function() end
+
+    local mpdh = string.format("telnet://%s:%s", host, port)
+    local echo = string.format("printf \"%sstatus\\ncurrentsong\\nclose\\n\"", password)
+    local cmd  = string.format("%s | curl --connect-timeout 1 -fsm 3 %s", echo, mpdh)
+
+    mpd_notification_preset = { title = "Now playing", timeout = 6 }
+
+    helpers.set_map("current mpd track", nil)
+
+    function mpd.update()
+        helpers.async({ shell, "-c", cmd }, function(f)
+            mpd_now = {
+                random_mode  = false,
+                single_mode  = false,
+                repeat_mode  = false,
+                consume_mode = false,
+                pls_pos      = "N/A",
+                pls_len      = "N/A",
+                state        = "N/A",
+                file         = "N/A",
+                name         = "N/A",
+                artist       = "N/A",
+                title        = "N/A",
+                album        = "N/A",
+                genre        = "N/A",
+                track        = "N/A",
+                date         = "N/A",
+                time         = "N/A",
+                elapsed      = "N/A",
+                volume       = "N/A"
+            }
+
+            for line in string.gmatch(f, "[^\n]+") do
+                for k, v in string.gmatch(line, "([%w]+):[%s](.*)$") do
+                    if     k == "state"          then mpd_now.state        = v
+                    elseif k == "file"           then mpd_now.file         = v
+                    elseif k == "Name"           then mpd_now.name         = escape_f(v)
+                    elseif k == "Artist"         then mpd_now.artist       = escape_f(v)
+                    elseif k == "Title"          then mpd_now.title        = escape_f(v)
+                    elseif k == "Album"          then mpd_now.album        = escape_f(v)
+                    elseif k == "Genre"          then mpd_now.genre        = escape_f(v)
+                    elseif k == "Track"          then mpd_now.track        = escape_f(v)
+                    elseif k == "Date"           then mpd_now.date         = escape_f(v)
+                    elseif k == "Time"           then mpd_now.time         = v
+                    elseif k == "elapsed"        then mpd_now.elapsed      = string.match(v, "%d+")
+                    elseif k == "song"           then mpd_now.pls_pos      = v
+                    elseif k == "playlistlength" then mpd_now.pls_len      = v
+                    elseif k == "repeat"         then mpd_now.repeat_mode  = v ~= "0"
+                    elseif k == "single"         then mpd_now.single_mode  = v ~= "0"
+                    elseif k == "random"         then mpd_now.random_mode  = v ~= "0"
+                    elseif k == "consume"        then mpd_now.consume_mode = v ~= "0"
+                    elseif k == "volume"         then mpd_now.volume       = v
+                    end
+                end
+            end
+
+            mpd_notification_preset.text = string.format("%s (%s) - %s\n%s", mpd_now.artist,
+                                           mpd_now.album, mpd_now.date, mpd_now.title)
+            widget = mpd.widget
+            settings()
+
+            if mpd_now.state == "play" then
+                if notify == "on" and mpd_now.title ~= helpers.get_map("current mpd track") then
+                    helpers.set_map("current mpd track", mpd_now.title)
+
+                    if followtag then mpd_notification_preset.screen = focused() end
+
+                    local common =  {
+                        preset      = mpd_notification_preset,
+                        icon        = default_art,
+                        icon_size   = cover_size,
+                        replaces_id = mpd.id
+                    }
+
+                    if not string.match(mpd_now.file, "http.*://") then -- local file instead of http stream
+                        local path   = string.format("%s/%s", music_dir, string.match(mpd_now.file, ".*/"))
+                        local cover  = string.format("find '%s' -maxdepth 1 -type f | egrep -i -m1 '%s'",
+                                       path:gsub("'", "'\\''"), cover_pattern)
+                        helpers.async({ shell, "-c", cover }, function(current_icon)
+                            common.icon = current_icon:gsub("\n", "")
+                            if #common.icon == 0 then common.icon = nil end
+                            mpd.id = naughty.notify(common).id
+                        end)
+                    else
+                        mpd.id = naughty.notify(common).id
+                    end
+
+                end
+            elseif mpd_now.state ~= "pause" then
+                helpers.set_map("current mpd track", nil)
+            end
+        end)
+    end
+
+    mpd.timer = helpers.newtimer("mpd", timeout, mpd.update, true, true)
+
+    return mpd
+end
+
+return factory
diff --git a/lain/widget/net.lua b/lain/widget/net.lua
new file mode 100644
index 0000000..9b7b165
--- /dev/null
+++ b/lain/widget/net.lua
@@ -0,0 +1,122 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local helpers = require("lain.helpers")
+local naughty = require("naughty")
+local wibox   = require("wibox")
+local string  = string
+
+-- Network infos
+-- lain.widget.net
+
+local function factory(args)
+    args             = args or {}
+
+    local net        = { widget = args.widget or wibox.widget.textbox(), devices = {} }
+    local timeout    = args.timeout or 2
+    local units      = args.units or 1024 -- KB
+    local notify     = args.notify or "on"
+    local wifi_state = args.wifi_state or "off"
+    local eth_state  = args.eth_state or "off"
+    local screen     = args.screen or 1
+    local format     = args.format or "%.1f"
+    local settings   = args.settings or function() end
+
+    -- Compatibility with old API where iface was a string corresponding to 1 interface
+    net.iface = (args.iface and (type(args.iface) == "string" and {args.iface}) or
+                (type(args.iface) == "table" and args.iface)) or {}
+
+    function net.get_devices()
+        net.iface = {} -- reset at every call
+        helpers.line_callback("ip link", function(line)
+            net.iface[#net.iface + 1] = not string.match(line, "LOOPBACK") and string.match(line, "(%w+): <") or nil
+        end)
+    end
+
+    if #net.iface == 0 then net.get_devices() end
+
+    function net.update()
+        -- These are the totals over all specified interfaces
+        net_now = {
+            devices  = {},
+            -- Bytes since last iteration
+            sent     = 0,
+            received = 0
+        }
+
+        for _, dev in ipairs(net.iface) do
+            local dev_now    = {}
+            local dev_before = net.devices[dev] or { last_t = 0, last_r = 0 }
+            local now_t      = tonumber(helpers.first_line(string.format("/sys/class/net/%s/statistics/tx_bytes", dev)) or 0)
+            local now_r      = tonumber(helpers.first_line(string.format("/sys/class/net/%s/statistics/rx_bytes", dev)) or 0)
+
+            dev_now.carrier  = helpers.first_line(string.format("/sys/class/net/%s/carrier", dev)) or "0"
+            dev_now.state    = helpers.first_line(string.format("/sys/class/net/%s/operstate", dev)) or "down"
+
+            dev_now.sent     = (now_t - dev_before.last_t) / timeout / units
+            dev_now.received = (now_r - dev_before.last_r) / timeout / units
+
+            net_now.sent     = net_now.sent + dev_now.sent
+            net_now.received = net_now.received + dev_now.received
+
+            dev_now.sent     = string.format(format, dev_now.sent)
+            dev_now.received = string.format(format, dev_now.received)
+
+            dev_now.last_t   = now_t
+            dev_now.last_r   = now_r
+
+            if wifi_state == "on" and helpers.first_line(string.format("/sys/class/net/%s/uevent", dev)) == "DEVTYPE=wlan" then
+                dev_now.wifi   = true
+                if string.match(dev_now.carrier, "1") then
+                        dev_now.signal = tonumber(string.match(helpers.lines_from("/proc/net/wireless")[3], "(%-%d+%.)")) or nil
+                end
+            else
+                dev_now.wifi   = false
+            end
+
+            if eth_state == "on" and helpers.first_line(string.format("/sys/class/net/%s/uevent", dev)) ~= "DEVTYPE=wlan" then
+                dev_now.ethernet = true
+            else
+                dev_now.ethernet = false
+            end
+
+            net.devices[dev] = dev_now
+
+            -- Notify only once when connection is lost
+            if string.match(dev_now.carrier, "0") and notify == "on" and helpers.get_map(dev) then
+                naughty.notify {
+                    title    = dev,
+                    text     = "No carrier",
+                    icon     = helpers.icons_dir .. "no_net.png",
+                    screen   = screen
+                }
+                helpers.set_map(dev, false)
+            elseif string.match(dev_now.carrier, "1") then
+                helpers.set_map(dev, true)
+            end
+
+            net_now.carrier = dev_now.carrier
+            net_now.state = dev_now.state
+            net_now.devices[dev] = dev_now
+            -- net_now.sent and net_now.received will be
+            -- the totals across all specified devices
+        end
+
+        net_now.sent = string.format(format, net_now.sent)
+        net_now.received = string.format(format, net_now.received)
+
+        widget = net.widget
+        settings()
+    end
+
+    helpers.newtimer("network", timeout, net.update)
+
+    return net
+end
+
+return factory
diff --git a/lain/widget/pulse.lua b/lain/widget/pulse.lua
new file mode 100644
index 0000000..69f4d70
--- /dev/null
+++ b/lain/widget/pulse.lua
@@ -0,0 +1,58 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2016, Luca CPZ
+
+--]]
+
+local helpers = require("lain.helpers")
+local shell   = require("awful.util").shell
+local wibox   = require("wibox")
+local string  = string
+local type    = type
+
+-- PulseAudio volume
+-- lain.widget.pulse
+
+local function factory(args)
+    args           = args or {}
+
+    local pulse    = { widget = args.widget or wibox.widget.textbox(), device = "N/A" }
+    local timeout  = args.timeout or 5
+    local settings = args.settings or function() end
+
+    pulse.devicetype = args.devicetype or "sink"
+    pulse.cmd = args.cmd or "pacmd list-" .. pulse.devicetype .. "s | sed -n -e '/*/,$!d' -e '/index/p' -e '/base volume/d' -e '/volume:/p' -e '/muted:/p' -e '/device\\.string/p'"
+
+    function pulse.update()
+        helpers.async({ shell, "-c", type(pulse.cmd) == "string" and pulse.cmd or pulse.cmd() },
+        function(s)
+            volume_now = {
+                index  = string.match(s, "index: (%S+)") or "N/A",
+                device = string.match(s, "device.string = \"(%S+)\"") or "N/A",
+                muted  = string.match(s, "muted: (%S+)") or "N/A"
+            }
+
+            pulse.device = volume_now.index
+
+            local ch = 1
+            volume_now.channel = {}
+            for v in string.gmatch(s, ":.-(%d+)%%") do
+                volume_now.channel[ch] = v
+                ch = ch + 1
+            end
+
+            volume_now.left  = volume_now.channel[1] or "N/A"
+            volume_now.right = volume_now.channel[2] or "N/A"
+
+            widget = pulse.widget
+            settings()
+        end)
+    end
+
+    helpers.newtimer("pulse", timeout, pulse.update)
+
+    return pulse
+end
+
+return factory
diff --git a/lain/widget/pulsebar.lua b/lain/widget/pulsebar.lua
new file mode 100644
index 0000000..19e73b9
--- /dev/null
+++ b/lain/widget/pulsebar.lua
@@ -0,0 +1,175 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+      * (c) 2013, Rman
+
+--]]
+
+local helpers  = require("lain.helpers")
+local awful    = require("awful")
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local math     = math
+local string   = string
+local type     = type
+local tonumber = tonumber
+
+-- PulseAudio volume bar
+-- lain.widget.pulsebar
+
+local function factory(args)
+    local pulsebar = {
+        colors = {
+            background      = "#000000",
+            mute_background = "#000000",
+            mute            = "#EB8F8F",
+            unmute          = "#A4CE8A"
+        },
+
+        _current_level = 0,
+        _mute          = "no",
+        device         = "N/A"
+    }
+
+    args             = args or {}
+
+    local timeout    = args.timeout or 5
+    local settings   = args.settings or function() end
+    local width      = args.width or 63
+    local height     = args.height or 1
+    local margins    = args.margins or 1
+    local paddings   = args.paddings or 1
+    local ticks      = args.ticks or false
+    local ticks_size = args.ticks_size or 7
+    local tick       = args.tick or "|"
+    local tick_pre   = args.tick_pre or "["
+    local tick_post  = args.tick_post or "]"
+    local tick_none  = args.tick_none or " "
+
+    pulsebar.colors              = args.colors or pulsebar.colors
+    pulsebar.followtag           = args.followtag or false
+    pulsebar.notification_preset = args.notification_preset
+    pulsebar.devicetype          = args.devicetype or "sink"
+    pulsebar.cmd                 = args.cmd or "pacmd list-" .. pulsebar.devicetype .. "s | sed -n -e '/*/,$!d' -e '/index/p' -e '/base volume/d' -e '/volume:/p' -e '/muted:/p' -e '/device\\.string/p'"
+
+    if not pulsebar.notification_preset then
+        pulsebar.notification_preset = {
+            font = "Monospace 10"
+        }
+    end
+
+    pulsebar.bar = wibox.widget {
+        color            = pulsebar.colors.unmute,
+        background_color = pulsebar.colors.background,
+        forced_height    = height,
+        forced_width     = width,
+        margins          = margins,
+        paddings         = paddings,
+        ticks            = ticks,
+        ticks_size       = ticks_size,
+        widget           = wibox.widget.progressbar,
+    }
+
+    pulsebar.tooltip = awful.tooltip({ objects = { pulsebar.bar } })
+
+    function pulsebar.update(callback)
+        helpers.async({ awful.util.shell, "-c", type(pulsebar.cmd) == "string" and pulsebar.cmd or pulsebar.cmd() },
+        function(s)
+            volume_now = {
+                index  = string.match(s, "index: (%S+)") or "N/A",
+                device = string.match(s, "device.string = \"(%S+)\"") or "N/A",
+                muted  = string.match(s, "muted: (%S+)") or "N/A"
+            }
+
+            pulsebar.device = volume_now.index
+
+            local ch = 1
+            volume_now.channel = {}
+            for v in string.gmatch(s, ":.-(%d+)%%") do
+              volume_now.channel[ch] = v
+              ch = ch + 1
+            end
+
+            volume_now.left  = volume_now.channel[1] or "N/A"
+            volume_now.right = volume_now.channel[2] or "N/A"
+
+            local volu = volume_now.left
+            local mute = volume_now.muted
+
+            if volu:match("N/A") or mute:match("N/A") then return end
+
+            if volu ~= pulsebar._current_level or mute ~= pulsebar._mute then
+                pulsebar._current_level = tonumber(volu)
+                pulsebar.bar:set_value(pulsebar._current_level / 100)
+                if pulsebar._current_level == 0 or mute == "yes" then
+                    pulsebar._mute = mute
+                    pulsebar.tooltip:set_text ("[muted]")
+                    pulsebar.bar.color = pulsebar.colors.mute
+                    pulsebar.bar.background_color = pulsebar.colors.mute_background
+                else
+                    pulsebar._mute = "no"
+                    pulsebar.tooltip:set_text(string.format("%s %s: %s", pulsebar.devicetype, pulsebar.device, volu))
+                    pulsebar.bar.color = pulsebar.colors.unmute
+                    pulsebar.bar.background_color = pulsebar.colors.background
+                end
+
+                settings()
+
+                if type(callback) == "function" then callback() end
+            end
+        end)
+    end
+
+    function pulsebar.notify()
+        pulsebar.update(function()
+            local preset = pulsebar.notification_preset
+
+            preset.title = string.format("%s %s - %s%%", pulsebar.devicetype, pulsebar.device, pulsebar._current_level)
+
+            if pulsebar._mute == "yes" then
+                preset.title = preset.title .. " muted"
+            end
+
+            -- tot is the maximum number of ticks to display in the notification
+            -- fallback: default horizontal wibox height
+            local wib, tot = awful.screen.focused().mywibox, 20
+
+            -- if we can grab mywibox, tot is defined as its height if
+            -- horizontal, or width otherwise
+            if wib then
+                if wib.position == "left" or wib.position == "right" then
+                    tot = wib.width
+                else
+                    tot = wib.height
+                end
+            end
+
+            local int = math.modf((pulsebar._current_level / 100) * tot)
+            preset.text = string.format(
+                "%s%s%s%s",
+                tick_pre,
+                string.rep(tick, int),
+                string.rep(tick_none, tot - int),
+                tick_post
+            )
+
+            if pulsebar.followtag then preset.screen = awful.screen.focused() end
+
+            if not pulsebar.notification then
+                pulsebar.notification = naughty.notify {
+                    preset  = preset,
+                    destroy = function() pulsebar.notification = nil end
+                }
+            else
+                naughty.replace_text(pulsebar.notification, preset.title, preset.text)
+            end
+        end)
+    end
+
+    helpers.newtimer(string.format("pulsebar-%s-%s", pulsebar.devicetype, pulsebar.device), timeout, pulsebar.update)
+
+    return pulsebar
+end
+
+return factory
diff --git a/lain/widget/spotify-widget/README.md b/lain/widget/spotify-widget/README.md
new file mode 100644
index 0000000..3a7b8d7
--- /dev/null
+++ b/lain/widget/spotify-widget/README.md
@@ -0,0 +1,95 @@
+# Spotify widget
+
+This widget displays currently playing song on [Spotify for Linux](https://www.spotify.com/download/linux/) client: ![screenshot](./spo-wid-1.png)
+
+Some features:
+
+ - status icon which shows if music is currently playing
+ - artist and name of the current song
+ - dim widget if spotify is paused
+ - trim long artist/song names
+ - tooltip with more info about the song
+
+## Controls
+
+ - left click - play/pause
+ - scroll up - play next song
+ - scroll down - play previous song
+
+## Dependencies
+
+Note that widget uses the Arc icon theme, so it should be [installed](https://github.com/horst3180/arc-icon-theme#installation) first under **/usr/share/icons/Arc/** folder.
+
+## Customization
+
+It is possible to customize widget by providing a table with all or some of the following config parameters:
+
+| Name | Default | Description |
+|---|---|---|
+| `play_icon` | `/usr/share/icons/Arc/actions/24/player_play.png` | Play icon |
+| `pause_icon` | `/usr/share/icons/Arc/actions/24/player_pause.png` | Pause icon |
+| `font` | `Play 9`| Font |
+| `dim_when_paused` | `false` | Decrease the widget opacity if spotify is paused |
+| `dim_opacity` | `0.2` | Widget's opacity when dimmed, `dim_when_paused` should be set to `true` |
+| `max_length` | `15` | Maximum lentgh of artist and title names. Text will be ellipsized if longer. |
+| `show_tooltip` | `true` | Show tooltip on hover with information about the playing song |
+| `timeout` | 1 | How often in seconds the widget refreshes |
+| `sp_bin` | `sp` | Path to the `sp` binary. Required if `sp` is not in environment PATH. |
+
+
+### Example:
+
+```lua
+spotify_widget({
+    font = 'Ubuntu Mono 9',
+    play_icon = '/usr/share/icons/Papirus-Light/24x24/categories/spotify.svg',
+    pause_icon = '/usr/share/icons/Papirus-Dark/24x24/panel/spotify-indicator.svg',
+    dim_when_paused = true,
+    dim_opacity = 0.5,
+    max_length = -1,
+    show_tooltip = false,
+    sp_bin = gears.filesystem.get_configuration_dir() .. 'scripts/sp'
+})
+```
+
+Gives following widget
+
+Playing:
+![screenshot](./spotify-widget-custom-playing.png)
+
+Paused:
+![screenshot](./spotify-widget-custom-paused.png)
+
+## Installation
+
+First you need to have spotify CLI installed, it uses dbus to communicate with spotify-client:
+
+```bash 
+git clone https://gist.github.com/fa6258f3ff7b17747ee3.git
+cd ./fa6258f3ff7b17747ee3 
+chmod +x sp
+# This widget will work by default if the binary is in the system PATH
+sudo cp ./sp /usr/local/bin/
+# Alternatively, you may save the binary anywhere and supply the path via this widget's sp_bin argument:
+# cp ./sp ~/.config/awesome/scripts/
+```
+
+Then clone repo under **~/.config/awesome/** and add widget in **rc.lua**:
+
+```lua
+local spotify_widget = require("awesome-wm-widgets.spotify-widget.spotify")
+...
+s.mytasklist, -- Middle widget
+	{ -- Right widgets
+    	layout = wibox.layout.fixed.horizontal,
+		...
+        -- default        
+        spotify_widget(),
+        -- customized
+        spotify_widget({
+           font = 'Ubuntu Mono 9',
+           play_icon = '/usr/share/icons/Papirus-Light/24x24/categories/spotify.svg',
+           pause_icon = '/usr/share/icons/Papirus-Dark/24x24/panel/spotify-indicator.svg'
+        }),
+		...      
+```
diff --git a/lain/widget/spotify-widget/spo-wid-1.png b/lain/widget/spotify-widget/spo-wid-1.png
new file mode 100644
index 0000000..5c7e403
Binary files /dev/null and b/lain/widget/spotify-widget/spo-wid-1.png differ
diff --git a/lain/widget/spotify-widget/spotify-widget-custom-paused.png b/lain/widget/spotify-widget/spotify-widget-custom-paused.png
new file mode 100644
index 0000000..9ac9c4a
Binary files /dev/null and b/lain/widget/spotify-widget/spotify-widget-custom-paused.png differ
diff --git a/lain/widget/spotify-widget/spotify-widget-custom-playing.png b/lain/widget/spotify-widget/spotify-widget-custom-playing.png
new file mode 100644
index 0000000..f9628f9
Binary files /dev/null and b/lain/widget/spotify-widget/spotify-widget-custom-playing.png differ
diff --git a/lain/widget/spotify-widget/spotify.lua b/lain/widget/spotify-widget/spotify.lua
new file mode 100644
index 0000000..526c098
--- /dev/null
+++ b/lain/widget/spotify-widget/spotify.lua
@@ -0,0 +1,177 @@
+-------------------------------------------------
+-- Spotify Widget for Awesome Window Manager
+-- Shows currently playing song on Spotify for Linux client
+-- More details could be found here:
+-- https://github.com/streetturtle/awesome-wm-widgets/tree/master/spotify-widget
+
+-- @author Pavel Makhov
+-- @copyright 2020 Pavel Makhov
+-------------------------------------------------
+
+local awful = require("awful")
+local wibox = require("wibox")
+local watch = require("awful.widget.watch")
+
+local function ellipsize(text, length)
+    -- utf8 only available in Lua 5.3+
+    if utf8 == nil then
+        return text:sub(0, length)
+    end
+    return (utf8.len(text) > length and length > 0)
+        and text:sub(0, utf8.offset(text, length - 2) - 1) .. '...'
+        or text
+end
+
+local spotify_widget = {}
+
+local function worker(user_args)
+
+    local args = user_args or {}
+
+    local play_icon = args.play_icon or '/usr/share/icons/Arc/actions/24/player_play.png'
+    local pause_icon = args.pause_icon or '/usr/share/icons/Arc/actions/24/player_pause.png'
+    local font = args.font or 'Play 9'
+    local dim_when_paused = args.dim_when_paused == nil and false or args.dim_when_paused
+    local dim_opacity = args.dim_opacity or 0.2
+    -- local max_length = args.max_length or 15
+    local max_length = args.max_length or 35
+    local show_tooltip = args.show_tooltip == nil and true or args.show_tooltip
+    local timeout = args.timeout or 1
+    local sp_bin = args.sp_bin or 'sp'
+
+    local GET_SPOTIFY_STATUS_CMD = sp_bin .. ' status'
+    local GET_CURRENT_SONG_CMD = sp_bin .. ' current'
+
+    local cur_artist = ''
+    local cur_title = ''
+    local cur_album = ''
+
+    spotify_widget = wibox.widget {
+        {
+            id = 'artistw',
+            font = font,
+            widget = wibox.widget.textbox,
+        },
+        {
+            layout = wibox.layout.stack,
+            {
+                id = "icon",
+                widget = wibox.widget.imagebox,
+            },
+            {
+                widget = wibox.widget.textbox,
+                font = font,
+                text = ' ',
+                forced_height = 1
+            }
+        },
+        {
+            layout = wibox.container.scroll.horizontal,
+            max_size = 300,
+            step_function = wibox.container.scroll.step_functions.waiting_nonlinear_back_and_forth,
+            speed = 40,
+            {
+                id = 'titlew',
+                font = font,
+                widget = wibox.widget.textbox
+            }
+        },
+        layout = wibox.layout.align.horizontal,
+        set_status = function(self, is_playing)
+            self:get_children_by_id('icon')[1]:set_image(is_playing and play_icon or pause_icon)
+            if dim_when_paused then
+                self:get_children_by_id('icon')[1]:set_opacity(is_playing and 1 or dim_opacity)
+
+                self:get_children_by_id('titlew')[1]:set_opacity(is_playing and 1 or dim_opacity)
+                self:get_children_by_id('titlew')[1]:emit_signal('widget::redraw_needed')
+
+                self:get_children_by_id('artistw')[1]:set_opacity(is_playing and 1 or dim_opacity)
+                self:get_children_by_id('artistw')[1]:emit_signal('widget::redraw_needed')
+            end
+        end,
+        set_text = function(self, artist, song)
+            local artist_to_display = ellipsize(artist, max_length)
+            if self:get_children_by_id('artistw')[1]:get_markup() ~= artist_to_display then
+                --self:get_children_by_id('artistw')[1]:set_markup(artist_to_display)
+                self:get_children_by_id('artistw')[1]:set_markup(
+                    string.format('<span foreground="%s">%s</span>', "#98971a", artist_to_display)
+                )
+            end
+            local title_to_display = ellipsize(song, max_length)
+            if self:get_children_by_id('titlew')[1]:get_markup() ~= title_to_display then
+                --self:get_children_by_id('titlew')[1]:set_markup(title_to_display)
+                self:get_children_by_id('titlew')[1]:set_markup(
+                    string.format('<span foreground="%s">%s</span>', "#98971a", title_to_display .. "")
+                )
+            end
+        end
+    }
+
+    local update_widget_icon = function(widget, stdout, _, _, _)
+        stdout = string.gsub(stdout, "\n", "")
+        widget:set_status(stdout == 'Playing' and true or false)
+    end
+
+    local update_widget_text = function(widget, stdout, _, _, _)
+        if string.find(stdout, 'Error: Spotify is not running.') ~= nil then
+            widget:set_text('','')
+            widget:set_visible(false)
+            return
+        end
+
+        local escaped = string.gsub(stdout, "&", '&amp;')
+        local album, _, artist, title =
+            string.match(escaped, 'Album%s*(.*)\nAlbumArtist%s*(.*)\nArtist%s*(.*)\nTitle%s*(.*)\n')
+
+        if album ~= nil and title ~=nil and artist ~= nil then
+            cur_artist = artist
+            cur_title = title
+            cur_album = album
+            widget:set_text(" " .. artist .. " -", title)
+            widget:set_visible(true)
+        end
+    end
+
+    watch(GET_SPOTIFY_STATUS_CMD, timeout, update_widget_icon, spotify_widget)
+    watch(GET_CURRENT_SONG_CMD, timeout, update_widget_text, spotify_widget)
+
+    --- Adds mouse controls to the widget:
+    --  - left click - play/pause
+    --  - scroll up - play next song
+    --  - scroll down - play previous song
+    spotify_widget:connect_signal("button::press", function(_, _, _, button)
+        if (button == 1) then
+            awful.spawn("sp play", false)      -- left click
+        elseif (button == 4) then
+            awful.spawn("sp next", false)  -- scroll up
+        elseif (button == 5) then
+            awful.spawn("sp prev", false)  -- scroll down
+        end
+        awful.spawn.easy_async(GET_SPOTIFY_STATUS_CMD, function(stdout, stderr, exitreason, exitcode)
+            update_widget_icon(spotify_widget, stdout, stderr, exitreason, exitcode)
+        end)
+    end)
+
+
+    if show_tooltip then
+        local spotify_tooltip = awful.tooltip {
+            mode = 'outside',
+            preferred_positions = {'bottom'},
+         }
+
+        spotify_tooltip:add_to_object(spotify_widget)
+
+        spotify_widget:connect_signal('mouse::enter', function()
+            spotify_tooltip.markup = '<b>Album</b>: ' .. cur_album
+                .. '\n<b>Artist</b>: ' .. cur_artist
+                .. '\n<b>Song</b>: ' .. cur_title
+        end)
+    end
+
+    return spotify_widget
+
+end
+
+return setmetatable(spotify_widget, { __call = function(_, ...)
+    return worker(...)
+end })
diff --git a/lain/widget/sysload.lua b/lain/widget/sysload.lua
new file mode 100644
index 0000000..7260524
--- /dev/null
+++ b/lain/widget/sysload.lua
@@ -0,0 +1,39 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013,      Luca CPZ
+      * (c) 2010-2012, Peter Hofmann
+
+--]]
+
+local helpers     = require("lain.helpers")
+local wibox       = require("wibox")
+local open, match = io.open, string.match
+
+-- System load
+-- lain.widget.sysload
+
+local function factory(args)
+    args           = args or {}
+
+    local sysload  = { widget = args.widget or wibox.widget.textbox() }
+    local timeout  = args.timeout or 2
+    local settings = args.settings or function() end
+
+    function sysload.update()
+        local f = open("/proc/loadavg")
+        local ret = f:read("*all")
+        f:close()
+
+        load_1, load_5, load_15 = match(ret, "([^%s]+) ([^%s]+) ([^%s]+)")
+
+        widget = sysload.widget
+        settings()
+    end
+
+    helpers.newtimer("sysload", timeout, sysload.update)
+
+    return sysload
+end
+
+return factory
diff --git a/lain/widget/temp.lua b/lain/widget/temp.lua
new file mode 100644
index 0000000..99f8700
--- /dev/null
+++ b/lain/widget/temp.lua
@@ -0,0 +1,50 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2013, Luca CPZ
+
+--]]
+
+local helpers  = require("lain.helpers")
+local wibox    = require("wibox")
+local tonumber = tonumber
+
+-- {thermal,core} temperature info
+-- lain.widget.temp
+
+local function factory(args)
+    args           = args or {}
+
+    local temp     = { widget = args.widget or wibox.widget.textbox() }
+    local timeout  = args.timeout or 30
+    local tempfile = args.tempfile or "/sys/devices/virtual/thermal/thermal_zone0/temp"
+    local format   = args.format or "%.1f"
+    local settings = args.settings or function() end
+
+    function temp.update()
+        helpers.async({"find", "/sys/devices", "-type", "f", "-name", "*temp*"}, function(f)
+            temp_now = {}
+            local temp_fl, temp_value
+            for t in f:gmatch("[^\n]+") do
+                temp_fl = helpers.first_line(t)
+                if temp_fl then
+                    temp_value = tonumber(temp_fl)
+                    temp_now[t] = temp_value and temp_value/1e3 or temp_fl
+                end
+            end
+            if temp_now[tempfile] then
+                coretemp_now = string.format(format, temp_now[tempfile])
+            else
+                coretemp_now = "N/A"
+            end
+            widget = temp.widget
+            settings()
+        end)
+    end
+
+    helpers.newtimer("thermal", timeout, temp.update)
+
+    return temp
+end
+
+return factory
diff --git a/lain/widget/weather.lua b/lain/widget/weather.lua
new file mode 100644
index 0000000..c683d42
--- /dev/null
+++ b/lain/widget/weather.lua
@@ -0,0 +1,146 @@
+--[[
+
+     Licensed under GNU General Public License v2
+      * (c) 2015, Luca CPZ
+
+--]]
+
+local helpers  = require("lain.helpers")
+local json     = require("lain.util").dkjson
+local focused  = require("awful.screen").focused
+local naughty  = require("naughty")
+local wibox    = require("wibox")
+local math     = math
+local os       = os
+local string   = string
+local type     = type
+local tonumber = tonumber
+
+-- OpenWeatherMap
+-- current weather and X-days forecast
+-- lain.widget.weather
+
+local function factory(args)
+    args                        = args or {}
+
+    local weather               = { widget = args.widget or wibox.widget.textbox() }
+    local APPID                 = args.APPID -- mandatory
+    local timeout               = args.timeout or 60 * 15 -- 15 min
+    local current_call          = args.current_call  or "curl -s 'https://api.openweathermap.org/data/2.5/weather?id=%s&units=%s&lang=%s&APPID=%s'"
+    local forecast_call         = args.forecast_call or "curl -s 'https://api.openweathermap.org/data/2.5/forecast?id=%s&units=%s&lang=%s&APPID=%s'"
+    local city_id               = args.city_id or 0 -- placeholder
+    local units                 = args.units or "metric"
+    local lang                  = args.lang or "en"
+    local cnt                   = args.cnt or 5
+    local icons_path            = args.icons_path or helpers.icons_dir .. "openweathermap/"
+    local notification_preset   = args.notification_preset or {}
+    local notification_text_fun = args.notification_text_fun or
+                                  function (wn)
+                                      local day = os.date("%a %d", wn["dt"])
+                                      local temp = math.floor(wn["main"]["temp"])
+                                      local desc = wn["weather"][1]["description"]
+                                      return string.format("<b>%s</b>: %s, %d ", day, desc, temp)
+                                  end
+    local weather_na_markup     = args.weather_na_markup or " N/A "
+    local followtag             = args.followtag or false
+    local showpopup             = args.showpopup or "on"
+    local settings              = args.settings or function() end
+
+    weather.widget:set_markup(weather_na_markup)
+    weather.icon_path = icons_path .. "na.png"
+    weather.icon = wibox.widget.imagebox(weather.icon_path)
+
+    function weather.show(seconds)
+        weather.hide()
+
+        if followtag then
+            notification_preset.screen = focused()
+        end
+
+        if not weather.notification_text then
+            weather.update()
+            weather.forecast_update()
+        end
+
+        weather.notification = naughty.notify {
+            preset  = notification_preset,
+            text    = weather.notification_text,
+            icon    = weather.icon_path,
+            timeout = type(seconds) == "number" and seconds or notification_preset.timeout
+        }
+    end
+
+    function weather.hide()
+        if weather.notification then
+            naughty.destroy(weather.notification)
+            weather.notification = nil
+        end
+    end
+
+    function weather.attach(obj)
+        obj:connect_signal("mouse::enter", function()
+            weather.show(0)
+        end)
+        obj:connect_signal("mouse::leave", function()
+            weather.hide()
+        end)
+    end
+
+    function weather.forecast_update()
+        local cmd = string.format(forecast_call, city_id, units, lang, APPID)
+        helpers.async(cmd, function(f)
+            local err
+            weather_now, _, err = json.decode(f, 1, nil)
+
+            if not err and type(weather_now) == "table" and tonumber(weather_now["cod"]) == 200 then
+                weather.notification_text = ""
+                for i = 1, weather_now["cnt"], weather_now["cnt"]//cnt do
+                    weather.notification_text = weather.notification_text ..
+                                                notification_text_fun(weather_now["list"][i])
+                    if i < weather_now["cnt"] then
+                        weather.notification_text = weather.notification_text .. "\n"
+                    end
+                end
+            end
+        end)
+    end
+
+    function weather.update()
+        local cmd = string.format(current_call, city_id, units, lang, APPID)
+        helpers.async(cmd, function(f)
+            local err
+            weather_now, _, err = json.decode(f, 1, nil)
+
+            if not err and type(weather_now) == "table" and tonumber(weather_now["cod"]) == 200 then
+                local sunrise = tonumber(weather_now["sys"]["sunrise"])
+                local sunset  = tonumber(weather_now["sys"]["sunset"])
+                local icon    = weather_now["weather"][1]["icon"]
+                local loc_now = os.time()
+
+                if sunrise <= loc_now and loc_now <= sunset then
+                    icon = string.gsub(icon, "n", "d")
+                else
+                    icon = string.gsub(icon, "d", "n")
+                end
+
+                weather.icon_path = icons_path .. icon .. ".png"
+                widget = weather.widget
+                settings()
+            else
+                weather.icon_path = icons_path .. "na.png"
+                weather.widget:set_markup(weather_na_markup)
+            end
+
+            weather.icon:set_image(weather.icon_path)
+        end)
+    end
+
+    if showpopup == "on" then weather.attach(weather.widget) end
+
+    weather.timer = helpers.newtimer("weather-" .. city_id, timeout, weather.update, false, true)
+    weather.timer_forecast = helpers.newtimer("weather_forecast-" .. city_id, timeout, weather.forecast_update, false, true)
+
+    return weather
+end
+
+return factory
diff --git a/lain/wiki/Home.md b/lain/wiki/Home.md
new file mode 100644
index 0000000..c31550f
--- /dev/null
+++ b/lain/wiki/Home.md
@@ -0,0 +1,44 @@
+Welcome to the Lain wiki!
+
+If you spot a typo or have a suggestion to improve these pages, please notify me opening an [issue](https://github.com/lcpz/lain/issues) format. Thank you.
+
+Dependencies
+------------
+
+Package | Requested by | Reasons of choice
+--- | --- | ---
+[curl](https://curl.haxx.se) | `imap`, `mpd`, and `weather` widgets | 1. faster and simpler to use than [LuaSocket](https://github.com/diegonehab/luasocket); 2. it's in the core of almost every distro; 3. can be called [asynchronously](https://awesomewm.org/doc/api/libraries/awful.spawn.html#easy_async)
+
+Installation
+------------
+
+### Arch Linux
+
+[AUR package](https://aur.archlinux.org/packages/lain-git/)
+
+### Other distributions
+
+```shell
+git clone https://github.com/lcpz/lain.git ~/.config/awesome/lain
+```
+
+Also available via [LuaRocks](https://luarocks.org/modules/lcpz/lain):
+
+```shell
+luarocks install lcpz/lain
+```
+
+Usage
+--------
+
+First, include it into your `rc.lua`:
+
+```lua
+local lain = require("lain")
+```
+
+Then check out the submodules you want:
+
+- [Layouts](https://github.com/lcpz/lain/wiki/Layouts)
+- [Widgets](https://github.com/lcpz/lain/wiki/Widgets)
+- [Utilities](https://github.com/lcpz/lain/wiki/Utilities)
diff --git a/lain/wiki/Layouts.md b/lain/wiki/Layouts.md
new file mode 100644
index 0000000..0286d4b
--- /dev/null
+++ b/lain/wiki/Layouts.md
@@ -0,0 +1,255 @@
+
+    lain/layout
+    .
+    |-- termfair
+    |-- termfair.center
+    |-- cascade
+    |-- cascade.tile
+    |-- centerwork
+    |-- centerwork.horizontal
+
+Usage
+=====
+
+As usual, specify your favourites in `awful.layout.layouts`, or set them on specific tags with [`awful.layout.set`](https://awesomewm.org/doc/api/libraries/awful.layout.html#set).
+
+```lua
+awful.layout.set(lain.layout.termfair, tag)
+```
+
+How do layouts work?
+====================
+
+`termfair`
+--------
+
+This layout restricts the size of each window. Each window will have the
+same width but is variable in height. Furthermore, windows are
+left-aligned. The basic workflow is as follows (the number above the
+screen is the number of open windows, the number in a cell is the fixed
+number of a client):
+
+	     (1)                (2)                (3)
+	+---+---+---+      +---+---+---+      +---+---+---+
+	|   |   |   |      |   |   |   |      |   |   |   |
+	| 1 |   |   |  ->  | 2 | 1 |   |  ->  | 3 | 2 | 1 |  ->
+	|   |   |   |      |   |   |   |      |   |   |   |
+	+---+---+---+      +---+---+---+      +---+---+---+
+
+	     (4)                (5)                (6)
+	+---+---+---+      +---+---+---+      +---+---+---+
+	| 4 |   |   |      | 5 | 4 |   |      | 6 | 5 | 4 |
+	+---+---+---+  ->  +---+---+---+  ->  +---+---+---+
+	| 3 | 2 | 1 |      | 3 | 2 | 1 |      | 3 | 2 | 1 |
+	+---+---+---+      +---+---+---+      +---+---+---+
+
+The first client will be located in the left column. When opening
+another window, this new window will be placed in the left column while
+moving the first window into the middle column. Once a row is full,
+another row above it will be created.
+
+Default number of columns and rows are respectively taken from `nmaster`
+and `ncol` values in `awful.tag`, but you can set your own.
+
+For example, this sets `termfair` to 3 columns and at least 1 row:
+
+```lua
+lain.layout.termfair.nmaster = 3
+lain.layout.termfair.ncol    = 1
+```
+
+`termfair.center`
+----------
+
+Similar to `termfair`, but with fixed number of vertical columns. Cols are centerded until there are `nmaster` columns, then windows are stacked as slaves, with possibly `ncol` clients per column at most.
+
+            (1)                (2)                (3)
+       +---+---+---+      +-+---+---+-+      +---+---+---+
+       |   |   |   |      | |   |   | |      |   |   |   |
+       |   | 1 |   |  ->  | | 1 | 2 | | ->   | 1 | 2 | 3 |  ->
+       |   |   |   |      | |   |   | |      |   |   |   |
+       +---+---+---+      +-+---+---+-+      +---+---+---+
+
+            (4)                (5)
+       +---+---+---+      +---+---+---+
+       |   |   | 3 |      |   | 2 | 4 |
+       + 1 + 2 +---+  ->  + 1 +---+---+
+       |   |   | 4 |      |   | 3 | 5 |
+       +---+---+---+      +---+---+---+
+
+Like `termfair`, default number of columns and rows are respectively taken from `nmaster`
+and `ncol` values in `awful.tag`, but you can set your own.
+
+For example, this sets `termfair.center` to 3 columns and at least 1 row:
+
+```lua
+lain.layout.termfair.center.nmaster = 3
+lain.layout.termfair.center.ncol    = 1
+```
+
+`cascade`
+-------
+
+Cascade all windows of a tag.
+
+You can control the offsets by setting these two variables:
+
+```lua
+lain.layout.cascade.offset_x = 64
+lain.layout.cascade.offset_y = 16
+```
+
+The following reserves space for 5 windows:
+
+```lua
+lain.layout.cascade.nmaster = 5
+```
+
+That is, no window will get resized upon the creation of a new window,
+unless there's more than 5 windows.
+
+`cascade.tile`
+-----------
+
+Similar to `awful.layout.suit.tile` layout, however, clients in the slave
+column are cascaded instead of tiled.
+
+Left column size can be set, otherwise is controlled by `mwfact` of the
+tag. Additional windows will be opened in another column on the right.
+New windows are placed above old windows.
+
+Whether the slave column is placed on top of the master window or not is
+controlled by the value of `ncol`. A value of 1 means "overlapping slave column"
+and anything else means "don't overlap windows".
+
+Usage example:
+
+```lua
+lain.layout.cascade.tile.offset_x      = 2
+lain.layout.cascade.tile.offset_y      = 32
+lain.layout.cascade.tile.extra_padding = 5
+lain.layout.cascade.tile.nmaster       = 5
+lain.layout.cascade.tile.ncol          = 2
+```
+
+`extra_padding` reduces the size of the master window if "overlapping
+slave column" is activated. This allows you to see if there are any
+windows in your slave column.
+
+Setting `offset_x` to a very small value or even 0 is recommended to avoid wasting space.
+
+`centerwork`
+----------
+
+You start with one window, centered horizontally:
+
+	+--------------------------+
+	|       +----------+       |
+	|       |          |       |
+	|       |          |       |
+	|       |          |       |
+	|       |   MAIN   |       |
+	|       |          |       |
+	|       |          |       |
+	|       |          |       |
+	|       |          |       |
+	|       +----------+       |
+	+--------------------------+
+
+This is your main working window. You do most of the work right here.
+Sometimes, you may want to open up additional windows. They're put on left and right, alternately.
+
+	+--------------------------+
+	| +---+ +----------+ +---+ |
+	| |   | |          | |   | |
+	| |   | |          | |   | |
+	| |   | |          | |   | |
+	| +---+ |   MAIN   | +---+ |
+	| +---+ |          | +---+ |
+	| |   | |          | |   | |
+	| |   | |          | |   | |
+	| |   | |          | |   | |
+	| +---+ +----------+ +---+ |
+	+--------------------------+
+
+*Please note:* If you use Awesome's default configuration, navigation in
+this layout may be very confusing. How do you get from the main window
+to satellite ones depends on the order in which the windows are opened.
+Thus, use of `awful.client.focus.bydirection()` is suggested.
+Here's an example:
+
+```lua
+globalkeys = awful.util.table.join(
+    -- [...]
+    awful.key({ modkey }, "j",
+        function()
+            awful.client.focus.bydirection("down")
+            if client.focus then client.focus:raise() end
+        end),
+    awful.key({ modkey }, "k",
+        function()
+            awful.client.focus.bydirection("up")
+            if client.focus then client.focus:raise() end
+        end),
+    awful.key({ modkey }, "h",
+        function()
+            awful.client.focus.bydirection("left")
+            if client.focus then client.focus:raise() end
+        end),
+    awful.key({ modkey }, "l",
+        function()
+            awful.client.focus.bydirection("right")
+            if client.focus then client.focus:raise() end
+        end),
+    -- [...]
+)
+```
+
+`centerwork.horizontal`
+-----------
+
+Same as `centerwork`, except that the main
+window expands horizontally, and the additional windows
+are put ontop/below it. Useful if you have a screen turned 90°.
+
+Pre 4.0 `uselesstile` patches
+=============================
+
+In branch 3.5, this module provided useless gaps layouts. Since useless gaps have been implemented in Awesome 4.0, those layouts have been removed.
+
+Following are a couple of `uselesstile` variants that were not part of lain. They are kept only for reference and are not supported.
+
+Xmonad-like
+-----------
+
+If you want to have `awful.layout.suit.tile` behave like xmonad, with internal gaps two times wider than external ones, download [this](https://gist.github.com/lcpz/9e56dcfbe66bfe14967c) as `lain/layout/uselesstile`.
+
+Inverted master
+---------------
+
+Want to invert master window position? Use [this](https://gist.github.com/lcpz/c59dc59c9f99d98218eb) version. You can set `single_gap` with `width` and `height` in your `theme.lua`, in order to define the window geometry when there's only one client, otherwise it goes maximized. An example:
+
+    theme.single_gap = { width = 600, height = 100 }
+
+What about layout icons?
+========================
+
+They are located in ``lain/icons/layout``.
+
+To use them, define new `layout_*` variables in your ``theme.lua``. For instance:
+
+```lua
+theme.lain_icons         = os.getenv("HOME") ..
+                           "/.config/awesome/lain/icons/layout/default/"
+theme.layout_termfair    = theme.lain_icons .. "termfair.png"
+theme.layout_centerfair  = theme.lain_icons .. "centerfair.png"  -- termfair.center
+theme.layout_cascade     = theme.lain_icons .. "cascade.png"
+theme.layout_cascadetile = theme.lain_icons .. "cascadetile.png" -- cascade.tile
+theme.layout_centerwork  = theme.lain_icons .. "centerwork.png"
+theme.layout_centerworkh = theme.lain_icons .. "centerworkh.png" -- centerwork.horizontal
+```
+
+Credit goes to [Nicolas Estibals](https://github.com/nestibal) for creating
+layout icons for default theme.
+
+You can use them as a template for your custom versions.
\ No newline at end of file
diff --git a/lain/wiki/Utilities.md b/lain/wiki/Utilities.md
new file mode 100644
index 0000000..4ec3057
--- /dev/null
+++ b/lain/wiki/Utilities.md
@@ -0,0 +1,338 @@
+Quake
+-----
+
+A Quake-like dropdown container for your favourite application.
+
+**Usage**
+
+Define it globally to have a single instance for all screens:
+
+```lua
+local quake = lain.util.quake()
+```
+
+or define it in `connect_for_each_screen` to have one instance for each screen:
+
+```lua
+awful.screen.connect_for_each_screen(function(s)
+    -- Quake application
+    s.quake = lain.util.quake()
+    -- [...]
+```
+
+**Keybinding example**
+
+If using a global instance:
+```lua
+awful.key({ modkey, }, "z", function () quake:toggle() end),
+```
+
+If using a per-screen instance:
+```lua
+awful.key({ modkey, }, "z", function () awful.screen.focused().quake:toggle() end),
+```
+
+**Input table**
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`app` | client to spawn | string | "xterm"
+`name` | client name | string | "QuakeDD"
+`argname` | how to specify client name | string | "-name %s"
+`extra` | extra `app` arguments | string | empty string
+`border` | border width | integer | 1
+`visible` | initially visible | boolean | false
+`followtag` | always spawn on currently focused screen | boolean | false
+`overlap` | Overlap the wibox or not | boolean | false
+`settings` | Additional settings to make on the client | function | `nil`
+`screen` | screen where to spawn the client | integer | `awful.screen.focused()`
+`height` | dropdown client height | float in [0,1] or exact pixels number | 0.25
+`width` | dropdown client width | float in [0,1] or exact pixels number | 1
+`vert` | vertical position | string, possible values: "top", "bottom", "center" | "top"
+`horiz` | horizontal position | string, possible values: "left", "right", "center" | "left"
+
+`height` and `width` express a fraction of the workspace.
+
+`settings` is a function which takes the client as input, and can be used to customize its properties. For instance:
+
+```lua
+-- set the client sticky
+s.quake = lain.util.quake { settings = function(c) c.sticky = true end }
+```
+
+Read [here](https://awesomewm.org/doc/api/classes/client.html#Object_properties) for the complete list of properties.
+
+**Notes**
+
+* [Does not work](https://github.com/lcpz/lain/issues/358) with `gnome-terminal`, `konsole`, or any other terminal which is strictly designed for a Desktop Environment. Just pick a better terminal, [there's plenty](https://wiki.archlinux.org/index.php/List_of_applications#Terminal_emulators).
+* Set `followtag = true` if [experiencing issues with multiple screens](https://github.com/lcpz/lain/issues/346).
+* If you have a `awful.client.setslave` rule for your application, ensure you use an exception for `QuakeDD` (or your defined `name`). Otherwise, you may run into problems with focus.
+* If you are using a VTE-based terminal like `termite`, be sure to set [`argname = "--name %s"`](https://github.com/lcpz/lain/issues/211).
+
+Separators
+----------
+
+Adds Cairo separators.
+
+```lua
+local separators = lain.util.separators
+```
+
+A separator function `separators.separator` takes two color arguments, defined as strings. `"alpha"` argument is allowed. Example:
+
+```lua
+arrl_dl = separators.arrow_left(beautiful.bg_focus, "alpha")
+arrl_ld = separators.arrow_left("alpha", beautiful.bg_focus)
+```
+
+You can customize height and width by setting `separators_height` and `separators_width` in your `theme.lua`. Default values are 0 and 9, respectively.
+
+List of functions:
+
+     +-- separators
+     |
+     |`-- arrow_right()    Draw a right arrow.
+      `-- arrow_left()     Draw a left arrow.
+
+markup
+------
+
+Mades markup easier.
+
+```lua
+local markup = lain.util.markup
+```
+
+List of functions:
+
+     +-- markup
+     |
+     |`-- bold()        Set bold.
+     |`-- italic()      Set italicized text.
+     |`-- strike()      Set strikethrough text.
+     |`-- underline()   Set underlined text.
+     |`-- monospace()   Set monospaced text.
+     |`-- big()         Set bigger text.
+     |`-- small()       Set smaller text.
+     |`-- font()        Set the font of the text.
+     |`-- font()        Set the font of the text.
+     |`-- color()       Set background and foreground color.
+     |`-- fontfg()      Set font and foreground color.
+     |`-- fontbg()      Set font and background color.
+      `-- fontcolor()   Set font, plus background and foreground colors.
+     |
+     |`--+ bg
+     |   |
+     |    `-- color()   Set background color.
+     |
+      `--+ fg
+         |
+          `-- color()   Set foreground color.
+
+they all take one argument, which is the text to markup, except the following:
+
+```lua
+markup.font(font, text)
+markup.color(fg, bg, text)
+markup.fontfg(font, fg, text)
+markup.fontbg(font, bg, text)
+markup.fontcolor(font, fg, bg, text)
+markup.fg.color(color, text)
+markup.bg.color(color, text)
+```
+
+Dynamic tagging
+---------------
+
+That is:
+
+- add a new tag;
+- rename current tag;
+- move current tag;
+- delete current tag.
+
+If you delete a tag, any rule set on it shall be broken, so be careful.
+
+Use it with key bindings like these:
+
+```lua
+awful.key({ modkey, "Shift" }, "n", function () lain.util.add_tag(mylayout) end),
+awful.key({ modkey, "Shift" }, "r", function () lain.util.rename_tag() end),
+awful.key({ modkey, "Shift" }, "Left", function () lain.util.move_tag(1) end),   -- move to next tag
+awful.key({ modkey, "Shift" }, "Right", function () lain.util.move_tag(-1) end), -- move to previous tag
+awful.key({ modkey, "Shift" }, "d", function () lain.util.delete_tag() end),
+```
+
+The argument in `lain.util.add_tag` represents the tag layout, and is optional: if not present, it will be defaulted to `awful.layout.suit.tile`.
+
+Useless gaps resize
+---------------------
+
+Changes `beautiful.useless_gaps` on the fly.
+
+```lua
+lain.util.useless_gap_resize(thatmuch, s, t)
+```
+
+The argument `thatmuch` is the number of pixel to add to/substract from gaps (integer).
+
+The arguments `s` and `t` are the `awful.screen` and `awful.tag` in which you want to change the gap. They are optional.
+
+Following are example keybindings for changing client gaps on current screen and tag.
+
+Example 1:
+
+```lua
+-- On the fly useless gaps change
+awful.key({ altkey, "Control" }, "+", function () lain.util.useless_gaps_resize(1) end),
+awful.key({ altkey, "Control" }, "-", function () lain.util.useless_gaps_resize(-1) end),
+```
+
+where `altkey = Mod1`. Example 2:
+
+```lua
+mywidget:buttons(awful.util.table.join (
+        awful.button({}, 4, function() lain.util.useless_gaps_resize(-1) end),
+        awful.button({}, 5, function() lain.util.useless_gaps_resize(1) end)
+    end)
+))
+```
+
+so when hovering the mouse over `mywidget`, you can adjust useless gaps size by scrolling with the mouse wheel.
+
+tag\_view\_nonempty
+-------------------
+
+This function lets you jump to the next/previous non-empty tag.
+It takes two arguments:
+
+* `direction`: `1` for next non-empty tag, `-1` for previous.
+* `sc`: Screen which the taglist is in. Default is `mouse.screen` or `1`. This
+  argument is optional.
+
+You can use it with key bindings like these:
+
+```lua
+-- Non-empty tag browsing
+awful.key({ altkey }, "Left", function () lain.util.tag_view_nonempty(-1) end),
+awful.key({ altkey }, "Right", function () lain.util.tag_view_nonempty(1) end),
+```
+
+where `altkey = "Mod1"`.
+
+magnify\_client
+---------------
+
+Set a client to floating and resize it in the same way the "magnifier"
+layout does it. Place it on the "current" screen (derived from the mouse
+position). This allows you to magnify any client you wish, regardless of
+the currently used layout. Use it with a client keybinding like this:
+
+```lua
+clientkeys = awful.util.table.join(
+    -- [...]
+    awful.key({ modkey, "Control" }, "m", lain.util.magnify_client),
+    -- [...]
+)
+```
+
+If you want to "de-magnify" it, just retype the keybinding.
+
+If you want magnified client to respond to `incmwfact`, read [here](https://github.com/lcpz/lain/issues/195).
+
+menu\_clients\_current\_tags
+----------------------------
+
+Similar to `awful.menu.clients`, but this menu only shows the clients
+of currently visible tags. Use it with a key binding like this:
+
+```lua
+awful.key({ "Mod1" }, "Tab", function()
+    lain.util.menu_clients_current_tags({ width = 350 }, { keygrabber = true })
+end),
+```
+
+menu\_iterator
+--------------
+
+A generic menu utility which enables iteration over lists of possible
+actions to execute. The perfect example is a menu for choosing what
+configuration to apply to X with `xrandr`, as suggested on the [Awesome wiki page](https://awesomewm.org/recipes/xrandr).
+
+<p align="center">
+    <img src="https://user-images.githubusercontent.com/4147254/36317474-3027f8b6-130b-11e8-9b6b-9a2cf55ae841.gif"/>
+    <br>An example Synergy menu, courtesy of <a href="https://github.com/sim590/dotfiles/blob/master/awesome/rc/xrandr.lua">sim590</a>
+</p>
+
+You can either manually create a menu by defining a table in this format:
+
+```lua
+{ { "choice description 1", callbackFuction1 }, { "choice description 2", callbackFunction2 }, ... }
+```
+
+or use `lain.util.menu_iterator.menu`. Once you have your menu, use it with `lain.menu_iterator.iterate`.
+
+### Input tables
+
+**lain.menu_iterator.iterate**
+
+| Argument  | Description | Type
+|---|---| ---
+| `menu`    | the menu to iterate on                                                           | table
+| `timeout` | time (in seconds) to wait on a choice before the choice is accepted              | integer (default: 4)
+| `icon`    | path to the icon to display in `naughty.notify` window                           | string
+
+**lain.menu_iterator.menu**
+
+| Argument  | Description | Type
+|---|---| ---
+`choices` | list of choices (e.g., `{ "choice1", "choice2", ... }`) | array of strings
+`name` | name of the program related to this menu | string
+`selected_cb` | callback to execute for each selected choice, it takes one choice (string) as argument; can be `nil` (no action to execute) | function
+`rejected_cb` | callback to execute for all rejected choices (the remaining choices, once one is selected), it takes one choice (string) as argument; can be `nil` (no action to execute) | function
+`extra_choices` | more choices to be added to the menu; unlike `choices`, these ones won't trigger `rejected_cb` | array of `{ choice, callback }` pairs, where `choice` is a string and `callback` is a function
+`combination` | how choices have to be combined in the menu; possible values are: "single" (default), the set of possible choices will simply be the input set ; "powerset", the set of possible choices will be the [power set](https://en.wikipedia.org/wiki/Power_set) of the input set | string
+
+### Examples
+
+A simple example is:
+
+```lua
+local mymenu_iterable = lain.util.menu_iterator.menu {
+    choices     = {"My first choice", "My second choice"},
+    name        = "My awesome program",
+    selected_cb = function(choice)
+        -- do something with selected choice
+    end,
+    rejected_cb = function(choice)
+        -- do something with every rejected choice
+    end
+}
+```
+
+The variable `mymenu_iterable` is a menu compatible with the function `lain.util.menu_iterator.iterate`, which will iterate over it and displays notification with `naughty.notify` every time it is called. You can use it like this:
+
+```lua
+local confirm_timeout = 5 -- time to wait before confirming the menu selection
+local my_notify_icon = "/path/to/icon" -- the icon to display in the notification
+lain.util.menu_iterator.iterate(mymenu_iterable, confirm_timeout, my_notify_icon)
+```
+
+Once `confirm_timeout` has passed without anymore calls to `iterate`, the choice is made and the associated callbacks (both for selected and rejected choices) are spawned.
+
+A useful practice is to add a `Cancel` option as an extra choice for canceling a menu selection. Extending the above example:
+
+```lua
+local mymenu_iterable = lain.util.menu_iterator.menu {
+    choices     = {"My first choice", "My second choice"},
+    name        = "My awesome program",
+    selected_cb = function(choice)
+        -- do something with selected choice
+    end,
+    rejected_cb = function(choice)
+        -- do something with every rejected choice
+    end
+    -- nil means no action to do
+    extra_choices = { {"Cancel"}, nil }
+}
+```
diff --git a/lain/wiki/Widgets.md b/lain/wiki/Widgets.md
new file mode 100644
index 0000000..1653ea2
--- /dev/null
+++ b/lain/wiki/Widgets.md
@@ -0,0 +1,55 @@
+# Usage
+
+Every lain widget is a table.
+
+A lain widget is generated by a `function`.
+
+The `function` signature, input and output arguments can be found in the [related wiki entry](https://github.com/lcpz/lain/wiki/Widgets#index).
+
+Every lain widget contains a `wibox.widget`, which is updated by a timed function. To access the widget, use the field `widget`, to access the timed function, use the field `update`. Some lain widgets may also have an `icon` field, which is a `wibox.widget.imagebox`, and/or a `timer` field, which is the `gears.timer` on `update`.
+
+Every `function` may take either a table or a list of variables as input.
+
+If the input is a table, you must define a function variable called `settings` in it. There you will be able to define `widget` appearance.
+
+For instance, if `widget` is a textbox, to markup it call `widget:set_markup(...)` within `settings`.
+
+In the scope of `settings` you can use predefined arguments, which are specified in the wiki entries.
+
+Example of a lain widget:
+
+```lua
+local cpu = lain.widget.cpu {
+    settings = function()
+        widget:set_markup("Cpu " .. cpu_now.usage)
+    end
+}
+-- to access the widget: cpu.widget
+```
+
+Given the asynchronous nature of these widgets, be sure to use a [defensive programming](https://github.com/lcpz/lain/issues/451#issuecomment-615450523) style when you write your configuration. You can find various examples of this in [awesome-copycats](https://github.com/lcpz/awesome-copycats).
+
+# Index
+
+- [alsa](https://github.com/lcpz/lain/wiki/alsa)
+- [alsabar](https://github.com/lcpz/lain/wiki/alsabar)
+- [bat](https://github.com/lcpz/lain/wiki/bat)
+- [cal](https://github.com/lcpz/lain/wiki/cal)
+- [cpu](https://github.com/lcpz/lain/wiki/cpu)
+- [fs](https://github.com/lcpz/lain/wiki/fs)
+- [imap](https://github.com/lcpz/lain/wiki/imap)
+- [mem](https://github.com/lcpz/lain/wiki/mem)
+- [mpd](https://github.com/lcpz/lain/wiki/mpd)
+- [net](https://github.com/lcpz/lain/wiki/net)
+- [pulse](https://github.com/lcpz/lain/wiki/pulse)
+- [pulsebar](https://github.com/lcpz/lain/wiki/pulsebar)
+- [sysload](https://github.com/lcpz/lain/wiki/sysload)
+- [temp](https://github.com/lcpz/lain/wiki/temp)
+- [weather](https://github.com/lcpz/lain/wiki/weather)
+
+## User contributions
+
+- [moc](https://github.com/lcpz/lain/wiki/moc)
+- [redshift](https://github.com/lcpz/lain/wiki/redshift)
+- [task](https://github.com/lcpz/lain/wiki/task)
+- [tp_smapi](https://github.com/lcpz/lain/wiki/tp_smapi)
diff --git a/lain/wiki/_Footer.md b/lain/wiki/_Footer.md
new file mode 100644
index 0000000..b64f13b
--- /dev/null
+++ b/lain/wiki/_Footer.md
@@ -0,0 +1 @@
+[Home](https://github.com/lcpz/lain/wiki) • [Layouts](https://github.com/lcpz/lain/wiki/Layouts) • [Widgets](https://github.com/lcpz/lain/wiki/Widgets) • [Utilities](https://github.com/lcpz/lain/wiki/Utilities)
diff --git a/lain/wiki/_Sidebar.md b/lain/wiki/_Sidebar.md
new file mode 100644
index 0000000..0289783
--- /dev/null
+++ b/lain/wiki/_Sidebar.md
@@ -0,0 +1,26 @@
+* [Home](https://github.com/lcpz/lain/wiki/Home)
+* [Layouts](https://github.com/lcpz/lain/wiki/Layouts)
+  * [Usage](https://github.com/lcpz/lain/wiki/Layouts#Usage)
+  * [How do layouts work?](https://github.com/lcpz/lain/wiki/Layouts#how-do-layouts-work)
+    * [termfair](https://github.com/lcpz/lain/wiki/Layouts#termfair)
+    * [centerfair](https://github.com/lcpz/lain/wiki/Layouts#termfaircenter)
+    * [cascade](https://github.com/lcpz/lain/wiki/Layouts#cascade)
+    * [cascadetile](https://github.com/lcpz/lain/wiki/Layouts#cascadetile)
+    * [centerwork](https://github.com/lcpz/lain/wiki/Layouts#centerwork)
+    * [centerworkh](https://github.com/lcpz/lain/wiki/Layouts#centerworkhorizontal)
+  * [Pre 4.0 uselesstile patches](https://github.com/lcpz/lain/wiki/Layouts#pre-40-uselesstile-patches)
+  * [What about layout icons?](https://github.com/lcpz/lain/wiki/Layouts#what-about-layout-icons)
+* [Widgets](https://github.com/lcpz/lain/wiki/Widgets)
+  * [Usage](https://github.com/lcpz/lain/wiki/Widgets#usage)
+  * [Index](https://github.com/lcpz/lain/wiki/Widgets#index)
+    * [Users contributed](https://github.com/lcpz/lain/wiki/Widgets#users-contributed)
+* [Utilities](https://github.com/lcpz/lain/wiki/Utilities)
+    * [quake](https://github.com/lcpz/lain/wiki/Utilities#quake)
+    * [separators](https://github.com/lcpz/lain/wiki/Utilities#separators)
+    * [markup](https://github.com/lcpz/lain/wiki/Utilities#markup)
+    * [dynamic tagging](https://github.com/lcpz/lain/wiki/Utilities#dynamic-tagging)
+    * [useless_gaps_resize](https://github.com/lcpz/lain/wiki/Utilities#useless-gaps-resize)
+    * [tag_view_non_empty](https://github.com/lcpz/lain/wiki/Utilities#tag_view_nonempty)
+    * [magnify_client](https://github.com/lcpz/lain/wiki/Utilities#magnify_client)
+    * [menu_clients_current_tags](https://github.com/lcpz/lain/wiki/Utilities#menu_clients_current_tags)
+    * [menu_iterator](https://github.com/lcpz/lain/wiki/Utilities#menu_iterator)
diff --git a/lain/wiki/alsa.md b/lain/wiki/alsa.md
new file mode 100644
index 0000000..1418379
--- /dev/null
+++ b/lain/wiki/alsa.md
@@ -0,0 +1,149 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows ALSA volume.
+
+```lua
+local volume = lain.widget.alsa()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 5
+`cmd` | Alsa mixer command | string | "amixer"
+`channel` | Mixer channel | string | "Master"
+`togglechannel` | Toggle channel | string | `nil`
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`cmd` is useful if you need to pass additional arguments to amixer. For instance, you may want to define `cmd = "amixer -c X"` in order to set amixer with card `X`.
+
+`settings` can use the following variables:
+
+Variable | Meaning | Type | Values
+--- | --- | --- | ---
+`volume_now.level` | Volume level | integer | 0-100
+`volume_now.status` | Device status | string | "on", "off"
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`channel` | ALSA channel | string
+`update` | Update `widget` | function
+
+## Toggle channel
+
+In case mute toggling can't be mapped to master channel (this happens, for instance, when you are using an HDMI output), define togglechannel as your S/PDIF device. You can get the device ID with `scontents` command.
+
+For instance, if card number is 1 and S/PDIF number is 3:
+
+```shell
+$ amixer -c 1 scontents
+Simple mixer control 'Master',0
+  Capabilities: volume
+  Playback channels: Front Left - Front Right
+  Capture channels: Front Left - Front Right
+  Limits: 0 - 255
+  Front Left: 255 [100%]
+  Front Right: 255 [100%]
+Simple mixer control 'IEC958',0
+  Capabilities: pswitch pswitch-joined
+  Playback channels: Mono
+  Mono: Playback [on]
+Simple mixer control 'IEC958',1
+  Capabilities: pswitch pswitch-joined
+  Playback channels: Mono
+  Mono: Playback [on]
+Simple mixer control 'IEC958',2
+  Capabilities: pswitch pswitch-joined
+  Playback channels: Mono
+  Mono: Playback [on]
+Simple mixer control 'IEC958',3
+  Capabilities: pswitch pswitch-joined
+  Playback channels: Mono
+  Mono: Playback [on]
+```
+
+you have to set `togglechannel = "IEC958,3"`.
+
+## Buttons
+
+If you want buttons, just add the following after your widget in `rc.lua`.
+
+```lua
+volume.widget:buttons(awful.util.table.join(
+    awful.button({}, 1, function() -- left click
+        awful.spawn(string.format("%s -e alsamixer", terminal))
+    end),
+    awful.button({}, 2, function() -- middle click
+        os.execute(string.format("%s set %s 100%%", volume.cmd, volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 3, function() -- right click
+        os.execute(string.format("%s set %s toggle", volume.cmd, volume.togglechannel or volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 4, function() -- scroll up
+        os.execute(string.format("%s set %s 1%%+", volume.cmd, volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 5, function() -- scroll down
+        os.execute(string.format("%s set %s 1%%-", volume.cmd, volume.channel))
+        volume.update()
+    end)
+))
+```
+
+## Keybindings
+
+You can control the widget with keybindings like these:
+
+```lua
+-- ALSA volume control
+awful.key({ altkey }, "Up",
+	function ()
+		os.execute(string.format("amixer set %s 1%%+", volume.channel))
+		volume.update()
+	end),
+awful.key({ altkey }, "Down",
+	function ()
+		os.execute(string.format("amixer set %s 1%%-", volume.channel))
+		volume.update()
+	end),
+awful.key({ altkey }, "m",
+	function ()
+		os.execute(string.format("amixer set %s toggle", volume.togglechannel or volume.channel))
+		volume.update()
+	end),
+awful.key({ altkey, "Control" }, "m",
+	function ()
+		os.execute(string.format("amixer set %s 100%%", volume.channel))
+		volume.update()
+	end),
+awful.key({ altkey, "Control" }, "0",
+	function ()
+		os.execute(string.format("amixer set %s 0%%", volume.channel))
+		volume.update()
+	end),
+```
+
+where `altkey = "Mod1"`.
+
+### Muting with PulseAudio
+
+If you are using this widget in conjuction with PulseAudio, add the option `-D pulse` to the muting keybinding, like this:
+
+```lua
+awful.key({ altkey }, "m",
+	function ()
+		os.execute(string.format("amixer -D pulse set %s toggle", volume.togglechannel or volume.channel))
+		volume.update()
+	end),
+```
diff --git a/lain/wiki/alsabar.md b/lain/wiki/alsabar.md
new file mode 100644
index 0000000..a986d8f
--- /dev/null
+++ b/lain/wiki/alsabar.md
@@ -0,0 +1,108 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows ALSA volume with a progressbar; provides tooltips and notifications.
+
+```lua
+local volume = lain.widget.alsabar()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 5
+`settings` | User settings | function | empty function
+`width` | Bar width | number | 63
+`height` | Bar height | number | 1
+`margins` | Bar margins | number | 1
+`paddings` | Bar paddings | number | 1
+`ticks` | Set bar ticks on | boolean | false
+`ticks_size` | Ticks size | integer | 7
+`tick` | String for a notification tick | string | "|"
+`tick_pre` | String for the left notification delimeter | string | "["
+`tick_post` | String for the right notification delimeter | string | "]"
+`tick_none` | String for an empty notification tick | string | " "
+`cmd` | ALSA mixer command | string | "amixer"
+`channel` | Mixer channel | string | "Master"
+`togglechannel` | Toggle channel | string | `nil`
+`tick` | The character usef for ticks in the notification | string | "|"
+`colors` | Bar colors | table | see [Default colors](https://github.com/lcpz/lain/wiki/alsabar#default-colors)
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/alsabar#default-notification_preset)
+`followtag` | Display the notification on currently focused screen | boolean | false
+
+`cmd` is useful if you need to pass additional arguments to  `amixer`. For instance, you may want to define `cmd = "amixer -c X"` in order to set amixer with card `X`.
+
+In case mute toggling can't be mapped to master channel (this happens, for instance, when you are using an HDMI output), define `togglechannel` as your S/PDIF device. Read [`alsa`](https://github.com/lcpz/lain/wiki/alsa#toggle-channel) page to know how.
+
+To set the maximum number of ticks to display in the notification, define `max_ticks` (integer) in `notification_preset`.
+
+`settings` can use the following variables:
+
+Variable | Meaning | Type | Values
+--- | --- | --- | ---
+`volume_now.level` | Volume level | integer | 0-100
+`volume_now.status` | Device status | string | "on", "off"
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+### Default colors
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`background` | Bar backgrund color | string | "#000000"
+`mute` | Bar mute color | string | "#EB8F8F"
+`unmute` | Bar unmute color | string | "#A4CE8A"
+
+### Default `notification_preset`
+
+```lua
+notification_preset = {
+    font = "Monospace 10"
+}
+```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`bar` | The widget | `wibox.widget.progressbar`
+`channel` | ALSA channel | string
+`notify` | The notification | function
+`update` | Update `bar` | function
+`tooltip` | The tooltip | `awful.tooltip`
+
+## Buttons
+
+If you want buttons, just add the following after your widget in `rc.lua`.
+
+```lua
+volume.bar:buttons(awful.util.table.join(
+    awful.button({}, 1, function() -- left click
+        awful.spawn(string.format("%s -e alsamixer", terminal))
+    end),
+    awful.button({}, 2, function() -- middle click
+        os.execute(string.format("%s set %s 100%%", volume.cmd, volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 3, function() -- right click
+        os.execute(string.format("%s set %s toggle", volume.cmd, volume.togglechannel or volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 4, function() -- scroll up
+        os.execute(string.format("%s set %s 1%%+", volume.cmd, volume.channel))
+        volume.update()
+    end),
+    awful.button({}, 5, function() -- scroll down
+        os.execute(string.format("%s set %s 1%%-", volume.cmd, volume.channel))
+        volume.update()
+    end)
+))
+```
+
+## Keybindings
+
+Read [here](https://github.com/lcpz/lain/wiki/alsa#keybindings). If you want notifications, use `volume.notify()` instead of `volume.update()`.
diff --git a/lain/wiki/bat.md b/lain/wiki/bat.md
new file mode 100644
index 0000000..4af8cdc
--- /dev/null
+++ b/lain/wiki/bat.md
@@ -0,0 +1,103 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows the remaining time and percentage capacity of your laptop battery, as well
+as the current wattage. Multiple batteries are supported.
+
+Displays a notification when battery is fully charged, low, or critical.
+
+```lua
+local mybattery = lain.widget.bat()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 30
+`pspath` | Power supply directory path | string | "/sys/class/power_supply/"
+`battery` | Single battery id | string | autodetected
+`batteries` | Multiple batteries id table | table of strings | autodetected
+`ac` | AC | string | autodetected
+`notify` | Show notification popups | string | "on"
+`full_notify` | Show a notification popup when the battery's fully charged | string | inherited value from `notify`
+`n_perc` | Percentages assumed for critical and low battery levels | table of integers | `{5, 15}`
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+The widget will try to autodetect `battery`, `batteries` and `ac`. If something
+goes wrong, you will have to define them manually. In that case, you only have
+to define one between `battery` and `batteries`. If you have one battery, you
+can either use `args.battery = "BAT*"` or `args.batteries = {"BAT*"}`, where `BAT*`
+is the identifier of your battery in `pspath` (do not use it as a wildcard).
+Of course, if you have multiple batteries, you need to use the latter option.
+
+To disable notifications, set `notify` to `"off"`.
+
+If you define `pspath`, **be sure** to not forget the final slash (/).
+
+`settings` can use the `bat_now` table, which contains the following strings:
+
+- `status`, general status ("N/A", "Discharging", "Charging", "Full");
+- `n_status[i]`, i-th battery status (like above);
+- `ac_status`, AC-plug flag (0 if cable is unplugged, 1 if plugged, "N/A" otherwise);
+- `perc`, total charge percentage (integer between 0 and 100 or "N/A");
+- `n_perc[i]`, i-th battery charge percentage (like above);
+- `time`, time remaining until charge if charging, until discharge if discharging (HH:MM string or "N/A");
+- `watt`, battery watts (float with 2 decimals);
+- `capacity`, remaining battery capacity in percent;
+- `n_capacity[i]`, i-th battery remaining capacity (like above).
+
+and can modify the following three tables, which will be the preset for the naughty notifications:
+* `bat_notification_charged_preset` (used if battery is fully charged and connected to AC)
+* `bat_notification_low_preset` (used if battery charge level <= 15)
+* `bat_notification_critical_preset` (used if battery charge level <= 5)
+
+Check [here](https://awesomewm.org/doc/api/libraries/naughty.html#notify) for
+the list of variables they can contain. Default definitions:
+
+```lua
+bat_notification_charged_preset = {
+        title   = "Battery full",
+        text    = "You can unplug the cable",
+        timeout = 15,
+        fg      = "#202020",
+        bg      = "#CDCDCD"
+    }
+
+```
+
+```lua
+bat_notification_low_preset = {
+        title = "Battery low",
+        text = "Plug the cable!",
+        timeout = 15,
+        fg = "#202020",
+        bg = "#CDCDCD"
+}
+```
+```lua
+bat_notification_critical_preset = {
+        title = "Battery exhausted",
+        text = "Shutdown imminent",
+        timeout = 15,
+        fg = "#000000",
+        bg = "#FFFFFF"
+}
+```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+## Note
+
+Alternatively, you can try the [`upower` recipe](https://awesomewm.org/recipes/watch).
diff --git a/lain/wiki/cal.md b/lain/wiki/cal.md
new file mode 100644
index 0000000..5b6e358
--- /dev/null
+++ b/lain/wiki/cal.md
@@ -0,0 +1,83 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Creates a calendar notification that can be attached to widgets.
+
+This is a simpler but [faster](https://github.com/awesomeWM/awesome/issues/1861)
+alternative to [`awful.widget.calendar_popup`](https://awesomewm.org/doc/api/classes/awful.widget.calendar_popup.html), which emulates UNIX's `cal`.
+
+```lua
+local mycal = lain.widget.cal()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`attach_to` | List of widgets | table | empty table
+`week_start` | First day of the week | integer | 2 (Monday)
+`three` | Display three months spanning the date | boolean | false
+`followtag` | Display the notification on currently focused screen | boolean | false
+`week_number` | Display the week number | string ("none", "left" or "right") | "none"
+`week_number_format` | Week number format | string | `"%3d \| "` for "left", `"\| %-3d"` for "right"
+`icons` | Path to calendar icons | string | [icons/cal/white/](https://github.com/lcpz/lain/tree/master/icons/cal/white)
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/cal#default-notification_preset)
+
+Set `attach_to` as the list of widgets to which you want to attach the calendar, like this:
+
+```lua
+local mycal = lain.widget.cal {
+    attach_to = { mywidget1, mywidget2, ...  },
+    -- [...]
+}
+```
+
+For every widget in `attach_to`:
+
+- Left click / scroll down: switch to previous month.
+- Middle click show current month.
+- Right click / scroll up: switch to next month.
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+### Default `notification_preset`
+
+```lua
+notification_preset = {
+    font = "Monospace 10",
+    fg   = "#FFFFFF",
+    bg   = "#000000"
+}
+```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`attach` | Attach the calendar to an input widget | function
+`show` | Show calendar | function
+`hide` | Hide calendar | function
+
+`attach` takes as argument any widget you want to attach the calendar to, while
+`show` takes as optional argument an integer to indicate the seconds to timeout.
+
+## Keybinding
+
+```lua
+awful.key({ altkey }, "c", function () mycal.show(7) end)
+```
+
+Where `altkey = "Mod1"`.
+
+## Notes
+
+* Naughty notifications require `notification_preset.font` to be **monospaced**, in order to correctly display the output.
+* If you want to [disable notification icon](https://github.com/lcpz/lain/pull/351), set `icons = ""` in the input table.
+* If you want to localise the calendar, put `os.setlocale(os.getenv("LANG"))` in your `rc.lua`.
+* If you want to get notifications [only with mouse clicks](https://github.com/lcpz/lain/issues/320) on a given widget, use this code:
+  ```lua
+  yourwidget:disconnect_signal("mouse::enter", mycal.hover_on)
+  ```
diff --git a/lain/wiki/cpu.md b/lain/wiki/cpu.md
new file mode 100644
index 0000000..d3dd6e5
--- /dev/null
+++ b/lain/wiki/cpu.md
@@ -0,0 +1,31 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows the current CPU usage, both in general and per core.
+
+```lua
+local mycpu = lain.widget.cpu()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 2
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`settings` can use these strings:
+
+* `cpu_now.usage`, the general use percentage;
+* `cpu_now[i].usage`, the i-th core use percentage, with `i` starting from 1.
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
\ No newline at end of file
diff --git a/lain/wiki/fs.md b/lain/wiki/fs.md
new file mode 100644
index 0000000..a8b82aa
--- /dev/null
+++ b/lain/wiki/fs.md
@@ -0,0 +1,83 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows file systems informations.
+
+If a partition is given in input, a notification will be displayed when it is almost full.
+
+```lua
+local mypartition = lain.widget.fs()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 600
+`partition` | (Optional) Partition to watch: a notification will be displayed when full | string | `nil`
+`threshold` | Percentage threshold at which the notification is triggered | integer | 99
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/fs#default-notification_preset)
+`followtag` | Display the notification on currently focused screen | boolean | false
+`showpopup` | Display popups with mouse hovering | string, possible values: "on", "off" | "on"
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`settings` can use the table `fs_now`, which contains a string entry for each file system path available. For instance, root infos are located in the variable `fs_now["/"]`. Every entry in this table have the following variables:
+
+Variable | Meaning | Type
+--- | --- | ---
+`units` | (multiple of) units used | string ("Kb", "Mb", "Gb", and so on)
+`percentage` | the used percentage | integer
+`size` | size in `units` of the given fs | float
+`used` | amount of space used in the given fs, expressed in `units` | float
+`free` | amount of free space in the given fs, expressed in `units` | float
+
+Usage example:
+
+```lua
+-- shows used (percentage) and remaining space in home partition
+local fsroothome = lain.widget.fs({
+    settings  = function()
+        widget:set_text("/home: " ..  fs_now["/home"].percentage .. "% (" ..
+        fs_now["/home"].free .. " " .. fs_now["/home"].units .. " left)")
+    end
+})
+-- output example: "/home: 37% (239.4 Gb left)"
+```
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+### Default `notification_preset`
+
+```lua
+notification_preset = {
+    font = "Monospace 10",
+    fg   = "#FFFFFF",
+    bg   = "#000000"
+}
+```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`show` | The notification | function
+
+You can display the notification with a key binding like this:
+
+```lua
+awful.key({ altkey }, "h", function () mypartition.show(seconds, scr) end),
+```
+
+where ``altkey = "Mod1"`` and ``show`` arguments, both optionals, are:
+
+* `seconds`, notification time in seconds
+* `scr`, screen which to display the notification in
+
+## Note
+
+Naughty notifications require `notification_preset.font` to be **monospaced**, in order to correctly display the output.
diff --git a/lain/wiki/imap.md b/lain/wiki/imap.md
new file mode 100644
index 0000000..5a17270
--- /dev/null
+++ b/lain/wiki/imap.md
@@ -0,0 +1,116 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows mails count fetching over IMAP.
+
+```lua
+local myimap = lain.widget.imap(args)
+```
+
+New mails are notified like this:
+
+	+--------------------------------------------+
+	| +---+                                      |
+	| |\ /| donald@disney.org has 3 new messages |
+	| +---+                                      |
+	+--------------------------------------------+
+
+## Input table
+
+Required parameters are:
+
+Variable | Meaning | Type
+--- | --- | ---
+`server` | Mail server | string
+`mail` | User mail | string
+`password` | User password | string
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+while the optional are:
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`port` | IMAP port | integer | 993
+`timeout` | Refresh timeout (in seconds) | integer | 60
+`pwdtimeout` | Timeout for password retrieval function (see [here](https://github.com/lcpz/lain/wiki/imap#password-security)) | integer | 10
+`is_plain` | Define whether `password` is a plain password (true) or a command that retrieves it (false) | boolean | false
+`followtag` | Notification behaviour | boolean | false
+`notify` | Show notification popups | string | "on"
+`settings` | User settings | function | empty function
+
+`settings` can use `imap_now` table, which contains the following non negative integers:
+
+- `["MESSAGES"]`
+- `["RECENT"]`
+- `["UNSEEN"]`
+
+example of fetch: `total = imap_now["MESSAGES"]`. For backwards compatibility, `settings` can also use `mailcount`, a pointer to `imap_now["UNSEEN"]`.
+
+Also, `settings` can modify `mail_notification_preset` table, which will be the preset for the naughty notifications. Check [here](https://awesomewm.org/apidoc/libraries/naughty.html#notify) for the list of variables it can contain. Default definition:
+
+```lua
+mail_notification _preset = {
+    icon = "lain/icons/mail.png",
+    position = "top_left"
+}
+```
+
+Note that `mailcount` and `imap_now` elements are equals to 0 either if there are no new mails or credentials are invalid, so make sure that your settings are correct.
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+You can have multiple instances of this widget at the same time.
+
+## Password security
+
+The reason why `is_plain` is false by default is to discourage the habit of storing passwords in plain.
+
+In general, when `is_plain == false`, `password` can be either a string, a table or a function: the widget will execute it asynchronously in the first two cases.
+
+### Using plain passwords
+
+You can set your password in plain like this:
+
+```lua
+myimapcheck = lain.widget.imap {
+    is_plain = true,
+    password = "mymailpassword",
+    -- [...]
+}
+```
+
+and you will have the same security provided by `~/.netrc`.
+
+### Using a password manager
+
+I recommend to use [spm](https://notabug.org/kl3/spm) or [pass](https://www.passwordstore.org). In this case, `password` has to be a function. Example stub:
+
+```lua
+myimapcheck = lain.widget.imap {
+    password = function()
+        -- do your retrieval
+        return retrieved_password, try_again
+    end,
+    -- [...]
+}
+```
+
+Where `retrieved_password` is the password retrieved from the manager, and `try_again` supports [DBus Secret Service](https://specifications.freedesktop.org/secret-service).
+
+The process flow is that the first `password()` call spawns the unlock prompt, then the second call retrieves the password. [Here](https://gist.github.com/lcpz/1854fc4320f4701957cd5309c8eed4a6) is an example of `password` function.
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+`pwdtimer` | Password retrieval timer (available only if `password` is a function)| [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+You can use `timer` to start/stop the widget as you like.
diff --git a/lain/wiki/mem.md b/lain/wiki/mem.md
new file mode 100644
index 0000000..470908b
--- /dev/null
+++ b/lain/wiki/mem.md
@@ -0,0 +1,36 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows memory status in MiB, [like `top` and `free -h`](https://github.com/lcpz/lain/issues/271).
+
+```lua
+local mymem = lain.widget.mem()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 2
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+in `settings` you can use the following variables:
+
+Variable | Meaning | Type
+--- | --- | ---
+`mem_now.used` | Memory used (MiB) | string
+`mem_now.swapused` | Swap memory used (MiB) | string
+`mem_now.perc` | Memory percentage | int
+
+(See line 23-39 of [this file](https://github.com/lcpz/lain/blob/master/widget/mem.lua) for more potential variables.)
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
\ No newline at end of file
diff --git a/lain/wiki/moc.md b/lain/wiki/moc.md
new file mode 100644
index 0000000..6f68d4e
--- /dev/null
+++ b/lain/wiki/moc.md
@@ -0,0 +1,123 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+A widget for showing the current song track's information from MOC (Music On Console).
+
+```lua
+local mymoc = lain.widget.contrib.moc()
+```
+
+Now playing songs are notified like this:
+
+	+--------------------------------------------------------+
+	| +-------+                                              |
+	| |/^\_/^\| Now playing                                  |
+    | |\ O O /| Cannibal Corpse (Hammer Smashed Face) - 1993 |
+    | | '.o.' | Hammer Smashed Face (Radio Disney Version)   |
+	| +-------+                                              |
+	+--------------------------------------------------------+
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 1
+`music_dir` | Music directory | string | "~/Music"
+`cover_size` | Album art notification size (both height and width) | integer | 100
+`cover_pattern` | Pattern for the album art file | string | `*\\.(jpg|jpeg|png|gif)`*
+`default_art` | Default art | string | ""
+`followtag` | Display the notification on currently focused screen | boolean | false
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+\* In Lua, "\\\\" means "\" escaped.
+
+Default `cover_pattern` definition will made the widget set the first jpg, jpeg, png or gif file found in the directory as the album art.
+
+Pay attention to case sensitivity when defining `music_dir`.
+
+`settings` can use `moc_now` table, which contains the following string values:
+
+- state (possible values: "PLAY", "PAUSE", "STOP")
+- file
+- artist
+- title
+- album
+- elapsed (Time elapsed for the current track)
+- total (The current track's total time)
+
+and can modify `moc_notification_preset` table, which will be the preset for the naughty notifications. Check [here](https://awesomewm.org/apidoc/libraries/naughty.html#notify) for the list of variables it can contain. Default definition:
+
+```lua
+moc_notification_preset = {
+    title   = "Now playing",
+    timeout = 6,
+    text    = string.format("%s (%s) - %s\n%s", moc_now.artist,
+              moc_now.album, moc_now.elapsed, moc_now.title)
+}
+```
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+You can use `timer` to start/stop the widget as you like.
+
+## Keybindings
+
+You can control the widget with key bindings like these:
+
+```lua
+-- MOC control
+awful.key({ altkey, "Control" }, "Up",
+	function ()
+		os.execute("mocp -G") -- toggle
+		moc.update()
+	end),
+awful.key({ altkey, "Control" }, "Down",
+	function ()
+		os.execute("mocp -s") -- stop
+		moc.update()
+	end),
+awful.key({ altkey, "Control" }, "Left",
+	function ()
+		os.execute("mocp -r") -- previous
+		moc.update()
+	end),
+awful.key({ altkey, "Control" }, "Right",
+	function ()
+		os.execute("mocp -f") -- next
+		moc.update()
+	end),
+```
+
+where `altkey = "Mod1"`.
+
+If you don't use the widget for long periods and wish to spare CPU, you can toggle it with a keybinding like this:
+
+```lua
+-- toggle MOC widget
+awful.key({ altkey }, "0",
+        function ()
+            local common = { text = "MOC widget ", position = "top_middle", timeout = 2 }
+            if moc.timer.started then
+                moc.timer:stop()
+                common.text = common.text .. markup.bold("OFF")
+            else
+                moc.timer:start()
+                common.text = common.text .. markup.bold("ON")
+            end
+            naughty.notify(common)
+        end),
+```
diff --git a/lain/wiki/mpd.md b/lain/wiki/mpd.md
new file mode 100644
index 0000000..9f614c0
--- /dev/null
+++ b/lain/wiki/mpd.md
@@ -0,0 +1,182 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows MPD status.
+
+```lua
+local mympd = lain.widget.mpd()
+```
+
+Now playing songs are notified like this:
+
+	+--------------------------------------------------------+
+	| +-------+                                              |
+	| |/^\_/^\| Now playing                                  |
+    | |\ O O /| Cannibal Corpse (Hammer Smashed Face) - 1993 |
+    | | '.o.' | Hammer Smashed Face (Radio Disney Version)   |
+	| +-------+                                              |
+	+--------------------------------------------------------+
+
+**Note:** if MPD is turned off or not set correctly, the widget will constantly display "N/A" values.
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 2
+`password` | MPD password | string | ""
+`host` | MPD server | string | "127.0.0.1"
+`port` | MPD port | string | "6600"
+`music_dir` | Music directory | string | "~/Music"
+`cover_size` | Album art notification size (both height and width) | integer | 100
+`cover_pattern` | Pattern for the album art file | string | `*.(jpg\|jpeg\|png\|gif)$`
+`default_art` | Default art | string | `nil`
+`notify` | Show notification pop-ups | string | "on"
+`followtag` | Notification behaviour | boolean | false
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+\* In Lua, "\\\\" means "\" escaped.
+
+The default `cover_pattern` definition will make the widget set the first JPG, JPEG, PNG or GIF file found in the directory as the album art.
+
+Pay attention to case sensitivity when defining `music_dir`.
+
+`settings` can use `mpd_now` table, which contains the following values:
+
+(**note:** the first four are boolean [flags](https://github.com/lcpz/lain/pull/205), the remaining are all strings)
+
+- random_mode
+- single_mode
+- repeat_mode
+- consume_mode
+- pls_pos (playlist position)
+- pls_len (playlist length)
+- state (possible values: "play", "pause", "stop")
+- file
+- artist
+- title
+- name
+- album
+- track
+- genre
+- date
+- [time](https://github.com/lcpz/lain/pull/90) (length of current song, in seconds)
+- [elapsed](https://github.com/lcpz/lain/pull/90) (elapsed time of current song, in seconds)
+- volume
+
+And can modify `mpd_notification_preset` table, which will be the preset for the naughty notifications. Check [here](https://awesomewm.org/doc/api/libraries/naughty.html#notify) for the list of variables it can contain. Default definition:
+
+```lua
+mpd_notification_preset = {
+   title   = "Now playing",
+   timeout = 6,
+   text    = string.format("%s (%s) - %s\n%s", mpd_now.artist,
+             mpd_now.album, mpd_now.date, mpd_now.title)
+}
+```
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The textbox | `wibox.widget.textbox`
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+You can use `timer` to start/stop the widget as you like.
+
+## Key bindings
+
+You can control the widget with key bindings like these:
+
+```lua
+-- MPD control
+awful.key({ altkey, "Control" }, "Up",
+	function ()
+		awful.spawn.with_shell("mpc toggle || ncmpc toggle || pms toggle")
+		mympd.update()
+	end),
+awful.key({ altkey, "Control" }, "Down",
+	function ()
+		awful.spawn.with_shell("mpc stop || ncmpc stop || pms stop")
+		mympd.update()
+	end),
+awful.key({ altkey, "Control" }, "Left",
+	function ()
+		awful.spawn.with_shell("mpc prev || ncmpc prev || pms prev")
+		mympd.update()
+	end),
+awful.key({ altkey, "Control" }, "Right",
+	function ()
+		awful.spawn.with_shell("mpc next || ncmpc next || pms next")
+		mympd.update()
+	end),
+```
+
+Where `altkey = "Mod1"`.
+
+If you don't use the widget for long periods and wish to spare CPU, you can toggle it with a key binding like this:
+
+```lua
+-- disable MPD widget
+awful.key({ altkey }, "0",
+    function ()
+        local common = {
+            text = "MPD widget ",
+            position = "top_middle",
+            timeout = 2
+        }
+        if mympd.timer.started then
+            mympd.timer:stop()
+            common.text = common.text .. markup.bold("OFF")
+        else
+            mympd.timer:start()
+            common.text = common.text .. markup.bold("ON")
+        end
+        naughty.notify(common)
+    end),
+```
+
+## Notes
+
+### Cover not showing in notifications
+
+If the cover file is existent but not showed in notifications, [try](https://github.com/lcpz/lain/issues/393) setting `music_dir` to a symlink of your music folder, rather than to a physical path. This can be easily done through
+```shell
+ln -s /the/real_path_to_your_music/ /home/username/Music
+```
+However, this only applies if the music is stored outside your user-specific folder, for instance in an external partition.
+
+### Always use `set_markup`
+
+In `settings`, if you use `widget:set_text`, [it will ignore Pango markup](https://github.com/lcpz/lain/issues/258), so be sure to always use `widget:set_markup`.
+
+### Volume fade in toggling MPD
+
+If you want a fade in/out in toggling MPD, you can put [this script](https://gist.github.com/lcpz/76e315bc27c6cdf7edd5021964b88df1) in your local `bin` directory:
+
+```shell
+$ curl https://gist.githubusercontent.com/lcpz/76e315bc27c6cdf7edd5021964b88df1/raw/97f7ba586418a4e07637cfbc91d2974278dfa623/mpd-fade -o ~/bin/mpc-fade
+$ chmod +x ~/bin/mpc-fade
+```
+
+Set your 1% decrease/increase commands [here](https://gist.github.com/lcpz/76e315bc27c6cdf7edd5021964b88df1#file-mpd-fade-L8-L9), then use a key binding like this:
+
+```lua
+-- MPD toggle with volume fading
+awful.key({ "Shift" }, "Pause",
+    function()
+        awful.spawn.easy_async("mpc-fade 20 4", -- mpc-fade <percentage> <length in secs>
+        function(stdout, stderr, reason, exit_code)
+            mympd.update()
+        end)
+    end),
+```
diff --git a/lain/wiki/net.md b/lain/wiki/net.md
new file mode 100644
index 0000000..4d0d508
--- /dev/null
+++ b/lain/wiki/net.md
@@ -0,0 +1,117 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Monitors network interfaces and shows current traffic.
+
+```lua
+local mynet = lain.widget.net()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 2
+`iface` | Network device(s) | string (single interface) or table of strings (multiple interfaces) | autodetected
+`units` | Units | integer | 1024 (kilobytes)
+`notify` | Display "no carrier" notifications | string | "on"
+`wifi_state` | Get Wi-Fi connection status | string | "off"
+`eth_state` | Get Ethernet connection status | string | "off"
+`screen` | Notifications screen | integer | 1
+`format` | String format for output | string | "%.1f"
+`settings` | User settings | function | empty function
+
+`iface` can be a string or an table of the form `{ "eth0", "eth1", ... }` containing a list of the devices to collect data on.
+
+If more than one device is included, `net_now.sent` and `net_now.received` will contain cumulative values over all given devices.
+Use `net_now.devices["eth0"]` to access `sent`, `received`, `state` or `carrier` per device.
+
+Possible alternative values for `units` are 1 (byte) or multiple of 1024: 1024^2 (MB), 1024^3 (GB), and so on.
+
+If `notify = "off"` is set, the widget won't display a notification when there's no carrier.
+
+`settings` can use the following `iface` related strings:
+
+- `net_now.carrier` ("0", "1");
+- `net_now.state` ("up", "down");
+- `net_now.sent` and `net_now.received` (numbers) will be the sum across all specified interfaces;
+- `net_now.devices["interface"]` contains the previous attributes for each detected interface.
+
+If `wifi_state = "on"` is set, `settings` can use the following extra strings attached to `net_now.devices["wireless interface"]`:
+- `wifi` (true, false) indicates if the interface is connected to a network;
+- `signal` (number) is the connection signal strength in dBm;
+
+If `eth_state = "on"` is set, `settings` can use the following extra string: `net_now.devices["ethernet interface"].ethernet`, which is a boolean indicating if an Ethernet connection's active.
+
+For compatibility reasons, if multiple devices are given, `net_now.carrier` and `net_now.state` correspond to the last interface in the `iface` table and should not be relied upon (deprecated).
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
+`get_devices` | Update the `iface` table | function
+
+## Notes
+
+### Setting `iface` manually
+
+If the widget [spawns a "no carrier" notification and you are sure to have an active network device](https://github.com/lcpz/lain/issues/102), then autodetection is probably not working. This may due to [your user privileges](https://github.com/lcpz/lain/issues/102#issuecomment-246470526). In this case you can set `iface` manually. You can see which device is **UP,LOWER_UP** with the following command:
+
+```shell
+ip link show
+```
+## Usage examples
+### Two widgets for upload/download rates from the same `iface`
+
+```lua
+local mynetdown = wibox.widget.textbox()
+local mynetup = lain.widget.net {
+    settings = function()
+        widget:set_markup(net_now.sent)
+        mynetdown:set_markup(net_now.received)
+    end
+}
+```
+### Wi-Fi/Ethernet connection and signal strength indicator
+```lua
+local wifi_icon = wibox.widget.imagebox()
+local eth_icon = wibox.widget.imagebox()
+local net = lain.widget.net {
+    notify = "off",
+    wifi_state = "on",
+    eth_state = "on",
+    settings = function()
+        local eth0 = net_now.devices.eth0
+        if eth0 then
+            if eth0.ethernet then
+                eth_icon:set_image(ethernet_icon_filename)
+            else
+                eth_icon:set_image()
+            end
+        end
+
+        local wlan0 = net_now.devices.wlan0
+        if wlan0 then
+            if wlan0.wifi then
+                local signal = wlan0.signal
+                if signal < -83 then
+                    wifi_icon:set_image(wifi_weak_filename)
+                elseif signal < -70 then
+                    wifi_icon:set_image(wifi_mid_filename)
+                elseif signal < -53 then
+                    wifi_icon:set_image(wifi_good_filename)
+                elseif signal >= -53 then
+                    wifi_icon:set_image(wifi_great_filename)
+                end
+            else
+                wifi_icon:set_image()
+            end
+        end
+    end
+}
+```
\ No newline at end of file
diff --git a/lain/wiki/pulse.md b/lain/wiki/pulse.md
new file mode 100644
index 0000000..7a05cca
--- /dev/null
+++ b/lain/wiki/pulse.md
@@ -0,0 +1,136 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows and controls PulseAudio volume.
+
+```lua
+local volume = lain.widget.pulse()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 5
+`devicetype` | PulseAudio device type | string ("sink", "source") | "sink"
+`cmd` | PulseAudio command | string or function | see [here](https://github.com/lcpz/lain/blob/master/widget/pulse.lua#L26)
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`cmd` is a terminal command to catch infos from current default device. You can redefine it, being sure that the ouput is something like this:
+
+```shell
+* index: 0
+    volume: front-left: 18340 /  28% / -33.18 dB,   front-right: 18340 /  28% / -33.18 dB
+    muted: no
+    device.string = "front:1"
+```
+
+If your devices change dynamically, you can define it as a function which returns a command string.
+
+If sed doesn't work, you can try with a grep variant:
+
+```lua
+cmd = "pacmd list-" .. pulse.devicetype .. "s | grep -e $(pactl info | grep -e 'ink' | cut -d' ' -f3) -e 'volume: front' -e 'muted'"
+```
+
+### `settings` variables
+
+`settings` can use the following variables:
+
+Variable | Meaning | Type | Values
+--- | --- | --- | ---
+`volume_now.device` | Device name | string | device name or "N/A"
+`volume_now.index` | Device index | string | >= "0"
+`volume_now.muted` | Device mute status | string | "yes", "no", "N/A"
+`volume_now.channel` | Device channels | table of string integers | `volume_now.channel[i]`, where `i >= 1`
+`volume_now.left` | Front left sink level or first source | string | "0"-"100"
+`volume_now.right` | Front right sink level or second source | string | "0"-"100"
+
+`volume_now.channel` is a table of your PulseAudio devices. Fetch a channel level like this: `volume_now.channel[i]`, where `i >= 1`.
+
+`volume_now.{left,right}` are pointers for `volume_now.{channel[1], channel[2]}` (stereo).
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
+
+## Buttons
+
+```lua
+volume.widget:buttons(awful.util.table.join(
+    awful.button({}, 1, function() -- left click
+        awful.spawn("pavucontrol")
+    end),
+    awful.button({}, 2, function() -- middle click
+        os.execute(string.format("pactl set-sink-volume %s 100%%", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 3, function() -- right click
+        os.execute(string.format("pactl set-sink-mute %s toggle", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 4, function() -- scroll up
+        os.execute(string.format("pactl set-sink-volume %s +1%%", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 5, function() -- scroll down
+        os.execute(string.format("pactl set-sink-volume %s -1%%", volume.device))
+        volume.update()
+    end)
+))
+```
+
+## Keybindings
+
+```lua
+-- PulseAudio volume control
+awful.key({ altkey }, "Up",
+    function ()
+        os.execute(string.format("pactl set-sink-volume %s +1%%", volume.device))
+        volume.update()
+    end),
+awful.key({ altkey }, "Down",
+    function ()
+        os.execute(string.format("pactl set-sink-volume %s -1%%", volume.device))
+        volume.update()
+    end),
+awful.key({ altkey }, "m",
+    function ()
+        os.execute(string.format("pactl set-sink-mute %s toggle", volume.device))
+        volume.update()
+    end),
+awful.key({ altkey, "Control" }, "m",
+    function ()
+        os.execute(string.format("pactl set-sink-volume %s 100%%", volume.device))
+        volume.update()
+    end),
+awful.key({ altkey, "Control" }, "0",
+    function ()
+        os.execute(string.format("pactl set-sink-volume %s 0%%", volume.device))
+        volume.update()
+    end),
+```
+
+where `altkey = "Mod1"`.
+
+## Example
+
+```lua
+-- PulseAudio volume (based on multicolor theme)
+local volume = lain.widget.pulse {
+    settings = function()
+        vlevel = volume_now.left .. "-" .. volume_now.right .. "% | " .. volume_now.device
+        if volume_now.muted == "yes" then
+            vlevel = vlevel .. " M"
+        end
+        widget:set_markup(lain.util.markup("#7493d2", vlevel))
+    end
+}
+```
diff --git a/lain/wiki/pulsebar.md b/lain/wiki/pulsebar.md
new file mode 100644
index 0000000..de3a475
--- /dev/null
+++ b/lain/wiki/pulsebar.md
@@ -0,0 +1,98 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows PulseAudio volume with a progressbar; provides tooltips and notifications.
+
+```lua
+local volume = lain.widget.pulsebar()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 5
+`settings` | User settings | function | empty function
+`width` | Bar width | number | 63
+`height` | Bar height | number | 1
+`margins` | Bar margins | number | 1
+`paddings` | Bar paddings | number | 1
+`ticks` | Set bar ticks on | boolean | false
+`ticks_size` | Ticks size | number | 7
+`tick` | String for a notification tick | string | "|"
+`tick_pre` | String for the left notification delimeter | string | "["
+`tick_post` | String for the right notification delimeter | string | "]"
+`tick_none` | String for an empty notification tick | string | " "
+`scallback` | [PulseAudio sink callback](https://github.com/lcpz/lain/wiki/pulseaudio/) | function | `nil`
+`sink` | Mixer sink | number | 0
+`colors` | Bar colors | table | see [Default colors](https://github.com/lcpz/lain/wiki/pulsebar#default-colors)
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/pulsebar#default-notification_preset)
+`followtag` | Display the notification on currently focused screen | boolean | false
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/pulsebar#default-notification_preset)
+`devicetype` | PulseAudio device type | string ("sink", "source") | "sink"
+`cmd` | PulseAudio command | string or function | see [here](https://github.com/lcpz/lain/blob/master/widget/pulsebar.lua#L48)
+
+Read [pulse](https://github.com/lcpz/lain/wiki/pulse) page for `cmd` settings.
+
+`settings` can use [these variables](https://github.com/lcpz/lain/wiki/pulse#settings-variables).
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+### Default colors
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`background` | Bar backgrund color | string | "#000000"
+`mute` | Bar mute color | string | "#EB8F8F"
+`unmute` | Bar unmute color | string | "#A4CE8A"
+
+### Default `notification_preset`
+
+```lua
+notification_preset = {
+    font = "Monospace 10"
+}
+```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`bar` | The widget | `wibox.widget.progressbar`
+`device` | PulseAudio device | string
+`notify` | The notification | function
+`update` | Update state | function
+`tooltip` | The tooltip | `awful.tooltip`
+
+## Buttons
+
+```lua
+volume.bar:buttons(awful.util.table.join(
+    awful.button({}, 1, function() -- left click
+        awful.spawn("pavucontrol")
+    end),
+    awful.button({}, 2, function() -- middle click
+        os.execute(string.format("pactl set-sink-volume %d 100%%", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 3, function() -- right click
+        os.execute(string.format("pactl set-sink-mute %d toggle", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 4, function() -- scroll up
+        os.execute(string.format("pactl set-sink-volume %d +1%%", volume.device))
+        volume.update()
+    end),
+    awful.button({}, 5, function() -- scroll down
+        os.execute(string.format("pactl set-sink-volume %d -1%%", volume.device))
+        volume.update()
+    end)
+))
+```
+
+## Keybindings
+
+Same as [here](https://github.com/lcpz/lain/wiki/pulse#keybindings). If you want notifications, use `volume.notify()` instead of `volume.update()`.
diff --git a/lain/wiki/redshift.md b/lain/wiki/redshift.md
new file mode 100644
index 0000000..ea6f637
--- /dev/null
+++ b/lain/wiki/redshift.md
@@ -0,0 +1,103 @@
+### What is Redshift? #
+
+[**Project homepage**](http://jonls.dk/redshift/)
+
+>**Redshift** is an application that adjusts the computer display's color temperature based upon the Sun's apparent position in relation to the user's location on Earth.
+>
+>The program is free software, inspired by the proprietary f.lux, and can be used to reduce eye strain as well as insomnia and delayed sleep phase syndrome.
+>
+>The computer display's color temperature transitions evenly from night to daytime temperature to allow the user's eyes to slowly adapt. At night, the color temperature is low and is typically 3000–4000 K (default is 3500 K), preferably matching the room's lighting temperature. Typical color temperature during the daytime is 5500–6500 K (default is 5500 K).
+
+**Source:** [Wikipedia](https://en.wikipedia.org/wiki/Redshift_%28software%29)
+
+### Preparations
+
+**Redshift must be installed** on your system if you want to use this widget.
+
+Packages should be available for most distributions. Source code and build instructions can be found on Github [here](https://github.com/jonls/redshift).
+
+You also need a valid config file. Please see the [project homepage](http://jonls.dk/redshift/) for details. An example: [`~/.config/redshift.conf`](https://github.com/jonls/redshift/blob/master/redshift.conf.sample).
+
+You have to match the location settings to your personal situation: you can adjust the `lat` and `lon` variables using a [web service](https://encrypted.google.com/search?q=get+latitude+and+longitude).
+
+You might also want to modify the color temperatures to fit your preferences.
+
+### Using the widget
+
+This widget provides the following functions:
+
+| function | meaning |
+| --- | --- |
+| `redshift.toggle()` | Toggles Redshift adjustments on or off, and also restarts it if terminates. |
+| `redshift.attach(widget, update_function)` | Attach to a widget. Click on the widget to toggle redshift on or off. `update_function` is a callback function which will be triggered each time Redshift changes its status. (See the examples below.) |
+
+### Usage examples
+
+#### Textbox status widget
+
+```lua
+myredshift = wibox.widget.textbox()
+lain.widget.contrib.redshift.attach(
+    myredshift,
+    function (active)
+        if active then
+            myredshift:set_text("RS on")
+        else
+            myredshift:set_text("RS off")
+        end
+    end
+)
+```
+
+Then add `myredshift` to your wibox.
+
+#### Checkbox status widget
+
+```lua
+local markup = lain.util.markup
+
+local myredshift = wibox.widget{
+    checked      = false,
+    check_color  = "#EB8F8F",
+    border_color = "#EB8F8F",
+    border_width = 1,
+    shape        = gears.shape.square,
+    widget       = wibox.widget.checkbox
+}
+
+local myredshift_text = wibox.widget{
+    align  = "center",
+    widget = wibox.widget.textbox,
+}
+
+local myredshift_stack = wibox.widget{
+    myredshift,
+    myredshift_text,
+    layout = wibox.layout.stack
+}
+
+lain.widget.contrib.redshift.attach(
+    myredshift,
+    function (active)
+        if active then
+            -- rename 'beautiful' to 'theme' if using awesome-copycats
+            myredshift_text:set_markup(markup(beautiful.bg_normal, "<b>R</b>"))
+        else
+            -- rename 'beautiful' to 'theme' if using awesome-copycats
+            myredshift_text:set_markup(markup(beautiful.fg_normal, "R"))
+        end
+        myredshift.checked = active
+    end
+)
+```
+
+Then add `myredshift_stack` to your wibox.
+
+#### Keybinding
+
+Add this to the keybindings in your `rc.lua`:
+
+```lua
+-- Toggle Redshift with Mod+Shift+t
+awful.key({ modkey, "Shift" }, "t", function () lain.widget.contrib.redshift.toggle() end),
+```
diff --git a/lain/wiki/sysload.md b/lain/wiki/sysload.md
new file mode 100644
index 0000000..5ed4c97
--- /dev/null
+++ b/lain/wiki/sysload.md
@@ -0,0 +1,28 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows the current system load.
+
+```lua
+mysysload = lain.widget.sysload()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 2
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`settings` can use strings `load_1`, `load_5` and `load_15`, which are the load averages over 1, 5, and 15 minutes.
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
\ No newline at end of file
diff --git a/lain/wiki/task.md b/lain/wiki/task.md
new file mode 100644
index 0000000..af53a6a
--- /dev/null
+++ b/lain/wiki/task.md
@@ -0,0 +1,51 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Attaches a [taskwarrior](http://taskwarrior.org) notifications to a widget, and lets you execute `task` commands from the promptbox.
+
+```lua
+lain.widget.contrib.task.attach(widget, args)
+```
+
+`args` is an optional table which can contain:
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`show_cmd` | Taskwarrior command to show in the popup | string | "task next"
+`prompt_text` | Prompt text | string | "Enter task command: "
+`followtag` | Display the notification on currently focused screen | boolean | false
+`notification_preset` | Notification preset | table | See [default `notification_preset`](https://github.com/lcpz/lain/wiki/task#default-notification_preset)
+
+The tasks are shown in a notification popup when the mouse is moved over the attached `widget`, and the popup is hidden when the mouse is moved away. By default, the notification will show the output of `task next`. With `show_cmd`, the `task` popup command can be customized, for example if you want to [filter the tasks](https://taskwarrior.org/docs/filter.html) or show a [custom report](https://github.com/lcpz/lain/pull/213).
+
+With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+You can call the notification with a keybinding like this:
+
+```lua
+awful.key({ modkey, altkey }, "t", function () lain.widget.contrib.task.show(scr) end),
+```
+
+where ``altkey = "Mod1"`` and `scr` (optional) indicates the screen which you want the notification in.
+
+And you can prompt to input a `task` command with a keybinding like this:
+
+```lua
+awful.key({ altkey }, "t", lain.widget.contrib.task.prompt),
+```
+
+### Default `notification_preset`
+
+```lua
+notification_preset = {
+    font = "Monospace 10",
+    icon = helpers.icons_dir .. "/taskwarrior.png"
+}
+```
+
+## Note
+
+* If your widget does not display `task next` output, try changing Taskwarrior verbose, for instance: `show_cmd = 'task rc.verbose:label'` or `show_cmd = 'task rc.verbose:nothing'`.
\ No newline at end of file
diff --git a/lain/wiki/temp.md b/lain/wiki/temp.md
new file mode 100644
index 0000000..a4f8161
--- /dev/null
+++ b/lain/wiki/temp.md
@@ -0,0 +1,37 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Shows the current CPU temperature.
+
+```lua
+local mytemp = lain.widget.temp()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`timeout` | Refresh timeout (in seconds) | integer | 30
+`tempfile` | Path of file which stores core temperature value | string | "/sys/devices/virtual/thermal/thermal_zone0/temp"
+`settings` | User settings | function | empty function
+`format` | String format for output | string | "%.1f"
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+`settings` can use the string `coretemp_now`, which contains the info retrieved from `tempfile`, and the table `temp_now`, which contains an entry for each `*temp*` file in each directory in the following paths:
+
+```shell
+/sys/class/devices/virtual/thermal/thermal_zone*
+/sys/class/devices/platform/coretemp*/hwmon/hwon*
+```
+
+All values are expressed in Celsius (GNU/Linux standard).
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`update` | Update `widget` | function
diff --git a/lain/wiki/tp_smapi.md b/lain/wiki/tp_smapi.md
new file mode 100644
index 0000000..3fa8adf
--- /dev/null
+++ b/lain/wiki/tp_smapi.md
@@ -0,0 +1,104 @@
+# Description
+
+[`tp_smapi`](http://www.thinkwiki.org/wiki/Tp_smapi) interface and widget creator.
+
+```lua
+local tp_smapi = lain.widget.contrib.tp_smapi(apipath)
+```
+
+The argument `apipath` is an optional string which defines the API path. Its default value is `"/sys/devices/platform/smapi"`.
+
+# Functions
+
+## tp_smapi.get(batid, feature)
+
+Gets the `feature` of battery `batid`. Returns a string. The list of available features is available at [this page](https://www.thinkwiki.org/wiki/Tp_smapi#Battery_status_features).
+
+## tp_smapi.installed(batid)
+
+Checks if battery `batid` is installed. Returns a boolean.
+
+## tp_smapi.status(batid)
+
+Gets the status of battery `batid`. Returns a string ("charging", "discharging", or "full").
+
+## tp_smapi.percentage(batid)
+
+Gets the percentage of battery `batid`. Returns a numeric string.
+
+## tp_smapi.time(batid)
+
+Gets the time of battery `batid`. Depending on the current status, it can be either running or charging time. Returns a string of the format `HH:MM`.
+
+## tp_smapi.hide()
+
+Removes any notification spawned by `tp_smapi.show`.
+
+## tp_smapi.show(batid, seconds, scr)
+
+Notifies the current information of battery `batid` for `seconds` seconds on screen `scr`.
+The argument `scr` is optional, and if missing, the notification will be displayed on the currently focused screen.
+
+## tp_smapi.create_widget(args)
+
+Creates a [lain widget](https://github.com/lcpz/lain/wiki/Widgets#usage) of the available ThinkPad batteries.
+
+```lua
+local tpbat = tp_smapi.create_widget()
+```
+
+### Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`widget` | The widget type to use | [`wibox.widget`](https://awesomewm.org/doc/api/classes/wibox.widget.html) | [`wibox.widget.textbox`](https://awesomewm.org/doc/api/classes/wibox.widget.textbox.html)
+`timeout` | Refresh timeout (in seconds) | integer | 30
+`pspath` | Power supply directory path | string | "/sys/class/power_supply/"
+`battery` | Single battery id | string | autodetected
+`batteries` | Multiple batteries id table | table of strings | autodetected
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+The widget will try to autodetect `battery` and `batteries`. If something
+goes wrong, you will have to define them manually. In that case, you only have
+to define one between `battery` and `batteries`. If you have one battery, you
+can either use `args.battery = "BAT*"` or `args.batteries = {"BAT*"}`, where `BAT*`
+is the identifier of your battery in `pspath` (do not use it as a wildcard).
+Of course, if you have multiple batteries, you need to use the latter option.
+
+If you define `pspath`, **be sure** to not forget the final slash (/).
+
+`settings` can use the `tpbat_now` table, which contains the following strings:
+
+- `status`, general status ("N/A", "discharging", "charging", "full");
+- `n_status[i]`, i-th battery status (like above);
+- `n_perc[i]`, i-th battery charge percentage (like above);
+- `n_time[i]`, i-th battery running or charging time (HH:MM string or "N/A");
+
+`n_time[i]` is the running time of battery `i` when it is discharging, and the charging time otherwise.
+
+### Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | [`wibox.widget`](https://awesomewm.org/doc/api/classes/wibox.widget.html) | [textbox](https://awesomewm.org/doc/api/classes/wibox.widget.textbox.html)
+`batteries` | Battery identifiers | Table of strings
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+### Usage example
+
+```lua
+local tp_smapi = lain.widget.contrib.tp_smapi()
+local bat = tp_smapi.create_widget {
+  battery  = "BAT0",
+  settings = function()
+    widget:set_markup(tpbat_now.n_perc[1] .. "%")
+  end
+}
+
+bat.widget:connect_signal("mouse::enter", function () tp_smapi.show("BAT0") end)
+bat.widget:connect_signal("mouse::leave", function () tp_smapi.hide() end)
+```
diff --git a/lain/wiki/watch.md b/lain/wiki/watch.md
new file mode 100644
index 0000000..ff18a5c
--- /dev/null
+++ b/lain/wiki/watch.md
@@ -0,0 +1,222 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Template for asynchronous watcher widgets.
+
+Executes an input command and makes the user feed a `wibox.widget` with the output.
+
+```lua
+local mywatch = lain.widget.watch()
+```
+
+This has been implemented in Awesome 4.0 as [`awful.widget.watch`](https://awesomewm.org/doc/api/classes/awful.widget.watch.html). But while Awesome `watch` returns only the widget, Lain one returns a table including its timer and internal update function too.
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`widget` | Widget to feed | `wibox.widget` | `wibox.widget.textbox`
+`timeout` | Refresh timeout seconds | number | 5
+`cmd` | The command to execute | string **or** table | `nil`
+`nostart` | Widget timer doesn't start immediately | boolean | false
+`stoppable` | Widget timer is stoppable | boolean | false
+`settings` | User settings | function | see [Default `settings` function](https://github.com/lcpz/lain/wiki/watch#default-settings-function)
+
+If your command needs a shell, you need to set `cmd` as an array of 3 strings, where the first contains the shell, the second contains `-c`, and the third contains the actual command. Example:
+
+```lua
+cmd = { awful.util.shell, "-c", "myactualcommand" }
+```
+
+`settings` can use the string `output`, which is the output of `cmd`.
+
+### Default `settings` function
+
+```lua
+settings = function() widget:set_text(output) end
+```
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | input widget type or `wibox.widget.textbox`
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html) or `nil`
+
+The `update` function can be used to refresh the widget before `timeout` expires.
+
+If `stoppable == true`, the widget will have an ad-hoc timer, which you can control though `timer` variable.
+
+## Use case examples
+
+### bitcoin
+
+```lua
+-- Bitcoin to USD current price, using Coinbase V1 API
+local bitcoin = lain.widget.watch({
+    timeout = 43200, -- half day
+    stoppable = true,
+    cmd = "curl -m5 -s 'https://coinbase.com/api/v1/prices/buy'",
+    settings = function()
+        local btc, pos, err = require("lain.util").dkjson.decode(output, 1, nil)
+        local btc_price = (not err and btc and btc["subtotal"]["amount"]) or "N/A"
+
+        -- customize here
+        widget:set_text(btc_price)
+    end
+})
+```
+
+### btrfs
+
+```lua
+-- btrfs root df
+local myrootfs = lain.widget.watch({
+    timeout = 600,
+    cmd = "btrfs filesystem df -g /",
+    settings  = function()
+        local total, used  = string.match(output, "Data.-total=(%d+%.%d+)GiB.-used=(%d+%.%d+)GiB")
+        local percent_used = math.ceil((tonumber(used) / tonumber(total)) * 100)
+
+        -- customize here
+        widget:set_text(" [/: " .. percent_used .. "%] ")
+    end
+})
+```
+
+### cmus
+
+```lua
+-- cmus audio player
+local cmus = lain.widget.watch({
+    timeout = 2,
+    stoppable = true,
+    cmd = "cmus-remote -Q",
+    settings = function()
+        local cmus_now = {
+            state   = "N/A",
+            artist  = "N/A",
+            title   = "N/A",
+            album   = "N/A"
+        }
+
+        for w in string.gmatch(output, "(.-)tag") do
+            a, b = w:match("(%w+) (.-)\n")
+            cmus_now[a] = b
+        end
+
+        -- customize here
+        widget:set_text(cmus_now.artist .. " - " .. cmus_now.title)
+    end
+})
+```
+
+### maildir
+
+```lua
+-- checks whether there are files in the "new" directories of a mail dirtree
+local mailpath = "~/Mail"
+local mymaildir = lain.widget.watch({
+    timeout = 60,
+    stoppable = true,
+    cmd = { awful.util.shell, "-c", string.format("ls -1dr %s/*/new/*", mailpath) },
+    settings = function()
+        local inbox_now = { digest = "" }
+
+        for dir in output:gmatch(".-/(%w+)/new") do
+            inbox_now[dir] = 1
+            for _ in output:gmatch(dir) do
+                inbox_now[dir] = inbox_now[dir] + 1
+            end
+            if #inbox_now.digest > 0 then inbox_now.digest = inbox_now.digest .. ", " end
+            inbox_now.digest = inbox_now.digest .. string.format("%s (%d)", dir, inbox_now[dir])
+        end
+
+        -- customize here
+        widget:set_text("mail: " .. inbox_now.digest)
+    end
+})
+```
+
+### mpris
+
+```lua
+-- infos from mpris clients such as spotify and VLC
+-- based on https://github.com/acrisci/playerctl
+local mpris = lain.widget.watch({
+    cmd = "playerctl status && playerctl metadata",
+    timeout = 2,
+    stoppable = true,
+    settings = function()
+         local escape_f  = require("awful.util").escape
+         local mpris_now = {
+             state        = "N/A",
+             artist       = "N/A",
+             title        = "N/A",
+             art_url      = "N/A",
+             album        = "N/A",
+             album_artist = "N/A"
+         }
+
+         mpris_now.state = string.match(output, "Playing") or
+                           string.match(output, "Paused")  or "N/A"
+
+         for k, v in string.gmatch(output, "'[^:]+:([^']+)':[%s]<%[?'([^']+)'%]?>")
+         do
+             if     k == "artUrl"      then mpris_now.art_url      = v
+             elseif k == "artist"      then mpris_now.artist       = escape_f(v)
+             elseif k == "title"       then mpris_now.title        = escape_f(v)
+             elseif k == "album"       then mpris_now.album        = escape_f(v)
+             elseif k == "albumArtist" then mpris_now.album_artist = escape_f(v)
+             end
+         end
+
+        -- customize here
+        widget:set_text(mpris_now.artist .. " - " .. mpris_now.title)
+    end
+})
+```
+
+### upower
+
+```lua
+-- battery infos from freedesktop upower
+local mybattery = lain.widget.watch({
+    timeout = 30,
+    cmd = { awful.util.shell, "-c", "upower -i /org/freedesktop/UPower/devices/battery_BAT | sed -n '/present/,/icon-name/p'" },
+    settings = function()
+        local bat_now = {
+            present      = "N/A",
+            state        = "N/A",
+            warninglevel = "N/A",
+            energy       = "N/A",
+            energyfull   = "N/A",
+            energyrate   = "N/A",
+            voltage      = "N/A",
+            percentage   = "N/A",
+            capacity     = "N/A",
+            icon         = "N/A"
+        }
+
+        for k, v in string.gmatch(output, '([%a]+[%a|-]+):%s*([%a|%d]+[,|%a|%d]-)') do
+            if     k == "present"       then bat_now.present      = v
+            elseif k == "state"         then bat_now.state        = v
+            elseif k == "warning-level" then bat_now.warninglevel = v
+            elseif k == "energy"        then bat_now.energy       = string.gsub(v, ",", ".") -- Wh
+            elseif k == "energy-full"   then bat_now.energyfull   = string.gsub(v, ",", ".") -- Wh
+            elseif k == "energy-rate"   then bat_now.energyrate   = string.gsub(v, ",", ".") -- W
+            elseif k == "voltage"       then bat_now.voltage      = string.gsub(v, ",", ".") -- V
+            elseif k == "percentage"    then bat_now.percentage   = tonumber(v)              -- %
+            elseif k == "capacity"      then bat_now.capacity     = string.gsub(v, ",", ".") -- %
+            elseif k == "icon-name"     then bat_now.icon         = v
+            end
+        end
+
+        -- customize here
+        widget:set_text("Bat: " .. bat_now.percentage .. " " .. bat_now.state)
+    end
+})
+```
diff --git a/lain/wiki/weather.md b/lain/wiki/weather.md
new file mode 100644
index 0000000..6052156
--- /dev/null
+++ b/lain/wiki/weather.md
@@ -0,0 +1,133 @@
+## Usage
+
+[Read here.](https://github.com/lcpz/lain/wiki/Widgets#usage)
+
+### Description
+
+Provides current weather status widgets and X-days forecast pop-up notifications.
+
+Powered by OpenWeatherMap. Obtain a free API key [here](http://openweathermap.org/api) and set it as the `APPID` argument.
+
+By default, it uses [current](http://openweathermap.org/current) for current weather data and [forecast16](http://openweathermap.org/forecast16) for forecasts.
+
+```lua
+local myweather = lain.widget.weather()
+```
+
+## Input table
+
+Variable | Meaning | Type | Default
+--- | --- | --- | ---
+`APPID` | API key | String | `nil`
+`timeout` | Refresh timeout seconds for current weather status | number | 900 (15 min)
+`current_call` | Command to fetch weather status data from the API | string | see `default_current_call`
+`forecast_call` | Command to fetch forecast data from the API | string | see `default_forecast_call`
+`city_id` | API city code | number | not set
+`units` | Temperature units system | string | "metric"
+`lang` | API data localization | string | "en"
+`cnt` | Forecast days interval | integer | 5
+`icons_path` | Icons path | string | `lain/icons/openweathermap`
+`notification_preset` | Preset for notifications | table | empty table
+`notification_text_fun` | Function to format forecast notifications | function | see `notification_text_fun` below
+`weather_na_markup` | Markup to be used when weather textbox is not available | text | " N/A "
+`followtag` | Display the notification on currently focused screen | boolean | false
+`showpopup` | Display popups with mouse hovering | string, possible values: "on", "off" | "on"
+`settings` | User settings | function | empty function
+`widget` | Widget to render | function | `wibox.widget.textbox`
+
+- ``default_current_call``
+
+    `"curl -s 'http://api.openweathermap.org/data/2.5/weather?id=%s&units=%s&lang=%s&APPID=%s'"`
+
+    You can rewrite it using any fetcher solution you like, or you can modify it in order to fetch data by city name, instead of ID: just replace `id` with `q`:
+
+    `"curl -s 'http://api.openweathermap.org/data/2.5/weather?q=%s&units=%s&lang=%s&APPID=%s'"`
+
+    and set `city_id` with your city name, for instance `city_id = "London,UK"`.
+
+- ``default_forecast_call``
+
+    `"curl -s 'http://api.openweathermap.org/data/2.5/forecast/daily?id=%s&units=%s&lang=%s&APPID=%s'"`
+
+    Like above.
+
+- ``city_id``
+
+    An integer that defines the OpenWeatherMap ID code of your city.
+    To obtain it go to [OpenWeatherMap](http://openweathermap.org/) and query for your city in the top search bar. The link will look like this:
+
+        http://openweathermap.org/city/2643743
+
+    your `city_id` is the number at the end.
+
+- ``units``
+
+    - For temperature in Fahrenheit use `units = "imperial"`
+    - For temperature in Celsius use `units = "metric"` (Lain default)
+    - For temperature in Kelvin use `units = "standard"` (OpenWeatherMap default)
+
+- ``lang``
+
+    See *Multilingual Support* section [here](http://openweathermap.org/current).
+
+- ``icons_path``
+
+    You can set your own icons path if you don't wish to use `lain/icons/openweathermap`. Just be sure that your icons are PNGs and named exactly like [OpenWeatherMap ones](http://openweathermap.org/weather-conditions).
+
+- ``notification_preset``
+
+   Notifications preset table. See [here](https://awesomewm.org/doc/api/libraries/naughty.html#notify) for the details.
+
+- ``notification_text_fun``
+   ```lua
+   function (wn)
+       local day = os.date("%a %d", wn["dt"])
+       local temp = math.floor(wn["main"]["temp"])
+       local desc = wn["weather"][1]["description"]
+
+       return string.format("<b>%s</b>: %s, %d ", day, desc, temp)
+   end
+   ```
+
+- ``followtag``
+
+   With multiple screens, the default behaviour is to show a visual notification pop-up window on the first screen. By setting `followtag` to `true` it will be shown on the currently focused tag screen.
+
+- ``settings``
+
+    In your `settings` function, you can use `widget` variable to refer to the textbox, and the dictionary `weather_now` to refer to data retrieved by `current_call`. The dictionary is built with [dkjson library](http://dkolf.de/src/dkjson-lua.fsl/home), and its structure is defined [here](http://openweathermap.org/weather-data).
+    For instance, you can retrieve current weather status and temperature in this way:
+    ```lua
+    descr = weather_now["weather"][1]["description"]:lower()
+    units = math.floor(weather_now["main"]["temp"])
+    ```
+
+## Output table
+
+Variable | Meaning | Type
+--- | --- | ---
+`widget` | The widget | `wibox.widget.textbox`
+`icon` | The icon | `wibox.widget.imagebox`
+`update` | Update `widget` | function
+`timer` | The widget timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+`timer_forecast` | The forecast notification timer | [`gears.timer`](https://awesomewm.org/doc/api/classes/gears.timer.html)
+
+## Functions
+
+You can attach the forecast notification to any widget like this:
+
+```lua
+myweather.attach(obj)
+```
+
+Hovering over ``obj`` will display the notification.
+
+## Key bindings
+
+You can create a key binding for the weather pop-up like this:
+
+```lua
+awful.key( { "Mod1" }, "w", function () myweather.show(5) end )
+```
+
+Where the ``show`` argument is an integer defining timeout seconds.
diff --git a/rc.lua b/rc.lua
old mode 100755
new mode 100644
index 898b85e..7846928
--- a/rc.lua
+++ b/rc.lua
@@ -1,52 +1,1298 @@
+-- See original rc.lua:
+-- https://awesomewm.org/doc/api/sample%20files/rc.lua.html
+-- or in:
+-- /etc/xdg/awesome/rc.lua
+
+-- {{{ Required libraries
+
+-- If LuaRocks is installed, make sure that packages installed through it are
+-- found (e.g. lgi). If LuaRocks is not installed, do nothing.
 pcall(require, "luarocks.loader")
 
-local awful = require("awful")
-local beautiful = require("beautiful")
-local gears = require("gears")
+local gears         = require("gears")
+local awful         = require("awful")
+                      require("awful.autofocus")
+local wibox         = require("wibox")
+local beautiful     = require("beautiful")
+local naughty       = require("naughty")
+local lain          = require("lain")
+--local menubar       = require("menubar")
+local freedesktop   = require("freedesktop")
+local hotkeys_popup = require("awful.hotkeys_popup")
+                      require("awful.hotkeys_popup.keys")
+local mytable       = awful.util.table or gears.table -- 4.{0,1} compatibility
+
+-- }}}
+
+-- {{{ Error handling
+
+-- Check if awesome encountered an error during startup and fell back to
+-- another config (This code will only ever execute for the fallback config)
+if awesome.startup_errors then
+    naughty.notify {
+        preset = naughty.config.presets.critical,
+        title = "Oops, there were errors during startup!",
+        text = awesome.startup_errors
+    }
+end
+
+-- Handle runtime errors after startup
+do
+    local in_error = false
+
+    awesome.connect_signal("debug::error", function (err)
+        if in_error then return end
+
+        in_error = true
+
+        naughty.notify {
+            preset = naughty.config.presets.critical,
+            title = "Oops, an error happened!",
+            text = tostring(err)
+        }
+
+        in_error = false
+    end)
+end
+
+-- }}}
+
+-- {{{ Autostart windowless processes
+
+-- This function will run once every time Awesome is started
+local function run_once(cmd_arr)
+    for _, cmd in ipairs(cmd_arr) do
+        awful.spawn.with_shell(string.format("pgrep -u $USER -fx '%s' > /dev/null || (%s)", cmd, cmd))
+    end
+end
+
+--run_once({ "urxvtd", "unclutter -root" }) -- comma-separated entries
+run_once({ "picom", "--animations" })
+
+-- This function implements the XDG autostart specification
+--[[
+awful.spawn.with_shell(
+    'if (xrdb -query | grep -q "^awesome\\.started:\\s*true$"); then exit; fi;' ..
+    'xrdb -merge <<< "awesome.started:true";' ..
+    -- list each of your autostart commands, followed by ; inside single quotes, followed by ..
+    'dex --environment Awesome --autostart --search-paths ' ..
+    '"${XDG_CONFIG_HOME:-$HOME/.config}/autostart:${XDG_CONFIG_DIRS:-/etc/xdg}/autostart";' -- https://github.com/jceb/dex
+)
+--]]
+
+-- }}}
+
+-- {{{ Variable definitions
+
+local themes = {
+    "blackburn",       -- 1
+    "copland",         -- 2
+    "dremora",         -- 3
+    "holo",            -- 4
+    "multicolor",      -- 5
+    "powerarrow",      -- 6
+    "powerarrow-dark", -- 7
+    "rainbow",         -- 8
+    "steamburn",       -- 9
+    "vertex"           -- 10
+}
+
+local chosen_theme = themes[5]
+local modkey       = "Mod4"
+local altkey       = "Mod1"
+local ctrlkey     = "Control"
+--local terminal     = "urxvtc"
+
+local vi_focus     = false -- vi-like client focus https://github.com/lcpz/awesome-copycats/issues/275
+local cycle_prev   = true  -- cycle with only the previously focused client or all https://github.com/lcpz/awesome-copycats/issues/274
+local editor       = os.getenv("EDITOR") or "nvim"
+--local browser      = "librewolf"
+local browser      = "firefox"
+
+local terminal    = "wezterm"
+local secterminal    = "alacritty"
+--local filex    = "ranger"
+local filex    = "yazi"
+
+awful.util.terminal = terminal
+awful.util.tagnames = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
+awful.layout.layouts = {
+    awful.layout.suit.spiral,
+    awful.layout.suit.floating,
+    awful.layout.suit.tile,
+    awful.layout.suit.tile.left,
+    awful.layout.suit.tile.bottom,
+    awful.layout.suit.tile.top,
+    --awful.layout.suit.fair,
+    --awful.layout.suit.fair.horizontal,
+    --awful.layout.suit.spiral.dwindle,
+    --awful.layout.suit.max,
+    --awful.layout.suit.max.fullscreen,
+    --awful.layout.suit.magnifier,
+    --awful.layout.suit.corner.nw,
+    --awful.layout.suit.corner.ne,
+    --awful.layout.suit.corner.sw,
+    --awful.layout.suit.corner.se,
+    --lain.layout.cascade,
+    --lain.layout.cascade.tile,
+    --lain.layout.centerwork,
+    --lain.layout.centerwork.horizontal,
+    --lain.layout.termfair,
+    --lain.layout.termfair.center
+}
+
+lain.layout.termfair.nmaster           = 3
+lain.layout.termfair.ncol              = 1
+lain.layout.termfair.center.nmaster    = 3
+lain.layout.termfair.center.ncol       = 1
+lain.layout.cascade.tile.offset_x      = 2
+lain.layout.cascade.tile.offset_y      = 32
+lain.layout.cascade.tile.extra_padding = 5
+lain.layout.cascade.tile.nmaster       = 5
+lain.layout.cascade.tile.ncol          = 2
+
+-- https://awesomewm.org/doc/api/classes/client.html
+awful.util.taglist_buttons = mytable.join(
+    awful.button({ }, 1, function(t) t:view_only() end),
+    awful.button({ modkey }, 1, function(t)
+        if client.focus then client.focus:move_to_tag(t) end
+    end),
+    awful.button({ }, 3, awful.tag.viewtoggle),
+    awful.button({ modkey }, 3, function(t)
+        if client.focus then client.focus:toggle_tag(t) end
+    end),
+    awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
+    awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
+)
+
+awful.util.tasklist_buttons = mytable.join(
+     awful.button({ }, 1, function(c)
+         if c == client.focus then
+             c.minimized = true
+         else
+             c:emit_signal("request::activate", "tasklist", { raise = true })
+         end
+     end),
+     awful.button({ }, 3, function()
+         awful.menu.client_list({ theme = { width = 250 } })
+     end),
+     awful.button({ }, 4, function() awful.client.focus.byidx(1) end),
+     awful.button({ }, 5, function() awful.client.focus.byidx(-1) end)
+)
+
+beautiful.init(string.format("%s/.config/awesome/themes/%s/theme.lua", os.getenv("HOME"), chosen_theme))
+
+-- }}}
+
+-- {{{ Menu
+
+-- Create a launcher widget and a main menu
+local myawesomemenu = {
+   { "Hotkeys", function() hotkeys_popup.show_help(nil, awful.screen.focused()) end },
+   { "Manual", string.format("%s -e man awesome", terminal) },
+   { "Edit config", string.format("%s -e %s %s", terminal, editor, awesome.conffile) },
+   { "Restart", awesome.restart },
+   { "Quit", function() awesome.quit() end },
+}
+
+awful.util.mymainmenu = freedesktop.menu.build {
+    before = {
+        { "Awesome", myawesomemenu, beautiful.awesome_icon },
+        -- other triads can be put here
+    },
+    after = {
+        { "Open terminal", terminal },
+        -- other triads can be put here
+    }
+}
+
+-- Hide the menu when the mouse leaves it
+--[[
+awful.util.mymainmenu.wibox:connect_signal("mouse::leave", function()
+    if not awful.util.mymainmenu.active_child or
+       (awful.util.mymainmenu.wibox ~= mouse.current_wibox and
+       awful.util.mymainmenu.active_child.wibox ~= mouse.current_wibox) then
+        awful.util.mymainmenu:hide()
+    else
+        awful.util.mymainmenu.active_child.wibox:connect_signal("mouse::leave",
+        function()
+            if awful.util.mymainmenu.wibox ~= mouse.current_wibox then
+                awful.util.mymainmenu:hide()
+            end
+        end)
+    end
+end)
+--]]
+
+-- Set the Menubar terminal for applications that require it
+--menubar.utils.terminal = terminal
+
+-- }}}
+
+-- {{{ Screen
+
+-- Re-set wallpaper when a screen's geometry changes (e.g. different resolution)
+screen.connect_signal("property::geometry", function(s)
+    -- Wallpaper
+    if beautiful.wallpaper then
+        local wallpaper = beautiful.wallpaper
+        -- If wallpaper is a function, call it with the screen
+        if type(wallpaper) == "function" then
+            wallpaper = wallpaper(s)
+        end
+        gears.wallpaper.maximized(wallpaper, s, true)
+    end
+end)
+
+-- No borders when rearranging only 1 non-floating or maximized client
+screen.connect_signal("arrange", function (s)
+    local only_one = #s.tiled_clients == 1
+    for _, c in pairs(s.clients) do
+        if only_one and not c.floating or c.maximized or c.fullscreen then
+            c.border_width = 0
+        else
+            c.border_width = beautiful.border_width
+        end
+    end
+
+  -- Maximize firefox when it's the only client
+  for s in screen do
+    local clients = s.clients
+    local firefox_clients = {}
+
+    for _, c in ipairs(clients) do
+      if c.class == "firefox" then
+        table.insert(firefox_clients, c)
+      end
+    end
+
+    if #clients == 1 and #firefox_clients == 1 then
+      firefox_clients[1].maximized = true
+    else
+      for _, fc in ipairs(firefox_clients) do
+        fc.maximized = false
+      end
+    end
+  end
+
+end)
+
+-- Create a wibox for each screen and add it
+awful.screen.connect_for_each_screen(function(s) beautiful.at_screen_connect(s) end)
+
+check_toggle_widget_visibility()
+
+-- }}}
+
+-- {{{ Mouse bindings
+
+--root.buttons(mytable.join(
+--    awful.button({ }, 3, function () awful.util.mymainmenu:toggle() end),
+--    awful.button({ }, 4, awful.tag.viewnext),
+--    awful.button({ }, 5, awful.tag.viewprev)
+--))
+
+-- }}}
+
+-- {{{ Key bindings
+globalkeys = mytable.join(
+    -- {{{ Personal keybindings
+
+    -- Awesome keybindings
+    awful.key({ modkey,         }, "Return", function () awful.spawn.with_shell( "~/.local/bin/my_scripts/term_wd.sh ".. terminal) end,
+              {description = "Launch terminal wd", group = "awesome"}),
+    awful.key({ modkey, "Shift" }, "Return", function () awful.spawn( terminal ) end,
+              {description = "Launch terminal", group = "awesome"}),
+    awful.key({ modkey, ctrlkey }, "Return", function () awful.spawn.with_shell( "~/.local/bin/my_scripts/term_wd.sh " .. secterminal ) end,
+              {description = "Launch terminal", group = "awesome"}),
+
+    awful.key({ modkey, ctrlkey }, "r", awesome.restart,
+              {description = "Reload awesome", group = "awesome"}),
+
+    awful.key({ modkey, "Shift" }, "q",   awesome.quit,
+              {description = "Quit awesome", group = "awesome"}),
+
+    awful.key({ }, "F1",      hotkeys_popup.show_help,
+        {description = "Show help", group="awesome"}),
+
+    --awful.key({ modkey, "Shift" }, "w", function () awful.spawn( browser ) end,
+    --          {description = "Launch firefox", group = "awesome"}),
+    -- awful.key({ modkey, ctrlkey }, "w", function () awful.util.mymainmenu:show() end,
+    --     {description = "Show main menu", group = "awesome"}),
+    awful.key({ modkey, "Shift" }, "p", function ()
+            for s in screen do
+                s.mywibox.visible = not s.mywibox.visible
+                if s.mybottomwibox then
+                    s.mybottomwibox.visible = not s.mybottomwibox.visible
+                end
+            end
+        end,
+        {description = "Show/hide wibox (bar)", group = "awesome"}),
+
+    awful.key({ modkey, ctrlkey }, "p", function() toggle_widget_visibility() end,
+              { description = "toggle widgets visibility", group = "custom" }),
+
+    -- Run launcher
+    awful.key({ modkey },            "a",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/tmux_attach.sh "..terminal)  end,
+              {description = "run tmux", group = "launcher"}),
+
+    awful.key({ modkey },            "g",     function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/nvim_fzf.sh "..terminal)   end,
+              {description = "nvim_fzf", group = "launcher"}),
+
+    awful.key({ modkey },            "d",     function ()
+    awful.util.spawn("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi")   end,
+              {description = "run rofi", group = "launcher"}),
+
+    awful.key({ modkey },            "c",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/term_calc.sh "..terminal)   end,
+              {description = "calculator", group = "launcher"}),
+
+    awful.key({ modkey, "Shift" },            "c",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/code_helper.sh new "..terminal)   end,
+              {description = "code launcher", group = "launcher"}),
+
+    awful.key({ modkey, "Control" },            "c",     function ()
+    awful.util.spawn("GTK_THEME=Adwaita:dark gnome-calendar")   end,
+              {description = "calendar", group = "launcher"}),
+
+    awful.key({ modkey, "Shift" },            "d",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/code_helper.sh old " .. terminal)   end,
+              {description = "code launcher", group = "launcher"}),
+
+    awful.key({ modkey },            "r",     function ()
+    awful.util.spawn("dmenu_run -fn 'Linux Libertine Mono'")    end,
+              {description = "run dmenu", group = "launcher"}),
+
+    awful.key({ modkey },            "w",     function ()
+    awful.util.spawn(terminal.. " -e " .. filex .. " ~/")    end,
+              {description = "run ranger", group = "launcher"}),
+
+    awful.key({ modkey },            "e",        function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/file_explorer_wd.sh " .. terminal .. " " .. filex )   end,
+              {description = "run ranger in wd", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"     },            "e",        function ()
+    awful.util.spawn("sh /home/jonas/.local/bin/my_scripts/sysmenu_awsm.sh")  end,
+              {description = "Run sysmenu", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"     },            "s",        function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/win_screenshot_awsm.sh")    end,
+              {description = "Screenshot to cb", group = "launcher"}),
+
+    awful.key({ modkey, "Control"     },            "s",        function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/tesseract_ocr.sh")    end,
+              {description = "Screenshot ocr", group = "launcher"}),
+
+	-- Lock screen 
+    awful.key({ modkey, "Shift"    },            "x",     function ()
+    awful.spawn("i3lock")     end,
+              {description = "i3lock", group = "launcher"}),
+
+    awful.key({ modkey, "Control"     },            "x",        function ()
+    awful.spawn("i3lock -i /home/jonas/Downloads/lock-wallpaper.png")  end,
+              {description = "i3lock pic", group = "launcher"}),
+	-- Suspend 
+    awful.key({ modkey, "Shift"    },            "comma",     function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/suspend_awsm.sh")   end,
+              {description = "Suspend", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"    },            "period",     function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/suspend_awsm_lock.sh")    end,
+              {description = "Suspend", group = "launcher"}),
+
+	-- Nice things
+    awful.key({modkey},            "v",        function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/clip_history.sh greenclip")   end,
+              {description = "clip_history", group = "launcher"}),
+
+    awful.key({modkey},            "period",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/emojipick/emojipick")   end,
+              {description = "Emojipick", group = "launcher"}),
+
+	-- Program shortcuts
+    awful.key({modkey},            "b",     function ()
+    awful.util.spawn(terminal.. " -e sudo htop")    end,
+              {description = "Htop", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"    },            "b",     function ()
+    awful.util.spawn(terminal.. " -e sudo bashtop") end,
+              {description = "Bashtop", group = "launcher"}),
+
+    awful.key({ modkey, "Control"    },            "b",     function ()
+    awful.util.spawn(terminal .. " -e sudo ytop")    end,
+              {description = "Ytop", group = "launcher"}),
+
+    awful.key({ modkey },            "n",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/files_wd.sh")     end,
+              {description = "run file manager in wd", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"    },            "n",     function ()
+    awful.util.spawn("thunar")  end,
+              {description = "run thunar", group = "launcher"}),
+
+    awful.key({ modkey, "Control"    },            "n",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/open_notes.sh 1 "..terminal)    end,
+              {description = "Ytop", group = "launcher"}),
+
+    awful.key({modkey},            "m",     function ()
+    awful.util.spawn("nm-connection-editor")  end,
+              {description = "Network connections", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"    },            "m",     function ()
+    awful.util.spawn("spotify")      end,
+              {description = "Spotify", group = "launcher"}),
+
+    awful.key({ modkey, "Control"    },            "m",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/open_notes.sh 2 "..terminal)   end,
+              {description = "Ytop", group = "launcher"}),
+
+    awful.key({modkey},            "p",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/xrandr_helper.sh")  end,
+              {description = "Xrandr", group = "launcher"}),
+
+    awful.key({modkey},            "t",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/script_copy.sh")  end,
+              {description = "Script_copy", group = "launcher"}),
+
+    awful.key({ modkey, "Shift"    },           "t",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/script_helper.sh "..terminal)      end,
+              {description = "Script_helper", group = "launcher"}),
+
+    awful.key({modkey },            "section",     function ()
+    awful.util.spawn("sh /home/jonas/.local/bin/my_scripts/loadEww.sh")  end,
+              {description = "Load Eww", group = "launcher"}),
+
+    awful.key({modkey, "Shift" }, 'section', function() _G.dashboard_show() end,
+              {description = 'toggle dashboard', group = 'awesome'}),
+
+    awful.key({ "Shift" },            "F1",     function ()
+    awful.util.spawn("/home/jonas/.local/bin/my_scripts/show_keys.sh vim "..terminal)   end,
+              {description = "vim keybinds", group = "launcher"}),
+
+	-- Print
+    awful.key({ },  "Print",     function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/screenshot_select.sh")   end,
+              {description = "Screenshot", group = "launcher"}),
+
+    awful.key({ "Shift"  },  "Print",     function ()
+    awful.spawn("sh /home/jonas/.local/bin/my_scripts/screenshot.sh")  end,
+              {description = "Screenshot", group = "launcher"}),
+
+    awful.key({ "Control" },  "Print",     function ()
+    awful.spawn("/home/jonas/.local/bin/my_scripts/screenshot_ocr.sh")  end,
+              {description = "Screenshot", group = "launcher"}),
+
+    -- Tag browsing with modkey
+    awful.key({ modkey,         }, "Left",   awful.tag.viewprev,
+        {description = "view previous", group = "tag"}),
+    awful.key({ modkey,         }, "Right",  awful.tag.viewnext,
+        {description = "view next", group = "tag"}),
+    -- awful.key({ altkey,         }, "Escape", awful.tag.history.restore,
+    --     {description = "go back", group = "tag"}),
+
+     -- Tag browsing ALT+TAB (ALT+SHIFT+TAB)
+    --awful.key({ altkey,         }, "Tab", awful.tag.viewnext,
+    --    {description = "view next", group = "tag"}),
+    --awful.key({ altkey, "Shift" }, "Tab", awful.tag.viewprev,
+    --    {description = "view previous", group = "tag"}),
+
+    -- Non-empty tag browsing CTRL+TAB (CTRL+SHIFT+TAB)
+     awful.key({ altkey }, "Tab", function () lain.util.tag_view_nonempty(-1) end,
+               {description = "view  previous nonempty", group = "tag"}),
+     awful.key({ altkey, "Shift" }, "Tab", function () lain.util.tag_view_nonempty(1) end,
+               {description = "view  previous nonempty", group = "tag"}),
+
+    -- Default client focus
+    awful.key({ modkey,         }, "j", function () awful.client.focus.byidx( 1) end,
+        {description = "Focus next by index", group = "client"}),
+    awful.key({ modkey,         }, "k", function () awful.client.focus.byidx(-1) end,
+        {description = "Focus previous by index", group = "client"}),
+
+    -- By direction client focus
+    --awful.key({ altkey, "Shift" }, "j", function() awful.client.focus.global_bydirection("down")
+    --    if client.focus then client.focus:raise() end end,
+    --    {description = "Focus down", group = "client"}),
+    --awful.key({ altkey, "Shift" }, "k", function() awful.client.focus.global_bydirection("up")
+    --    if client.focus then client.focus:raise() end end,
+    --    {description = "Focus up", group = "client"}),
+    --awful.key({ altkey, "Shift" }, "h", function() awful.client.focus.global_bydirection("left")
+    --    if client.focus then client.focus:raise() end end,
+    --    {description = "Focus left", group = "client"}),
+    --awful.key({ altkey, "Shift" }, "l", function() awful.client.focus.global_bydirection("right")
+    --    if client.focus then client.focus:raise() end end,
+    --    {description = "Focus right", group = "client"}),
+
+        -- By direction client focus with arrows
+    awful.key({ ctrlkey, modkey }, "Down", function() awful.client.focus.global_bydirection("down")
+        if client.focus then client.focus:raise() end end,
+        {description = "Focus down", group = "client"}),
+    awful.key({ ctrlkey, modkey }, "Up", function() awful.client.focus.global_bydirection("up")
+        if client.focus then client.focus:raise() end end,
+        {description = "Focus up", group = "client"}),
+    awful.key({ ctrlkey, modkey }, "Left", function() awful.client.focus.global_bydirection("left")
+        if client.focus then client.focus:raise() end end,
+        {description = "Focus left", group = "client"}),
+    awful.key({ ctrlkey, modkey }, "Right", function() awful.client.focus.global_bydirection("right")
+        if client.focus then client.focus:raise() end end,
+        {description = "Focus right", group = "client"}),
+
+    -- Layout manipulation
+    awful.key({ modkey, "Shift" }, "j", function () awful.client.swap.byidx(1) end,
+        {description = "swap with next client by index", group = "client"}),
+    awful.key({ modkey, "Shift" }, "k", function () awful.client.swap.byidx( -1) end,
+        {description = "swap with previous client by index", group = "client"}),
+    awful.key({ modkey          }, "l", function () awful.screen.focus_relative(1) end,
+        {description = "focus the next screen", group = "screen"}),
+    awful.key({ modkey          }, "h", function () awful.screen.focus_relative(-1) end,
+        {description = "focus the previous screen", group = "screen"}),
+    awful.key({ modkey,         }, "u", awful.client.urgent.jumpto,
+        {description = "jump to urgent client", group = "client"}),
+    -- awful.key({ ctrlkey,        }, "Tab", function () awful.client.focus.history.previous()
+    --     if client.focus then client.focus:raise() end end,
+    --     {description = "go back", group = "client"}),
+
+    -- On the fly useless gaps change
+    awful.key({ modkey }, "+", function () lain.util.useless_gaps_resize(1) end,
+        {description = "increment useless gaps", group = "tag"}),
+    awful.key({ modkey }, "-", function () lain.util.useless_gaps_resize(-1) end,
+        {description = "decrement useless gaps", group = "tag"}),
+    awful.key({ modkey }, "z", function () lain.util.useless_gaps_resize(-8) end,
+        {description = "No gaps", group = "tag"}),
+    awful.key({ modkey }, "x", function () lain.util.useless_gaps_resize(8) end,
+        {description = "Default gaps", group = "tag"}),
+
+    awful.key({ modkey }, "o", function () awful.tag.incmwfact( 0.05) end,
+        {description = "increase master width factor", group = "layout"}),
+    awful.key({ modkey }, "y", function () awful.tag.incmwfact(-0.05) end,
+        {description = "decrease master width factor", group = "layout"}),
+
+    awful.key({ modkey, "Shift" }, "a", function() awful.spawn("picom-trans -c -5") end,
+        {description = "decrease transparency", group = "custom"}),
+
+    awful.key({ modkey, "Control" }, "a", function() awful.spawn("picom-trans -c +5") end,
+        {description = "increase transparency", group = "custom"}),
+
+    -- Dynamic tagging
+    -- awful.key({ modkey, "Shift" }, "n", function () lain.util.add_tag() end,
+    --     {description = "add new tag", group = "tag"}),
+    -- awful.key({ modkey, "Shift" }, "r", function () lain.util.rename_tag() end,
+    --     {description = "rename tag", group = "tag"}),
+    -- awful.key({ modkey, "Shift" }, "Left", function () lain.util.move_tag(-1) end,
+    --     {description = "move tag to the left", group = "tag"}),
+    -- awful.key({ modkey, "Shift" }, "Right", function () lain.util.move_tag(1) end,
+    --     {description = "move tag to the right", group = "tag"}),
+    -- awful.key({ modkey, "Shift" }, "d", function () lain.util.delete_tag() end,
+    --     {description = "delete tag", group = "tag"}),
+
+    -- awful.key({ modkey, "Shift" }, "l", function () awful.tag.incmwfact( 0.05) end,
+    --     {description = "increase master width factor", group = "layout"}),
+    -- awful.key({ modkey, "Shift" }, "h", function () awful.tag.incmwfact(-0.05) end,
+    --     {description = "decrease master width factor", group = "layout"}),
+    -- awful.key({ modkey, "Shift" }, "Up", function () awful.tag.incnmaster( 1, nil, true) end,
+    --     {description = "increase the number of master clients", group = "layout"}),
+    -- awful.key({ modkey, "Shift" }, "Down", function () awful.tag.incnmaster(-1, nil, true) end,
+    --     {description = "decrease the number of master clients", group = "layout"}),
+    -- awful.key({ modkey, ctrlkey }, "h", function () awful.tag.incncol( 1, nil, true) end,
+    --     {description = "increase the number of columns", group = "layout"}),
+    -- awful.key({ modkey, ctrlkey }, "l", function () awful.tag.incncol(-1, nil, true) end,
+    --     {description = "decrease the number of columns", group = "layout"}),
+    -- awful.key({ modkey,         }, "Tab", function () awful.layout.inc( 1) end,
+    --     {description = "select next", group = "layout"}),
+    -- awful.key({ modkey, "Shift" }, "Tab", function () awful.layout.inc(-1) end,
+    --     {description = "select previous", group = "layout"}),
+
+    -- awful.key({ modkey, ctrlkey }, "n",
+    --           function ()
+    --               local c = awful.client.restore()
+    --               -- Focus restored client
+    --               if c then
+    --                   client.focus = c
+    --                   c:raise()
+    --               end
+    --           end,
+    --           {description = "restore minimized", group = "client"}),
+
+    -- Dropdown application
+    awful.key({ modkey, }, "F12", function () awful.screen.focused().quake:toggle() end,
+              {description = "dropdown application", group = "super"}),
+
+    -- Widgets popups
+    -- awful.key({ modkey, altkey, }, "c", function () lain.widget.cal.show(7) end,
+    --     {description = "show calendar", group = "widgets"}),
+    -- awful.key({ altkey, }, "h", function () if beautiful.fs then beautiful.fs.show(7) end end,
+    --     {description = "show filesystem", group = "widgets"}),
+    -- awful.key({ altkey, }, "w", function () if beautiful.weather then beautiful.weather.show(7) end end,
+    --     {description = "show weather", group = "widgets"}),
+
+    -- Brightness
+    awful.key({ }, "XF86MonBrightnessUp", function () os.execute("xbacklight -inc 10") end,
+        {description = "+10%", group = "hotkeys"}),
+    awful.key({ }, "XF86MonBrightnessDown", function () os.execute("xbacklight -dec 10") end,
+        {description = "-10%", group = "hotkeys"}),
+
+    -- ALSA volume control
+    --awful.key({ ctrlkey }, "Up",
+    awful.key({ }, "XF86AudioRaiseVolume",
+        function ()
+            os.execute(string.format("amixer -q set %s 1%%+", beautiful.volume.channel))
+            beautiful.volume.update()
+        end),
+    --awful.key({ ctrlkey }, "Down",
+    awful.key({ }, "XF86AudioLowerVolume",
+        function ()
+            os.execute(string.format("amixer -q set %s 1%%-", beautiful.volume.channel))
+            beautiful.volume.update()
+        end),
+    awful.key({ }, "XF86AudioMute",
+        function ()
+            os.execute(string.format("amixer -q set %s toggle", beautiful.volume.togglechannel or beautiful.volume.channel))
+            beautiful.volume.update()
+        end)
+
+    -- Copy primary to clipboard (terminals to gtk)
+    -- awful.key({ modkey }, "c", function () awful.spawn.with_shell("xsel | xsel -i -b") end,
+    --     {description = "copy terminal to gtk", group = "hotkeys"}),
+    -- Copy clipboard to primary (gtk to terminals)
+    -- awful.key({ modkey }, "v", function () awful.spawn.with_shell("xsel -b | xsel") end,
+    --     {description = "copy gtk to terminal", group = "hotkeys"}),
+    -- awful.key({ altkey, "Shift" }, "x",
+    --           function ()
+    --               awful.prompt.run {
+    --                 prompt       = "Run Lua code: ",
+    --                 textbox      = awful.screen.focused().mypromptbox.widget,
+    --                 exe_callback = awful.util.eval,
+    --                 history_path = awful.util.get_cache_dir() .. "/history_eval"
+    --               }
+    --           end,
+    --           {description = "lua execute prompt", group = "awesome"})
+    --]]
+)
+
+clientkeys = mytable.join(
+    -- awful.key({ altkey, "Shift" }, "m",      lain.util.magnify_client,
+    --           {description = "magnify client", group = "client"}),
+    awful.key({ modkey,           }, "f",
+        function (c)
+            c.fullscreen = not c.fullscreen
+            c:raise()
+        end,
+        {description = "toggle fullscreen", group = "client"}),
+
+    awful.key({ modkey }, "q", function (c) c:kill() end,
+      {description = "close", group = "hotkeys"}),
+
+    --awful.key({ modkey,         }, "space", awful.client.floating.toggle,
+    --  {description = "toggle floating", group = "client"}),
+
+    awful.key(
+      { modkey }, "space",
+      function(c)
+        awful.client.floating.toggle(c)
+
+        -- If the client is now floating, center it
+        if c.floating then
+          awful.placement.centered(c, {honor_workarea = true})
+        end
+      end,
+      {description = "toggle floating and center", group = "client"}
+    ),
+
+    -- awful.key({ modkey, ctrlkey }, "Return", function (c) c:swap(awful.client.getmaster()) end,
+    --   {description = "move to master", group = "client"}),
+    -- awful.key({ modkey, "Shift" }, "t", function (c) c.ontop = not c.ontop end,
+    --   {description = "toggle keep on top", group = "client"}),
+
+    awful.key({ modkey, "Shift"}, "l",
+        function ()
+            local c = client.focus
+            if c then c:move_to_screen() end
+        end, {description = "move client to next screen", group = "client"}),
+
+    awful.key({ modkey, "Shift"}, "h",
+        function ()
+            local c = client.focus
+            if c then c:move_to_screen(c.screen.index-1) end
+        end, {description = "move client to prev screen", group = "client"}),
+
+    -- awful.key({ modkey,         }, "n",
+    --     function (c)
+    --         -- The client currently has the input focus, so it cannot be
+    --         -- minimized, since minimized clients can't have the focus.
+    --         c.minimized = true
+    --     end ,
+    -- {description = "minimize", group = "client"}),
+
+     awful.key({ modkey, "Shift", ctrlkey           }, "m",
+         function (c)
+             c.maximized = not c.maximized
+             c:raise()
+         end ,
+     {description = "maximize", group = "client"})
+)
+
+-- Toggleable Tag Switching
+local last_tag = {}
+
+local function toggle_tag(tag)
+  local num_screens = screen:count()
+  local current_screen = awful.screen.focused()
+
+  if current_screen.selected_tag == tag then
+    if num_screens == 1 and last_tag[current_screen] then
+      last_tag[current_screen]:view_only()
+    end
+  else
+    last_tag[current_screen] = current_screen.selected_tag
+    tag:view_only()
+  end
+end
+
+local binary_mask = 341
+
+local function is_odd_with_mask(tag_index)
+    return (binary_mask & (1 << (tag_index - 1))) ~= 0
+end
+
+local EVEN_TAG_MASK = 170
+
+local function is_odd(index)
+  --return index % 2 == 1
+  return (EVEN_TAG_MASK & (1 << (index - 1))) == 0
+end
+
+local function switch_to_tag(tag_index)
+  local num_screens = screen:count()
+  if not tag_index or tag_index < 1 then return end
+
+  if num_screens == 2 then
+    -- Determine monitor based on binary mask and tag index
+    for s in screen do
+      --if is_odd(tag_index) and s.index == 1 then
+      --  awful.screen.focus(s)
+      --  local tag = s.tags[tag_index]
+      --  if tag then
+      --    tag:view_only()
+      --  end
+      --elseif not is_odd(tag_index) and s.index == 2 then
+      --  awful.screen.focus(s)
+      --  local tag = s.tags[tag_index]
+      --  if tag then
+      --    tag:view_only()
+      --  end
+      --end
+
+      if (is_odd_with_mask(tag_index) and s.index == 1) or
+        (not is_odd_with_mask(tag_index) and s.index == 2) then
+      --if (is_odd(tag_index) and s.index == 1) or
+      --  (not is_odd(tag_index) and s.index == 2) then
+        awful.screen.focus(s)
+        local tag = s.tags[tag_index]
+        if tag then
+          tag:view_only()
+        end
+        return
+      end
+    end
+  elseif num_screens > 2 then
+    local target_screen_index = ((tag_index - 1) % num_screens) + 1 -- Determine target screen cyclically
+    local target_screen = screen[target_screen_index]
+
+    awful.screen.focus(target_screen)
+    local tag = target_screen.tags[((tag_index - 1) % #target_screen.tags) + 1]
+    if tag then
+      tag:view_only()
+    end
+  else
+    local current_screen = awful.screen.focused()
+    local tag = current_screen.tags[tag_index]
+    if tag then
+      --tag:view_only()
+      --awful.tag.viewtoggle(tag)
+      toggle_tag(tag)
+    end
+  end
+end
+
+local function switch_to_tag_move(tag_index)
+  local num_screens = screen:count()
+
+  if num_screens == 2 then
+    local primary_screen = screen[1]
+    local secondary_screen = screen[2]
+    local current_screen = awful.screen.focused()
+    local client_is_odd = is_odd_with_mask(tag_index)
+    local focused_client = client.focus
+
+    if current_screen == primary_screen and not client_is_odd then
+      -- Currently on primary screen, but tag is even -> Switch to secondary screen
+      awful.screen.focus(secondary_screen)
+      focused_client:move_to_screen(secondary_screen)
+      local target_tag = secondary_screen.tags[tag_index]
+      if target_tag then
+        focused_client:move_to_tag(target_tag)
+      end
+      local target_tag = secondary_screen.tags[tag_index]
+      target_tag:view_only()
+      client.focus = focused_client
+      focused_client:raise()
+
+    elseif current_screen == secondary_screen and client_is_odd then
+      -- Currently on secondary screen, but tag is odd -> Switch to primary screen
+      awful.screen.focus(primary_screen)
+      focused_client:move_to_screen(primary_screen)
+      local target_tag = primary_screen.tags[tag_index]
+      if target_tag then
+        focused_client:move_to_tag(target_tag)
+      end
+      local target_tag = primary_screen.tags[tag_index]
+      target_tag:view_only()
+      client.focus = focused_client
+      focused_client:raise()
+
+    else
+      local target_tag = current_screen.tags[tag_index]
+      focused_client:move_to_tag(target_tag)
+      target_tag:view_only()
+    end
+
+  elseif num_screens > 2 then
+    -- Determine target screen cyclically
+    local target_screen_index = ((tag_index - 1) % num_screens) + 1
+    local target_screen = screen[target_screen_index]
+
+    awful.screen.focus(target_screen)
+    local tag = target_screen.tags[((tag_index - 1) % #target_screen.tags) + 1]
+    if client.focus.screen ~= target_screen then
+      client.focus:move_to_screen(target_screen)
+    end
+    client.focus:move_to_tag(tag)
+    tag:view_only()
+
+  else
+    local current_screen = awful.screen.focused()
+    local tag = current_screen.tags[tag_index]
+    client.focus:move_to_tag(tag)
+    toggle_tag(tag)
+  end
+end
+
+local function switch_to_tag_stay(tag_index)
+  local num_screens = screen:count()
+
+  if num_screens == 2 then
+    local primary_screen = screen[1]
+    local secondary_screen = screen[2]
+    local current_screen = awful.screen.focused()
+    local current_tag = awful.screen.focused().selected_tag
+    local client_is_odd = is_odd_with_mask(tag_index)
+    local focused_client = client.focus
+
+    if not focused_client then return end
+
+    if current_screen == primary_screen and not client_is_odd then
+      -- Currently on primary screen, but tag is even -> Switch to secondary screen
+      local target_tag = secondary_screen.tags[tag_index]
+      focused_client:move_to_tag(target_tag)
+      focused_client:move_to_screen(secondary_screen)
+      awful.screen.focus(primary_screen)
+      current_tag:view_only()
+
+    elseif current_screen == secondary_screen and client_is_odd then
+      -- Currently on secondary screen, but tag is odd -> Switch to primary screen
+      local target_tag = primary_screen.tags[tag_index]
+      focused_client:move_to_tag(target_tag)
+      focused_client:move_to_screen(primary_screen)
+      awful.screen.focus(secondary_screen)
+      current_tag:view_only()
+
+    else
+      local target_tag = current_screen.tags[tag_index]
+      focused_client:move_to_tag(target_tag)
+    end
+
+  elseif num_screens > 2 then
+    -- Determine target screen cyclically
+    local target_screen_index = ((tag_index - 1) % num_screens) + 1
+    local target_screen = screen[target_screen_index]
+
+    local tag = target_screen.tags[((tag_index - 1) % #target_screen.tags) + 1]
+    if client.focus.screen ~= target_screen then
+      client.focus:move_to_screen(target_screen)
+    end
+    client.focus:move_to_tag(tag)
+
+  else
+    local current_screen = awful.screen.focused()
+    local tag = current_screen.tags[tag_index]
+    client.focus:move_to_tag(tag)
+  end
+end
+
+-- Bind all key numbers to tags
+for i = 1, 9 do
+  globalkeys = mytable.join(globalkeys,
+    -- View tag only.
+    awful.key({ modkey }, "#" .. i + 9,
+      function ()
+        switch_to_tag(i)
+      end,
+      {description = "view tag #"..i.." on appropriate monitor", group = "tag"}),
+
+    -- Move client to tag and view it.
+    awful.key({ modkey, "Shift" }, "#" .. i + 9,
+      function ()
+        --if client.focus then
+        --  local tag = client.focus.screen.tags[i]
+        --  if tag then
+        --    client.focus:move_to_tag(tag)
+        --    toggle_tag(tag)
+        --  end
+        --end
+        switch_to_tag_move(i)
+      end,
+      {description = "move focused client to tag #"..i, group = "tag"}),
+    -- Move client to tag.
+    awful.key({ modkey, "Control" }, "#" .. i + 9,
+      function ()
+        --if client.focus then
+        --  local tag = client.focus.screen.tags[i]
+        --  if tag then
+        --    client.focus:move_to_tag(tag)
+        --  end
+        --end
+        switch_to_tag_stay(i)
+      end,
+      {description = "move focused client to tag #"..i, group = "tag"}),
+    -- Toggle tag on focused client.
+    awful.key({ modkey, "Control", "Shift" }, "#" .. i + 9,
+      function ()
+        if client.focus then
+          local tag = client.focus.screen.tags[i]
+          if tag then
+            client.focus:toggle_tag(tag)
+          end
+        end
+      end,
+      {description = "toggle focused client on tag #" .. i, group = "tag"})
+  )
+end
+
+clientbuttons = mytable.join(
+    awful.button({ }, 1, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+    end),
+    awful.button({ modkey }, 1, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+        awful.mouse.client.move(c)
+    end),
+    awful.button({ modkey }, 3, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+        awful.mouse.client.resize(c)
+    end)
+)
+
+-- Set keys
+root.keys(globalkeys)
+
+-- }}}
+
+-- {{{ Rules
+
+-- Rules to apply to new clients (through the "manage" signal).
+awful.rules.rules = {
+    {
+        rule = { class = "firefox" },
+        properties = {
+            --maximized = false, -- Ensure Firefox is not always maximized
+            floating = false,  -- Ensure it respects tiled layouts
+            tag = "2",
+        },
+    },
+    {
+        rule = { class = "thunar" },
+        properties = {
+            maximized = false,
+            floating = false,
+        },
+    },
+
+    -- All clients will match this rule.
+    { rule = { },
+      properties = { border_width = beautiful.border_width,
+                     border_color = beautiful.border_normal,
+                     callback = awful.client.setslave,
+                     focus = awful.client.focus.filter,
+                     raise = true,
+                     keys = clientkeys,
+                     buttons = clientbuttons,
+                     screen = awful.screen.preferred,
+                     placement = awful.placement.no_overlap+awful.placement.no_offscreen,
+                     size_hints_honor = false
+     }
+    },
+
+    -- Floating clients.
+  --{
+  --  rule_any = {
+  --    instance = {
+  --      "DTA", -- Firefox addon DownThemAll.
+  --      "copyq", -- Includes session name in class.
+  --      "pinentry",
+  --    },
+  --    class = {
+  --      "Arandr",
+  --      "Blueman-manager",
+  --      "Gpick",
+  --      "Kruler",
+  --      "MessageWin", -- kalarm.
+  --      "Sxiv",
+  --      "Tor Browser", -- Needs a fixed window size to avoid fingerprinting by screen size.
+  --      "Wpa_gui",
+  --      "veromix",
+  --      "xtightvncviewer"},
+  --
+  --    -- Note that the name property shown in xprop might be set slightly after creation of the client
+  --    -- and the name shown there might not match defined rules here.
+  --    name = {
+  --      "Event Tester",  -- xev.
+  --    },
+  --    role = {
+  --      "AlarmWindow",  -- Thunderbird's calendar.
+  --      "ConfigManager",  -- Thunderbird's about:config.
+  --      "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
+  --    }
+  --  }, properties = { floating = true }},
+
+    -- Add titlebars to normal clients and dialogs
+    { rule_any = {type = { "normal", "dialog" }
+      }, properties = { titlebars_enabled = false }
+    },
+
+    -- Set Firefox to always map on the tag named "2" on screen 1.
+    -- { rule = { class = "Firefox" },
+    --   properties = { screen = 1, tag = "2" } },
+}
+
+-- }}}
+
+-- {{{ Signals
+
+-- Signal function to execute when a new client appears.
+client.connect_signal("manage", function (c)
+    -- Set the windows at the slave,
+    -- i.e. put it at the end of others instead of setting it master.
+    -- if not awesome.startup then awful.client.setslave(c) end
+
+    if awesome.startup
+      and not c.size_hints.user_position
+      and not c.size_hints.program_position then
+        -- Prevent clients from being unreachable after screen count changes.
+        awful.placement.no_offscreen(c)
+    end
+end)
+
+-- Add a titlebar if titlebars_enabled is set to true in the rules.
+client.connect_signal("request::titlebars", function(c)
+    -- Custom
+    if beautiful.titlebar_fun then
+        beautiful.titlebar_fun(c)
+        return
+    end
+
+    -- Default
+    -- buttons for the titlebar
+    local buttons = mytable.join(
+        awful.button({ }, 1, function()
+            c:emit_signal("request::activate", "titlebar", {raise = true})
+            awful.mouse.client.move(c)
+        end),
+        awful.button({ }, 3, function()
+            c:emit_signal("request::activate", "titlebar", {raise = true})
+            awful.mouse.client.resize(c)
+        end)
+    )
+
+    awful.titlebar(c, { size = 16 }) : setup {
+        { -- Left
+            awful.titlebar.widget.iconwidget(c),
+            buttons = buttons,
+            layout  = wibox.layout.fixed.horizontal
+        },
+        { -- Middle
+            { -- Title
+                align  = "center",
+                widget = awful.titlebar.widget.titlewidget(c)
+            },
+            buttons = buttons,
+            layout  = wibox.layout.flex.horizontal
+        },
+        { -- Right
+            awful.titlebar.widget.floatingbutton (c),
+            awful.titlebar.widget.maximizedbutton(c),
+            awful.titlebar.widget.stickybutton   (c),
+            awful.titlebar.widget.ontopbutton    (c),
+            awful.titlebar.widget.closebutton    (c),
+            layout = wibox.layout.fixed.horizontal()
+        },
+        layout = wibox.layout.align.horizontal
+    }
+end)
+
+-- Enable sloppy focus, so that focus follows mouse.
+--client.connect_signal("mouse::enter", function(c)
+--    c:emit_signal("request::activate", "mouse_enter", {raise = vi_focus})
+--end)
+
+client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
+client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)
+
+-- switch to parent after closing child window
+local function backham()
+    local s = awful.screen.focused()
+    local c = awful.client.focus.history.get(s, 0)
+    if c then
+        client.focus = c
+        c:raise()
+    end
+end
+
+-- attach to minimized state
+client.connect_signal("property::minimized", backham)
+-- attach to closed state
+client.connect_signal("unmanage", backham)
+-- ensure there is always a selected client during tag switching or logins
+tag.connect_signal("property::selected", backham)
+
+-- }}}
+
+-- Multiple monitor taglist setup
+-- See: {code_root_dir}/Code2/Lua/my_lua/testing/awsm_tag_testing.lua
+
+local function setup_tags_for_monitors()
+  local num_screens = screen.count()
+
+  for s in screen do
+    s.tags = {}
+
+    if num_screens == 2 then
+      for i = 1, 9 do
+        if s.index == 1 and is_odd_with_mask(i) then
+          awful.tag.add(i, { screen = s, layout = awful.layout.suit.spiral })
+        elseif s.index == 2 and not is_odd_with_mask(i) then
+          awful.tag.add(i, { screen = s, layout = awful.layout.suit.spiral })
+        end
+      end
+    else
+      -- Cyclical tag distribution for 3 or more monitors
+      for i = 1, 9 do
+        -- Assign tag `i` to the monitor `((i - 1) % num_screens) + 1`
+        local target_screen = ((i - 1) % num_screens) + 1
+        if s.index == target_screen then
+          awful.tag.add(i, {
+            screen = s,
+            layout = awful.layout.suit.spiral,
+          })
+        end
+      end
+    end
+  end
+end
 
--- focus windows automatically when they are raised
-require("awful.autofocus")
+local function move_clients_cyclically()
+  local screens = screen:count()
+  if screens < 3 then return end
 
-local awesome_conf_dir = gears.filesystem.get_configuration_dir()
+  -- Move clients cyclically across all monitors based on tag index
+  for _, c in ipairs(client.get()) do
+    local tags = c:tags()
+    for _, tag in ipairs(tags) do
+      local tag_index = tonumber(tag.name)
+      if tag_index then
+        local target_screen_index = ((tag_index - 1) % screens) + 1
+        local target_screen = screen[target_screen_index]
 
--- Global variables
-Terminal = "alacritty"
-TerminalCmd = Terminal .. " -e "
-Editor = "nvim"
+        if target_screen and c.screen ~= target_screen then
+          c:move_to_screen(target_screen)
+        end
+        break
+      end
+    end
+  end
+end
 
+local function move_even_tag_clients()
+  local screens = screen:count()
+  if screens ~= 2 then return end
 
--- Error handling: this isn't useful here, but is if the config is used as fallback.
-dofile(awesome_conf_dir .. "error_handling.lua")
+  local primary_screen = screen[1]
+  local secondary_screen = screen[2]
+  local current_tag = awful.screen.focused().selected_tag
+  local current_tag_index = current_tag and tonumber(current_tag.name)
 
--- Themes define colours, font and wallpapers.
-beautiful.init(awesome_conf_dir .. "theme/theme.lua")
+  for _, c in ipairs(client.get()) do
+    local tags = c:tags()
+    for _, tag in ipairs(tags) do
+      local tag_index = tonumber(tag.name)
+      if tag_index and (EVEN_TAG_MASK & (1 << (tag_index - 1))) ~= 0 then
+        c:move_to_screen(secondary_screen)
+        local new_tag = secondary_screen.tags[tag_index]
+        c:move_to_tag(new_tag)
+        break
+      end
+    end
+  end
 
--- Screens, layouts, tags
-dofile(awesome_conf_dir .. "screens.lua")
+  switch_to_tag(1)
+  switch_to_tag(2)
+  switch_to_tag(current_tag_index)
+end
 
--- Key bindings
-dofile(awesome_conf_dir .. "keys.lua")
+local function handle_monitor_remove()
+  local screens = screen:count()
+  if screens ~= 1 then return end
+  local primary_screen = screen[1]
+  -- This will restore focus to selected tag on first monitor...
+  local current_tag = awful.screen.focused().selected_tag
+  local current_tag_index = current_tag and tonumber(current_tag.name)
 
--- Rules: how windows are placed and managed
--- If you want to make specific programs appear on specific tags, you can do that here.
-dofile(awesome_conf_dir .. "rules.lua")
+  for _, c in ipairs(client.get()) do
+    local tags = c:tags()
+    for _, tag in ipairs(tags) do
+      local tag_index = tonumber(tag.name)
+      if tag_index then
+        local new_tag = primary_screen.tags[tag_index]
+        if new_tag then
+          c:move_to_screen(primary_screen)
+          c:move_to_tag(new_tag)
+        end
+      end
+    end
+  end
 
--- Signals: what to do when a window is created, moved, etc.
-dofile(awesome_conf_dir .. "signals.lua")
+  switch_to_tag(current_tag_index)
+end
 
+--awful.screen.connect_for_each_screen(function(s)
+--  if screen:count() == 2 then
+--    move_even_tag_clients()
+--  end
+--end)
 
+screen.connect_signal("added", function()
+  --setup_tags_for_monitors()
+  move_even_tag_clients()
+  move_clients_cyclically()
+end)
 
--- Autostart applications
-awful.spawn.with_shell("pgrep signal-desktop || signal-desktop --start-in-tray")
+--screen.connect_signal("removed", function()
+--  setup_tags_for_monitors()
+--end)
 
--- Keyboard & monitor manager, automatically runs autorandr and setxkbmap
--- when a new keyboard or monitor is plugged in/out.
-awful.spawn.with_shell("~/.config/scripts/manager")
+tag.connect_signal("request::screen", function(t)
+  handle_monitor_remove()
+end)
 
--- Unison sync script: syncs files with my server.
-awful.spawn.with_shell("pgrep unison || ~/.config/scripts/unison-sync")
+--setup_tags_for_monitors()
 
--- Set the screen to turn off & lock after 5 minutes of inactivity.
-awful.spawn.with_shell("xset s 300")
--- xss-lock will exit if already running, no need to pgrep.
-awful.spawn.with_shell("xss-lock ~/.config/scripts/lock")
diff --git a/rc.lua.template b/rc.lua.template
new file mode 100644
index 0000000..6370d0e
--- /dev/null
+++ b/rc.lua.template
@@ -0,0 +1,832 @@
+--[[
+
+     Awesome WM configuration template
+     github.com/lcpz
+
+--]]
+
+-- {{{ Required libraries
+
+-- If LuaRocks is installed, make sure that packages installed through it are
+-- found (e.g. lgi). If LuaRocks is not installed, do nothing.
+pcall(require, "luarocks.loader")
+
+local gears         = require("gears")
+local awful         = require("awful")
+                      require("awful.autofocus")
+local wibox         = require("wibox")
+local beautiful     = require("beautiful")
+local naughty       = require("naughty")
+local lain          = require("lain")
+--local menubar       = require("menubar")
+local freedesktop   = require("freedesktop")
+local hotkeys_popup = require("awful.hotkeys_popup")
+                      require("awful.hotkeys_popup.keys")
+local mytable       = awful.util.table or gears.table -- 4.{0,1} compatibility
+
+-- }}}
+
+-- {{{ Error handling
+
+-- Check if awesome encountered an error during startup and fell back to
+-- another config (This code will only ever execute for the fallback config)
+if awesome.startup_errors then
+    naughty.notify {
+        preset = naughty.config.presets.critical,
+        title = "Oops, there were errors during startup!",
+        text = awesome.startup_errors
+    }
+end
+
+-- Handle runtime errors after startup
+do
+    local in_error = false
+
+    awesome.connect_signal("debug::error", function (err)
+        if in_error then return end
+
+        in_error = true
+
+        naughty.notify {
+            preset = naughty.config.presets.critical,
+            title = "Oops, an error happened!",
+            text = tostring(err)
+        }
+
+        in_error = false
+    end)
+end
+
+-- }}}
+
+-- {{{ Autostart windowless processes
+
+-- This function will run once every time Awesome is started
+local function run_once(cmd_arr)
+    for _, cmd in ipairs(cmd_arr) do
+        awful.spawn.with_shell(string.format("pgrep -u $USER -fx '%s' > /dev/null || (%s)", cmd, cmd))
+    end
+end
+
+run_once({ "urxvtd", "unclutter -root" }) -- comma-separated entries
+
+-- This function implements the XDG autostart specification
+--[[
+awful.spawn.with_shell(
+    'if (xrdb -query | grep -q "^awesome\\.started:\\s*true$"); then exit; fi;' ..
+    'xrdb -merge <<< "awesome.started:true";' ..
+    -- list each of your autostart commands, followed by ; inside single quotes, followed by ..
+    'dex --environment Awesome --autostart --search-paths ' ..
+    '"${XDG_CONFIG_HOME:-$HOME/.config}/autostart:${XDG_CONFIG_DIRS:-/etc/xdg}/autostart";' -- https://github.com/jceb/dex
+)
+--]]
+
+-- }}}
+
+-- {{{ Variable definitions
+
+local themes = {
+    "blackburn",       -- 1
+    "copland",         -- 2
+    "dremora",         -- 3
+    "holo",            -- 4
+    "multicolor",      -- 5
+    "powerarrow",      -- 6
+    "powerarrow-dark", -- 7
+    "rainbow",         -- 8
+    "steamburn",       -- 9
+    "vertex"           -- 10
+}
+
+local chosen_theme = themes[5]
+local modkey       = "Mod4"
+local altkey       = "Mod1"
+local terminal     = "urxvtc"
+local vi_focus     = false -- vi-like client focus https://github.com/lcpz/awesome-copycats/issues/275
+local cycle_prev   = true  -- cycle with only the previously focused client or all https://github.com/lcpz/awesome-copycats/issues/274
+local editor       = os.getenv("EDITOR") or "nvim"
+local browser      = "librewolf"
+
+awful.util.terminal = terminal
+awful.util.tagnames = { "1", "2", "3", "4", "5" }
+awful.layout.layouts = {
+    awful.layout.suit.floating,
+    awful.layout.suit.tile,
+    awful.layout.suit.tile.left,
+    awful.layout.suit.tile.bottom,
+    awful.layout.suit.tile.top,
+    --awful.layout.suit.fair,
+    --awful.layout.suit.fair.horizontal,
+    --awful.layout.suit.spiral,
+    --awful.layout.suit.spiral.dwindle,
+    --awful.layout.suit.max,
+    --awful.layout.suit.max.fullscreen,
+    --awful.layout.suit.magnifier,
+    --awful.layout.suit.corner.nw,
+    --awful.layout.suit.corner.ne,
+    --awful.layout.suit.corner.sw,
+    --awful.layout.suit.corner.se,
+    --lain.layout.cascade,
+    --lain.layout.cascade.tile,
+    --lain.layout.centerwork,
+    --lain.layout.centerwork.horizontal,
+    --lain.layout.termfair,
+    --lain.layout.termfair.center
+}
+
+lain.layout.termfair.nmaster           = 3
+lain.layout.termfair.ncol              = 1
+lain.layout.termfair.center.nmaster    = 3
+lain.layout.termfair.center.ncol       = 1
+lain.layout.cascade.tile.offset_x      = 2
+lain.layout.cascade.tile.offset_y      = 32
+lain.layout.cascade.tile.extra_padding = 5
+lain.layout.cascade.tile.nmaster       = 5
+lain.layout.cascade.tile.ncol          = 2
+
+awful.util.taglist_buttons = mytable.join(
+    awful.button({ }, 1, function(t) t:view_only() end),
+    awful.button({ modkey }, 1, function(t)
+        if client.focus then client.focus:move_to_tag(t) end
+    end),
+    awful.button({ }, 3, awful.tag.viewtoggle),
+    awful.button({ modkey }, 3, function(t)
+        if client.focus then client.focus:toggle_tag(t) end
+    end),
+    awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
+    awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
+)
+
+awful.util.tasklist_buttons = mytable.join(
+     awful.button({ }, 1, function(c)
+         if c == client.focus then
+             c.minimized = true
+         else
+             c:emit_signal("request::activate", "tasklist", { raise = true })
+         end
+     end),
+     awful.button({ }, 3, function()
+         awful.menu.client_list({ theme = { width = 250 } })
+     end),
+     awful.button({ }, 4, function() awful.client.focus.byidx(1) end),
+     awful.button({ }, 5, function() awful.client.focus.byidx(-1) end)
+)
+
+beautiful.init(string.format("%s/.config/awesome/themes/%s/theme.lua", os.getenv("HOME"), chosen_theme))
+
+-- }}}
+
+-- {{{ Menu
+
+-- Create a launcher widget and a main menu
+local myawesomemenu = {
+   { "Hotkeys", function() hotkeys_popup.show_help(nil, awful.screen.focused()) end },
+   { "Manual", string.format("%s -e man awesome", terminal) },
+   { "Edit config", string.format("%s -e %s %s", terminal, editor, awesome.conffile) },
+   { "Restart", awesome.restart },
+   { "Quit", function() awesome.quit() end },
+}
+
+awful.util.mymainmenu = freedesktop.menu.build {
+    before = {
+        { "Awesome", myawesomemenu, beautiful.awesome_icon },
+        -- other triads can be put here
+    },
+    after = {
+        { "Open terminal", terminal },
+        -- other triads can be put here
+    }
+}
+
+-- Hide the menu when the mouse leaves it
+--[[
+awful.util.mymainmenu.wibox:connect_signal("mouse::leave", function()
+    if not awful.util.mymainmenu.active_child or
+       (awful.util.mymainmenu.wibox ~= mouse.current_wibox and
+       awful.util.mymainmenu.active_child.wibox ~= mouse.current_wibox) then
+        awful.util.mymainmenu:hide()
+    else
+        awful.util.mymainmenu.active_child.wibox:connect_signal("mouse::leave",
+        function()
+            if awful.util.mymainmenu.wibox ~= mouse.current_wibox then
+                awful.util.mymainmenu:hide()
+            end
+        end)
+    end
+end)
+--]]
+
+-- Set the Menubar terminal for applications that require it
+--menubar.utils.terminal = terminal
+
+-- }}}
+
+-- {{{ Screen
+
+-- Re-set wallpaper when a screen's geometry changes (e.g. different resolution)
+screen.connect_signal("property::geometry", function(s)
+    -- Wallpaper
+    if beautiful.wallpaper then
+        local wallpaper = beautiful.wallpaper
+        -- If wallpaper is a function, call it with the screen
+        if type(wallpaper) == "function" then
+            wallpaper = wallpaper(s)
+        end
+        gears.wallpaper.maximized(wallpaper, s, true)
+    end
+end)
+
+-- No borders when rearranging only 1 non-floating or maximized client
+screen.connect_signal("arrange", function (s)
+    local only_one = #s.tiled_clients == 1
+    for _, c in pairs(s.clients) do
+        if only_one and not c.floating or c.maximized or c.fullscreen then
+            c.border_width = 0
+        else
+            c.border_width = beautiful.border_width
+        end
+    end
+end)
+
+-- Create a wibox for each screen and add it
+awful.screen.connect_for_each_screen(function(s) beautiful.at_screen_connect(s) end)
+
+-- }}}
+
+-- {{{ Mouse bindings
+
+root.buttons(mytable.join(
+    awful.button({ }, 3, function () awful.util.mymainmenu:toggle() end),
+    awful.button({ }, 4, awful.tag.viewnext),
+    awful.button({ }, 5, awful.tag.viewprev)
+))
+
+-- }}}
+
+-- {{{ Key bindings
+
+globalkeys = mytable.join(
+    -- Destroy all notifications
+    awful.key({ "Control",           }, "space", function() naughty.destroy_all_notifications() end,
+              {description = "destroy all notifications", group = "hotkeys"}),
+    -- Take a screenshot
+    -- https://github.com/lcpz/dots/blob/master/bin/screenshot
+    awful.key({ altkey }, "p", function() os.execute("screenshot") end,
+              {description = "take a screenshot", group = "hotkeys"}),
+
+    -- X screen locker
+    awful.key({ altkey, "Control" }, "l", function () os.execute(scrlocker) end,
+              {description = "lock screen", group = "hotkeys"}),
+
+    -- Show help
+    awful.key({ modkey,           }, "s",      hotkeys_popup.show_help,
+              {description="show help", group="awesome"}),
+
+    -- Tag browsing
+    awful.key({ modkey,           }, "Left",   awful.tag.viewprev,
+              {description = "view previous", group = "tag"}),
+    awful.key({ modkey,           }, "Right",  awful.tag.viewnext,
+              {description = "view next", group = "tag"}),
+    awful.key({ modkey,           }, "Escape", awful.tag.history.restore,
+              {description = "go back", group = "tag"}),
+
+    -- Non-empty tag browsing
+    awful.key({ altkey }, "Left", function () lain.util.tag_view_nonempty(-1) end,
+              {description = "view  previous nonempty", group = "tag"}),
+    awful.key({ altkey }, "Right", function () lain.util.tag_view_nonempty(1) end,
+              {description = "view  previous nonempty", group = "tag"}),
+
+    -- Default client focus
+    awful.key({ altkey,           }, "j",
+        function ()
+            awful.client.focus.byidx( 1)
+        end,
+        {description = "focus next by index", group = "client"}
+    ),
+    awful.key({ altkey,           }, "k",
+        function ()
+            awful.client.focus.byidx(-1)
+        end,
+        {description = "focus previous by index", group = "client"}
+    ),
+
+    -- By-direction client focus
+    awful.key({ modkey }, "j",
+        function()
+            awful.client.focus.global_bydirection("down")
+            if client.focus then client.focus:raise() end
+        end,
+        {description = "focus down", group = "client"}),
+    awful.key({ modkey }, "k",
+        function()
+            awful.client.focus.global_bydirection("up")
+            if client.focus then client.focus:raise() end
+        end,
+        {description = "focus up", group = "client"}),
+    awful.key({ modkey }, "h",
+        function()
+            awful.client.focus.global_bydirection("left")
+            if client.focus then client.focus:raise() end
+        end,
+        {description = "focus left", group = "client"}),
+    awful.key({ modkey }, "l",
+        function()
+            awful.client.focus.global_bydirection("right")
+            if client.focus then client.focus:raise() end
+        end,
+        {description = "focus right", group = "client"}),
+
+    -- Menu
+    awful.key({ modkey,           }, "w", function () awful.util.mymainmenu:show() end,
+              {description = "show main menu", group = "awesome"}),
+
+    -- Layout manipulation
+    awful.key({ modkey, "Shift"   }, "j", function () awful.client.swap.byidx(  1)    end,
+              {description = "swap with next client by index", group = "client"}),
+    awful.key({ modkey, "Shift"   }, "k", function () awful.client.swap.byidx( -1)    end,
+              {description = "swap with previous client by index", group = "client"}),
+    awful.key({ modkey, "Control" }, "j", function () awful.screen.focus_relative( 1) end,
+              {description = "focus the next screen", group = "screen"}),
+    awful.key({ modkey, "Control" }, "k", function () awful.screen.focus_relative(-1) end,
+              {description = "focus the previous screen", group = "screen"}),
+    awful.key({ modkey,           }, "u", awful.client.urgent.jumpto,
+              {description = "jump to urgent client", group = "client"}),
+    awful.key({ modkey,           }, "Tab",
+        function ()
+            if cycle_prev then
+                awful.client.focus.history.previous()
+            else
+                awful.client.focus.byidx(-1)
+            end
+            if client.focus then
+                client.focus:raise()
+            end
+        end,
+        {description = "cycle with previous/go back", group = "client"}),
+
+    -- Show/hide wibox
+    awful.key({ modkey }, "b", function ()
+            for s in screen do
+                s.mywibox.visible = not s.mywibox.visible
+                if s.mybottomwibox then
+                    s.mybottomwibox.visible = not s.mybottomwibox.visible
+                end
+            end
+        end,
+        {description = "toggle wibox", group = "awesome"}),
+
+    -- On-the-fly useless gaps change
+    awful.key({ altkey, "Control" }, "+", function () lain.util.useless_gaps_resize(1) end,
+              {description = "increment useless gaps", group = "tag"}),
+    awful.key({ altkey, "Control" }, "-", function () lain.util.useless_gaps_resize(-1) end,
+              {description = "decrement useless gaps", group = "tag"}),
+
+    -- Dynamic tagging
+    awful.key({ modkey, "Shift" }, "n", function () lain.util.add_tag() end,
+              {description = "add new tag", group = "tag"}),
+    awful.key({ modkey, "Shift" }, "r", function () lain.util.rename_tag() end,
+              {description = "rename tag", group = "tag"}),
+    awful.key({ modkey, "Shift" }, "Left", function () lain.util.move_tag(-1) end,
+              {description = "move tag to the left", group = "tag"}),
+    awful.key({ modkey, "Shift" }, "Right", function () lain.util.move_tag(1) end,
+              {description = "move tag to the right", group = "tag"}),
+    awful.key({ modkey, "Shift" }, "d", function () lain.util.delete_tag() end,
+              {description = "delete tag", group = "tag"}),
+
+    -- Standard program
+    awful.key({ modkey,           }, "Return", function () awful.spawn(terminal) end,
+              {description = "open a terminal", group = "launcher"}),
+    awful.key({ modkey, "Control" }, "r", awesome.restart,
+              {description = "reload awesome", group = "awesome"}),
+    awful.key({ modkey, "Shift"   }, "q", awesome.quit,
+              {description = "quit awesome", group = "awesome"}),
+
+    awful.key({ modkey, altkey    }, "l",     function () awful.tag.incmwfact( 0.05)          end,
+              {description = "increase master width factor", group = "layout"}),
+    awful.key({ modkey, altkey    }, "h",     function () awful.tag.incmwfact(-0.05)          end,
+              {description = "decrease master width factor", group = "layout"}),
+    awful.key({ modkey, "Shift"   }, "h",     function () awful.tag.incnmaster( 1, nil, true) end,
+              {description = "increase the number of master clients", group = "layout"}),
+    awful.key({ modkey, "Shift"   }, "l",     function () awful.tag.incnmaster(-1, nil, true) end,
+              {description = "decrease the number of master clients", group = "layout"}),
+    awful.key({ modkey, "Control" }, "h",     function () awful.tag.incncol( 1, nil, true)    end,
+              {description = "increase the number of columns", group = "layout"}),
+    awful.key({ modkey, "Control" }, "l",     function () awful.tag.incncol(-1, nil, true)    end,
+              {description = "decrease the number of columns", group = "layout"}),
+    awful.key({ modkey,           }, "space", function () awful.layout.inc( 1)                end,
+              {description = "select next", group = "layout"}),
+    awful.key({ modkey, "Shift"   }, "space", function () awful.layout.inc(-1)                end,
+              {description = "select previous", group = "layout"}),
+
+    awful.key({ modkey, "Control" }, "n", function ()
+        local c = awful.client.restore()
+        -- Focus restored client
+        if c then
+            c:emit_signal("request::activate", "key.unminimize", {raise = true})
+        end
+    end, {description = "restore minimized", group = "client"}),
+
+    -- Dropdown application
+    awful.key({ modkey, }, "z", function () awful.screen.focused().quake:toggle() end,
+              {description = "dropdown application", group = "launcher"}),
+
+    -- Widgets popups
+    awful.key({ altkey, }, "c", function () if beautiful.cal then beautiful.cal.show(7) end end,
+              {description = "show calendar", group = "widgets"}),
+    awful.key({ altkey, }, "h", function () if beautiful.fs then beautiful.fs.show(7) end end,
+              {description = "show filesystem", group = "widgets"}),
+    awful.key({ altkey, }, "w", function () if beautiful.weather then beautiful.weather.show(7) end end,
+              {description = "show weather", group = "widgets"}),
+
+    -- Screen brightness
+    awful.key({ }, "XF86MonBrightnessUp", function () os.execute("xbacklight -inc 10") end,
+              {description = "+10%", group = "hotkeys"}),
+    awful.key({ }, "XF86MonBrightnessDown", function () os.execute("xbacklight -dec 10") end,
+              {description = "-10%", group = "hotkeys"}),
+
+    -- ALSA volume control
+    awful.key({ altkey }, "Up",
+        function ()
+            os.execute(string.format("amixer -q set %s 1%%+", beautiful.volume.channel))
+            beautiful.volume.update()
+        end,
+        {description = "volume up", group = "hotkeys"}),
+    awful.key({ altkey }, "Down",
+        function ()
+            os.execute(string.format("amixer -q set %s 1%%-", beautiful.volume.channel))
+            beautiful.volume.update()
+        end,
+        {description = "volume down", group = "hotkeys"}),
+    awful.key({ altkey }, "m",
+        function ()
+            os.execute(string.format("amixer -q set %s toggle", beautiful.volume.togglechannel or beautiful.volume.channel))
+            beautiful.volume.update()
+        end,
+        {description = "toggle mute", group = "hotkeys"}),
+    awful.key({ altkey, "Control" }, "m",
+        function ()
+            os.execute(string.format("amixer -q set %s 100%%", beautiful.volume.channel))
+            beautiful.volume.update()
+        end,
+        {description = "volume 100%", group = "hotkeys"}),
+    awful.key({ altkey, "Control" }, "0",
+        function ()
+            os.execute(string.format("amixer -q set %s 0%%", beautiful.volume.channel))
+            beautiful.volume.update()
+        end,
+        {description = "volume 0%", group = "hotkeys"}),
+
+    -- MPD control
+    awful.key({ altkey, "Control" }, "Up",
+        function ()
+            os.execute("mpc toggle")
+            beautiful.mpd.update()
+        end,
+        {description = "mpc toggle", group = "widgets"}),
+    awful.key({ altkey, "Control" }, "Down",
+        function ()
+            os.execute("mpc stop")
+            beautiful.mpd.update()
+        end,
+        {description = "mpc stop", group = "widgets"}),
+    awful.key({ altkey, "Control" }, "Left",
+        function ()
+            os.execute("mpc prev")
+            beautiful.mpd.update()
+        end,
+        {description = "mpc prev", group = "widgets"}),
+    awful.key({ altkey, "Control" }, "Right",
+        function ()
+            os.execute("mpc next")
+            beautiful.mpd.update()
+        end,
+        {description = "mpc next", group = "widgets"}),
+    awful.key({ altkey }, "0",
+        function ()
+            local common = { text = "MPD widget ", position = "top_middle", timeout = 2 }
+            if beautiful.mpd.timer.started then
+                beautiful.mpd.timer:stop()
+                common.text = common.text .. lain.util.markup.bold("OFF")
+            else
+                beautiful.mpd.timer:start()
+                common.text = common.text .. lain.util.markup.bold("ON")
+            end
+            naughty.notify(common)
+        end,
+        {description = "mpc on/off", group = "widgets"}),
+
+    -- Copy primary to clipboard (terminals to gtk)
+    awful.key({ modkey }, "c", function () awful.spawn.with_shell("xsel | xsel -i -b") end,
+              {description = "copy terminal to gtk", group = "hotkeys"}),
+    -- Copy clipboard to primary (gtk to terminals)
+    awful.key({ modkey }, "v", function () awful.spawn.with_shell("xsel -b | xsel") end,
+              {description = "copy gtk to terminal", group = "hotkeys"}),
+
+    -- User programs
+    awful.key({ modkey }, "q", function () awful.spawn(browser) end,
+              {description = "run browser", group = "launcher"}),
+
+    -- Default
+    --[[ Menubar
+    awful.key({ modkey }, "p", function() menubar.show() end,
+              {description = "show the menubar", group = "launcher"}),
+    --]]
+    --[[ dmenu
+    awful.key({ modkey }, "x", function ()
+            os.execute(string.format("dmenu_run -i -fn 'Monospace' -nb '%s' -nf '%s' -sb '%s' -sf '%s'",
+            beautiful.bg_normal, beautiful.fg_normal, beautiful.bg_focus, beautiful.fg_focus))
+        end,
+        {description = "show dmenu", group = "launcher"}),
+    --]]
+    -- alternatively use rofi, a dmenu-like application with more features
+    -- check https://github.com/DaveDavenport/rofi for more details
+    --[[ rofi
+    awful.key({ modkey }, "x", function ()
+            os.execute(string.format("rofi -show %s -theme %s",
+            'run', 'dmenu'))
+        end,
+        {description = "show rofi", group = "launcher"}),
+    --]]
+    -- Prompt
+    awful.key({ modkey }, "r", function () awful.screen.focused().mypromptbox:run() end,
+              {description = "run prompt", group = "launcher"}),
+
+    awful.key({ modkey }, "x",
+              function ()
+                  awful.prompt.run {
+                    prompt       = "Run Lua code: ",
+                    textbox      = awful.screen.focused().mypromptbox.widget,
+                    exe_callback = awful.util.eval,
+                    history_path = awful.util.get_cache_dir() .. "/history_eval"
+                  }
+              end,
+              {description = "lua execute prompt", group = "awesome"})
+    --]]
+)
+
+clientkeys = mytable.join(
+    awful.key({ altkey, "Shift"   }, "m",      lain.util.magnify_client,
+              {description = "magnify client", group = "client"}),
+    awful.key({ modkey,           }, "f",
+        function (c)
+            c.fullscreen = not c.fullscreen
+            c:raise()
+        end,
+        {description = "toggle fullscreen", group = "client"}),
+    awful.key({ modkey, "Shift"   }, "c",      function (c) c:kill()                         end,
+              {description = "close", group = "client"}),
+    awful.key({ modkey, "Control" }, "space",  awful.client.floating.toggle                     ,
+              {description = "toggle floating", group = "client"}),
+    awful.key({ modkey, "Control" }, "Return", function (c) c:swap(awful.client.getmaster()) end,
+              {description = "move to master", group = "client"}),
+    awful.key({ modkey,           }, "o",      function (c) c:move_to_screen()               end,
+              {description = "move to screen", group = "client"}),
+    awful.key({ modkey,           }, "t",      function (c) c.ontop = not c.ontop            end,
+              {description = "toggle keep on top", group = "client"}),
+    awful.key({ modkey,           }, "n",
+        function (c)
+            -- The client currently has the input focus, so it cannot be
+            -- minimized, since minimized clients can't have the focus.
+            c.minimized = true
+        end ,
+        {description = "minimize", group = "client"}),
+    awful.key({ modkey,           }, "m",
+        function (c)
+            c.maximized = not c.maximized
+            c:raise()
+        end ,
+        {description = "(un)maximize", group = "client"}),
+    awful.key({ modkey, "Control" }, "m",
+        function (c)
+            c.maximized_vertical = not c.maximized_vertical
+            c:raise()
+        end ,
+        {description = "(un)maximize vertically", group = "client"}),
+    awful.key({ modkey, "Shift"   }, "m",
+        function (c)
+            c.maximized_horizontal = not c.maximized_horizontal
+            c:raise()
+        end ,
+        {description = "(un)maximize horizontally", group = "client"})
+)
+
+-- Bind all key numbers to tags.
+-- Be careful: we use keycodes to make it work on any keyboard layout.
+-- This should map on the top row of your keyboard, usually 1 to 9.
+for i = 1, 9 do
+    globalkeys = mytable.join(globalkeys,
+        -- View tag only.
+        awful.key({ modkey }, "#" .. i + 9,
+                  function ()
+                        local screen = awful.screen.focused()
+                        local tag = screen.tags[i]
+                        if tag then
+                           tag:view_only()
+                        end
+                  end,
+                  {description = "view tag #"..i, group = "tag"}),
+        -- Toggle tag display.
+        awful.key({ modkey, "Control" }, "#" .. i + 9,
+                  function ()
+                      local screen = awful.screen.focused()
+                      local tag = screen.tags[i]
+                      if tag then
+                         awful.tag.viewtoggle(tag)
+                      end
+                  end,
+                  {description = "toggle tag #" .. i, group = "tag"}),
+        -- Move client to tag.
+        awful.key({ modkey, "Shift" }, "#" .. i + 9,
+                  function ()
+                      if client.focus then
+                          local tag = client.focus.screen.tags[i]
+                          if tag then
+                              client.focus:move_to_tag(tag)
+                          end
+                     end
+                  end,
+                  {description = "move focused client to tag #"..i, group = "tag"}),
+        -- Toggle tag on focused client.
+        awful.key({ modkey, "Control", "Shift" }, "#" .. i + 9,
+                  function ()
+                      if client.focus then
+                          local tag = client.focus.screen.tags[i]
+                          if tag then
+                              client.focus:toggle_tag(tag)
+                          end
+                      end
+                  end,
+                  {description = "toggle focused client on tag #" .. i, group = "tag"})
+    )
+end
+
+clientbuttons = mytable.join(
+    awful.button({ }, 1, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+    end),
+    awful.button({ modkey }, 1, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+        awful.mouse.client.move(c)
+    end),
+    awful.button({ modkey }, 3, function (c)
+        c:emit_signal("request::activate", "mouse_click", {raise = true})
+        awful.mouse.client.resize(c)
+    end)
+)
+
+-- Set keys
+root.keys(globalkeys)
+
+-- }}}
+
+-- {{{ Rules
+
+-- Rules to apply to new clients (through the "manage" signal).
+awful.rules.rules = {
+    -- All clients will match this rule.
+    { rule = { },
+      properties = { border_width = beautiful.border_width,
+                     border_color = beautiful.border_normal,
+                     callback = awful.client.setslave,
+                     focus = awful.client.focus.filter,
+                     raise = true,
+                     keys = clientkeys,
+                     buttons = clientbuttons,
+                     screen = awful.screen.preferred,
+                     placement = awful.placement.no_overlap+awful.placement.no_offscreen,
+                     size_hints_honor = false
+     }
+    },
+
+    -- Floating clients.
+    { rule_any = {
+        instance = {
+          "DTA",  -- Firefox addon DownThemAll.
+          "copyq",  -- Includes session name in class.
+          "pinentry",
+        },
+        class = {
+          "Arandr",
+          "Blueman-manager",
+          "Gpick",
+          "Kruler",
+          "MessageWin",  -- kalarm.
+          "Sxiv",
+          "Tor Browser", -- Needs a fixed window size to avoid fingerprinting by screen size.
+          "Wpa_gui",
+          "veromix",
+          "xtightvncviewer"},
+
+        -- Note that the name property shown in xprop might be set slightly after creation of the client
+        -- and the name shown there might not match defined rules here.
+        name = {
+          "Event Tester",  -- xev.
+        },
+        role = {
+          "AlarmWindow",  -- Thunderbird's calendar.
+          "ConfigManager",  -- Thunderbird's about:config.
+          "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
+        }
+      }, properties = { floating = true }},
+
+    -- Add titlebars to normal clients and dialogs
+    { rule_any = {type = { "normal", "dialog" }
+      }, properties = { titlebars_enabled = true }
+    },
+
+    -- Set Firefox to always map on the tag named "2" on screen 1.
+    -- { rule = { class = "Firefox" },
+    --   properties = { screen = 1, tag = "2" } },
+}
+
+-- }}}
+
+-- {{{ Signals
+
+-- Signal function to execute when a new client appears.
+client.connect_signal("manage", function (c)
+    -- Set the windows at the slave,
+    -- i.e. put it at the end of others instead of setting it master.
+    -- if not awesome.startup then awful.client.setslave(c) end
+
+    if awesome.startup
+      and not c.size_hints.user_position
+      and not c.size_hints.program_position then
+        -- Prevent clients from being unreachable after screen count changes.
+        awful.placement.no_offscreen(c)
+    end
+end)
+
+-- Add a titlebar if titlebars_enabled is set to true in the rules.
+client.connect_signal("request::titlebars", function(c)
+    -- Custom
+    if beautiful.titlebar_fun then
+        beautiful.titlebar_fun(c)
+        return
+    end
+
+    -- Default
+    -- buttons for the titlebar
+    local buttons = mytable.join(
+        awful.button({ }, 1, function()
+            c:emit_signal("request::activate", "titlebar", {raise = true})
+            awful.mouse.client.move(c)
+        end),
+        awful.button({ }, 3, function()
+            c:emit_signal("request::activate", "titlebar", {raise = true})
+            awful.mouse.client.resize(c)
+        end)
+    )
+
+    awful.titlebar(c, { size = 16 }) : setup {
+        { -- Left
+            awful.titlebar.widget.iconwidget(c),
+            buttons = buttons,
+            layout  = wibox.layout.fixed.horizontal
+        },
+        { -- Middle
+            { -- Title
+                align  = "center",
+                widget = awful.titlebar.widget.titlewidget(c)
+            },
+            buttons = buttons,
+            layout  = wibox.layout.flex.horizontal
+        },
+        { -- Right
+            awful.titlebar.widget.floatingbutton (c),
+            awful.titlebar.widget.maximizedbutton(c),
+            awful.titlebar.widget.stickybutton   (c),
+            awful.titlebar.widget.ontopbutton    (c),
+            awful.titlebar.widget.closebutton    (c),
+            layout = wibox.layout.fixed.horizontal()
+        },
+        layout = wibox.layout.align.horizontal
+    }
+end)
+
+-- Enable sloppy focus, so that focus follows mouse.
+client.connect_signal("mouse::enter", function(c)
+    c:emit_signal("request::activate", "mouse_enter", {raise = vi_focus})
+end)
+
+client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
+client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)
+
+-- switch to parent after closing child window
+local function backham()
+    local s = awful.screen.focused()
+    local c = awful.client.focus.history.get(s, 0)
+    if c then
+        client.focus = c
+        c:raise()
+    end
+end
+
+-- attach to minimized state
+client.connect_signal("property::minimized", backham)
+-- attach to closed state
+client.connect_signal("unmanage", backham)
+-- ensure there is always a selected client during tag switching or logins
+tag.connect_signal("property::selected", backham)
+
+-- }}}
diff --git a/rules.lua b/rules.lua
deleted file mode 100755
index d73ef50..0000000
--- a/rules.lua
+++ /dev/null
@@ -1,75 +0,0 @@
-local awful = require("awful")
-local beautiful = require("beautiful")
-
-
--- Rules to apply to new clients (through the "manage" signal).
-awful.rules.rules = {
-    -- All clients will match this rule.
-    { rule = { },
-      properties = { border_width = beautiful.border_width,
-                     border_color = beautiful.border_normal,
-                     focus = awful.client.focus.filter,
-                     raise = true,
-                     keys = ClientKeys,
-                     buttons = ClientButtons,
-                     screen = awful.screen.preferred,
-                     placement = awful.placement.no_overlap+awful.placement.no_offscreen
-     }
-    },
-
-    -- Floating clients.
-    { rule_any = {
-        instance = {
-          "DTA",  -- Firefox addon DownThemAll.
-          "copyq",  -- Includes session name in class.
-          "pinentry",
-        },
-        class = {
-          "Arandr",
-          "Blueman-manager",
-          "Gpick",
-          "Kruler",
-          "MessageWin",  -- kalarm.
-          --"Sxiv",
-          "Tor Browser", -- Needs a fixed window size to avoid fingerprinting by screen size.
-          "Wpa_gui",
-          "veromix",
-          "xtightvncviewer"},
-
-        -- Note that the name property shown in xprop might be set slightly after creation of the client
-        -- and the name shown there might not match defined rules here.
-        name = {
-          "Event Tester",  -- xev.
-        },
-        role = {
-          "AlarmWindow",  -- Thunderbird's calendar.
-          "ConfigManager",  -- Thunderbird's about:config.
-          "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
-        }
-      }, properties = { floating = true }},
-
-    -- place conky in background on primary screen
-    { rule = { class = "conky" },
-      properties = { focusable = false, screen = function() return screen.primary end,
-        placement = awful.placement.restore, new_tag = { hide = true, volatile = true }},
-      callback = function()
-        if not awful.rules.conky_signals_connected then
-          local function conky_restart()
-            awful.spawn("killall -SIGUSR1 conky", false)
-          end
-
-          -- restart conky when a screen is removed or its geometry changes, or when awesome restarts
-          screen.connect_signal("property::geometry", conky_restart)
-          screen.connect_signal("removed", conky_restart)
-          awesome.connect_signal("exit", conky_restart)
-
-          awful.rules.conky_signals_connected = true
-        end
-      end
-    },
-
-    -- Set Firefox to always map on the tag named "2" on screen 1.
-    -- This is just an example.
-    -- { rule = { class = "Firefox" },
-    --   properties = { screen = 1, tag = "2" } },
-}
diff --git a/screens.lua b/screens.lua
deleted file mode 100755
index a2d5ba9..0000000
--- a/screens.lua
+++ /dev/null
@@ -1,59 +0,0 @@
-local awful = require("awful")
-local beautiful = require("beautiful")
-local gears = require("gears")
-local bar = require("bar.bar")
-
-local function set_wallpaper(s)
-    -- Wallpaper
-    if beautiful.wallpaper then
-        local wallpaper = beautiful.wallpaper
-        -- If wallpaper is a function, call it with the screen
-        if type(wallpaper) == "function" then
-            wallpaper = wallpaper(s)
-        end
-        gears.wallpaper.maximized(wallpaper, s, false)
-    elseif beautiful.wallpaper_color then
-        gears.wallpaper.set(beautiful.wallpaper_color)
-    elseif beautiful.wallpaper_folder then
-        local f = io.popen("sh -c \"find ".. beautiful.wallpaper_folder .. " -name '*.png' | shuf -n 1 | xargs echo -n\"")
-        if f == nil then
-            return
-        end
-        local wallpaper = f:read("*all")
-        f:close()
-        gears.wallpaper.maximized(wallpaper, s, false)
-    end
-end
-
--- Re-set wallpaper when a screen's geometry changes (e.g. different resolution)
-screen.connect_signal("property::geometry", set_wallpaper)
-
--- Table of layouts to cover with awful.layout.inc, order matters.
-awful.layout.layouts = {
-    -- awful.layout.suit.floating,
-    awful.layout.suit.tile,
-    awful.layout.suit.tile.left,
-    -- awful.layout.suit.tile.bottom,
-    -- awful.layout.suit.tile.top,
-    awful.layout.suit.fair,
-    -- awful.layout.suit.fair.horizontal,
-    -- awful.layout.suit.spiral,
-    -- awful.layout.suit.spiral.dwindle,
-    -- awful.layout.suit.max,
-    -- awful.layout.suit.max.fullscreen,
-    -- awful.layout.suit.magnifier,
-    -- awful.layout.suit.corner.nw,
-    -- awful.layout.suit.corner.ne,
-    -- awful.layout.suit.corner.sw,
-    -- awful.layout.suit.corner.se,
-}
-
-awful.screen.connect_for_each_screen(function(s)
-    -- Wallpaper
-    set_wallpaper(s)
-
-    bar(s)
-
-    -- Each screen has its own tag table.
-    awful.tag({ "1", "2", "3", "4", "5", "6" }, s, awful.layout.layouts[1])
-end)
diff --git a/signals.lua b/signals.lua
deleted file mode 100755
index 76dfff5..0000000
--- a/signals.lua
+++ /dev/null
@@ -1,19 +0,0 @@
-local awful = require("awful")
-local beautiful = require("beautiful")
-
--- Signal function to execute when a new client appears.
-client.connect_signal("manage", function (c)
-    -- Set the windows at the slave,
-    -- i.e. put it at the end of others instead of setting it master.
-    if not awesome.startup then awful.client.setslave(c) end
-
-    if awesome.startup
-      and not c.size_hints.user_position
-      and not c.size_hints.program_position then
-        -- Prevent clients from being unreachable after screen count changes.
-        awful.placement.no_offscreen(c)
-    end
-end)
-
-client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
-client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)
diff --git a/theme/theme.lua b/theme/theme.lua
deleted file mode 100755
index 5c661f3..0000000
--- a/theme/theme.lua
+++ /dev/null
@@ -1,98 +0,0 @@
----------------------------
--- Gruvbox awesome theme --
----------------------------
-
-local gears = require("gears")
-
-local theme = {}
-
-theme.background = "#282828"
-theme.foreground = "#ebdbb2"
-theme.color0 = "#3c3836"
-theme.color1 = "#cc241d"
-theme.color2 = "#98971a"
-theme.color3 = "#d79921"
-theme.color4 = "#458588"
-theme.color5 = "#b16286"
-theme.color6 = "#689d6a"
-theme.color7 = "#a89984"
-theme.color8 = "#928374"
-theme.color9 = "#fb4934"
-theme.color10 = "#b8bb26"
-theme.color11 = "#fabd2f"
-theme.color12 = "#83a598"
-theme.color13 = "#d3869b"
-theme.color14 = "#8ec07c"
-theme.color15 = "#fbf1c7"
-theme.cursor = "#bdae93"
-
-
-theme.bg_accent = theme.color0
-theme.fg_accent = theme.color11
-theme.fg_inactive = theme.color14
-
--- ADD THE GAAAAP
-theme.useless_gap = 5
-theme.gap_single_client = true
-
-theme.bar_bg = theme.background
-theme.bar_fg = theme.foreground
-
-theme.font          = "FantasqueSansM Nerd Font 8"
-theme.bar_height    = 18
-
-theme.bg_normal     = theme.background
-theme.bg_focus      = theme.background
-theme.bg_urgent     = theme.background
-theme.bg_minimize   = theme.background
-theme.bg_systray    = theme.background
-
-theme.fg_normal     = theme.foreground
-theme.fg_focus      = theme.foreground
-theme.fg_urgent     = theme.foreground
-theme.fg_minimize   = theme.foreground
-
-theme.border_width  = 2
-theme.border_normal = theme.color8
-theme.border_focus  = theme.color15
-theme.border_marked = "#91231c"
-
-theme.notification_border_color = theme.color8
-theme.notification_border_width = 2
-theme.notification_max_width = 500
-theme.notification_max_height = 100
-theme.notification_icon_size = 100
-
-theme.taglist_fg_focus = theme.foreground
-theme.taglist_fg_occupied = theme.foreground
-theme.taglist_fg_empty = theme.fg_inactive
-theme.taglist_bg_focus = theme.bg_accent
-
-theme.tasklist_fg_focus = theme.color15
-theme.tasklist_fg_normal = theme.color14
-
-theme.titlebar_fg_focus = theme.color15
-theme.titlebar_fg_normal = theme.color14
-
--- theme.wallpaper = "~/.config/awesome/theme/walls/railway.jpg"
--- theme.wallpaper = "~/.config/awesome/theme/walls/calvin.png"
--- theme.wallpaper = "~/.config/awesome/theme/walls/mountain-night-3.jpg"
--- theme.wallpaper = "~/.config/awesome/theme/walls/mtn.jpg"
-theme.wallpaper = "~/.config/awesome/theme/walls/foggy-forest-3.jpg"
--- function theme.wallpaper(s)
---     -- XXX: Tilde expansion doesn't work here
---     local awesome_conf_dir = gears.filesystem.get_configuration_dir()
---     if s.geometry.width == 2560 and s.geometry.height == 1080 then
---         return awesome_conf_dir .. "theme/walls/foggy-forest-3.jpg"
---     else
---         return  awesome_conf_dir .. "theme/walls/leaves-dark.jpg"
---     end
--- end
--- theme.wallpaper_color = "#1d2021"
--- theme.wallpaper_folder = "~/.config/awesome/theme/walls/"
-
--- Variable used by `~/.config/scripts/lock`.
--- If this isn't set, the lock script will use the lock.png image.
-theme.lockwall = "~/.config/awesome/theme/walls/foggy-forest-3.jpg"
-
-return theme
diff --git a/theme/walls/astronaut.jpg b/theme/walls/astronaut.jpg
deleted file mode 100644
index 37614bb..0000000
Binary files a/theme/walls/astronaut.jpg and /dev/null differ
diff --git a/theme/walls/blue-mountains.jpg b/theme/walls/blue-mountains.jpg
deleted file mode 100644
index a62909f..0000000
Binary files a/theme/walls/blue-mountains.jpg and /dev/null differ
diff --git a/theme/walls/calvin.png b/theme/walls/calvin.png
deleted file mode 100644
index 145971b..0000000
Binary files a/theme/walls/calvin.png and /dev/null differ
diff --git a/theme/walls/flower.jpg b/theme/walls/flower.jpg
deleted file mode 100644
index 9720294..0000000
Binary files a/theme/walls/flower.jpg and /dev/null differ
diff --git a/theme/walls/foggy-forest-2.jpg b/theme/walls/foggy-forest-2.jpg
deleted file mode 100644
index 9f93ce7..0000000
Binary files a/theme/walls/foggy-forest-2.jpg and /dev/null differ
diff --git a/theme/walls/foggy-forest-3.jpg b/theme/walls/foggy-forest-3.jpg
deleted file mode 100644
index 590f063..0000000
Binary files a/theme/walls/foggy-forest-3.jpg and /dev/null differ
diff --git a/theme/walls/foggy-forest-4.jpg b/theme/walls/foggy-forest-4.jpg
deleted file mode 100644
index 1551a09..0000000
Binary files a/theme/walls/foggy-forest-4.jpg and /dev/null differ
diff --git a/theme/walls/foggy-forest.jpg b/theme/walls/foggy-forest.jpg
deleted file mode 100644
index 845c6d6..0000000
Binary files a/theme/walls/foggy-forest.jpg and /dev/null differ
diff --git a/theme/walls/forest-house.png b/theme/walls/forest-house.png
deleted file mode 100644
index 06909ee..0000000
Binary files a/theme/walls/forest-house.png and /dev/null differ
diff --git a/theme/walls/leaves.jpg b/theme/walls/leaves.jpg
deleted file mode 100644
index ca5253c..0000000
Binary files a/theme/walls/leaves.jpg and /dev/null differ
diff --git a/theme/walls/lock.png b/theme/walls/lock.png
deleted file mode 100644
index 8fb4ee7..0000000
Binary files a/theme/walls/lock.png and /dev/null differ
diff --git a/theme/walls/mountain-night-2.jpg b/theme/walls/mountain-night-2.jpg
deleted file mode 100644
index 082a156..0000000
Binary files a/theme/walls/mountain-night-2.jpg and /dev/null differ
diff --git a/theme/walls/mountain-night-3.jpg b/theme/walls/mountain-night-3.jpg
deleted file mode 100644
index 6ff3691..0000000
Binary files a/theme/walls/mountain-night-3.jpg and /dev/null differ
diff --git a/theme/walls/mountain-night-4.png b/theme/walls/mountain-night-4.png
deleted file mode 100644
index 290400d..0000000
Binary files a/theme/walls/mountain-night-4.png and /dev/null differ
diff --git a/theme/walls/mountain-night.png b/theme/walls/mountain-night.png
deleted file mode 100644
index 715327e..0000000
Binary files a/theme/walls/mountain-night.png and /dev/null differ
diff --git a/theme/walls/mtn.jpg b/theme/walls/mtn.jpg
deleted file mode 100644
index ced24c3..0000000
Binary files a/theme/walls/mtn.jpg and /dev/null differ
diff --git a/theme/walls/murky-peaks.jpg b/theme/walls/murky-peaks.jpg
deleted file mode 100644
index 9776f86..0000000
Binary files a/theme/walls/murky-peaks.jpg and /dev/null differ
diff --git a/theme/walls/night-city.jpg b/theme/walls/night-city.jpg
deleted file mode 100644
index b3a4472..0000000
Binary files a/theme/walls/night-city.jpg and /dev/null differ
diff --git a/theme/walls/nord-earth.jpg b/theme/walls/nord-earth.jpg
deleted file mode 100644
index 2687f6c..0000000
Binary files a/theme/walls/nord-earth.jpg and /dev/null differ
diff --git a/theme/walls/nord-earth.png b/theme/walls/nord-earth.png
deleted file mode 100644
index c23cdb6..0000000
Binary files a/theme/walls/nord-earth.png and /dev/null differ
diff --git a/theme/walls/nord-fish.png b/theme/walls/nord-fish.png
deleted file mode 100644
index c6eee14..0000000
Binary files a/theme/walls/nord-fish.png and /dev/null differ
diff --git a/theme/walls/nord-scenary.png b/theme/walls/nord-scenary.png
deleted file mode 100644
index 0152fa6..0000000
Binary files a/theme/walls/nord-scenary.png and /dev/null differ
diff --git a/theme/walls/nord-the-great-wave.png b/theme/walls/nord-the-great-wave.png
deleted file mode 100644
index 2b315fb..0000000
Binary files a/theme/walls/nord-the-great-wave.png and /dev/null differ
diff --git a/theme/walls/pixelmoon.png b/theme/walls/pixelmoon.png
deleted file mode 100644
index b885be1..0000000
Binary files a/theme/walls/pixelmoon.png and /dev/null differ
diff --git a/theme/walls/place.jpg b/theme/walls/place.jpg
deleted file mode 100644
index 057f492..0000000
Binary files a/theme/walls/place.jpg and /dev/null differ
diff --git a/theme/walls/planet.jpg b/theme/walls/planet.jpg
deleted file mode 100644
index 0b9acf7..0000000
Binary files a/theme/walls/planet.jpg and /dev/null differ
diff --git a/theme/walls/railway-2.jpg b/theme/walls/railway-2.jpg
deleted file mode 100644
index a53d2ce..0000000
Binary files a/theme/walls/railway-2.jpg and /dev/null differ
diff --git a/theme/walls/railway.jpg b/theme/walls/railway.jpg
deleted file mode 100644
index 4c4f0c6..0000000
Binary files a/theme/walls/railway.jpg and /dev/null differ
diff --git a/theme/walls/rocky.jpg b/theme/walls/rocky.jpg
deleted file mode 100644
index f7a549f..0000000
Binary files a/theme/walls/rocky.jpg and /dev/null differ
diff --git a/theme/walls/two-astronauts.png b/theme/walls/two-astronauts.png
deleted file mode 100644
index 124765e..0000000
Binary files a/theme/walls/two-astronauts.png and /dev/null differ
diff --git a/themes/multicolor/icons/ac.png b/themes/multicolor/icons/ac.png
new file mode 100755
index 0000000..272b832
Binary files /dev/null and b/themes/multicolor/icons/ac.png differ
diff --git a/themes/multicolor/icons/bat.png b/themes/multicolor/icons/bat.png
new file mode 100755
index 0000000..bd63927
Binary files /dev/null and b/themes/multicolor/icons/bat.png differ
diff --git a/themes/multicolor/icons/clock.png b/themes/multicolor/icons/clock.png
new file mode 100755
index 0000000..22aef71
Binary files /dev/null and b/themes/multicolor/icons/clock.png differ
diff --git a/themes/multicolor/icons/cpu.png b/themes/multicolor/icons/cpu.png
new file mode 100755
index 0000000..e3794ca
Binary files /dev/null and b/themes/multicolor/icons/cpu.png differ
diff --git a/themes/multicolor/icons/dish.png b/themes/multicolor/icons/dish.png
new file mode 100755
index 0000000..c71499b
Binary files /dev/null and b/themes/multicolor/icons/dish.png differ
diff --git a/themes/multicolor/icons/dwindle.png b/themes/multicolor/icons/dwindle.png
new file mode 100755
index 0000000..94d8382
Binary files /dev/null and b/themes/multicolor/icons/dwindle.png differ
diff --git a/themes/multicolor/icons/fairh.png b/themes/multicolor/icons/fairh.png
new file mode 100755
index 0000000..4468efc
Binary files /dev/null and b/themes/multicolor/icons/fairh.png differ
diff --git a/themes/multicolor/icons/fairv.png b/themes/multicolor/icons/fairv.png
new file mode 100755
index 0000000..7c8728e
Binary files /dev/null and b/themes/multicolor/icons/fairv.png differ
diff --git a/themes/multicolor/icons/floating.png b/themes/multicolor/icons/floating.png
new file mode 100755
index 0000000..7593a2a
Binary files /dev/null and b/themes/multicolor/icons/floating.png differ
diff --git a/themes/multicolor/icons/fs.png b/themes/multicolor/icons/fs.png
new file mode 100755
index 0000000..1c1b13e
Binary files /dev/null and b/themes/multicolor/icons/fs.png differ
diff --git a/themes/multicolor/icons/fullscreen.png b/themes/multicolor/icons/fullscreen.png
new file mode 100755
index 0000000..f63a69c
Binary files /dev/null and b/themes/multicolor/icons/fullscreen.png differ
diff --git a/themes/multicolor/icons/magnifier.png b/themes/multicolor/icons/magnifier.png
new file mode 100755
index 0000000..8819554
Binary files /dev/null and b/themes/multicolor/icons/magnifier.png differ
diff --git a/themes/multicolor/icons/mail.png b/themes/multicolor/icons/mail.png
new file mode 100755
index 0000000..25021f5
Binary files /dev/null and b/themes/multicolor/icons/mail.png differ
diff --git a/themes/multicolor/icons/max.png b/themes/multicolor/icons/max.png
new file mode 100755
index 0000000..4b6a8c3
Binary files /dev/null and b/themes/multicolor/icons/max.png differ
diff --git a/themes/multicolor/icons/mem.png b/themes/multicolor/icons/mem.png
new file mode 100755
index 0000000..d04ee11
Binary files /dev/null and b/themes/multicolor/icons/mem.png differ
diff --git a/themes/multicolor/icons/net_down.png b/themes/multicolor/icons/net_down.png
new file mode 100755
index 0000000..09433b1
Binary files /dev/null and b/themes/multicolor/icons/net_down.png differ
diff --git a/themes/multicolor/icons/net_up.png b/themes/multicolor/icons/net_up.png
new file mode 100755
index 0000000..395d014
Binary files /dev/null and b/themes/multicolor/icons/net_up.png differ
diff --git a/themes/multicolor/icons/note.png b/themes/multicolor/icons/note.png
new file mode 100755
index 0000000..2f41eb3
Binary files /dev/null and b/themes/multicolor/icons/note.png differ
diff --git a/themes/multicolor/icons/note_on.png b/themes/multicolor/icons/note_on.png
new file mode 100755
index 0000000..264d2c8
Binary files /dev/null and b/themes/multicolor/icons/note_on.png differ
diff --git a/themes/multicolor/icons/spiral.png b/themes/multicolor/icons/spiral.png
new file mode 100755
index 0000000..6a1ebf1
Binary files /dev/null and b/themes/multicolor/icons/spiral.png differ
diff --git a/themes/multicolor/icons/spkr.png b/themes/multicolor/icons/spkr.png
new file mode 100755
index 0000000..80c20b0
Binary files /dev/null and b/themes/multicolor/icons/spkr.png differ
diff --git a/themes/multicolor/icons/square_a.png b/themes/multicolor/icons/square_a.png
new file mode 100755
index 0000000..1774d95
Binary files /dev/null and b/themes/multicolor/icons/square_a.png differ
diff --git a/themes/multicolor/icons/square_b.png b/themes/multicolor/icons/square_b.png
new file mode 100755
index 0000000..b47e9f3
Binary files /dev/null and b/themes/multicolor/icons/square_b.png differ
diff --git a/themes/multicolor/icons/submenu.png b/themes/multicolor/icons/submenu.png
new file mode 100755
index 0000000..7c81cab
Binary files /dev/null and b/themes/multicolor/icons/submenu.png differ
diff --git a/themes/multicolor/icons/temp.png b/themes/multicolor/icons/temp.png
new file mode 100755
index 0000000..6c8f8bd
Binary files /dev/null and b/themes/multicolor/icons/temp.png differ
diff --git a/themes/multicolor/icons/tile.png b/themes/multicolor/icons/tile.png
new file mode 100755
index 0000000..64103d9
Binary files /dev/null and b/themes/multicolor/icons/tile.png differ
diff --git a/themes/multicolor/icons/tilebottom.png b/themes/multicolor/icons/tilebottom.png
new file mode 100755
index 0000000..9363636
Binary files /dev/null and b/themes/multicolor/icons/tilebottom.png differ
diff --git a/themes/multicolor/icons/tileleft.png b/themes/multicolor/icons/tileleft.png
new file mode 100755
index 0000000..9331898
Binary files /dev/null and b/themes/multicolor/icons/tileleft.png differ
diff --git a/themes/multicolor/icons/tiletop.png b/themes/multicolor/icons/tiletop.png
new file mode 100755
index 0000000..1cef886
Binary files /dev/null and b/themes/multicolor/icons/tiletop.png differ
diff --git a/themes/multicolor/icons/titlebar/close_focus.png b/themes/multicolor/icons/titlebar/close_focus.png
new file mode 100755
index 0000000..cd297db
Binary files /dev/null and b/themes/multicolor/icons/titlebar/close_focus.png differ
diff --git a/themes/multicolor/icons/titlebar/close_normal.png b/themes/multicolor/icons/titlebar/close_normal.png
new file mode 100755
index 0000000..5448ed8
Binary files /dev/null and b/themes/multicolor/icons/titlebar/close_normal.png differ
diff --git a/themes/multicolor/icons/titlebar/floating_focus_active.png b/themes/multicolor/icons/titlebar/floating_focus_active.png
new file mode 100755
index 0000000..ae5a8e2
Binary files /dev/null and b/themes/multicolor/icons/titlebar/floating_focus_active.png differ
diff --git a/themes/multicolor/icons/titlebar/floating_focus_inactive.png b/themes/multicolor/icons/titlebar/floating_focus_inactive.png
new file mode 100755
index 0000000..c54eb0c
Binary files /dev/null and b/themes/multicolor/icons/titlebar/floating_focus_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/floating_normal_active.png b/themes/multicolor/icons/titlebar/floating_normal_active.png
new file mode 100755
index 0000000..62342d1
Binary files /dev/null and b/themes/multicolor/icons/titlebar/floating_normal_active.png differ
diff --git a/themes/multicolor/icons/titlebar/floating_normal_inactive.png b/themes/multicolor/icons/titlebar/floating_normal_inactive.png
new file mode 100755
index 0000000..e2bbdfa
Binary files /dev/null and b/themes/multicolor/icons/titlebar/floating_normal_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/maximized_focus_active.png b/themes/multicolor/icons/titlebar/maximized_focus_active.png
new file mode 100755
index 0000000..957298b
Binary files /dev/null and b/themes/multicolor/icons/titlebar/maximized_focus_active.png differ
diff --git a/themes/multicolor/icons/titlebar/maximized_focus_inactive.png b/themes/multicolor/icons/titlebar/maximized_focus_inactive.png
new file mode 100755
index 0000000..1187229
Binary files /dev/null and b/themes/multicolor/icons/titlebar/maximized_focus_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/maximized_normal_active.png b/themes/multicolor/icons/titlebar/maximized_normal_active.png
new file mode 100755
index 0000000..a705f81
Binary files /dev/null and b/themes/multicolor/icons/titlebar/maximized_normal_active.png differ
diff --git a/themes/multicolor/icons/titlebar/maximized_normal_inactive.png b/themes/multicolor/icons/titlebar/maximized_normal_inactive.png
new file mode 100755
index 0000000..4c1ab1f
Binary files /dev/null and b/themes/multicolor/icons/titlebar/maximized_normal_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/minimize_focus.png b/themes/multicolor/icons/titlebar/minimize_focus.png
new file mode 100755
index 0000000..bbe8cff
Binary files /dev/null and b/themes/multicolor/icons/titlebar/minimize_focus.png differ
diff --git a/themes/multicolor/icons/titlebar/minimize_normal.png b/themes/multicolor/icons/titlebar/minimize_normal.png
new file mode 100755
index 0000000..36621d0
Binary files /dev/null and b/themes/multicolor/icons/titlebar/minimize_normal.png differ
diff --git a/themes/multicolor/icons/titlebar/ontop_focus_active.png b/themes/multicolor/icons/titlebar/ontop_focus_active.png
new file mode 100755
index 0000000..25a3080
Binary files /dev/null and b/themes/multicolor/icons/titlebar/ontop_focus_active.png differ
diff --git a/themes/multicolor/icons/titlebar/ontop_focus_inactive.png b/themes/multicolor/icons/titlebar/ontop_focus_inactive.png
new file mode 100755
index 0000000..d3c077a
Binary files /dev/null and b/themes/multicolor/icons/titlebar/ontop_focus_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/ontop_normal_active.png b/themes/multicolor/icons/titlebar/ontop_normal_active.png
new file mode 100755
index 0000000..117a203
Binary files /dev/null and b/themes/multicolor/icons/titlebar/ontop_normal_active.png differ
diff --git a/themes/multicolor/icons/titlebar/ontop_normal_inactive.png b/themes/multicolor/icons/titlebar/ontop_normal_inactive.png
new file mode 100755
index 0000000..d3a10c8
Binary files /dev/null and b/themes/multicolor/icons/titlebar/ontop_normal_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/sticky_focus_active.png b/themes/multicolor/icons/titlebar/sticky_focus_active.png
new file mode 100755
index 0000000..147ce6a
Binary files /dev/null and b/themes/multicolor/icons/titlebar/sticky_focus_active.png differ
diff --git a/themes/multicolor/icons/titlebar/sticky_focus_inactive.png b/themes/multicolor/icons/titlebar/sticky_focus_inactive.png
new file mode 100755
index 0000000..396628a
Binary files /dev/null and b/themes/multicolor/icons/titlebar/sticky_focus_inactive.png differ
diff --git a/themes/multicolor/icons/titlebar/sticky_normal_active.png b/themes/multicolor/icons/titlebar/sticky_normal_active.png
new file mode 100755
index 0000000..bdb5595
Binary files /dev/null and b/themes/multicolor/icons/titlebar/sticky_normal_active.png differ
diff --git a/themes/multicolor/icons/titlebar/sticky_normal_inactive.png b/themes/multicolor/icons/titlebar/sticky_normal_inactive.png
new file mode 100755
index 0000000..a96b9b1
Binary files /dev/null and b/themes/multicolor/icons/titlebar/sticky_normal_inactive.png differ
diff --git a/themes/multicolor/theme.lua b/themes/multicolor/theme.lua
new file mode 100644
index 0000000..54a17e1
--- /dev/null
+++ b/themes/multicolor/theme.lua
@@ -0,0 +1,776 @@
+--[[
+
+     Multicolor Awesome WM theme 2.0
+     github.com/lcpz
+
+--]]
+
+local gears = require("gears")
+local lain  = require("lain")
+local awful = require("awful")
+local wibox = require("wibox")
+local dpi   = require("beautiful.xresources").apply_dpi
+
+local os = os
+local my_table = awful.util.table or gears.table -- 4.{0,1} compatibility
+
+local theme                                     = {}
+theme.confdir                                   = os.getenv("HOME") .. "/.config/awesome/themes/multicolor"
+theme.wallpaper                                 = theme.confdir .. "/wall.png"
+--theme.font                                      = "JetBrainsMono Nerd Font 11"
+theme.font                                      = "JetBrainsMono Nerd Font Bold 11"
+theme.taglist_font                              = "JetBrainsMono Nerd Font Bold 11"
+theme.menu_bg_normal                            = "#282828"
+theme.menu_bg_focus                             = "#282828"
+theme.bg_normal                                 = "#282828"
+theme.bg_focus                                  = "#282828"
+theme.bg_urgent                                 = "#282828"
+--theme.fg_normal                                 = "#aaaaaa"
+theme.fg_normal                                 = "#ebdbb2"
+--theme.fg_focus                                  = "#ff8c00"
+theme.fg_focus                                  = "#282828"
+theme.fg_urgent                                 = "#af1d18"
+theme.fg_minimize                               = "#ffffff"
+theme.border_width                              = dpi(1)
+theme.border_normal                             = "#1c2022"
+theme.border_focus                              = "#ebdbb2"
+theme.border_marked                             = "#3ca4d8"
+theme.menu_border_width                         = 0
+theme.menu_width                                = dpi(130)
+theme.menu_submenu_icon                         = theme.confdir .. "/icons/submenu.png"
+theme.menu_fg_normal                            = "#aaaaaa"
+theme.menu_fg_focus                             = "#ff8c00"
+theme.menu_bg_normal                            = "#050505dd"
+theme.menu_bg_focus                             = "#050505dd"
+theme.widget_temp                               = theme.confdir .. "/icons/temp.png"
+theme.widget_uptime                             = theme.confdir .. "/icons/ac.png"
+theme.widget_cpu                                = theme.confdir .. "/icons/cpu.png"
+theme.widget_weather                            = theme.confdir .. "/icons/dish.png"
+theme.widget_fs                                 = theme.confdir .. "/icons/fs.png"
+theme.widget_mem                                = theme.confdir .. "/icons/mem.png"
+theme.widget_note                               = theme.confdir .. "/icons/note.png"
+theme.widget_note_on                            = theme.confdir .. "/icons/note_on.png"
+--theme.widget_netdown                            = theme.confdir .. "/icons/net_down.png"
+--theme.widget_netup                              = theme.confdir .. "/icons/net_up.png"
+theme.widget_mail                               = theme.confdir .. "/icons/mail.png"
+theme.widget_batt                               = theme.confdir .. "/icons/bat.png"
+theme.widget_clock                              = theme.confdir .. "/icons/clock.png"
+--theme.widget_vol                                = theme.confdir .. "/icons/spkr.png"
+--theme.taglist_squares_sel                       = theme.confdir .. "/icons/square_a.png"
+--theme.taglist_squares_unsel                     = theme.confdir .. "/icons/square_b.png"
+theme.tasklist_plain_task_name                  = true
+theme.tasklist_disable_icon                     = true
+theme.useless_gap                               = 8
+theme.layout_txt_tile                           = "[t]"
+theme.layout_txt_tileleft                       = "[l]"
+theme.layout_txt_tilebottom                     = "[b]"
+theme.layout_txt_tiletop                        = "[tt]"
+theme.layout_txt_fairv                          = "[fv]"
+theme.layout_txt_fairh                          = "[fh]"
+theme.layout_txt_spiral                         = " [@]"
+theme.layout_txt_dwindle                        = "[d]"
+theme.layout_txt_max                            = "[m]"
+theme.layout_txt_fullscreen                     = "[F]"
+theme.layout_txt_magnifier                      = "[M]"
+theme.layout_txt_floating                       = "[*]"
+theme.layout_tile                               = theme.confdir .. "/icons/tile.png"
+theme.layout_tilegaps                           = theme.confdir .. "/icons/tilegaps.png"
+theme.layout_tileleft                           = theme.confdir .. "/icons/tileleft.png"
+theme.layout_tilebottom                         = theme.confdir .. "/icons/tilebottom.png"
+theme.layout_tiletop                            = theme.confdir .. "/icons/tiletop.png"
+theme.layout_fairv                              = theme.confdir .. "/icons/fairv.png"
+theme.layout_fairh                              = theme.confdir .. "/icons/fairh.png"
+theme.layout_spiral                             = theme.confdir .. "/icons/spiral.png"
+theme.layout_dwindle                            = theme.confdir .. "/icons/dwindle.png"
+theme.layout_max                                = theme.confdir .. "/icons/max.png"
+theme.layout_fullscreen                         = theme.confdir .. "/icons/fullscreen.png"
+theme.layout_magnifier                          = theme.confdir .. "/icons/magnifier.png"
+theme.layout_floating                           = theme.confdir .. "/icons/floating.png"
+theme.titlebar_close_button_normal              = theme.confdir .. "/icons/titlebar/close_normal.png"
+theme.titlebar_close_button_focus               = theme.confdir .. "/icons/titlebar/close_focus.png"
+theme.titlebar_minimize_button_normal           = theme.confdir .. "/icons/titlebar/minimize_normal.png"
+theme.titlebar_minimize_button_focus            = theme.confdir .. "/icons/titlebar/minimize_focus.png"
+theme.titlebar_ontop_button_normal_inactive     = theme.confdir .. "/icons/titlebar/ontop_normal_inactive.png"
+theme.titlebar_ontop_button_focus_inactive      = theme.confdir .. "/icons/titlebar/ontop_focus_inactive.png"
+theme.titlebar_ontop_button_normal_active       = theme.confdir .. "/icons/titlebar/ontop_normal_active.png"
+theme.titlebar_ontop_button_focus_active        = theme.confdir .. "/icons/titlebar/ontop_focus_active.png"
+theme.titlebar_sticky_button_normal_inactive    = theme.confdir .. "/icons/titlebar/sticky_normal_inactive.png"
+theme.titlebar_sticky_button_focus_inactive     = theme.confdir .. "/icons/titlebar/sticky_focus_inactive.png"
+theme.titlebar_sticky_button_normal_active      = theme.confdir .. "/icons/titlebar/sticky_normal_active.png"
+theme.titlebar_sticky_button_focus_active       = theme.confdir .. "/icons/titlebar/sticky_focus_active.png"
+theme.titlebar_floating_button_normal_inactive  = theme.confdir .. "/icons/titlebar/floating_normal_inactive.png"
+theme.titlebar_floating_button_focus_inactive   = theme.confdir .. "/icons/titlebar/floating_focus_inactive.png"
+theme.titlebar_floating_button_normal_active    = theme.confdir .. "/icons/titlebar/floating_normal_active.png"
+theme.titlebar_floating_button_focus_active     = theme.confdir .. "/icons/titlebar/floating_focus_active.png"
+theme.titlebar_maximized_button_normal_inactive = theme.confdir .. "/icons/titlebar/maximized_normal_inactive.png"
+theme.titlebar_maximized_button_focus_inactive  = theme.confdir .. "/icons/titlebar/maximized_focus_inactive.png"
+theme.titlebar_maximized_button_normal_active   = theme.confdir .. "/icons/titlebar/maximized_normal_active.png"
+theme.titlebar_maximized_button_focus_active    = theme.confdir .. "/icons/titlebar/maximized_focus_active.png"
+
+local markup = lain.util.markup
+
+-- Textclock
+os.setlocale(os.getenv("LANG")) -- to localize the clock
+--local clockicon = wibox.widget.imagebox(theme.widget_clock)
+local clockicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#8ec07c", "󰥔 "),
+    align = "center",
+    valign = "center"
+}
+
+--local mytextclock = wibox.widget.textclock(markup("#7788af", "%A %d %B ") .. markup("#ab7367", ">") .. markup("#de5e1e", " %H:%M "))
+
+--local mytextclock = wibox.widget.textclock(markup("#8ec07c", "%A %d %B ") .. markup("#8ec07c", "—") .. markup("#8ec07c", " %H:%M "))
+--mytextclock.font = theme.font
+
+local mytextclock = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#8ec07c", "Loading..."),
+    align = "center",
+    valign = "center",
+}
+
+-- Define a function to log clock updates
+local function log_clock_update(message)
+    local log_file = "/home/jonas/awesome_clock_update.log"
+    local log_entry = os.date("%Y-%m-%d %H:%M:%S") .. " - " .. message .. "\n"
+
+    local file = io.open(log_file, "a")
+    if file then
+        file:write(log_entry)
+        file:close()
+    else
+        print("Failed to open log file for writing: " .. log_file)
+    end
+end
+
+-- Define a function to update the clock widget
+local function update_clock_widget()
+    local script_path = "/home/jonas/.local/bin/statusbar/sb-clock"
+
+    awful.spawn.easy_async_with_shell(script_path, function(stdout, stderr)
+        if stderr and #stderr > 0 then
+            mytextclock:set_markup(markup.fontfg(theme.font, "#fb4934", "Error"))
+            --log_clock_update("Error: " .. stderr)
+            return
+        end
+
+        local output = stdout:gsub("^%s*(.-)%s*$", "%1") -- Trim whitespace
+        mytextclock:set_markup(markup.fontfg(theme.font, "#8ec07c", output .. " "))
+        --log_clock_update("Clock output updated: " .. output)
+    end)
+end
+
+-- Create a timer to update the clock widget every 30 seconds
+gears.timer({
+    timeout = 30,
+    autostart = true,
+    callback = update_clock_widget,
+})
+
+update_clock_widget()
+
+-- Calendar
+theme.cal = lain.widget.cal({
+    attach_to = { mytextclock },
+    notification_preset = {
+        font = "Terminus 10",
+        fg   = theme.fg_normal,
+        bg   = theme.bg_normal
+    }
+})
+
+-- Weather
+--local weathericon = wibox.widget.imagebox(theme.widget_weather)
+
+local gruvbox_blue = "#458588"
+local gruvbox_red = "#cc241d"
+local default_color = "#ebdbb2"
+
+local weathericon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, default_color, "   "),
+    align = "center",
+    valign = "center"
+}
+
+--theme.weather = lain.widget.weather({
+--    city_id = 2673730,
+--    notification_preset = { font = theme.font, fg = theme.fg_normal },
+--
+--    weather_na_markup = markup.fontfg(theme.font, "#ebdbb2", "N/A "),
+--    settings = function()
+--        descr = weather_now["weather"][1]["description"]:lower()
+--        units = math.floor(weather_now["main"]["temp"])
+--        widget:set_markup(markup.fontfg(theme.font, "#ebdbb2", descr .. " @ " .. units .. "°C "))
+--    end
+--})
+--theme.weather = lain.widget.weather({
+--    city_id = 2673730,
+--    notification_preset = { font = theme.font, fg = theme.fg_normal },
+--    weather_na_markup = markup.fontfg(theme.font, default_color, "N/A"),
+--
+--    settings = function()
+--        descr = weather_now["weather"][1]["description"]:lower()
+--        units = math.floor(weather_now["main"]["temp"])
+--
+--        local color
+--        if units < 0 then
+--            color = gruvbox_blue
+--        elseif units > 20 then
+--            color = gruvbox_red
+--        else
+--            color = default_color
+--        end
+--
+--        --widget:set_markup(markup.fontfg(theme.font, color, descr .. " @ " .. units .. "°C "))
+--        widget:set_markup(markup.fontfg(theme.font, color, units .. "°C "))
+--    end
+--})
+
+local weather_widget = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, default_color, "Loading..."),
+    align = "center",
+    valign = "center",
+}
+
+local function log_weather_update(message)
+    local log_file = "/home/jonas/awesome_weather_update.log"
+    local log_entry = os.date("%Y-%m-%d %H:%M:%S") .. " - " .. message .. "\n"
+
+    local file = io.open(log_file, "a")
+    if file then
+        file:write(log_entry)
+        file:close()
+    else
+        print("Failed to open log file for writing: " .. log_file)
+    end
+end
+
+local function update_weather_widget()
+    local script_path = "~/.local/bin/statusbar/weather"
+
+    awful.spawn.easy_async_with_shell(script_path, function(stdout, stderr)
+        if stderr and #stderr > 0 then
+            weather_widget:set_markup(markup.fontfg(theme.font, default_color, "Error"))
+            weathericon:set_markup(markup.fontfg(theme.font, default_color, "   "))
+            return
+        end
+
+        local output = stdout:gsub("^%s*(.-)%s*$", "%1") -- Trim whitespace
+        local units = tonumber(output:match("%-?%d+")) -- Extract numeric temperature
+        local color
+
+        if units then
+            if units < 0 then
+                color = gruvbox_blue
+            elseif units > 20 then
+                color = gruvbox_red
+            else
+                color = default_color
+            end
+            weather_widget:set_markup(markup.fontfg(theme.font, color, output))
+            weathericon:set_markup(markup.fontfg(theme.font, color, "   "))
+        else
+            weather_widget:set_markup(markup.fontfg(theme.font, default_color, output))
+            weathericon:set_markup(markup.fontfg(theme.font, default_color, "   "))
+        end
+
+        local log_message = "Weather output updated: " .. output
+        --log_weather_update(log_message)
+    end)
+end
+
+gears.timer({
+    timeout = 600,
+    autostart = true,
+    callback = update_weather_widget,
+})
+
+update_weather_widget()
+
+-- / fs
+--[[ commented because it needs Gio/Glib >= 2.54
+local fsicon = wibox.widget.imagebox(theme.widget_fs)
+theme.fs = lain.widget.fs({
+    notification_preset = { font = "Terminus 10", fg = theme.fg_normal },
+    settings  = function()
+        widget:set_markup(markup.fontfg(theme.font, "#80d9d8", string.format("%.1f", fs_now["/"].percentage) .. "% "))
+    end
+})
+--]]
+
+-- Mail IMAP check
+--[[ to be set before use
+local mailicon = wibox.widget.imagebox()
+theme.mail = lain.widget.imap({
+    timeout  = 180,
+    server   = "server",
+    mail     = "mail",
+    password = "keyring get mail",
+    settings = function()
+        if mailcount > 0 then
+            mailicon:set_image(theme.widget_mail)
+            widget:set_markup(markup.fontfg(theme.font, "#cccccc", mailcount .. " "))
+        else
+            widget:set_text("")
+            --mailicon:set_image() -- not working in 4.0
+            mailicon._private.image = nil
+            mailicon:emit_signal("widget::redraw_needed")
+            mailicon:emit_signal("widget::layout_changed")
+        end
+    end
+})
+--]]
+
+-- CPU
+--local cpuicon = wibox.widget.imagebox(theme.widget_cpu)
+
+local cpuicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#b16286", "  "),
+    align = "center",
+    valign = "center"
+}
+
+local cpu = lain.widget.cpu({
+    settings = function()
+        --widget:set_markup(markup.fontfg(theme.font, "#e33a6e", cpu_now.usage .. "% "))
+        widget:set_markup(markup.fontfg(theme.font, "#b16286", cpu_now.usage .. "% "))
+    end
+})
+
+-- Coretemp
+--local tempicon = wibox.widget.imagebox(theme.widget_temp)
+local tempicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#d79921", "  "),
+    align = "center",
+    valign = "center"
+}
+local temp = lain.widget.temp({
+    settings = function()
+        --widget:set_markup(markup.fontfg(theme.font, "#f1af5f", coretemp_now .. "°C "))
+        widget:set_markup(markup.fontfg(theme.font, "#d79921", coretemp_now .. "°C "))
+    end
+})
+
+-- Battery
+--local baticon = wibox.widget.imagebox(theme.widget_batt)
+local baticon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#d3869b", "  "),
+    align = "center",
+    valign = "center"
+}
+--local bat = lain.widget.bat({
+--    settings = function()
+--        local perc = bat_now.perc ~= "N/A" and bat_now.perc .. "%" or bat_now.perc
+--
+--        if bat_now.ac_status == 1 then
+--            perc = perc .. " plug"
+--        end
+--
+--        --widget:set_markup(markup.fontfg(theme.font, theme.fg_normal, perc .. " "))
+--        widget:set_markup(markup.fontfg(theme.font, "#d3869b", perc .. " "))
+--    end
+--})
+local bat = lain.widget.bat({
+    settings = function()
+        local perc = bat_now.perc ~= "N/A" and tonumber(bat_now.perc) or nil
+        local icon = " "
+
+        if bat_now.ac_status == 1 then
+            icon = "󰂄"
+        elseif perc then
+            -- Icons based on percentage
+            if perc >= 80 then
+                icon = " "
+            elseif perc >= 60 then
+                icon = " "
+            elseif perc >= 40 then
+                icon = " "
+            elseif perc >= 20 then
+                icon = " "
+            else
+                icon = " "
+            end
+        end
+
+        baticon:set_markup(markup.fontfg(theme.font, "#d3869b", " " .. icon .. " "))
+        widget:set_markup(markup.fontfg(theme.font, "#d3869b", (perc or "100") .. "%  "))
+    end
+})
+
+-- ALSA volume
+--local volicon = wibox.widget.imagebox(theme.widget_vol)
+local volicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#83a598", " 󰕾 "),
+    align = "center",
+    valign = "center"
+}
+theme.volume = lain.widget.alsa({
+    settings = function()
+        --if volume_now.status == "off" then
+        --  volume_now.level = volume_now.level .. "M"
+        --end
+        if volume_now.status == "off" then
+            volicon:set_markup(markup.fontfg(theme.font, "#83a598", " 󰖁 "))
+        else
+            volicon:set_markup(markup.fontfg(theme.font, "#83a598", " 󰕾 "))
+        end
+
+        widget:set_markup(markup.fontfg(theme.font, "#83a598", volume_now.level .. "% "))
+    end
+})
+
+-- Net
+--local netdownicon = wibox.widget.imagebox(theme.widget_netdown)
+local netdowninfo = wibox.widget.textbox()
+--local netupicon = wibox.widget.imagebox(theme.widget_netup)
+local netupinfo = lain.widget.net({
+    settings = function()
+        --if iface ~= "network off" and
+        --   string.match(theme.weather.widget.text, "N/A")
+        --then
+        --    theme.weather.update()
+        --end
+        --theme.weather.update()
+
+        --widget:set_markup(markup.fontfg(theme.font, "#e54c62", net_now.sent .. " "))
+        --netdowninfo:set_markup(markup.fontfg(theme.font, "#87af5f", net_now.received .. " "))
+        widget:set_markup(markup.fontfg(theme.font, "#fe8019", net_now.sent .. " "))
+        netdowninfo:set_markup(markup.fontfg(theme.font, "#689d6a", net_now.received .. " "))
+    end
+})
+
+local netupicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#fe8019", " "),
+    align = "center",
+    valign = "center"
+}
+
+local netdownicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#689d6a", "  "),
+    align = "center",
+    valign = "center"
+}
+
+-- MEM
+--local memicon = wibox.widget.imagebox(theme.widget_mem)
+local memicon = wibox.widget {
+    widget = wibox.widget.textbox,
+    markup = markup.fontfg(theme.font, "#fabd2f", " 󰍛 "),
+    align = "center",
+    valign = "center"
+}
+
+local memory = lain.widget.mem({
+    settings = function()
+        --widget:set_markup(markup.fontfg(theme.font, "#e0da37", mem_now.used .. "M "))
+        widget:set_markup(markup.fontfg(theme.font, "#fabd2f", mem_now.used .. "M "))
+    end
+})
+
+-- MPD
+local mpdicon = wibox.widget.imagebox()
+theme.mpd = lain.widget.mpd({
+    settings = function()
+        mpd_notification_preset = {
+            text = string.format("%s [%s] - %s\n%s", mpd_now.artist,
+                   mpd_now.album, mpd_now.date, mpd_now.title)
+        }
+
+        if mpd_now.state == "play" then
+            artist = mpd_now.artist .. " > "
+            title  = mpd_now.title .. " "
+            mpdicon:set_image(theme.widget_note_on)
+        elseif mpd_now.state == "pause" then
+            artist = "mpd "
+            title  = "paused "
+        else
+            artist = ""
+            title  = ""
+            --mpdicon:set_image() -- not working in 4.0
+            mpdicon._private.image = nil
+            mpdicon:emit_signal("widget::redraw_needed")
+            mpdicon:emit_signal("widget::layout_changed")
+        end
+        widget:set_markup(markup.fontfg(theme.font, "#e54c62", artist) .. markup.fontfg(theme.font, "#b2b2b2", title))
+    end
+})
+
+local spotify_widget = require("lain.widget.spotify-widget.spotify")
+
+local custom_spotify_widget = spotify_widget({
+    font = theme.font,
+    dim_when_paused = true,
+    dim_opacity = 0.5,
+    max_length = -1,
+})
+
+ -- Spotify widget with left, right, top, bottom margins
+local spotify_widget_with_margin = wibox.container.margin(custom_spotify_widget, 0, 3, 0, 0)
+
+local function update_txt_layoutbox(s)
+    -- Writes a string representation of the current layout in a textbox widget
+    local txt_l = theme["layout_txt_" .. awful.layout.getname(awful.layout.get(s))] or ""
+    s.mytxtlayoutbox:set_text(txt_l)
+end
+
+
+local my_config_path = os.getenv("HOME") .. "/.config/my_config.txt"
+
+local function read_config()
+  local file = io.open(my_config_path, "r")
+  if not file then
+    return nil -- Return nil if the file doesn't exist
+  end
+
+  local config = {}
+  for line in io.lines(my_config_path) do
+    local key, value = line:match("^%s*(%S+)%s*:%s*(%S+)%s*$")
+    if key and value then
+      config[key] = value:lower() -- Store values in lowercase for case-insensitive comparison
+    end
+  end
+  return config
+end
+
+local function write_config(key, value)
+  local lines = {}
+  local key_found = false
+
+  -- Read existing lines if file exists
+  local file = io.open(my_config_path, "r")
+  if file then
+    for line in file:lines() do
+      local existing_key = line:match("^%s*(%S+)%s*:")
+      if existing_key == key then
+        table.insert(lines, key .. ": " .. tostring(value))
+        key_found = true
+      else
+        table.insert(lines, line)
+      end
+    end
+    file:close()
+  end
+
+  -- If key is not found, append it
+  if not key_found then
+    table.insert(lines, key .. ": " .. tostring(value))
+  end
+
+  -- Write to file (create if not exists)
+  file = io.open(my_config_path, "w")
+  if not file then
+    error("Unable to open or create file: " .. my_config_path)
+  end
+
+  for _, line in ipairs(lines) do
+    file:write(line .. "\n")
+  end
+  file:close()
+end
+
+-- Modified toggle_widget_visibility function
+function toggle_widget_visibility(update_config)
+  update_config = update_config == nil or update_config -- Default to true if not specified
+
+  local widgets_to_toggle = {
+    netdownicon,
+    netdowninfo,
+    netupicon,
+    netupinfo.widget,
+    memicon,
+    memory.widget,
+    cpuicon,
+    cpu.widget,
+  }
+
+  for _, widget in ipairs(widgets_to_toggle) do
+    widget.visible = not widget.visible
+  end
+
+  if update_config then
+    local my_config = read_config()
+    local current_state = (my_config and my_config["awsm_bar_toggled"] == "true") or false
+    write_config("awsm_bar_toggled", tostring(not current_state))
+  end
+end
+
+function check_toggle_widget_visibility()
+  local my_config = read_config()
+
+  if my_config and my_config["awsm_bar_toggled"] == "true" then
+    toggle_widget_visibility(false) -- Do not update the file at startup
+  end
+end
+
+function theme.at_screen_connect(s)
+    -- Quake application
+    s.quake = lain.util.quake({ app = awful.util.terminal })
+
+    -- If wallpaper is a function, call it with the screen
+    local wallpaper = theme.wallpaper
+    if type(wallpaper) == "function" then
+        wallpaper = wallpaper(s)
+    end
+    gears.wallpaper.maximized(wallpaper, s, true)
+
+    -- Tags
+    awful.tag(awful.util.tagnames, s, awful.layout.layouts[1])
+
+    -- Create a promptbox for each screen
+    s.mypromptbox = awful.widget.prompt()
+    -- Create an imagebox widget which will contains an icon indicating which layout we're using.
+
+    -- We need one layoutbox per screen.
+    s.mytxtlayoutbox = wibox.widget.textbox(theme["layout_txt_" .. awful.layout.getname(awful.layout.get(s))])
+    awful.tag.attached_connect_signal(s, "property::selected", function () update_txt_layoutbox(s) end)
+    awful.tag.attached_connect_signal(s, "property::layout", function () update_txt_layoutbox(s) end)
+    s.mytxtlayoutbox:buttons(my_table.join(
+                           awful.button({}, 1, function() awful.layout.inc(1) end),
+                           awful.button({}, 2, function () awful.layout.set( awful.layout.layouts[1] ) end),
+                           awful.button({}, 3, function() awful.layout.inc(-1) end),
+                           awful.button({}, 4, function() awful.layout.inc(1) end),
+                           awful.button({}, 5, function() awful.layout.inc(-1) end)))
+
+    -- Create a taglist widget
+    --s.mytaglist = awful.widget.taglist(s, awful.widget.taglist.filter.all, awful.util.taglist_buttons)
+    --s.mytaglist = awful.widget.taglist {
+    --    screen = s,
+    --    filter = function (t) return t.selected or #t:clients() > 0 end,
+    --    --buttons = taglist_buttons
+    --}
+
+  local gruvbox_white = "#ebdbb2"
+  local gruvbox_black = "#282828"
+
+  -- Modify the taglist label function
+  local original_taglist_label = awful.widget.taglist.taglist_label
+
+  awful.widget.taglist.taglist_label = function(tag, args, tb)
+
+    -- Use the original taglist_label function
+    local text, bg, bg_image, icon, other_args = original_taglist_label(tag, args, tb)
+
+    -- Customize colors based on whether the tag is selected
+    if tag.selected then
+      bg = gruvbox_white
+      other_args.fg_focus = gruvbox_black
+    else
+      bg = gruvbox_black
+      other_args.fg_focus = gruvbox_white
+    end
+
+    return text, bg, bg_image, icon, other_args
+  end
+
+  -- https://awesomewm.org/doc/api/classes/wibox.widget.textbox.html
+  s.mytaglist = awful.widget.taglist {
+    screen = s,
+    filter = function(t) return t.selected or #t:clients() > 0 end,
+    layout = {
+      --spacing = 8,
+      --spacing = 2,
+      layout = wibox.layout.fixed.horizontal,
+    },
+    widget_template = {
+      {
+        {
+          id = "text_role",
+          widget = wibox.widget.textbox,
+        },
+        widget = wibox.container.place, -- Center the text
+        halign = "center", -- Horizontal alignment
+      },
+      id = "background_role",
+      widget = wibox.container.background,
+      forced_width = 30,
+    },
+  }
+
+    -- Create a tasklist widget
+    --s.mytasklist = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, awful.util.tasklist_buttons)
+
+    -- Create the wibox
+    s.mywibox = awful.wibar({ position = "top", screen = s, height = dpi(25), bg = theme.bg_normal, fg = theme.fg_normal })
+
+    -- Add widgets to the wibox
+    s.mywibox:setup {
+        layout = wibox.layout.align.horizontal,
+        { -- Left widgets
+            layout = wibox.layout.fixed.horizontal,
+            --s.mylayoutbox,
+            s.mytaglist,
+            s.mytxtlayoutbox,
+            --s.mypromptbox,
+            mpdicon,
+            theme.mpd.widget,
+        },
+        --s.mytasklist, -- Middle widget
+        nil,
+        { -- Right widgets
+            layout = wibox.layout.fixed.horizontal,
+            --wibox.widget.systray(),
+
+            --mailicon,
+            --theme.mail.widget,
+
+            --spotify_widget({
+            --    font = theme.font,
+            --    -- play_icon = '/usr/share/icons/Papirus-Light/24x24/categories/spotify.svg',
+            --    -- pause_icon = '/usr/share/icons/Papirus-Dark/24x24/panel/spotify-indicator.svg',
+            --    dim_when_paused = true,
+            --    dim_opacity = 0.5,
+            --    max_length = -1,
+            --}),
+            spotify_widget_with_margin,
+            netdownicon,
+            netdowninfo,
+            netupicon,
+            netupinfo.widget,
+            memicon,
+            memory.widget,
+            cpuicon,
+            cpu.widget,
+            --fsicon,
+            --theme.fs.widget,
+            weathericon,
+            --theme.weather.widget,
+            weather_widget,
+            tempicon,
+            temp.widget,
+            volicon,
+            theme.volume.widget,
+            baticon,
+            bat.widget,
+            clockicon,
+            mytextclock,
+        },
+    }
+
+    -- Create the bottom wibox
+    --s.mybottomwibox = awful.wibar({ position = "bottom", screen = s, border_width = 0, height = dpi(20), bg = theme.bg_normal, fg = theme.fg_normal })
+
+    -- Add widgets to the bottom wibox
+    --s.mybottomwibox:setup {
+    --    layout = wibox.layout.align.horizontal,
+    --    { -- Left widgets
+    --        layout = wibox.layout.fixed.horizontal,
+    --    },
+    --    s.mytasklist, -- Middle widget
+    --    { -- Right widgets
+    --        layout = wibox.layout.fixed.horizontal,
+    --        s.mylayoutbox,
+    --    },
+    --}
+end
+
+return theme
diff --git a/themes/multicolor/wall.png b/themes/multicolor/wall.png
new file mode 100755
index 0000000..a3188d0
Binary files /dev/null and b/themes/multicolor/wall.png differ
