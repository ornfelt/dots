diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..d42c9e0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,54 @@
+# Prerequisites
+*.d
+
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Linker output
+*.ilk
+*.map
+*.exp
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+*.idb
+*.pdb
+
+# Kernel Module Compile Results
+*.mod*
+*.cmd
+.tmp_versions/
+modules.order
+Module.symvers
+Mkfile.old
+dkms.conf
+a.out
+dwm
diff --git a/config.def.h b/config.def.h
index 9efa774..0c94360 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,21 +1,44 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+static unsigned int borderpx  = 1;        /* border pixel of windows */
+static unsigned int snap      = 32;       /* snap pixel */
+static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+static int showbar            = 1;        /* 0 means no bar */
+static int topbar             = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
+static char font[]            = "monospace:size=10";
+static char dmenufont[]       = "monospace:size=10";
+static const char *fonts[]          = { font };
+static char normbgcolor[]           = "#222222";
+static char normbordercolor[]       = "#444444";
+static char normfgcolor[]           = "#bbbbbb";
+static char selfgcolor[]            = "#eeeeee";
+static char selbordercolor[]        = "#005577";
+static char selbgcolor[]            = "#005577";
+static char *colors[][3] = {
+       /*               fg           bg           border   */
+       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+};
+
+typedef struct {
+	const char *name;
+	const void *cmd;
+} Sp;
+const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+const char *spcmd3[] = {"keepassxc", NULL };
+static Sp scratchpads[] = {
+	/* name          cmd  */
+	{"spterm",      spcmd1},
+	{"spranger",    spcmd2},
+	{"keepassxc",   spcmd3},
 };
 
 /* tagging */
@@ -26,22 +49,39 @@ static const Rule rules[] = {
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
 };
 
 /* layout(s) */
-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
-static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static int nmaster     = 1;    /* number of clients in master area */
+static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
 static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
 
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+#include "vanitygaps.c"
+
 static const Layout layouts[] = {
 	/* symbol     arrange function */
 	{ "[]=",      tile },    /* first entry is default */
-	{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
+	{ "[@]",      spiral },
+	{ "[\\]",     dwindle },
+	{ "H[]",      deck },
+	{ "TTT",      bstack },
+	{ "===",      bstackhoriz },
+	{ "HHH",      grid },
+	{ "###",      nrowgrid },
+	{ "---",      horizgrid },
+	{ ":::",      gaplessgrid },
+	{ "|M|",      centeredmaster },
+	{ ">M>",      centeredfloatingmaster },
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ NULL,       NULL },
 };
 
 /* key definitions */
@@ -51,27 +91,81 @@ static const Layout layouts[] = {
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+#define STACKKEYS(MOD,ACTION) \
+	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
+	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
+	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
+	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
+	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
+	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
+	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
+#define STATUSBAR "dwmblocks"
+
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+		{ "font",               STRING,  &font },
+		{ "dmenufont",          STRING,  &dmenufont },
+		{ "normbgcolor",        STRING,  &normbgcolor },
+		{ "normbordercolor",    STRING,  &normbordercolor },
+		{ "normfgcolor",        STRING,  &normfgcolor },
+		{ "selbgcolor",         STRING,  &selbgcolor },
+		{ "selbordercolor",     STRING,  &selbordercolor },
+		{ "selfgcolor",         STRING,  &selfgcolor },
+		{ "borderpx",          	INTEGER, &borderpx },
+		{ "snap",          		INTEGER, &snap },
+		{ "showbar",          	INTEGER, &showbar },
+		{ "topbar",          	INTEGER, &topbar },
+		{ "nmaster",          	INTEGER, &nmaster },
+		{ "resizehints",       	INTEGER, &resizehints },
+		{ "mfact",      	 	FLOAT,   &mfact },
+};
+
 static const Key keys[] = {
 	/* modifier                     key        function        argument */
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
 	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+	STACKKEYS(MODKEY,                          focus)
+	STACKKEYS(MODKEY|ShiftMask,                push)
 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
+	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
@@ -79,12 +173,16 @@ static const Key keys[] = {
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
 	TAGKEYS(                        XK_1,                      0)
 	TAGKEYS(                        XK_2,                      1)
 	TAGKEYS(                        XK_3,                      2)
@@ -94,7 +192,8 @@ static const Key keys[] = {
 	TAGKEYS(                        XK_7,                      6)
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+	{ MODKEY,                       XK_s,      togglesticky,   {0} },
 };
 
 /* button definitions */
@@ -103,11 +202,12 @@ static const Button buttons[] = {
 	/* click                event mask      button          function        argument */
 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
 	{ ClkTagBar,            0,              Button1,        view,           {0} },
 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..ec7de9e
--- /dev/null
+++ b/config.h
@@ -0,0 +1,364 @@
+/* See LICENSE file for copyright and license details. */
+
+/* Constants */
+/* #define TERMINAL "st" */
+/* #define TERMCLASS "St" */
+/* #define TERMINAL "urxvt" */
+/* #define TERMCLASS "Urxvt" */
+/* #define TERMINAL "alacritty" */
+/* #define TERMCLASS "alacritty" */
+#define TERMINAL "wezterm"
+#define TERMCLASS "wezterm"
+#define SECTERMINAL "st"
+
+#define FILES "thunar"
+//#define FILEX "ranger"
+#define FILEX "yazi"
+
+/* appearance */
+static unsigned int borderpx    = 3;        /* border pixel of windows */
+static const unsigned int gappx = 10;       /* default gap between windows in pixels */
+static unsigned int snap        = 32;       /* snap pixel */
+static unsigned int gappih      = 20;       /* horiz inner gap between windows */
+static unsigned int gappiv      = 20;       /* vert inner gap between windows */
+static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
+static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
+static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
+static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
+static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
+static int showbar              = 1;        /* 0 means no bar */
+static int topbar               = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
+/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
+/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
+//static char normbgcolor[]       = "#222222";
+static char normbgcolor[]       = "#282828";
+static char normbordercolor[]   = "#ebdbb2";
+static char normfgcolor[]       = "#ebdbb2";
+static char selfgcolor[]        = "#ebdbb2";
+static char selbordercolor[]    = "#770000";
+static char selbgcolor[]        = "#005577";
+static const char col1[]        = "#98971a";
+static const char col21[]       = "#fb4934";
+static const char col22[]       = "#ebdbb2";
+static const char col23[]       = "#458588";
+static const char col24[]       = "#ebdbb2";
+static const char col3[]        = "#fabd2f";
+static const char col4[]        = "#83a598";
+static const char col5[]        = "#d3869b";
+static const char col6[]        = "#8ec07c";
+static char *colors[][3]        = {
+    /*               fg              bg              border   */
+    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
+    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
+};
+
+typedef struct {
+    const char *name;
+    const void *cmd;
+} Sp;
+const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
+const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
+/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
+static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spcalc",      spcmd2},
+};
+
+/* tagging */
+static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
+
+static const Rule rules[] = {
+    /* xprop(1):
+     *    WM_CLASS(STRING) = instance, class
+     *    WM_NAME(STRING) = title
+     */
+    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
+    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
+    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
+    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
+    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
+    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
+    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
+};
+
+/* layout(s) */
+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static int nmaster     = 1;    /* number of clients in master area */
+static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+#include "vanitygaps.c"
+static const Layout layouts[] = {
+    /* symbol       arrange function */
+    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
+    { "[]=",        tile },                     /* Master on left, slaves on right */
+    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
+    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
+    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
+    { "[M]",        monocle },                  /* All windows on top of eachother */
+    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
+    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
+    { "><>",        NULL },                     /* no layout function means floating behavior */
+    { NULL,         NULL },
+};
+
+/* key definitions */
+#define MODKEY Mod4Mask
+#define MODKEY1 Mod1Mask
+#define TAGKEYS(KEY,TAG) \
+{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
+{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
+{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
+{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
+/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
+#define STACKKEYS(MOD,ACTION) \
+{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
+{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
+{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
+{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
+/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
+/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
+
+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+#define STATUSBAR "dwmblocks"
+
+/* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+static const char *termcmd[]  = { TERMINAL, NULL };
+//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
+
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+    { "color0",             STRING,     &normbordercolor },
+    { "foreground",         STRING,     &selbordercolor },
+    /* { "color8",             STRING,     &selbordercolor }, */
+    { "color0",             STRING,     &normbgcolor },
+    { "foreground",         STRING,     &normfgcolor },
+    { "color0",             STRING,     &selfgcolor },
+    { "foreground",         STRING,     &selbgcolor },
+    { "borderpx",           INTEGER,    &borderpx },
+    { "snap",               INTEGER,    &snap },
+    { "showbar",            INTEGER,    &showbar },
+    { "topbar",             INTEGER,    &topbar },
+    { "nmaster",            INTEGER,    &nmaster },
+    { "resizehints",        INTEGER,    &resizehints },
+    { "mfact",              FLOAT,      &mfact },
+    { "gappih",             INTEGER,    &gappih },
+    { "gappiv",             INTEGER,    &gappiv },
+    { "gappoh",             INTEGER,    &gappoh },
+    { "gappov",             INTEGER,    &gappov },
+    { "swallowfloating",    INTEGER,    &swallowfloating },
+    { "smartgaps",          INTEGER,    &smartgaps },
+};
+
+#include <X11/XF86keysym.h>
+
+static const Key keys[] = {
+    /*  modifier                    key                 function            argument */
+        STACKKEYS(MODKEY,                               focus)
+        STACKKEYS(MODKEY|ShiftMask,                     push)
+        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
+        TAGKEYS(                    XK_1,               0)
+        TAGKEYS(                    XK_2,               1)
+        TAGKEYS(                    XK_3,               2)
+        TAGKEYS(                    XK_4,               3)
+        TAGKEYS(                    XK_5,               4)
+        TAGKEYS(                    XK_6,               5)
+        TAGKEYS(                    XK_7,               6)
+        TAGKEYS(                    XK_8,               7)
+        TAGKEYS(                    XK_9,               8)
+        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
+        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
+
+        /* Layouts */
+        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
+        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
+        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
+        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
+        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
+        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
+        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
+        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
+        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
+        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
+        { MODKEY,                   XK_f,               togglefullscr,      {0} },
+        { MODKEY,                   XK_space,           togglefloating,     {0} },
+        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
+        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
+        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
+        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
+        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
+        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
+        { MODKEY,                   XK_x,               defaultgaps,        {0} },
+        { MODKEY,                   XK_z,               togglegaps,         {0} },
+        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
+        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
+        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
+        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+        { MODKEY,                   XK_q,               killclient,         {0} },
+        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
+        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
+        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
+        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
+        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
+        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
+        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
+        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
+        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
+        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
+        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
+
+        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
+        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
+        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
+        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
+        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
+        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
+        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
+        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
+        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
+        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
+        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
+        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
+        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
+        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
+        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
+        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
+        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
+        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
+        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
+        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/files_wd.sh") },
+        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
+        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
+        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
+        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
+        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
+        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
+        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
+        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
+        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
+        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
+        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
+        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
+        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
+        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
+        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
+        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
+
+        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
+        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
+        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
+        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
+        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
+        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
+        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
+        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
+        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
+        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
+
+        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
+        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
+        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
+        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
+        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
+        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
+        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
+        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
+        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
+        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
+        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
+        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
+        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
+
+        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
+        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
+        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
+        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
+        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
+        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
+        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
+        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
+        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
+        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
+        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
+        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
+        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
+        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
+        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
+        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
+        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
+        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
+        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
+        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
+        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
+        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
+        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
+        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
+        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
+        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
+};
+
+#define STATUSBAR "dwmblocks"
+
+/* button definitions */
+/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
+static const Button buttons[] = {
+    /* click                event mask      button          function        argument */
+#ifndef __OpenBSD__
+    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
+#endif
+    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
+    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
+    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
+    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
+    { ClkTagBar,            0,              Button1,        view,           {0} },
+    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
+    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
+    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
+};
diff --git a/config.mk b/config.mk
index 8efca9a..a933c0b 100644
--- a/config.mk
+++ b/config.mk
@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
 #FREETYPEINC = ${X11INC}/freetype2
 #MANPREFIX = ${PREFIX}/man
+#KVMLIB = -lkvm
 
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
 
 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
diff --git a/drw.c b/drw.c
index c41e6af..6be5dee 100644
--- a/drw.c
+++ b/drw.c
@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 /* Wrapper to create color schemes. The caller has to call free(3) on the
  * returned color scheme when done using it. */
 Clr *
-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
 {
 	size_t i;
 	Clr *ret;
diff --git a/drw.h b/drw.h
index 6471431..bdbf950 100644
--- a/drw.h
+++ b/drw.h
@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
 
 /* Colorscheme abstraction */
 void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
 
 /* Cursor abstraction */
 Cur *drw_cur_create(Drw *drw, int shape);
diff --git a/dwm.1 b/dwm.1
index ddc8321..d04bec6 100644
--- a/dwm.1
+++ b/dwm.1
@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
 indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
+.P
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
@@ -116,6 +124,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
 .B Mod1\-Shift\-c
 Close focused window.
 .TP
+.B Mod1\-Shift\-f
+Toggle fullscreen for focused window.
+.TP
 .B Mod1\-Shift\-space
 Toggle focused window between tiled and floating state.
 .TP
@@ -152,6 +163,21 @@ Toggles focused window between floating and tiled state.
 .TP
 .B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+.SH FILES
+The files containing programs to be started along with dwm are searched for in
+the following directories:
+.IP "1. $XDG_DATA_HOME/dwm"
+.IP "2. $HOME/.local/share/dwm"
+.IP "3. $HOME/.dwm"
+.P
+The first existing directory is scanned for any of the autostart files below.
+.TP 15
+autostart.sh
+This file is started as a shell background process before dwm enters its handler
+loop.
+.TP 15
+autostart_blocking.sh
+This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
diff --git a/dwm.c b/dwm.c
index 1443802..6232799 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -36,10 +37,17 @@
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
 #include <X11/Xutil.h>
+#include <X11/Xresource.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
 #include <X11/Xft/Xft.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
 
 #include "drw.h"
 #include "util.h"
@@ -47,24 +55,33 @@
 /* macros */
 #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+#define GETINC(X)               ((X) - 2000)
+#define INC(X)                  ((X) + 2000)
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+#define PREVSEL                 3000
+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+#define TAGMASK     			((1 << NUMTAGS) - 1)
+#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
 enum { SchemeNorm, SchemeSel }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
 	int i;
@@ -86,14 +103,18 @@ typedef struct Client Client;
 struct Client {
 	char name[256];
 	float mina, maxa;
+	float cfact;
 	int x, y, w, h;
+	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
 	int oldx, oldy, oldw, oldh;
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
 	int bw, oldbw;
 	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+    pid_t pid;
 	Client *next;
 	Client *snext;
+    Client *swallowing;
 	Monitor *mon;
 	Window win;
 };
@@ -118,6 +139,10 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -137,9 +162,24 @@ typedef struct {
 	const char *title;
 	unsigned int tags;
 	int isfloating;
+	int isterminal;
+	int noswallow;
 	int monitor;
 } Rule;
 
+/* Xresources preferences */
+enum resource_type {
+	STRING = 0,
+	INTEGER = 1,
+	FLOAT = 2
+};
+
+typedef struct {
+	char *name;
+	enum resource_type type;
+	void *dst;
+} ResourcePref;
+
 /* function declarations */
 static void applyrules(Client *c);
 static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
@@ -162,7 +202,7 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-static void enternotify(XEvent *e);
+static int drawstatusbar(Monitor *m, int bh, char* text);
 static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
@@ -171,6 +211,7 @@ static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
 static long getstate(Window w);
+static pid_t getstatusbarpid();
 static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
@@ -181,11 +222,11 @@ static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
 static void monocle(Monitor *m);
-static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *c);
 static void propertynotify(XEvent *e);
+static void pushstack(const Arg *arg);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
 static void resize(Client *c, int x, int y, int w, int h, int interact);
@@ -193,23 +234,35 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
+static void sendmonview(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
+static void setsticky(Client *c, int sticky);
 static void setlayout(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shiftview(const Arg *arg);
+static void shifttag(const Arg *arg);
 static void showhide(Client *c);
+static void sigstatusbar(const Arg *arg);
 static void spawn(const Arg *arg);
+static int stackpos(const Arg *arg);
 static void tag(const Arg *arg);
+static void tagview(const Arg *arg);
 static void tagmon(const Arg *arg);
-static void tile(Monitor *m);
+static void tagmonview(const Arg *arg);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
+static void togglescratch(const Arg *arg);
+static void togglesticky(const Arg *arg);
+static void togglefullscr(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -232,10 +285,25 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void load_xresources(void);
+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+
+static pid_t getparentprocess(pid_t p);
+static int isdescprocess(pid_t p, pid_t c);
+static Client *swallowingclient(Window w);
+static Client *termforwin(const Client *c);
+static pid_t winpid(Window w);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
-static char stext[256];
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
+static int statussig;
+static int statusw;
+static pid_t statuspid = -1;
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
@@ -248,13 +316,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[ConfigureRequest] = configurerequest,
 	[ConfigureNotify] = configurenotify,
 	[DestroyNotify] = destroynotify,
-	[EnterNotify] = enternotify,
 	[Expose] = expose,
 	[FocusIn] = focusin,
 	[KeyPress] = keypress,
 	[MappingNotify] = mappingnotify,
 	[MapRequest] = maprequest,
-	[MotionNotify] = motionnotify,
 	[PropertyNotify] = propertynotify,
 	[UnmapNotify] = unmapnotify
 };
@@ -267,6 +333,8 @@ static Drw *drw;
 static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
 
+static xcb_connection_t *xcon;
+
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
@@ -296,8 +364,15 @@ applyrules(Client *c)
 		&& (!r->class || strstr(class, r->class))
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
+			c->isterminal = r->isterminal;
+			c->noswallow  = r->noswallow;
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
+			if ((r->tags & SPTAGMASK) && r->isfloating) {
+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+			}
+
 			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
 				c->mon = m;
@@ -307,7 +382,7 @@ applyrules(Client *c)
 		XFree(ch.res_class);
 	if (ch.res_name)
 		XFree(ch.res_name);
-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
 }
 
 int
@@ -414,6 +489,53 @@ attachstack(Client *c)
 	c->mon->stack = c;
 }
 
+void
+swallow(Client *p, Client *c)
+{
+
+	if (c->noswallow || c->isterminal)
+		return;
+	if (c->noswallow && !swallowfloating && c->isfloating)
+		return;
+
+	detach(c);
+	detachstack(c);
+
+	setclientstate(c, WithdrawnState);
+	XUnmapWindow(dpy, p->win);
+
+	p->swallowing = c;
+	c->mon = p->mon;
+
+	Window w = p->win;
+	p->win = c->win;
+	c->win = w;
+	updatetitle(p);
+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+	arrange(p->mon);
+	configure(p);
+	updateclientlist();
+}
+
+void
+unswallow(Client *c)
+{
+	c->win = c->swallowing->win;
+
+	free(c->swallowing);
+	c->swallowing = NULL;
+
+	/* unfullscreen the client */
+	setfullscreen(c, 0);
+	updatetitle(c);
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	setclientstate(c, NormalState);
+	focus(NULL);
+	arrange(c->mon);
+}
+
 void
 buttonpress(XEvent *e)
 {
@@ -425,28 +547,58 @@ buttonpress(XEvent *e)
 
 	click = ClkRootWin;
 	/* focus monitor if necessary */
-	if ((m = wintomon(ev->window)) && m != selmon) {
+	if ((m = wintomon(ev->window)) && m != selmon
+	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
 		unfocus(selmon->sel, 1);
 		selmon = m;
 		focus(NULL);
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
-		do
+		unsigned int occ = 0;
+		for(c = m->clients; c; c=c->next)
+			occ |= c->tags == TAGMASK ? 0 : c->tags;
+		do {
+			/* Do not reserve space for vacant tags */
+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+				continue;
 			x += TEXTW(tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
+		} while (ev->x >= x && ++i < LENGTH(tags));
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
-			click = ClkStatusText;
-		else
-			click = ClkWinTitle;
+        } else if (ev->x > selmon->ww - statusw) {
+            x = selmon->ww - statusw;
+            click = ClkStatusText;
+
+			char *text, *s, ch;
+			statussig = 0;
+			for (text = s = stext; *s && x <= ev->x; s++) {
+				if ((unsigned char)(*s) < ' ') {
+					ch = *s;
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = ch;
+					text = s + 1;
+					if (x >= ev->x)
+						break;
+					statussig = ch;
+				} else if (*s == '^') {
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = '^';
+					if (*(++s) == 'f')
+						x += atoi(++s);
+					while (*(s++) != '^');
+					text = s;
+					s--;
+				}
+			}
 	} else if ((c = wintoclient(ev->window))) {
-		focus(c);
-		restack(selmon);
+		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+			focus(c);
 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
 		click = ClkClientWin;
 	}
@@ -485,7 +637,7 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors); i++)
+	for (i = 0; i < LENGTH(colors) + 1; i++)
 		free(scheme[i]);
 	free(scheme);
 	XDestroyWindow(dpy, wmcheckwin);
@@ -524,6 +676,10 @@ clientmessage(XEvent *e)
 		|| cme->data.l[2] == netatom[NetWMFullscreen])
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+
+        if (cme->data.l[1] == netatom[NetWMSticky]
+                || cme->data.l[2] == netatom[NetWMSticky])
+            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -640,6 +796,10 @@ createmon(void)
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
@@ -654,6 +814,9 @@ destroynotify(XEvent *e)
 
 	if ((c = wintoclient(ev->window)))
 		unmanage(c, 1);
+
+	else if ((c = swallowingclient(ev->window)))
+		unmanage(c->swallowing, 1);
 }
 
 void
@@ -694,6 +857,128 @@ dirtomon(int dir)
 	return m;
 }
 
+int
+drawstatusbar(Monitor *m, int bh, char* stext)
+{
+    int ret, i, w, x, len;
+    short isCode = 0;
+    char *text;
+    char *p;
+    FILE *ptr;
+    char ch;
+    int hotbool = 0;
+
+    len = strlen(stext) + 1 ;
+    if (!(text = (char*) malloc(sizeof(char)*len)))
+        die("malloc");
+    p = text;
+    memcpy(text, stext, len);
+
+    /* compute width of the status text */
+    w = 0;
+    i = -1;
+    while (text[++i]) {
+        if (text[i] == '^') {
+            if (!isCode) {
+                isCode = 1;
+                text[i] = '\0';
+                w += TEXTW(text) - lrpad;
+                text[i] = '^';
+                if (text[++i] == 'f')
+                    w += atoi(text + ++i);
+            } else {
+                isCode = 0;
+                text = text + i + 1;
+                i = -1;
+            }
+        }
+    }
+    if (!isCode)
+        w += TEXTW(text) - lrpad;
+    else
+        isCode = 0;
+    text = p;
+
+    w += 2; /* 1px padding on both sides */
+    ret = x = m->ww - w;
+
+    drw_setscheme(drw, scheme[LENGTH(colors)]);
+    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+    drw_rect(drw, x, 0, w, bh, 1, 1);
+    x++;
+
+    /* process status text */
+    i = -1;
+    drw_clr_create(drw, &drw->scheme[ColFg], col1);
+
+    while (text[++i]) {
+        if (text[i] == '^' && !isCode) {
+            isCode = 1;
+
+            text[i] = '\0';
+            w = TEXTW(text) - lrpad;
+            drw_text(drw, x, 0, w, bh, 0, text, 0);
+            x += w;
+
+            while (text[++i] != '^') {
+                if (text[i] == '2') {
+                    // Check if weather is hot or not
+                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
+                    if (ptr == NULL) printf("Fail to read wr...");
+                    do{
+                        ch = fgetc(ptr);
+                        // Check if temp is above +20 (= hot)
+                        if (hotbool){
+                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
+                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
+                                break;
+                            }else{
+                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
+                                break;
+                            }
+                        }
+
+                        if (ch == '+'){
+                            hotbool = 1;
+                        }else if (ch == '-') {
+                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
+                            break;
+                        }
+                        else{
+                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
+                            break;
+                        }
+                    } while (ch != EOF);
+                    fclose(ptr);
+                } else if (text[i] == '3') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
+                } else if (text[i] == '4') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
+                } else if (text[i] == '5') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
+                } else if (text[i] == '6') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
+                }
+            }
+
+            text = text + i + 1;
+            i=-1;
+            isCode = 0;
+        }
+    }
+
+    if (!isCode) {
+        w = TEXTW(text) - lrpad;
+        drw_text(drw, x, 0, w, bh, 0, text, 0);
+    }
+
+    drw_setscheme(drw, scheme[SchemeNorm]);
+    free(p);
+
+    return ret;
+}
+
 void
 drawbar(Monitor *m)
 {
@@ -707,26 +992,24 @@ drawbar(Monitor *m)
 		return;
 
 	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+	//if (m == selmon) { /* status is only drawn on selected monitor */
+    if (m == selmon || 1) { 
+		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
 	}
 
 	for (c = m->clients; c; c = c->next) {
-		occ |= c->tags;
+		occ |= c->tags == TAGMASK ? 0 : c->tags;
 		if (c->isurgent)
 			urg |= c->tags;
 	}
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
+		/* Do not draw vacant tags */
+		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+			continue;
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-				urg & 1 << i);
 		x += w;
 	}
 	w = TEXTW(m->ltsymbol);
@@ -734,15 +1017,8 @@ drawbar(Monitor *m)
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
 
 	if ((w = m->ww - tw - x) > bh) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
 			drw_rect(drw, x, 0, w, bh, 1, 1);
-		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
@@ -756,25 +1032,6 @@ drawbars(void)
 		drawbar(m);
 }
 
-void
-enternotify(XEvent *e)
-{
-	Client *c;
-	Monitor *m;
-	XCrossingEvent *ev = &e->xcrossing;
-
-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
-		return;
-	c = wintoclient(ev->window);
-	m = c ? c->mon : wintomon(ev->window);
-	if (m != selmon) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-	} else if (!c || c == selmon->sel)
-		return;
-	focus(c);
-}
-
 void
 expose(XEvent *e)
 {
@@ -837,27 +1094,16 @@ focusmon(const Arg *arg)
 void
 focusstack(const Arg *arg)
 {
-	Client *c = NULL, *i;
+	int i = stackpos(arg);
+	Client *c, *p;
 
-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+	if(i < 0)
 		return;
-	if (arg->i > 0) {
-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
-		if (!c)
-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
-	} else {
-		for (i = selmon->clients; i != selmon->sel; i = i->next)
-			if (ISVISIBLE(i))
-				c = i;
-		if (!c)
-			for (; i; i = i->next)
-				if (ISVISIBLE(i))
-					c = i;
-	}
-	if (c) {
-		focus(c);
-		restack(selmon);
-	}
+
+	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+	focus(c ? c : p);
+	restack(selmon);
 }
 
 Atom
@@ -876,6 +1122,30 @@ getatomprop(Client *c, Atom prop)
 	return atom;
 }
 
+pid_t
+getstatusbarpid()
+{
+	char buf[32], *str = buf, *c;
+	FILE *fp;
+
+	if (statuspid > 0) {
+		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+		if ((fp = fopen(buf, "r"))) {
+			fgets(buf, sizeof(buf), fp);
+			while ((c = strchr(str, '/')))
+				str = c + 1;
+			fclose(fp);
+			if (!strcmp(str, STATUSBAR))
+				return statuspid;
+		}
+	}
+	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+		return -1;
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+	return strtoul(buf, NULL, 10);
+}
+
 int
 getrootptr(int *x, int *y)
 {
@@ -1030,18 +1300,20 @@ killclient(const Arg *arg)
 void
 manage(Window w, XWindowAttributes *wa)
 {
-	Client *c, *t = NULL;
+	Client *c, *t = NULL, *term = NULL;
 	Window trans = None;
 	XWindowChanges wc;
 
 	c = ecalloc(1, sizeof(Client));
 	c->win = w;
+	c->pid = winpid(w);
 	/* geometry */
 	c->x = c->oldx = wa->x;
 	c->y = c->oldy = wa->y;
 	c->w = c->oldw = wa->width;
 	c->h = c->oldh = wa->height;
 	c->oldbw = wa->border_width;
+	c->cfact = 1.0;
 
 	updatetitle(c);
 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
@@ -1050,6 +1322,7 @@ manage(Window w, XWindowAttributes *wa)
 	} else {
 		c->mon = selmon;
 		applyrules(c);
+		term = termforwin(c);
 	}
 
 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
@@ -1067,6 +1340,10 @@ manage(Window w, XWindowAttributes *wa)
 	updatewindowtype(c);
 	updatesizehints(c);
 	updatewmhints(c);
+	c->sfx = c->x;
+	c->sfy = c->y;
+	c->sfw = c->w;
+	c->sfh = c->h;
 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
 	grabbuttons(c, 0);
 	if (!c->isfloating)
@@ -1084,6 +1361,8 @@ manage(Window w, XWindowAttributes *wa)
 	c->mon->sel = c;
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
+	if (term)
+		swallow(term, c);
 	focus(NULL);
 }
 
@@ -1124,23 +1403,6 @@ monocle(Monitor *m)
 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
 }
 
-void
-motionnotify(XEvent *e)
-{
-	static Monitor *mon = NULL;
-	Monitor *m;
-	XMotionEvent *ev = &e->xmotion;
-
-	if (ev->window != root)
-		return;
-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-		focus(NULL);
-	}
-	mon = m;
-}
-
 void
 movemouse(const Arg *arg)
 {
@@ -1244,16 +1506,36 @@ propertynotify(XEvent *e)
 			drawbars();
 			break;
 		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
 			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
 		if (ev->atom == netatom[NetWMWindowType])
 			updatewindowtype(c);
 	}
 }
 
+void
+pushstack(const Arg *arg) {
+	int i = stackpos(arg);
+	Client *sel = selmon->sel, *c, *p;
+
+	if(i < 0)
+		return;
+	else if(i == 0) {
+		detach(sel);
+		attach(sel);
+	}
+	else {
+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+			if(!(i -= (ISVISIBLE(c) && c != sel)))
+				break;
+		c = c ? c : p;
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	arrange(selmon);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1291,6 +1573,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
 	c->oldw = c->w; c->w = wc.width = w;
 	c->oldh = c->h; c->h = wc.height = h;
 	wc.border_width = c->bw;
+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+	    && !c->isfullscreen && !c->isfloating) {
+		c->w = wc.width += c->bw * 2;
+		c->h = wc.height += c->bw * 2;
+		wc.border_width = 0;
+	}
 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
 	configure(c);
 	XSync(dpy, False);
@@ -1389,6 +1678,89 @@ run(void)
 			handler[ev.type](&ev); /* call handler */
 }
 
+//void
+//runautostart(void)
+//{
+//	char *pathpfx;
+//	char *path;
+//	char *xdgdatahome;
+//	char *home;
+//	struct stat sb;
+//
+//	if ((home = getenv("HOME")) == NULL)
+//		/* this is almost impossible */
+//		return;
+//
+//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+//	 * otherwise use ~/.local/share/dwm as autostart script directory
+//	 */
+//	xdgdatahome = getenv("XDG_DATA_HOME");
+//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+//
+//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	} else {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+//		                     + strlen(dwmdir) + 3);
+//
+//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* check if the autostart script directory exists */
+//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+//		/* the XDG conformant path does not exist or is no directory
+//		 * so we try ~/.dwm instead
+//		 */
+//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+//		if(pathpfx_new == NULL) {
+//			free(pathpfx);
+//			return;
+//		}
+//		pathpfx = pathpfx_new;
+//
+//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* try the blocking script first */
+//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(path);
+//
+//	/* now the non-blocking script */
+//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(strcat(path, " &"));
+//
+//	free(pathpfx);
+//	free(path);
+//}
+
+void
+runautostart(void)
+{
+    system("killall -q dwmblocks; dwmblocks &");
+}
+
 void
 scan(void)
 {
@@ -1432,6 +1804,25 @@ sendmon(Client *c, Monitor *m)
 	arrange(NULL);
 }
 
+void
+sendmonview(Client *c, Monitor *m)
+{
+    if (c->mon == m)
+        return;
+    unfocus(c, 1);
+    detach(c);
+    detachstack(c);
+    arrange(c->mon);
+    c->mon = m;
+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+    attach(c);
+    attachstack(c);
+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+    arrange(m);
+    focus(c);
+    restack(m);
+}
+
 void
 setclientstate(Client *c, long state)
 {
@@ -1506,6 +1897,23 @@ setfullscreen(Client *c, int fullscreen)
 	}
 }
 
+void
+	 setsticky(Client *c, int sticky)
+	 {
+
+		 if(sticky && !c->issticky) {
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+			 c->issticky = 1;
+		 } else if(!sticky && c->issticky){
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *)0, 0);
+			 c->issticky = 0;
+			 arrange(c->mon);
+		 }
+	 }
+
+
 void
 setlayout(const Arg *arg)
 {
@@ -1520,6 +1928,58 @@ setlayout(const Arg *arg)
 		drawbar(selmon);
 }
 
+void
+shiftview(const Arg *arg) {
+	Arg shifted;
+
+	if(arg->i > 0) /* left circular shift */
+		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+
+	else /* right circular shift */
+		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+
+	view(&shifted);
+}
+
+void
+shifttag(const Arg *arg) {
+	Arg shifted;
+	Client *c;
+
+	if (!selmon->sel)
+		return;
+	c = selmon->sel;
+
+	if (arg->i > 0) /* left circular shift */
+		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+			^ (c->tags >> (LENGTH(tags) - arg->i));
+	else /* right circular shift */
+		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+			^ (c->tags << (LENGTH(tags) + arg->i));
+
+	toggletag(&shifted);
+}
+
+void
+setcfact(const Arg *arg) {
+	float f;
+	Client *c;
+
+	c = selmon->sel;
+
+	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f + c->cfact;
+	if(arg->f == 0.0)
+		f = 1.0;
+	else if(f < 0.25 || f > 4.0)
+		return;
+	c->cfact = f;
+	arrange(selmon);
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -1575,6 +2035,7 @@ setup(void)
 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
@@ -1583,7 +2044,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
@@ -1631,6 +2093,10 @@ showhide(Client *c)
 	if (!c)
 		return;
 	if (ISVISIBLE(c)) {
+		if ((c->tags & SPTAGMASK) && c->isfloating) {
+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+		}
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
@@ -1643,6 +2109,20 @@ showhide(Client *c)
 	}
 }
 
+void
+sigstatusbar(const Arg *arg)
+{
+	union sigval sv;
+
+	if (!statussig)
+		return;
+	sv.sival_int = arg->i;
+	if ((statuspid = getstatusbarpid()) <= 0)
+		return;
+
+	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+}
+
 void
 spawn(const Arg *arg)
 {
@@ -1665,6 +2145,36 @@ spawn(const Arg *arg)
 	}
 }
 
+int
+stackpos(const Arg *arg) {
+	int n, i;
+	Client *c, *l;
+
+	if(!selmon->clients)
+		return -1;
+
+	if(arg->i == PREVSEL) {
+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+		if(!l)
+			return -1;
+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return i;
+	}
+	else if(ISINC(arg->i)) {
+		if(!selmon->sel)
+			return -1;
+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MOD(i + GETINC(arg->i), n);
+	}
+	else if(arg->i < 0) {
+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MAX(i + arg->i, 0);
+	}
+	else
+		return arg->i;
+}
+
 void
 tag(const Arg *arg)
 {
@@ -1675,6 +2185,17 @@ tag(const Arg *arg)
 	}
 }
 
+void
+tagview(const Arg *arg)
+{
+    if (selmon->sel && arg->ui & TAGMASK) {
+        selmon->sel->tags = arg->ui & TAGMASK;
+        focus(NULL);
+        arrange(selmon);
+        view(arg);
+    }
+}
+
 void
 tagmon(const Arg *arg)
 {
@@ -1684,31 +2205,11 @@ tagmon(const Arg *arg)
 }
 
 void
-tile(Monitor *m)
+tagmonview(const Arg *arg)
 {
-	unsigned int i, n, h, mw, my, ty;
-	Client *c;
-
-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
-		return;
-
-	if (n > m->nmaster)
-		mw = m->nmaster ? m->ww * m->mfact : 0;
-	else
-		mw = m->ww;
-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
-			if (my + HEIGHT(c) < m->wh)
-				my += HEIGHT(c);
-		} else {
-			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) < m->wh)
-				ty += HEIGHT(c);
-		}
+    if (!selmon->sel || !mons->next)
+        return;
+    sendmonview(selmon->sel, dirtomon(arg->i));
 }
 
 void
@@ -1729,11 +2230,61 @@ togglefloating(const Arg *arg)
 		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
 	if (selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
+		/* restore last known float dimensions */
+		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+		       selmon->sel->sfw, selmon->sel->sfh, False);
+	else {
+		/* save last known float dimensions */
+		selmon->sel->sfx = selmon->sel->x;
+		selmon->sel->sfy = selmon->sel->y;
+		selmon->sel->sfw = selmon->sel->w;
+		selmon->sel->sfh = selmon->sel->h;
+	}
+	arrange(selmon);
+}
+
+void
+togglefullscr(const Arg *arg)
+{
+  if(selmon->sel)
+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+}
+
+void
+togglesticky(const Arg *arg)
+{
+	if (!selmon->sel)
+		return;
+	setsticky(selmon->sel, !selmon->sel->issticky);
 	arrange(selmon);
 }
 
+void
+togglescratch(const Arg *arg)
+{
+	Client *c;
+	unsigned int found = 0;
+	unsigned int scratchtag = SPTAG(arg->ui);
+	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+
+	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+	if (found) {
+		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+		if (newtagset) {
+			selmon->tagset[selmon->seltags] = newtagset;
+			focus(NULL);
+			arrange(selmon);
+		}
+		if (ISVISIBLE(c)) {
+			focus(c);
+			restack(selmon);
+		}
+	} else {
+		selmon->tagset[selmon->seltags] |= scratchtag;
+		spawn(&sparg);
+	}
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -1780,6 +2331,20 @@ unmanage(Client *c, int destroyed)
 	Monitor *m = c->mon;
 	XWindowChanges wc;
 
+	if (c->swallowing) {
+		unswallow(c);
+		return;
+	}
+
+	Client *s = swallowingclient(c->win);
+	if (s) {
+		free(s->swallowing);
+		s->swallowing = NULL;
+		arrange(m);
+		focus(NULL);
+		return;
+	}
+
 	detach(c);
 	detachstack(c);
 	if (!destroyed) {
@@ -1795,9 +2360,12 @@ unmanage(Client *c, int destroyed)
 		XUngrabServer(dpy);
 	}
 	free(c);
-	focus(NULL);
-	updateclientlist();
-	arrange(m);
+
+	if (!s) {
+		arrange(m);
+		focus(NULL);
+		updateclientlist();
+	}
 }
 
 void
@@ -2026,6 +2594,9 @@ updatewindowtype(Client *c)
 
 	if (state == netatom[NetWMFullscreen])
 		setfullscreen(c, 1);
+	if (state == netatom[NetWMSticky]) {
+		setsticky(c, 1);
+	}
 	if (wtype == netatom[NetWMWindowTypeDialog])
 		c->isfloating = 1;
 }
@@ -2052,8 +2623,11 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-		return;
+    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
+        view(&((Arg) { .ui = 0 }));
+        return;
+    }
+
 	selmon->seltags ^= 1; /* toggle sel tagset */
 	if (arg->ui & TAGMASK)
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
@@ -2061,6 +2635,136 @@ view(const Arg *arg)
 	arrange(selmon);
 }
 
+pid_t
+winpid(Window w)
+{
+
+	pid_t result = 0;
+
+#ifdef __linux__
+	xcb_res_client_id_spec_t spec = {0};
+	spec.client = w;
+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+
+	xcb_generic_error_t *e = NULL;
+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+
+	if (!r)
+		return (pid_t)0;
+
+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+		spec = i.data->spec;
+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+			uint32_t *t = xcb_res_client_id_value_value(i.data);
+			result = *t;
+			break;
+		}
+	}
+
+	free(r);
+
+	if (result == (pid_t)-1)
+		result = 0;
+
+#endif /* __linux__ */
+
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
+
+#endif /* __OpenBSD__ */
+	return result;
+}
+
+pid_t
+getparentprocess(pid_t p)
+{
+	unsigned int v = 0;
+
+#ifdef __linux__
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+
+	if (!(f = fopen(buf, "r")))
+		return 0;
+
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+#endif /* __linux__*/
+
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
+
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
+
+	return (pid_t)v;
+}
+
+int
+isdescprocess(pid_t p, pid_t c)
+{
+	while (p != c && c != 0)
+		c = getparentprocess(c);
+
+	return (int)c;
+}
+
+Client *
+termforwin(const Client *w)
+{
+	Client *c;
+	Monitor *m;
+
+	if (!w->pid || w->isterminal)
+		return NULL;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
+Client *
+swallowingclient(Window w)
+{
+	Client *c;
+	Monitor *m;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->swallowing && c->swallowing->win == w)
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
 Client *
 wintoclient(Window w)
 {
@@ -2139,6 +2843,60 @@ zoom(const Arg *arg)
 	pop(c);
 }
 
+void
+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+{
+	char *sdst = NULL;
+	int *idst = NULL;
+	float *fdst = NULL;
+
+	sdst = dst;
+	idst = dst;
+	fdst = dst;
+
+	char fullname[256];
+	char *type;
+	XrmValue ret;
+
+	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+	fullname[sizeof(fullname) - 1] = '\0';
+
+	XrmGetResource(db, fullname, "*", &type, &ret);
+	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+	{
+		switch (rtype) {
+		case STRING:
+			strcpy(sdst, ret.addr);
+			break;
+		case INTEGER:
+			*idst = strtoul(ret.addr, NULL, 10);
+			break;
+		case FLOAT:
+			*fdst = strtof(ret.addr, NULL);
+			break;
+		}
+	}
+}
+
+void
+load_xresources(void)
+{
+	Display *display;
+	char *resm;
+	XrmDatabase db;
+	ResourcePref *p;
+
+	display = XOpenDisplay(NULL);
+	resm = XResourceManagerString(display);
+	if (!resm)
+		return;
+
+	db = XrmGetStringDatabase(resm);
+	for (p = resources; p < resources + LENGTH(resources); p++)
+		resource_load(db, p->name, p->type, p->dst);
+	XCloseDisplay(display);
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -2150,15 +2908,22 @@ main(int argc, char *argv[])
 		fputs("warning: no locale support\n", stderr);
 	if (!(dpy = XOpenDisplay(NULL)))
 		die("dwm: cannot open display");
+	if (!(xcon = XGetXCBConnection(dpy)))
+		die("dwm: cannot get xcb connection\n");
 	checkotherwm();
+	XrmInitialize();
+	load_xresources();
 	setup();
 #ifdef __OpenBSD__
-	if (pledge("stdio rpath proc exec", NULL) == -1)
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
+	runautostart();
+    arrange(selmon);
 	run();
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
diff --git a/patches/dwm-6.0-smfact.diff b/patches/dwm-6.0-smfact.diff
new file mode 100644
index 0000000..2032ef0
--- /dev/null
+++ b/patches/dwm-6.0-smfact.diff
@@ -0,0 +1,117 @@
+--- config.def.h	2013-04-06 21:01:27.750829760 +0200
++++ config.def.h	2013-04-06 21:02:19.557495556 +0200
+@@ -10,6 +10,7 @@ static const char selbgcolor[]      = "#
+ static const char selfgcolor[]      = "#eeeeee";
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int minwsz    = 20;       /* Minimal heigt of a client for smfact */
+ static const Bool showbar           = True;     /* False means no bar */
+ static const Bool topbar            = True;     /* False means bottom bar */
+ 
+@@ -24,6 +25,7 @@ static const Rule rules[] = {
+ 
+ /* layout(s) */
+ static const float mfact      = 0.55; /* factor of master area size [0.05..0.95] */
++static const float smfact     = 0.00; /* factor of tiled clients [0.00..0.95] */
+ static const int nmaster      = 1;    /* number of clients in master area */
+ static const Bool resizehints = True; /* True means respect size hints in tiled resizals */
+ 
+@@ -60,6 +62,8 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setsmfact,      {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_l,      setsmfact,      {.f = -0.05} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+--- dwm.c	2011-12-19 16:02:46.000000000 +0100
++++ dwm.c	2013-04-06 21:00:46.620830452 +0200
+@@ -69,6 +69,7 @@ typedef union {
+ 	int i;
+ 	unsigned int ui;
+ 	float f;
++	float sf;
+ 	const void *v;
+ } Arg;
+ 
+@@ -127,6 +128,7 @@ typedef struct {
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
++	float smfact;
+ 	int nmaster;
+ 	int num;
+ 	int by;               /* bar geometry */
+@@ -220,6 +222,7 @@ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, Bool fullscreen);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
++static void setsmfact(const Arg *arg);
+ static void setup(void);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+@@ -651,6 +654,7 @@ createmon(void) {
+ 		die("fatal: could not malloc() %u bytes\n", sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
++	m->smfact = smfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
+@@ -1581,6 +1585,19 @@ setmfact(const Arg *arg) {
+ }
+ 
+ void
++setsmfact(const Arg *arg) {
++	float sf;
++
++	if(!arg || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	sf = arg->sf < 1.0 ? arg->sf + selmon->smfact : arg->sf - 1.0;
++	if(sf < 0 || sf > 0.9)
++		return;
++	selmon->smfact = sf;
++	arrange(selmon);
++}
++
++void
+ setup(void) {
+ 	XSetWindowAttributes wa;
+ 
+@@ -1703,7 +1720,7 @@ textnw(const char *text, unsigned int le
+ 
+ void
+ tile(Monitor *m) {
+-	unsigned int i, n, h, mw, my, ty;
++	unsigned int i, n, h, smh, mw, my, ty;
+ 	Client *c;
+ 
+ 	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+@@ -1721,9 +1738,23 @@ tile(Monitor *m) {
+ 			my += HEIGHT(c);
+ 		}
+ 		else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+-			ty += HEIGHT(c);
++			smh = m->mh * m->smfact;
++			if(!(nexttiled(c->next)))
++				h = (m->wh - ty) / (n - i);
++			else
++				h = (m->wh - smh - ty) / (n - i);
++			if(h < minwsz) {
++				c->isfloating = True;
++				XRaiseWindow(dpy, c->win);
++				resize(c, m->mx + (m->mw / 2 - WIDTH(c) / 2), m->my + (m->mh / 2 - HEIGHT(c) / 2), m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++				ty -= HEIGHT(c);
++			}
++			else
++				resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++			if(!(nexttiled(c->next)))
++				ty += HEIGHT(c) + smh;
++			else
++				ty += HEIGHT(c);
+ 		}
+ }
+ 
diff --git a/patches/dwm-actualfullscreen-20211013-cb3f58a.diff b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
new file mode 100644
index 0000000..d3be230
--- /dev/null
+++ b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
@@ -0,0 +1,68 @@
+From eea13010ffc3983392857ee1e3804e3aa1064d7a Mon Sep 17 00:00:00 2001
+From: Soenke Lambert <s.lambert@mittwald.de>
+Date: Wed, 13 Oct 2021 18:21:09 +0200
+Subject: [PATCH] Fullscreen current window with [Alt]+[Shift]+[f]
+
+This actually fullscreens a window, instead of just hiding the statusbar
+and applying the monocle layout.
+---
+ config.def.h | 1 +
+ dwm.1        | 3 +++
+ dwm.c        | 8 ++++++++
+ 3 files changed, 12 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..8cd3204 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -78,6 +78,7 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..a368d05 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+ .B Mod1\-Shift\-c
+ Close focused window.
+ .TP
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
++.TP
+ .B Mod1\-Shift\-space
+ Toggle focused window between tiled and floating state.
+ .TP
+diff --git a/dwm.c b/dwm.c
+index 4465af1..c1b899a 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -211,6 +211,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -1719,6 +1720,13 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+-- 
+2.30.2
+
diff --git a/patches/dwm-alpha-20230401-348f655.diff b/patches/dwm-alpha-20230401-348f655.diff
new file mode 100644
index 0000000..c948f04
--- /dev/null
+++ b/patches/dwm-alpha-20230401-348f655.diff
@@ -0,0 +1,288 @@
+From ad5887df95fda706291c81ee143d0786a1717b12 Mon Sep 17 00:00:00 2001
+From: getimiskon <getimiskon@disroot.org>
+Date: Sat, 1 Apr 2023 16:22:01 +0300
+Subject: [PATCH] Allow dwm to have translucent bars, while keeping all the
+ text on it opaque, just like the alpha-patch for st. Updated for 348f655.
+
+---
+ config.def.h |  7 +++++++
+ config.mk    |  2 +-
+ drw.c        | 26 ++++++++++++-----------
+ drw.h        |  9 +++++---
+ dwm.c        | 59 ++++++++++++++++++++++++++++++++++++++++++++++------
+ 5 files changed, 81 insertions(+), 22 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 9efa774..8b3789a 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -12,11 +12,18 @@ static const char col_gray2[]       = "#444444";
+ static const char col_gray3[]       = "#bbbbbb";
+ static const char col_gray4[]       = "#eeeeee";
+ static const char col_cyan[]        = "#005577";
++static const unsigned int baralpha = 0xd0;
++static const unsigned int borderalpha = OPAQUE;
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ };
++static const unsigned int alphas[][3]      = {
++    /*               fg      bg        border*/
++    [SchemeNorm] = { OPAQUE, baralpha, borderalpha },
++	[SchemeSel]  = { OPAQUE, baralpha, borderalpha },
++};
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+diff --git a/config.mk b/config.mk
+index ba64d3d..d609c42 100644
+--- a/config.mk
++++ b/config.mk
+@@ -23,7 +23,7 @@ FREETYPEINC = /usr/include/freetype2
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lXrender
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/drw.c b/drw.c
+index a58a2b4..d18e8d8 100644
+--- a/drw.c
++++ b/drw.c
+@@ -61,7 +61,7 @@ utf8decode(const char *c, long *u, size_t clen)
+ }
+ 
+ Drw *
+-drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
++drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap)
+ {
+ 	Drw *drw = ecalloc(1, sizeof(Drw));
+ 
+@@ -70,8 +70,11 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
+ 	drw->root = root;
+ 	drw->w = w;
+ 	drw->h = h;
+-	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+-	drw->gc = XCreateGC(dpy, root, 0, NULL);
++	drw->visual = visual;
++	drw->depth = depth;
++	drw->cmap = cmap;
++	drw->drawable = XCreatePixmap(dpy, root, w, h, depth);
++	drw->gc = XCreateGC(dpy, drw->drawable, 0, NULL);
+ 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+ 
+ 	return drw;
+@@ -87,7 +90,7 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
+ 	drw->h = h;
+ 	if (drw->drawable)
+ 		XFreePixmap(drw->dpy, drw->drawable);
+-	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, drw->depth);
+ }
+ 
+ void
+@@ -181,21 +184,22 @@ drw_fontset_free(Fnt *font)
+ }
+ 
+ void
+-drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha)
+ {
+ 	if (!drw || !dest || !clrname)
+ 		return;
+ 
+-	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+-	                       DefaultColormap(drw->dpy, drw->screen),
++	if (!XftColorAllocName(drw->dpy, drw->visual, drw->cmap,
+ 	                       clrname, dest))
+ 		die("error, cannot allocate color '%s'", clrname);
++
++    dest->pixel = (dest->pixel & 0x00ffffffU) | (alpha << 24);
+ }
+ 
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+@@ -205,7 +209,7 @@ drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+ 		return NULL;
+ 
+ 	for (i = 0; i < clrcount; i++)
+-		drw_clr_create(drw, &ret[i], clrnames[i]);
++		drw_clr_create(drw, &ret[i], clrnames[i], alphas[i]);
+ 	return ret;
+ }
+ 
+@@ -263,9 +267,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ 	} else {
+ 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+ 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+-		d = XftDrawCreate(drw->dpy, drw->drawable,
+-		                  DefaultVisual(drw->dpy, drw->screen),
+-		                  DefaultColormap(drw->dpy, drw->screen));
++		d = XftDrawCreate(drw->dpy, drw->drawable, drw->visual, drw->cmap);
+ 		x += lpad;
+ 		w -= lpad;
+ 	}
+diff --git a/drw.h b/drw.h
+index 6471431..2143533 100644
+--- a/drw.h
++++ b/drw.h
+@@ -20,6 +20,9 @@ typedef struct {
+ 	Display *dpy;
+ 	int screen;
+ 	Window root;
++    Visual *visual;
++    unsigned int depth;
++    Colormap cmap;
+ 	Drawable drawable;
+ 	GC gc;
+ 	Clr *scheme;
+@@ -27,7 +30,7 @@ typedef struct {
+ } Drw;
+ 
+ /* Drawable abstraction */
+-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
++Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap);
+ void drw_resize(Drw *drw, unsigned int w, unsigned int h);
+ void drw_free(Drw *drw);
+ 
+@@ -39,8 +42,8 @@ unsigned int drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int
+ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
+ 
+ /* Colorscheme abstraction */
+-void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++void drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha);
++Clr *drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index c2bd871..3b34de8 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -56,6 +56,7 @@
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define OPAQUE                  0xffU
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -232,6 +233,7 @@ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++static void xinitvisual();
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
+@@ -268,6 +270,11 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static int useargb = 0;
++static Visual *visual;
++static int depth;
++static Colormap cmap;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -1558,7 +1565,8 @@ setup(void)
+ 	sw = DisplayWidth(dpy, screen);
+ 	sh = DisplayHeight(dpy, screen);
+ 	root = RootWindow(dpy, screen);
+-	drw = drw_create(dpy, screen, root, sw, sh);
++	xinitvisual();
++	drw = drw_create(dpy, screen, root, sw, sh, visual, depth, cmap);
+ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+ 		die("no fonts could be loaded.");
+ 	lrpad = drw->fonts->h;
+@@ -1586,7 +1594,7 @@ setup(void)
+ 	/* init appearance */
+ 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+ 	for (i = 0; i < LENGTH(colors); i++)
+-		scheme[i] = drw_scm_create(drw, colors[i], 3);
++		scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 3);
+ 	/* init bars */
+ 	updatebars();
+ 	updatestatus();
+@@ -1813,16 +1821,18 @@ updatebars(void)
+ 	Monitor *m;
+ 	XSetWindowAttributes wa = {
+ 		.override_redirect = True,
+-		.background_pixmap = ParentRelative,
++		.background_pixel = 0,
++		.border_pixel = 0,
++		.colormap = cmap,
+ 		.event_mask = ButtonPressMask|ExposureMask
+ 	};
+ 	XClassHint ch = {"dwm", "dwm"};
+ 	for (m = mons; m; m = m->next) {
+ 		if (m->barwin)
+ 			continue;
+-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+-				CopyFromParent, DefaultVisual(dpy, screen),
+-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, depth,
++				InputOutput, visual,
++				CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
+ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+ 		XMapRaised(dpy, m->barwin);
+ 		XSetClassHint(dpy, m->barwin, &ch);
+@@ -2120,6 +2130,43 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
+ 	return -1;
+ }
+ 
++void
++xinitvisual()
++{
++    XVisualInfo *infos;
++	XRenderPictFormat *fmt;
++	int nitems;
++	int i;
++
++	XVisualInfo tpl = {
++        .screen = screen,
++		.depth = 32,
++		.class = TrueColor
++	};
++	long masks = VisualScreenMask | VisualDepthMask | VisualClassMask;
++
++	infos = XGetVisualInfo(dpy, masks, &tpl, &nitems);
++	visual = NULL;
++	for(i = 0; i < nitems; i ++) {
++        fmt = XRenderFindVisualFormat(dpy, infos[i].visual);
++		if (fmt->type == PictTypeDirect && fmt->direct.alphaMask) {
++            visual = infos[i].visual;
++			depth = infos[i].depth;
++			cmap = XCreateColormap(dpy, root, visual, AllocNone);
++			useargb = 1;
++			break;
++        }
++    }
++
++	XFree(infos);
++
++	if (! visual) {
++        visual = DefaultVisual(dpy, screen);
++		depth = DefaultDepth(dpy, screen);
++		cmap = DefaultColormap(dpy, screen);
++    }
++}
++
+ void
+ zoom(const Arg *arg)
+ {
+-- 
+2.40.0
+
diff --git a/patches/dwm-autostart-20210120-cb3f58a.diff b/patches/dwm-autostart-20210120-cb3f58a.diff
new file mode 100644
index 0000000..efee676
--- /dev/null
+++ b/patches/dwm-autostart-20210120-cb3f58a.diff
@@ -0,0 +1,179 @@
+From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
+From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
+Date: Wed, 10 Jun 2020 10:59:02 +0000
+Subject: [PATCH] dwm-xdgautostart-6.2.diff
+
+===================================================================
+---
+ dwm.1 | 23 +++++++++++++++++
+ dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 105 insertions(+)
+
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..9533aa6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 4465af1..2156b49 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
+ static char stext[256];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+@@ -1380,6 +1386,83 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++		pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
+ void
+ scan(void)
+ {
+@@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+-- 
+2.27.0
+
diff --git a/patches/dwm-cfacts-vanitygaps-6.4_combo.diff b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
new file mode 100644
index 0000000..db2cc14
--- /dev/null
+++ b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
@@ -0,0 +1,1018 @@
+diff --git a/config.def.h b/config.def.h
+index 9efa774..357dc6f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,11 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+@@ -71,7 +91,26 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+diff --git a/dwm.c b/dwm.c
+index f1d86b2..5bbd733 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -87,6 +87,7 @@ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
++	float cfact;
+ 	int x, y, w, h;
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+@@ -119,6 +120,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -201,6 +206,7 @@ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+@@ -208,7 +214,6 @@ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -641,6 +646,10 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -1043,6 +1052,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+@@ -1521,6 +1531,24 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
++}
++
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+@@ -1684,34 +1712,6 @@ tagmon(const Arg *arg)
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
+-void
+-tile(Monitor *m)
+-{
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
+-
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
+-
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
+-}
+-
+ void
+ togglebar(const Arg *arg)
+ {
+diff --git a/vanitygaps.c b/vanitygaps.c
+new file mode 100644
+index 0000000..1a816b6
+--- /dev/null
++++ b/vanitygaps.c
+@@ -0,0 +1,822 @@
++/* Key binding functions */
++static void defaultgaps(const Arg *arg);
++static void incrgaps(const Arg *arg);
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
++static void togglegaps(const Arg *arg);
++/* Layouts (delete the ones you do not need) */
++static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
++static void centeredmaster(Monitor *m);
++static void centeredfloatingmaster(Monitor *m);
++static void deck(Monitor *m);
++static void dwindle(Monitor *m);
++static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
++static void spiral(Monitor *m);
++static void tile(Monitor *m);
++/* Internals */
++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++static void setgaps(int oh, int ov, int ih, int iv);
++
++/* Settings */
++#if !PERTAG_PATCH
++static int enablegaps = 1;
++#endif // PERTAG_PATCH
++
++void
++setgaps(int oh, int ov, int ih, int iv)
++{
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
++}
++
++void
++togglegaps(const Arg *arg)
++{
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
++}
++
++void
++defaultgaps(const Arg *arg)
++{
++	setgaps(gappoh, gappov, gappih, gappiv);
++}
++
++void
++incrgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++{
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
++
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
++}
++
++void
++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++{
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++}
++
++/***
++ * Layouts
++ */
++
++/*
++ * Bottomstack layout + gaps
++ * https://dwm.suckless.org/patches/bottomstack/
++ */
++static void
++bstack(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
++
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
++}
++
++/*
++ * Centred master layout + gaps
++ * https://dwm.suckless.org/patches/centeredmaster/
++ */
++void
++centeredmaster(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
++}
++
++void
++centeredfloatingmaster(Monitor *m)
++{
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * Deck layout + gaps
++ * https://dwm.suckless.org/patches/deck/
++ */
++void
++deck(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
++}
++
++/*
++ * Fibonacci layout + gaps
++ * https://dwm.suckless.org/patches/fibonacci/
++ */
++void
++fibonacci(Monitor *m, int s)
++{
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
++}
++
++void
++dwindle(Monitor *m)
++{
++	fibonacci(m, 1);
++}
++
++void
++spiral(Monitor *m)
++{
++	fibonacci(m, 0);
++}
++
++/*
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
++ */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
++
++/*
++ * Default tile layout + gaps
++ */
++static void
++tile(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++}
+\ No newline at end of file
diff --git a/patches/dwm-focusonclick-20200110-61bb8b2.diff b/patches/dwm-focusonclick-20200110-61bb8b2.diff
new file mode 100644
index 0000000..59c7a1d
--- /dev/null
+++ b/patches/dwm-focusonclick-20200110-61bb8b2.diff
@@ -0,0 +1,130 @@
+From 7ac0b812540e21b470f2f6947c6cc1e30bf24b42 Mon Sep 17 00:00:00 2001
+From: iofq <cjriddz@protonmail.com>
+Date: Sun, 10 Jan 2021 22:43:16 -0600
+Subject: [PATCH] tweak fixes floating window mouse controls
+
+---
+ config.def.h |  1 +
+ dwm.c        | 47 ++++-------------------------------------------
+ 2 files changed, 5 insertions(+), 43 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..4f2c946 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -5,6 +5,7 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ static const char *fonts[]          = { "monospace:size=10" };
+ static const char dmenufont[]       = "monospace:size=10";
+ static const char col_gray1[]       = "#222222";
+diff --git a/dwm.c b/dwm.c
+index 664c527..de3e883 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,7 +163,6 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+-static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+@@ -182,7 +181,6 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+@@ -250,13 +248,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+-	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+-	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+@@ -425,7 +421,8 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+@@ -445,8 +442,8 @@ buttonpress(XEvent *e)
+ 		else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+-		focus(c);
+-		restack(selmon);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -752,25 +749,6 @@ drawbars(void)
+ 		drawbar(m);
+ }
+ 
+-void
+-enternotify(XEvent *e)
+-{
+-	Client *c;
+-	Monitor *m;
+-	XCrossingEvent *ev = &e->xcrossing;
+-
+-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+-		return;
+-	c = wintoclient(ev->window);
+-	m = c ? c->mon : wintomon(ev->window);
+-	if (m != selmon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-	} else if (!c || c == selmon->sel)
+-		return;
+-	focus(c);
+-}
+-
+ void
+ expose(XEvent *e)
+ {
+@@ -1116,23 +1094,6 @@ monocle(Monitor *m)
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+-void
+-motionnotify(XEvent *e)
+-{
+-	static Monitor *mon = NULL;
+-	Monitor *m;
+-	XMotionEvent *ev = &e->xmotion;
+-
+-	if (ev->window != root)
+-		return;
+-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-		focus(NULL);
+-	}
+-	mon = m;
+-}
+-
+ void
+ movemouse(const Arg *arg)
+ {
+-- 
+2.30.0
+
diff --git a/patches/dwm-hide_vacant_tags-6.4.diff b/patches/dwm-hide_vacant_tags-6.4.diff
new file mode 100644
index 0000000..42d9c05
--- /dev/null
+++ b/patches/dwm-hide_vacant_tags-6.4.diff
@@ -0,0 +1,48 @@
+:100644 100644 f1d86b2 0000000 M	dwm.c
+
+diff --git a/dwm.c b/dwm.c
+index f1d86b2..d41cc14 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -433,9 +433,15 @@ buttonpress(XEvent *e)
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+-		do
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
+ 			x += TEXTW(tags[i]);
+-		while (ev->x >= x && ++i < LENGTH(tags));
++		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+@@ -715,19 +721,18 @@ drawbar(Monitor *m)
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-		occ |= c->tags;
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-		if (occ & 1 << i)
+-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+-				urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = TEXTW(m->ltsymbol);
diff --git a/patches/dwm-noborder-6.2.diff b/patches/dwm-noborder-6.2.diff
new file mode 100644
index 0000000..f381eb8
--- /dev/null
+++ b/patches/dwm-noborder-6.2.diff
@@ -0,0 +1,30 @@
+From 9102fdb9c670218373bbe83c891c8e8138d6a6f4 Mon Sep 17 00:00:00 2001
+From: redacted <redacted@example.com>
+Date: Tue, 23 Apr 2019 00:39:27 +0100
+Subject: [PATCH] added noborder patch
+
+---
+ dwm.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/dwm.c b/dwm.c
+index 4465af1..685eca1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -1282,6 +1282,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
+-- 
+2.21.0
+
diff --git a/patches/dwm-notitle-20210715-138b405.diff b/patches/dwm-notitle-20210715-138b405.diff
new file mode 100644
index 0000000..bc8a3e5
--- /dev/null
+++ b/patches/dwm-notitle-20210715-138b405.diff
@@ -0,0 +1,81 @@
+From a3a7e94f59553689656871a65ea9ce90169a7c91 Mon Sep 17 00:00:00 2001
+From: birdalicous <jack.bird@durham.ac.uk>
+Date: Thu, 15 Jul 2021 12:28:29 +0100
+Subject: [PATCH] notitle patch applied#
+
+---
+ config.def.h |  1 -
+ dwm.c        | 20 ++++----------------
+ 2 files changed, 4 insertions(+), 17 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..eac20b4 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -103,7 +103,6 @@ static Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..6cd9fb7 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -64,8 +64,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -440,10 +440,8 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+ 		else
+-			click = ClkWinTitle;
++			click = ClkStatusText;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -730,15 +728,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -1236,11 +1227,8 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
+-- 
+2.32.0
+
diff --git a/patches/dwm-savefloats-20181212-b69c870.diff b/patches/dwm-savefloats-20181212-b69c870.diff
new file mode 100644
index 0000000..f5d8ed8
--- /dev/null
+++ b/patches/dwm-savefloats-20181212-b69c870.diff
@@ -0,0 +1,42 @@
+diff --git i/dwm.c w/dwm.c
+index 4465af1..96b0b26 100644
+--- i/dwm.c
++++ w/dwm.c
+@@ -88,6 +88,7 @@ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
+ 	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+ 	int bw, oldbw;
+@@ -1056,6 +1057,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -1714,8 +1719,16 @@ togglefloating(const Arg *arg)
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
+ 	arrange(selmon);
+ }
+ 
diff --git a/patches/dwm-scratchpads-20200414-728d397b.diff b/patches/dwm-scratchpads-20200414-728d397b.diff
new file mode 100644
index 0000000..d3e90c0
--- /dev/null
+++ b/patches/dwm-scratchpads-20200414-728d397b.diff
@@ -0,0 +1,199 @@
+From 728d397b21982af88737277fd9d6939a7b558786 Mon Sep 17 00:00:00 2001
+From: Christian Tenllado <ctenllado@gmail.com>
+Date: Tue, 14 Apr 2020 23:31:15 +0200
+Subject: [PATCH] Multiple scratchpads
+
+This patch enables multiple scratchpads, each with one asigned window.
+This enables the same scratchpad workflow that you have in i3.
+
+Scratchpads are implemented as special tags, whose mask does not
+apply to new spawned windows. To assign a window to a scratchpad you
+have to set up a rule, as you do with regular tags.
+
+Windows tagged with scratchpad tags can be set floating or not in the
+rules array. Most users would probably want them floating (i3 style),
+but having them tiled does also perfectly work and might fit better the
+DWM approach. In case they are set floating, the patch moves them to the
+center of the screen whenever they are shown. The patch can easily be
+modified to make this last feature configurable in the rules array (see
+the center patch).
+
+The togglescratch function, borrowed from the previous scratchpad patch
+and slightly modified, can be used to spawn a registered scratchpad
+process or toggle its view. This function looks for a window tagged with
+the selected scratchpad tag. If it is found its view is toggled. If it is
+not found the corresponding registered command is spawned. The
+config.def.h shows three examples of its use to spawn a terminal in the
+first scratchpad tag, a second terminal running ranger on the second
+scratchpad tag and the keepassxc application to manage passwords on a
+third scratchpad tag.
+
+If you prefer to spawn your scratchpad applications from the startup
+script, you might opt for binding keys to toggleview instead, as
+scratchpads are just special tags (you may even extend the TAGKEYS macro
+to generalize the key bindings).
+---
+ config.def.h | 28 ++++++++++++++++++++++++----
+ dwm.c        | 43 +++++++++++++++++++++++++++++++++++++++++--
+ 2 files changed, 65 insertions(+), 6 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..06265e1 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -18,17 +18,33 @@ static const char *colors[][3]      = {
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ };
+ 
++typedef struct {
++	const char *name;
++	const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++const char *spcmd3[] = {"keepassxc", NULL };
++static Sp scratchpads[] = {
++	/* name          cmd  */
++	{"spterm",      spcmd1},
++	{"spranger",    spcmd2},
++	{"keepassxc",   spcmd3},
++};
++
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+-
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	{ "Gimp",	  NULL,			NULL,		0,				1,			 -1 },
++	{ "Firefox",  NULL,			NULL,		1 << 8,			0,			 -1 },
++	{ NULL,		  "spterm",		NULL,		SPTAG(0),		1,			 -1 },
++	{ NULL,		  "spfm",		NULL,		SPTAG(1),		1,			 -1 },
++	{ NULL,		  "keepassxc",	NULL,		SPTAG(2),		0,			 -1 },
+ };
+ 
+ /* layout(s) */
+@@ -59,6 +75,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++
+ static Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+@@ -84,6 +101,9 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+@@ -106,7 +126,7 @@ static Button buttons[] = {
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+diff --git a/dwm.c b/dwm.c
+index 4465af1..646aa1a 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -54,7 +54,10 @@
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ 
+ /* enums */
+@@ -211,6 +214,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglescratch(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -299,6 +303,11 @@ applyrules(Client *c)
+ 		{
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+@@ -308,7 +317,7 @@ applyrules(Client *c)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+@@ -1616,6 +1625,10 @@ showhide(Client *c)
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+@@ -1719,6 +1732,32 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglescratch(const Arg *arg)
++{
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+-- 
+2.20.1
+
diff --git a/patches/dwm-stacker-6.2.diff b/patches/dwm-stacker-6.2.diff
new file mode 100644
index 0000000..8fe3b80
--- /dev/null
+++ b/patches/dwm-stacker-6.2.diff
@@ -0,0 +1,197 @@
+From d04f2d00688c8b0969d4f10f460c980dd91dac37 Mon Sep 17 00:00:00 2001
+From: MLquest8 <miskuzius@gmail.com>
+Date: Fri, 12 Jun 2020 16:04:18 +0400
+Subject: [PATCH] stacker updated for version 6.2
+
+---
+ config.def.h | 14 +++++++--
+ dwm.c        | 88 ++++++++++++++++++++++++++++++++++++++++------------
+ 2 files changed, 80 insertions(+), 22 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..d28f8fc 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -50,6 +50,14 @@ static const Layout layouts[] = {
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++#define STACKKEYS(MOD,ACTION) \
++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+@@ -64,8 +72,8 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++	STACKKEYS(MODKEY,                          focus)
++	STACKKEYS(MODKEY|ShiftMask,                push)
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+@@ -93,7 +101,7 @@ static Key keys[] = {
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 9fd0286..6c302c3 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -47,15 +47,21 @@
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define GETINC(X)               ((X) - 2000)
++#define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define PREVSEL                 3000
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -187,6 +193,7 @@ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+ static void propertynotify(XEvent *e);
++static void pushstack(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -207,6 +214,7 @@ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
++static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+@@ -833,27 +841,16 @@ focusmon(const Arg *arg)
+ void
+ focusstack(const Arg *arg)
+ {
+-	Client *c = NULL, *i;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-	if (!selmon->sel)
++	if(i < 0)
+ 		return;
+-	if (arg->i > 0) {
+-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+-		if (!c)
+-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+-	} else {
+-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+-			if (ISVISIBLE(i))
+-				c = i;
+-		if (!c)
+-			for (; i; i = i->next)
+-				if (ISVISIBLE(i))
+-					c = i;
+-	}
+-	if (c) {
+-		focus(c);
+-		restack(selmon);
+-	}
++
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+@@ -1246,6 +1243,29 @@ propertynotify(XEvent *e)
+ 	}
+ }
+ 
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -1653,6 +1673,36 @@ spawn(const Arg *arg)
+ 	}
+ }
+ 
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
+ void
+ tag(const Arg *arg)
+ {
+-- 
+2.26.2
+
diff --git a/patches/dwm-status2d-6.3.diff b/patches/dwm-status2d-6.3.diff
new file mode 100644
index 0000000..52bf58d
--- /dev/null
+++ b/patches/dwm-status2d-6.3.diff
@@ -0,0 +1,166 @@
+diff --git a/dwm.c b/dwm.c
+index a96f33c..24b1eeb 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,6 +163,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -485,7 +486,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+@@ -693,6 +694,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -707,9 +816,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1571,7 +1678,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
diff --git a/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
new file mode 100644
index 0000000..4adb383
--- /dev/null
+++ b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
@@ -0,0 +1,188 @@
+From 05f9b3c45d4267d52724b2a76f333ba00353cab3 Mon Sep 17 00:00:00 2001
+From: Daniel Bylinka <daniel.bylinka@gmail.com>
+Date: Fri, 2 Apr 2021 19:04:58 +0200
+Subject: [PATCH] [statuscmd] status2d compatibility
+
+---
+ config.def.h |  6 +++-
+ dwm.c        | 83 ++++++++++++++++++++++++++++++++++++++++++++++++----
+ 2 files changed, 83 insertions(+), 6 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..154a59b 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -54,6 +54,8 @@ static const Layout layouts[] = {
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+@@ -103,7 +105,9 @@ static Button buttons[] = {
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+diff --git a/dwm.c b/dwm.c
+index acbe6c9..ba478b9 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -173,6 +173,7 @@ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -207,6 +208,7 @@ static void setup(void);
+ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+@@ -239,6 +241,9 @@ static void zoom(const Arg *arg);
+ /* variables */
+ static const char broken[] = "broken";
+ static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -441,9 +446,34 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++		else if (ev->x > selmon->ww - statusw) {
++			x = selmon->ww - statusw;
+ 			click = ClkStatusText;
+-		else
++
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
++		} else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+@@ -696,7 +726,7 @@ dirtomon(int dir)
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+-	int ret, i, w, x, len;
++	int ret, i, j, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+@@ -705,7 +735,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+-	memcpy(text, stext, len);
++
++	i = -1, j = 0;
++	while (stext[++i])
++		if ((unsigned char)stext[i] >= ' ')
++			text[j++] = stext[i];
++	text[j] = '\0';
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+@@ -813,7 +848,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		tw = m->ww - drawstatusbar(m, bh, stext);
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -979,6 +1014,30 @@ getatomprop(Client *c, Atom prop)
+ 	return atom;
+ }
+ 
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
++}
++
+ int
+ getrootptr(int *x, int *y)
+ {
+@@ -1745,6 +1804,20 @@ sigchld(int unused)
+ 	while (0 < waitpid(-1, NULL, WNOHANG));
+ }
+ 
++void
++sigstatusbar(const Arg *arg)
++{
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++}
++
+ void
+ spawn(const Arg *arg)
+ {
+-- 
+2.31.0
+
diff --git a/patches/dwm-sticky-20240927-60f7034.diff b/patches/dwm-sticky-20240927-60f7034.diff
new file mode 100644
index 0000000..055d019
--- /dev/null
+++ b/patches/dwm-sticky-20240927-60f7034.diff
@@ -0,0 +1,146 @@
+From 60f7034ca1573e10cf9e005e2ef5a44e6b76ea9b Mon Sep 17 00:00:00 2001
+From: elbachir-one <bachiralfa@gmail.com>
+Date: Fri, 27 Sep 2024 12:35:36 +0100
+Subject: [PATCH] Added the missing keybinding
+
+---
+ config.def.h |  1 +
+ dwm.c        | 43 ++++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 41 insertions(+), 3 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 9efa774..55c0a6c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -95,6 +95,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 67c6b2b..e8ed755 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -49,7 +49,7 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+@@ -61,7 +61,7 @@
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+@@ -92,7 +92,7 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -200,6 +200,7 @@ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+@@ -211,6 +212,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglesticky(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -525,6 +527,10 @@ clientmessage(XEvent *e)
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -1507,6 +1513,23 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1576,6 +1599,7 @@ setup(void)
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+@@ -1735,6 +1759,15 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglesticky(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
++	arrange(selmon);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+@@ -2027,6 +2060,9 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+@@ -2163,3 +2199,4 @@ main(int argc, char *argv[])
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
++
+-- 
+2.46.0
+
diff --git a/patches/dwm-swallow-6.3.diff b/patches/dwm-swallow-6.3.diff
new file mode 100644
index 0000000..47586a0
--- /dev/null
+++ b/patches/dwm-swallow-6.3.diff
@@ -0,0 +1,412 @@
+From 0cf9a007511f7dfd7dd94171b172562ebac9b6d5 Mon Sep 17 00:00:00 2001
+From: Tom Schwindl <schwindl@posteo.de>
+Date: Sat, 10 Sep 2022 12:51:09 +0200
+Subject: [PATCH] 6.3 swallow patch
+
+---
+ config.def.h |   9 +-
+ config.mk    |   3 +-
+ dwm.c        | 235 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ 3 files changed, 237 insertions(+), 10 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 061ad662f82a..0b2b8ffd30d5 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,7 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -26,9 +27,11 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+diff --git a/config.mk b/config.mk
+index 81c493ef4aff..52d1ebf30bec 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/dwm.c b/dwm.c
+index e5efb6a22806..e68294b6b679 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -40,6 +40,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -92,9 +98,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++	pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++	Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -138,6 +146,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -235,6 +245,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
+ static const char broken[] = "broken";
+ static char stext[256];
+@@ -269,6 +285,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -298,6 +316,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -416,6 +436,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -656,6 +723,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -1022,12 +1092,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1042,6 +1113,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1076,6 +1148,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -1763,6 +1837,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -1778,9 +1866,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2044,6 +2135,136 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2133,10 +2354,12 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
+-- 
+2.37.2
+
diff --git a/patches/dwm-tagshift-6.3.diff b/patches/dwm-tagshift-6.3.diff
new file mode 100644
index 0000000..fb4d1d7
--- /dev/null
+++ b/patches/dwm-tagshift-6.3.diff
@@ -0,0 +1,69 @@
+diff --git a/config.def.h b/config.def.h
+index a2ac963..1bbede2 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -69,6 +69,10 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+diff --git a/dwm.c b/dwm.c
+index a96f33c..4bf0f70 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -204,6 +204,8 @@ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shiftview(const Arg *arg);
++static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+@@ -1632,6 +1634,40 @@ showhide(Client *c)
+ 	}
+ }
+ 
++void
++shiftview(const Arg *arg) {
++	Arg shifted;
++
++	if(arg->i > 0) /* left circular shift */
++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++
++	else /* right circular shift */
++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++
++	view(&shifted);
++}
++
++void
++shifttag(const Arg *arg) {
++	Arg shifted;
++	Client *c;
++
++	if (!selmon->sel)
++		return;
++	c = selmon->sel;
++
++	if (arg->i > 0) /* left circular shift */
++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++			^ (c->tags >> (LENGTH(tags) - arg->i));
++	else /* right circular shift */
++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++			^ (c->tags << (LENGTH(tags) + arg->i));
++
++	toggletag(&shifted);
++}
++
+ void
+ sigchld(int unused)
+ {
diff --git a/patches/dwm-xresources-20210827-138b405.diff b/patches/dwm-xresources-20210827-138b405.diff
new file mode 100644
index 0000000..29852a9
--- /dev/null
+++ b/patches/dwm-xresources-20210827-138b405.diff
@@ -0,0 +1,240 @@
+From f30583c6e2ab5e7de6ef4ebf156076ac0f6e69fc Mon Sep 17 00:00:00 2001
+From: Jack Bird <jack.bird@durham.ac.uk>
+Date: Fri, 27 Aug 2021 00:53:14 +0100
+Subject: [PATCH] xresources updated for 138b405
+
+---
+ config.def.h | 61 ++++++++++++++++++++++++++++++--------------
+ drw.c        |  2 +-
+ drw.h        |  2 +-
+ dwm.c        | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 116 insertions(+), 21 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..87ac198 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -1,21 +1,23 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+-static const unsigned int snap      = 32;       /* snap pixel */
+-static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static unsigned int borderpx  = 1;        /* border pixel of windows */
++static unsigned int snap      = 32;       /* snap pixel */
++static int showbar            = 1;        /* 0 means no bar */
++static int topbar             = 1;        /* 0 means bottom bar */
++static char font[]            = "monospace:size=10";
++static char dmenufont[]       = "monospace:size=10";
++static const char *fonts[]          = { font };
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
+ /* tagging */
+@@ -32,9 +34,9 @@ static const Rule rules[] = {
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+-static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ static const Layout layouts[] = {
+@@ -57,9 +59,30 @@ static const Layout layouts[] = {
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",               STRING,  &font },
++		{ "dmenufont",          STRING,  &dmenufont },
++		{ "normbgcolor",        STRING,  &normbgcolor },
++		{ "normbordercolor",    STRING,  &normbordercolor },
++		{ "normfgcolor",        STRING,  &normfgcolor },
++		{ "selbgcolor",         STRING,  &selbgcolor },
++		{ "selbordercolor",     STRING,  &selbordercolor },
++		{ "selfgcolor",         STRING,  &selfgcolor },
++		{ "borderpx",          	INTEGER, &borderpx },
++		{ "snap",          		INTEGER, &snap },
++		{ "showbar",          	INTEGER, &showbar },
++		{ "topbar",          	INTEGER, &topbar },
++		{ "nmaster",          	INTEGER, &nmaster },
++		{ "resizehints",       	INTEGER, &resizehints },
++		{ "mfact",      	 	FLOAT,   &mfact },
++};
++
+ static Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+diff --git a/drw.c b/drw.c
+index 4cdbcbe..8f1059e 100644
+--- a/drw.c
++++ b/drw.c
+@@ -208,7 +208,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 4bcd5ad..42b04ce 100644
+--- a/drw.h
++++ b/drw.h
+@@ -39,7 +39,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..2214b19 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -36,6 +36,7 @@
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
++#include <X11/Xresource.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+@@ -141,6 +142,19 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -234,6 +248,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
++static void load_xresources(void);
++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+@@ -2127,6 +2143,60 @@ zoom(const Arg *arg)
+ 	pop(c);
+ }
+ 
++void
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
++}
++
++void
++load_xresources(void)
++{
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
++}
++
+ int
+ main(int argc, char *argv[])
+ {
+@@ -2139,6 +2209,8 @@ main(int argc, char *argv[])
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
+ 	checkotherwm();
++	XrmInitialize();
++	load_xresources();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec", NULL) == -1)
+-- 
+2.33.0
+
diff --git a/patches/get.sh b/patches/get.sh
new file mode 100755
index 0000000..8c998a9
--- /dev/null
+++ b/patches/get.sh
@@ -0,0 +1,86 @@
+# Example
+# https://dwm.suckless.org/patches/alpha/
+# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
+# exit 0
+
+download_if_not_exists() {
+  local url="$1"
+  local filename=$(basename "$url") # Extract the file name from the URL
+
+  # Check if the file already exists
+  if [[ -f "$filename" ]]; then
+    echo "File '$filename' already exists. Skipping download."
+  else
+    echo "Downloading '$filename'..."
+    curl -O "$url"
+    if [[ $? -eq 0 ]]; then
+      echo "Downloaded '$filename' successfully."
+    else
+      echo "Failed to download '$filename'."
+    fi
+  fi
+}
+
+# https://dwm.suckless.org/patches/noborder/
+download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborder-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderfloatingfix-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderselflickerfix-2022042627-d93ff48803f0.diff
+
+# https://dwm.suckless.org/patches/stackmfact/
+download_if_not_exists https://dwm.suckless.org/patches/stackmfact/dwm-6.0-smfact.diff
+
+# https://dwm.suckless.org/patches/notitle/
+download_if_not_exists https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
+
+# https://dwm.suckless.org/patches/sticky/
+download_if_not_exists https://dwm.suckless.org/patches/sticky/dwm-sticky-20240927-60f7034.diff
+
+# https://dwm.suckless.org/patches/actualfullscreen/
+download_if_not_exists https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
+
+# https://dwm.suckless.org/patches/tagshift/
+download_if_not_exists https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
+
+# https://dwm.suckless.org/patches/statuscmd/
+#download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20241009-8933ebc.diff
+download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-status2d-20210405-60bb3df.diff
+
+# https://dwm.suckless.org/patches/swallow/
+download_if_not_exists https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
+
+# https://dwm.suckless.org/patches/xresources/
+download_if_not_exists https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
+
+# https://dwm.suckless.org/patches/hide_vacant_tags/
+download_if_not_exists https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.4.diff
+
+# https://dwm.suckless.org/patches/stacker/
+download_if_not_exists https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
+
+# https://dwm.suckless.org/patches/vanitygaps/
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-20190508-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
+download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
+
+# https://dwm.suckless.org/patches/autostart/
+download_if_not_exists https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
+
+# https://dwm.suckless.org/patches/scratchpad/
+#download_if_not_exists https://dwm.suckless.org/patches/scratchpad/dwm-scratchpad-20240321-061e9fe.diff
+
+#https://dwm.suckless.org/patches/scratchpads/
+download_if_not_exists https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
+
+# https://dwm.suckless.org/patches/focusonclick/
+download_if_not_exists https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
+
+# https://dwm.suckless.org/patches/save_floats/
+download_if_not_exists https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
+
+# https://dwm.suckless.org/patches/status2d/
+#download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-systray-6.4.diff
+download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-6.3.diff
+
diff --git a/patches_git/dwm-actualfullscreen.diff b/patches_git/dwm-actualfullscreen.diff
new file mode 100644
index 0000000..5aa0294
--- /dev/null
+++ b/patches_git/dwm-actualfullscreen.diff
@@ -0,0 +1,52 @@
+diff --git a/config.def.h b/config.def.h
+index 583f383..880a46a 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -118,6 +118,7 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+diff --git a/dwm.1 b/dwm.1
+index ddc8321..3d310ac 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+ .B Mod1\-Shift\-c
+ Close focused window.
+ .TP
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
++.TP
+ .B Mod1\-Shift\-space
+ Toggle focused window between tiled and floating state.
+ .TP
+diff --git a/dwm.c b/dwm.c
+index f9989e1..9ae5616 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -216,6 +216,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -1837,6 +1838,13 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-autostart.diff b/patches_git/dwm-autostart.diff
new file mode 100644
index 0000000..a09e438
--- /dev/null
+++ b/patches_git/dwm-autostart.diff
@@ -0,0 +1,165 @@
+diff --git a/dwm.1 b/dwm.1
+index 3d310ac..d04bec6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -155,6 +163,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 758c5ac..91fac46 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -200,6 +201,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -244,7 +246,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
+ static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+@@ -1514,6 +1520,83 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++		pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
+ void
+ scan(void)
+ {
+@@ -2322,6 +2405,7 @@ main(int argc, char *argv[])
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
diff --git a/patches_git/dwm-focusonclick.diff b/patches_git/dwm-focusonclick.diff
new file mode 100644
index 0000000..baf3978
--- /dev/null
+++ b/patches_git/dwm-focusonclick.diff
@@ -0,0 +1,117 @@
+diff --git a/config.def.h b/config.def.h
+index 69d4822..0c94360 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -11,6 +11,7 @@ static const unsigned int gappov    = 30;       /* vert outer gap between window
+ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static int showbar            = 1;        /* 0 means no bar */
+ static int topbar             = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ static char font[]            = "monospace:size=10";
+ static char dmenufont[]       = "monospace:size=10";
+ static const char *fonts[]          = { font };
+diff --git a/dwm.c b/dwm.c
+index c71fa3c..aec2675 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -203,7 +203,6 @@ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+-static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+@@ -223,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+@@ -315,13 +313,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+-	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+-	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+@@ -548,7 +544,8 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+@@ -597,8 +594,8 @@ buttonpress(XEvent *e)
+ 				}
+ 			}
+ 	} else if ((c = wintoclient(ev->window))) {
+-		focus(c);
+-		restack(selmon);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -1022,25 +1019,6 @@ drawbars(void)
+ 		drawbar(m);
+ }
+ 
+-void
+-enternotify(XEvent *e)
+-{
+-	Client *c;
+-	Monitor *m;
+-	XCrossingEvent *ev = &e->xcrossing;
+-
+-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+-		return;
+-	c = wintoclient(ev->window);
+-	m = c ? c->mon : wintomon(ev->window);
+-	if (m != selmon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-	} else if (!c || c == selmon->sel)
+-		return;
+-	focus(c);
+-}
+-
+ void
+ expose(XEvent *e)
+ {
+@@ -1412,23 +1390,6 @@ monocle(Monitor *m)
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+-void
+-motionnotify(XEvent *e)
+-{
+-	static Monitor *mon = NULL;
+-	Monitor *m;
+-	XMotionEvent *ev = &e->xmotion;
+-
+-	if (ev->window != root)
+-		return;
+-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-		focus(NULL);
+-	}
+-	mon = m;
+-}
+-
+ void
+ movemouse(const Arg *arg)
+ {
diff --git a/patches_git/dwm-hide_vacant_tags.diff b/patches_git/dwm-hide_vacant_tags.diff
new file mode 100644
index 0000000..b9320f6
--- /dev/null
+++ b/patches_git/dwm-hide_vacant_tags.diff
@@ -0,0 +1,46 @@
+diff --git a/dwm.c b/dwm.c
+index 0d205d0..34d25b6 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -441,9 +441,15 @@ buttonpress(XEvent *e)
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+-		do
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
+ 			x += TEXTW(tags[i]);
+-		while (ev->x >= x && ++i < LENGTH(tags));
++		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+@@ -831,19 +837,18 @@ drawbar(Monitor *m)
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-		occ |= c->tags;
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-		if (occ & 1 << i)
+-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+-				urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = TEXTW(m->ltsymbol);
diff --git a/patches_git/dwm-noborder.diff b/patches_git/dwm-noborder.diff
new file mode 100644
index 0000000..59cf669
--- /dev/null
+++ b/patches_git/dwm-noborder.diff
@@ -0,0 +1,18 @@
+diff --git a/dwm.c b/dwm.c
+index 1443802..857c396 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -1291,6 +1291,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
diff --git a/patches_git/dwm-notitle.diff b/patches_git/dwm-notitle.diff
new file mode 100644
index 0000000..b23989f
--- /dev/null
+++ b/patches_git/dwm-notitle.diff
@@ -0,0 +1,68 @@
+diff --git a/config.def.h b/config.def.h
+index 357dc6f..583f383 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -142,7 +142,6 @@ static const Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+diff --git a/dwm.c b/dwm.c
+index 82fc028..f9989e1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -63,8 +63,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -446,10 +446,8 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+ 		else
+-			click = ClkWinTitle;
++			click = ClkStatusText;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -850,15 +848,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -1361,11 +1352,8 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
diff --git a/patches_git/dwm-savefloats.diff b/patches_git/dwm-savefloats.diff
new file mode 100644
index 0000000..b66f755
--- /dev/null
+++ b/patches_git/dwm-savefloats.diff
@@ -0,0 +1,42 @@
+diff --git a/dwm.c b/dwm.c
+index 34d25b6..758c5ac 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -88,6 +88,7 @@ struct Client {
+ 	float mina, maxa;
+ 	float cfact;
+ 	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+@@ -1183,6 +1184,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -1874,8 +1879,16 @@ togglefloating(const Arg *arg)
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
+ 	arrange(selmon);
+ }
+ 
diff --git a/patches_git/dwm-scratchpads.diff b/patches_git/dwm-scratchpads.diff
new file mode 100644
index 0000000..0bef30e
--- /dev/null
+++ b/patches_git/dwm-scratchpads.diff
@@ -0,0 +1,133 @@
+diff --git a/config.def.h b/config.def.h
+index 1919b6c..69d4822 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -26,6 +26,20 @@ static char *colors[][3] = {
+        [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
++typedef struct {
++	const char *name;
++	const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++const char *spcmd3[] = {"keepassxc", NULL };
++static Sp scratchpads[] = {
++	/* name          cmd  */
++	{"spterm",      spcmd1},
++	{"spranger",    spcmd2},
++	{"keepassxc",   spcmd3},
++};
++
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+@@ -165,6 +179,9 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+@@ -189,7 +206,7 @@ static const Button buttons[] = {
+ 	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+diff --git a/dwm.c b/dwm.c
+index 87bc8c5..c71fa3c 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -66,7 +66,10 @@
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+@@ -256,6 +259,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglescratch(const Arg *arg);
+ static void togglesticky(const Arg *arg);
+ static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -365,6 +369,11 @@ applyrules(Client *c)
+ 			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+@@ -374,7 +383,7 @@ applyrules(Client *c)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+@@ -2085,6 +2094,10 @@ showhide(Client *c)
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+@@ -2228,6 +2241,32 @@ togglesticky(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglescratch(const Arg *arg)
++{
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-stacker.diff b/patches_git/dwm-stacker.diff
new file mode 100644
index 0000000..cde0a99
--- /dev/null
+++ b/patches_git/dwm-stacker.diff
@@ -0,0 +1,183 @@
+diff --git a/config.def.h b/config.def.h
+index 9ed2869..1919b6c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -76,6 +76,14 @@ static const Layout layouts[] = {
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++#define STACKKEYS(MOD,ACTION) \
++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+@@ -113,8 +121,8 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++	STACKKEYS(MODKEY,                          focus)
++	STACKKEYS(MODKEY|ShiftMask,                push)
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+@@ -166,7 +174,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+ 	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+diff --git a/dwm.c b/dwm.c
+index cb3067d..87bc8c5 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -55,14 +55,20 @@
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define GETINC(X)               ((X) - 2000)
++#define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++#define PREVSEL                 3000
++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -219,6 +225,7 @@ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+ static void propertynotify(XEvent *e);
++static void pushstack(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -244,6 +251,7 @@ static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
++static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+@@ -1086,27 +1094,16 @@ focusmon(const Arg *arg)
+ void
+ focusstack(const Arg *arg)
+ {
+-	Client *c = NULL, *i;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++	if(i < 0)
+ 		return;
+-	if (arg->i > 0) {
+-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+-		if (!c)
+-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+-	} else {
+-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+-			if (ISVISIBLE(i))
+-				c = i;
+-		if (!c)
+-			for (; i; i = i->next)
+-				if (ISVISIBLE(i))
+-					c = i;
+-	}
+-	if (c) {
+-		focus(c);
+-		restack(selmon);
+-	}
++
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+@@ -1533,6 +1530,29 @@ propertynotify(XEvent *e)
+ 	}
+ }
+ 
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -2113,6 +2133,36 @@ spawn(const Arg *arg)
+ 	}
+ }
+ 
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
+ void
+ tag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-status2d.diff b/patches_git/dwm-status2d.diff
new file mode 100644
index 0000000..c600b66
--- /dev/null
+++ b/patches_git/dwm-status2d.diff
@@ -0,0 +1,166 @@
+diff --git a/dwm.c b/dwm.c
+index db7e0c8..82fc028 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -167,6 +167,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -240,7 +241,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -490,7 +491,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	free(scheme);
+ 	XDestroyWindow(dpy, wmcheckwin);
+@@ -703,6 +704,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -717,9 +826,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1618,7 +1725,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
diff --git a/patches_git/dwm-statuscmd-status2d.diff b/patches_git/dwm-statuscmd-status2d.diff
new file mode 100644
index 0000000..bac794e
--- /dev/null
+++ b/patches_git/dwm-statuscmd-status2d.diff
@@ -0,0 +1,174 @@
+diff --git a/config.def.h b/config.def.h
+index 2099993..f74867c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -75,6 +75,8 @@ static const Layout layouts[] = {
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+@@ -148,7 +150,9 @@ static const Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+diff --git a/dwm.c b/dwm.c
+index 2fddeb1..ed799c2 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -179,6 +179,7 @@ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -217,6 +218,7 @@ static void seturgent(Client *c, int urg);
+ static void shiftview(const Arg *arg);
+ static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+@@ -254,6 +256,9 @@ static const char broken[] = "broken";
+ static const char dwmdir[] = "dwm";
+ static const char localshare[] = ".local/share";
+ static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -464,8 +469,33 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+ 			click = ClkLtSymbol;
+-		else
+-			click = ClkStatusText;
++        } else if (ev->x > selmon->ww - statusw) {
++            x = selmon->ww - statusw;
++            click = ClkStatusText;
++
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -726,7 +756,7 @@ dirtomon(int dir)
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+-	int ret, i, w, x, len;
++	int ret, i, j, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+@@ -735,7 +765,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+-	memcpy(text, stext, len);
++
++	i = -1, j = 0;
++	while (stext[++i])
++		if ((unsigned char)stext[i] >= ' ')
++			text[j++] = stext[i];
++	text[j] = '\0';
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+@@ -846,7 +881,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		tw = m->ww - drawstatusbar(m, bh, stext);
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1004,6 +1039,30 @@ getatomprop(Client *c, Atom prop)
+ 	return atom;
+ }
+ 
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
++}
++
+ int
+ getrootptr(int *x, int *y)
+ {
+@@ -1928,6 +1987,20 @@ showhide(Client *c)
+ 	}
+ }
+ 
++void
++sigstatusbar(const Arg *arg)
++{
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++}
++
+ void
+ spawn(const Arg *arg)
+ {
diff --git a/patches_git/dwm-sticky.diff b/patches_git/dwm-sticky.diff
new file mode 100644
index 0000000..0657003
--- /dev/null
+++ b/patches_git/dwm-sticky.diff
@@ -0,0 +1,133 @@
+diff --git a/config.def.h b/config.def.h
+index f6c7894..2099993 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -139,6 +139,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 91fac46..2fddeb1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -50,7 +50,7 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+@@ -61,7 +61,7 @@
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+@@ -94,7 +94,7 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -208,6 +208,7 @@ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
+ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+@@ -221,6 +222,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglesticky(const Arg *arg);
+ static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+@@ -544,6 +546,10 @@ clientmessage(XEvent *e)
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -1714,6 +1720,23 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1835,6 +1858,7 @@ setup(void)
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+@@ -1982,6 +2006,15 @@ togglefullscr(const Arg *arg)
+     setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+ }
+ 
++void
++togglesticky(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
++	arrange(selmon);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+@@ -2274,6 +2307,9 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+@@ -2411,3 +2447,4 @@ main(int argc, char *argv[])
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
++
diff --git a/patches_git/dwm-swallow.diff b/patches_git/dwm-swallow.diff
new file mode 100644
index 0000000..8119113
--- /dev/null
+++ b/patches_git/dwm-swallow.diff
@@ -0,0 +1,398 @@
+diff --git a/config.def.h b/config.def.h
+index f74867c..5a9f2d4 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,7 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+@@ -31,9 +32,11 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+diff --git a/config.mk b/config.mk
+index 8efca9a..a933c0b 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/dwm.c b/dwm.c
+index ed799c2..a424e60 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -41,6 +41,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -94,9 +100,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
++    pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++    Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -144,6 +152,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -249,6 +259,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
+ static const char autostartblocksh[] = "autostart_blocking.sh";
+ static const char autostartsh[] = "autostart.sh";
+@@ -290,6 +306,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -319,6 +337,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -437,6 +457,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -714,6 +781,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -1217,12 +1287,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1238,6 +1309,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1276,6 +1348,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -2134,6 +2208,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -2149,9 +2237,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2418,6 +2509,136 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2507,10 +2728,12 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
diff --git a/patches_git/dwm-tagshift.diff b/patches_git/dwm-tagshift.diff
new file mode 100644
index 0000000..b416cd8
--- /dev/null
+++ b/patches_git/dwm-tagshift.diff
@@ -0,0 +1,69 @@
+diff --git a/config.def.h b/config.def.h
+index 880a46a..f6c7894 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -89,6 +89,10 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ 	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+diff --git a/dwm.c b/dwm.c
+index 9ae5616..0d205d0 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -210,6 +210,8 @@ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shiftview(const Arg *arg);
++static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+@@ -1633,6 +1635,40 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++shiftview(const Arg *arg) {
++	Arg shifted;
++
++	if(arg->i > 0) /* left circular shift */
++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++
++	else /* right circular shift */
++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++
++	view(&shifted);
++}
++
++void
++shifttag(const Arg *arg) {
++	Arg shifted;
++	Client *c;
++
++	if (!selmon->sel)
++		return;
++	c = selmon->sel;
++
++	if (arg->i > 0) /* left circular shift */
++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++			^ (c->tags >> (LENGTH(tags) - arg->i));
++	else /* right circular shift */
++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++			^ (c->tags << (LENGTH(tags) + arg->i));
++
++	toggletag(&shifted);
++}
++
+ void
+ setcfact(const Arg *arg) {
+ 	float f;
diff --git a/patches_git/dwm-vanitygaps.diff b/patches_git/dwm-vanitygaps.diff
new file mode 100644
index 0000000..1f1b7b5
--- /dev/null
+++ b/patches_git/dwm-vanitygaps.diff
@@ -0,0 +1,1018 @@
+diff --git a/config.def.h b/config.def.h
+index 9efa774..357dc6f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,11 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+@@ -71,7 +91,26 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+diff --git a/dwm.c b/dwm.c
+index 857c396..db7e0c8 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -86,6 +86,7 @@ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
++	float cfact;
+ 	int x, y, w, h;
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+@@ -118,6 +119,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -200,6 +205,7 @@ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+@@ -207,7 +213,6 @@ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -640,6 +645,10 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -1042,6 +1051,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+@@ -1527,6 +1537,24 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
++}
++
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+@@ -1690,34 +1718,6 @@ tagmon(const Arg *arg)
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
+-void
+-tile(Monitor *m)
+-{
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
+-
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
+-
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
+-}
+-
+ void
+ togglebar(const Arg *arg)
+ {
+diff --git a/vanitygaps.c b/vanitygaps.c
+new file mode 100644
+index 0000000..1a816b6
+--- /dev/null
++++ b/vanitygaps.c
+@@ -0,0 +1,822 @@
++/* Key binding functions */
++static void defaultgaps(const Arg *arg);
++static void incrgaps(const Arg *arg);
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
++static void togglegaps(const Arg *arg);
++/* Layouts (delete the ones you do not need) */
++static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
++static void centeredmaster(Monitor *m);
++static void centeredfloatingmaster(Monitor *m);
++static void deck(Monitor *m);
++static void dwindle(Monitor *m);
++static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
++static void spiral(Monitor *m);
++static void tile(Monitor *m);
++/* Internals */
++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++static void setgaps(int oh, int ov, int ih, int iv);
++
++/* Settings */
++#if !PERTAG_PATCH
++static int enablegaps = 1;
++#endif // PERTAG_PATCH
++
++void
++setgaps(int oh, int ov, int ih, int iv)
++{
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
++}
++
++void
++togglegaps(const Arg *arg)
++{
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
++}
++
++void
++defaultgaps(const Arg *arg)
++{
++	setgaps(gappoh, gappov, gappih, gappiv);
++}
++
++void
++incrgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++{
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
++
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
++}
++
++void
++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++{
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++}
++
++/***
++ * Layouts
++ */
++
++/*
++ * Bottomstack layout + gaps
++ * https://dwm.suckless.org/patches/bottomstack/
++ */
++static void
++bstack(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
++
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
++}
++
++/*
++ * Centred master layout + gaps
++ * https://dwm.suckless.org/patches/centeredmaster/
++ */
++void
++centeredmaster(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
++}
++
++void
++centeredfloatingmaster(Monitor *m)
++{
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * Deck layout + gaps
++ * https://dwm.suckless.org/patches/deck/
++ */
++void
++deck(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
++}
++
++/*
++ * Fibonacci layout + gaps
++ * https://dwm.suckless.org/patches/fibonacci/
++ */
++void
++fibonacci(Monitor *m, int s)
++{
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
++}
++
++void
++dwindle(Monitor *m)
++{
++	fibonacci(m, 1);
++}
++
++void
++spiral(Monitor *m)
++{
++	fibonacci(m, 0);
++}
++
++/*
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
++ */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
++
++/*
++ * Default tile layout + gaps
++ */
++static void
++tile(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++}
+\ No newline at end of file
diff --git a/patches_git/dwm-xresources.diff b/patches_git/dwm-xresources.diff
new file mode 100644
index 0000000..220fdff
--- /dev/null
+++ b/patches_git/dwm-xresources.diff
@@ -0,0 +1,231 @@
+diff --git a/config.def.h b/config.def.h
+index 5a9f2d4..9ed2869 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -1,27 +1,29 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+-static const unsigned int snap      = 32;       /* snap pixel */
++static unsigned int borderpx  = 1;        /* border pixel of windows */
++static unsigned int snap      = 32;       /* snap pixel */
+ static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+ static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+-static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static int showbar            = 1;        /* 0 means no bar */
++static int topbar             = 1;        /* 0 means bottom bar */
++static char font[]            = "monospace:size=10";
++static char dmenufont[]       = "monospace:size=10";
++static const char *fonts[]          = { font };
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
+ /* tagging */
+@@ -40,9 +42,9 @@ static const Rule rules[] = {
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+-static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ #define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+@@ -82,9 +84,30 @@ static const Layout layouts[] = {
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",               STRING,  &font },
++		{ "dmenufont",          STRING,  &dmenufont },
++		{ "normbgcolor",        STRING,  &normbgcolor },
++		{ "normbordercolor",    STRING,  &normbordercolor },
++		{ "normfgcolor",        STRING,  &normfgcolor },
++		{ "selbgcolor",         STRING,  &selbgcolor },
++		{ "selbordercolor",     STRING,  &selbordercolor },
++		{ "selfgcolor",         STRING,  &selfgcolor },
++		{ "borderpx",          	INTEGER, &borderpx },
++		{ "snap",          		INTEGER, &snap },
++		{ "showbar",          	INTEGER, &showbar },
++		{ "topbar",          	INTEGER, &topbar },
++		{ "nmaster",          	INTEGER, &nmaster },
++		{ "resizehints",       	INTEGER, &resizehints },
++		{ "mfact",      	 	FLOAT,   &mfact },
++};
++
+ static const Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+diff --git a/drw.c b/drw.c
+index c41e6af..6be5dee 100644
+--- a/drw.c
++++ b/drw.c
+@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 6471431..bdbf950 100644
+--- a/drw.h
++++ b/drw.h
+@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index a424e60..cb3067d 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -37,6 +37,7 @@
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
++#include <X11/Xresource.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+@@ -157,6 +158,19 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -258,6 +272,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
++static void load_xresources(void);
++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+ 
+ static pid_t getparentprocess(pid_t p);
+ static int isdescprocess(pid_t p, pid_t c);
+@@ -2717,6 +2733,60 @@ zoom(const Arg *arg)
+ 	pop(c);
+ }
+ 
++void
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
++}
++
++void
++load_xresources(void)
++{
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
++}
++
+ int
+ main(int argc, char *argv[])
+ {
+@@ -2731,6 +2801,8 @@ main(int argc, char *argv[])
+ 	if (!(xcon = XGetXCBConnection(dpy)))
+ 		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
++	XrmInitialize();
++	load_xresources();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec ps", NULL) == -1)
diff --git a/vanitygaps.c b/vanitygaps.c
new file mode 100644
index 0000000..5acce38
--- /dev/null
+++ b/vanitygaps.c
@@ -0,0 +1,837 @@
+/* Key binding functions */
+static void defaultgaps(const Arg *arg);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void togglebgaps(const Arg *arg);
+/* Layouts (delete the ones you do not need) */
+static void bstack(Monitor *m);
+static void bstackhoriz(Monitor *m);
+static void centeredmaster(Monitor *m);
+static void centeredfloatingmaster(Monitor *m);
+static void deck(Monitor *m);
+static void dwindle(Monitor *m);
+static void fibonacci(Monitor *m, int s);
+static void grid(Monitor *m);
+static void nrowgrid(Monitor *m);
+static void spiral(Monitor *m);
+static void tile(Monitor *m);
+/* Internals */
+static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+static void setgaps(int oh, int ov, int ih, int iv);
+
+/* Settings */
+#if !PERTAG_PATCH
+static int enablegaps = 1;
+#endif // PERTAG_PATCH
+
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	#if PERTAG_PATCH
+	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	enablegaps = !enablegaps;
+	#endif // PERTAG_PATCH
+	arrange(NULL);
+}
+
+static void
+togglebgaps(const Arg *arg)
+{
+    browsergaps = !browsergaps;
+    arrange(NULL);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+{
+	unsigned int n, oe, ie;
+	#if PERTAG_PATCH
+	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	oe = ie = enablegaps;
+	#endif // PERTAG_PATCH
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (smartgaps && n == 1) {
+		oe = 0; // outer gaps disabled when only one client
+	}
+
+    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+        if (TAGMASK == (1 << 8)){
+            setgaps(gappoh, gappov, gappih, gappiv);
+        }
+    }
+
+	*oh = m->gappoh*oe; // outer horizontal gap
+	*ov = m->gappov*oe; // outer vertical gap
+	*ih = m->gappih*ie; // inner horizontal gap
+	*iv = m->gappiv*ie; // inner vertical gap
+	*nc = n;            // number of clients
+}
+
+void
+getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+{
+	unsigned int n;
+	float mfacts = 0, sfacts = 0;
+	int mtotal = 0, stotal = 0;
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mtotal += msize * (c->cfact / mfacts);
+		else
+			stotal += ssize * (c->cfact / sfacts);
+
+	*mf = mfacts; // total factor of master area
+	*sf = sfacts; // total factor of stack area
+	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+}
+
+/***
+ * Layouts
+ */
+
+/*
+ * Bottomstack layout + gaps
+ * https://dwm.suckless.org/patches/bottomstack/
+ */
+static void
+bstack(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sx = mx;
+		sy = my + mh + ih;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+	}
+}
+
+static void
+bstackhoriz(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh;
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+	}
+
+	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+	}
+}
+
+/*
+ * Centred master layout + gaps
+ * https://dwm.suckless.org/patches/centeredmaster/
+ */
+void
+centeredmaster(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int lx = 0, ly = 0, lw = 0, lh = 0;
+	int rx = 0, ry = 0, rw = 0, rh = 0;
+	float mfacts = 0, lfacts = 0, rfacts = 0;
+	int mtotal = 0, ltotal = 0, rtotal = 0;
+	int mrest = 0, lrest = 0, rrest = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* initialize areas */
+	mx = m->wx + ov;
+	my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+	mw = m->ww - 2*ov;
+	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+
+	if (m->nmaster && n > m->nmaster) {
+		/* go mfact box in the center if more than nmaster clients */
+		if (n - m->nmaster > 1) {
+			/* ||<-S->|<---M--->|<-S->|| */
+			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+			mx += lw + iv;
+		} else {
+			/* ||<---M--->|<-S->|| */
+			mw = (mw - iv) * m->mfact;
+			lw = 0;
+			rw = m->ww - mw - iv - 2*ov;
+		}
+		lx = m->wx + ov;
+		ly = m->wy + oh;
+		rx = mx + mw + iv;
+		ry = m->wy + oh;
+	}
+
+	/* calculate facts */
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+		if (!m->nmaster || n < m->nmaster)
+			mfacts += c->cfact;
+		else if ((n - m->nmaster) % 2)
+			lfacts += c->cfact; // total factor of left hand stack area
+		else
+			rfacts += c->cfact; // total factor of right hand stack area
+	}
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (!m->nmaster || n < m->nmaster)
+			mtotal += mh * (c->cfact / mfacts);
+		else if ((n - m->nmaster) % 2)
+			ltotal += lh * (c->cfact / lfacts);
+		else
+			rtotal += rh * (c->cfact / rfacts);
+
+	mrest = mh - mtotal;
+	lrest = lh - ltotal;
+	rrest = rh - rtotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (!m->nmaster || i < m->nmaster) {
+			/* nmaster clients are stacked vertically, in the center of the screen */
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			/* stack clients are stacked vertically */
+			if ((i - m->nmaster) % 2 ) {
+				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+				ly += HEIGHT(c) + ih;
+			} else {
+				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+				ry += HEIGHT(c) + ih;
+			}
+		}
+	}
+}
+
+void
+centeredfloatingmaster(Monitor *m)
+{
+	unsigned int i, n;
+	float mfacts, sfacts;
+	float mivf = 1.0; // master inner vertical gap factor
+	int oh, ov, ih, iv, mrest, srest;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv*(n - 1);
+	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		mivf = 0.8;
+		/* go mfact box in the center if more than nmaster clients */
+		if (m->ww > m->wh) {
+			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * 0.9;
+		} else {
+			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * m->mfact;
+		}
+		mx = m->wx + (m->ww - mw) / 2;
+		my = m->wy + (m->wh - mh - 2*oh) / 2;
+
+		sx = m->wx + ov;
+		sy = m->wy + oh;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			/* nmaster clients are stacked horizontally, in the center of the screen */
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv*mivf;
+		} else {
+			/* stack clients are stacked horizontally */
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * Deck layout + gaps
+ * https://dwm.suckless.org/patches/deck/
+ */
+void
+deck(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	if (n - m->nmaster > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+		}
+}
+
+/*
+ * Fibonacci layout + gaps
+ * https://dwm.suckless.org/patches/fibonacci/
+ */
+void
+fibonacci(Monitor *m, int s)
+{
+	unsigned int i, n;
+	int nx, ny, nw, nh;
+	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	nx = m->wx + ov;
+	ny = m->wy + oh;
+	nw = m->ww - 2*ov;
+	nh = m->wh - 2*oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
+
+				if ((i % 4) == 2 && !s)
+					nx += nw + iv;
+				else if ((i % 4) == 3 && !s)
+					ny += nh + ih;
+			}
+
+			if ((i % 4) == 0) {
+				if (s) {
+					ny += nh + ih;
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
+					ny -= nh + ih;
+				}
+			}
+			else if ((i % 4) == 1) {
+				nx += nw + iv;
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
+				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
+			else if ((i % 4) == 3) {
+				if (s) {
+					nx += nw + iv;
+					nw -= wrest;
+				} else {
+					nw -= wrest;
+					nx -= nw + iv;
+					nh += hrest;
+				}
+			}
+			if (i == 0)	{
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
+				ny = m->wy + oh;
+			}
+			else if (i == 1)
+				nw = m->ww - nw - iv - 2*ov;
+			i++;
+		}
+
+		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+	}
+}
+
+void
+dwindle(Monitor *m)
+{
+	fibonacci(m, 1);
+}
+
+void
+spiral(Monitor *m)
+{
+	fibonacci(m, 0);
+}
+
+/*
+ * Gappless grid layout + gaps (ironically)
+ * https://dwm.suckless.org/patches/gaplessgrid/
+ */
+void
+gaplessgrid(Monitor *m)
+{
+	unsigned int i, n;
+	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* grid dimensions */
+	for (cols = 0; cols <= n/2; cols++)
+		if (cols*cols >= n)
+			break;
+	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+		cols = 2;
+	rows = n/cols;
+	cn = rn = 0; // reset column no, row no, client count
+
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	x = m->wx + ov;
+	y = m->wy + oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+		if (i/rows + 1 > cols - n%cols) {
+			rows = n/cols + 1;
+			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+		}
+		resize(c,
+			x,
+			y + rn*(ch + ih) + MIN(rn, rrest),
+			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+			0);
+		rn++;
+		if (rn >= rows) {
+			rn = 0;
+			x += cw + ih + (cn < crest ? 1 : 0);
+			cn++;
+		}
+	}
+}
+
+/*
+ * Gridmode layout + gaps
+ * https://dwm.suckless.org/patches/gridmode/
+ */
+void
+grid(Monitor *m)
+{
+	unsigned int i, n;
+	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* grid dimensions */
+	for (rows = 0; rows <= n/2; rows++)
+		if (rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		cc = i / rows;
+		cr = i % rows;
+		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+	}
+}
+
+/*
+ * Horizontal grid layout + gaps
+ * https://dwm.suckless.org/patches/horizgrid/
+ */
+void
+horizgrid(Monitor *m) {
+	Client *c;
+	unsigned int n, i;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	int ntop, nbottom = 1;
+	float mfacts = 0, sfacts = 0;
+	int mrest, srest, mtotal = 0, stotal = 0;
+
+	/* Count windows */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	if (n <= 2)
+		ntop = n;
+	else {
+		ntop = n / 2;
+		nbottom = n - ntop;
+	}
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	sw = mw = m->ww - 2*ov;
+
+	if (n > ntop) {
+		sh = (mh - ih) / 2;
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		mw = m->ww - 2*ov - iv * (ntop - 1);
+		sw = m->ww - 2*ov - iv * (nbottom - 1);
+	}
+
+	/* calculate facts */
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mtotal += mh * (c->cfact / mfacts);
+		else
+			stotal += sw * (c->cfact / sfacts);
+
+	mrest = mh - mtotal;
+	srest = sw - stotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * nrowgrid layout + gaps
+ * https://dwm.suckless.org/patches/nrowgrid/
+ */
+void
+nrowgrid(Monitor *m)
+{
+	unsigned int n;
+	int ri = 0, ci = 0;  /* counters */
+	int oh, ov, ih, iv;                         /* vanitygap settings */
+	unsigned int cx, cy, cw, ch;                /* client geometry */
+	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+	unsigned int cols, rows = m->nmaster + 1;
+	Client *c;
+
+	/* count clients */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* nothing to do here */
+	if (n == 0)
+		return;
+
+	/* force 2 clients to always split vertically */
+	if (FORCE_VSPLIT && n == 2)
+		rows = 1;
+
+	/* never allow empty rows */
+	if (n < rows)
+		rows = n;
+
+	/* define first row */
+	cols = n / rows;
+	uc = cols;
+	cy = m->wy + oh;
+	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+	uh = ch;
+
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+		if (ci == cols) {
+			uw = 0;
+			ci = 0;
+			ri++;
+
+			/* next row */
+			cols = (n - uc) / (rows - ri);
+			uc += cols;
+			cy = m->wy + oh + uh + ih;
+			uh += ch + ih;
+		}
+
+		cx = m->wx + ov + uw;
+		cw = (m->ww - 2*ov - uw) / (cols - ci);
+		uw += cw + iv;
+
+		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+	}
+}
+
+/*
+ * Default tile layout + gaps
+ */
+static void
+tile(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+}
