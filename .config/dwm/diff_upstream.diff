diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..d42c9e0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,54 @@
+# Prerequisites
+*.d
+
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Linker output
+*.ilk
+*.map
+*.exp
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+*.idb
+*.pdb
+
+# Kernel Module Compile Results
+*.mod*
+*.cmd
+.tmp_versions/
+modules.order
+Module.symvers
+Mkfile.old
+dkms.conf
+a.out
+dwm
diff --git a/config.def.h b/config.def.h
index 9efa774..0c94360 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,21 +1,44 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+static unsigned int borderpx  = 1;        /* border pixel of windows */
+static unsigned int snap      = 32;       /* snap pixel */
+static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+static int showbar            = 1;        /* 0 means no bar */
+static int topbar             = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
+static char font[]            = "monospace:size=10";
+static char dmenufont[]       = "monospace:size=10";
+static const char *fonts[]          = { font };
+static char normbgcolor[]           = "#222222";
+static char normbordercolor[]       = "#444444";
+static char normfgcolor[]           = "#bbbbbb";
+static char selfgcolor[]            = "#eeeeee";
+static char selbordercolor[]        = "#005577";
+static char selbgcolor[]            = "#005577";
+static char *colors[][3] = {
+       /*               fg           bg           border   */
+       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+};
+
+typedef struct {
+	const char *name;
+	const void *cmd;
+} Sp;
+const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+const char *spcmd3[] = {"keepassxc", NULL };
+static Sp scratchpads[] = {
+	/* name          cmd  */
+	{"spterm",      spcmd1},
+	{"spranger",    spcmd2},
+	{"keepassxc",   spcmd3},
 };
 
 /* tagging */
@@ -26,22 +49,39 @@ static const Rule rules[] = {
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
 };
 
 /* layout(s) */
-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
-static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static int nmaster     = 1;    /* number of clients in master area */
+static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
 static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
 
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+#include "vanitygaps.c"
+
 static const Layout layouts[] = {
 	/* symbol     arrange function */
 	{ "[]=",      tile },    /* first entry is default */
-	{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
+	{ "[@]",      spiral },
+	{ "[\\]",     dwindle },
+	{ "H[]",      deck },
+	{ "TTT",      bstack },
+	{ "===",      bstackhoriz },
+	{ "HHH",      grid },
+	{ "###",      nrowgrid },
+	{ "---",      horizgrid },
+	{ ":::",      gaplessgrid },
+	{ "|M|",      centeredmaster },
+	{ ">M>",      centeredfloatingmaster },
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ NULL,       NULL },
 };
 
 /* key definitions */
@@ -51,27 +91,81 @@ static const Layout layouts[] = {
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+#define STACKKEYS(MOD,ACTION) \
+	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
+	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
+	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
+	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
+	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
+	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
+	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
+#define STATUSBAR "dwmblocks"
+
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+		{ "font",               STRING,  &font },
+		{ "dmenufont",          STRING,  &dmenufont },
+		{ "normbgcolor",        STRING,  &normbgcolor },
+		{ "normbordercolor",    STRING,  &normbordercolor },
+		{ "normfgcolor",        STRING,  &normfgcolor },
+		{ "selbgcolor",         STRING,  &selbgcolor },
+		{ "selbordercolor",     STRING,  &selbordercolor },
+		{ "selfgcolor",         STRING,  &selfgcolor },
+		{ "borderpx",          	INTEGER, &borderpx },
+		{ "snap",          		INTEGER, &snap },
+		{ "showbar",          	INTEGER, &showbar },
+		{ "topbar",          	INTEGER, &topbar },
+		{ "nmaster",          	INTEGER, &nmaster },
+		{ "resizehints",       	INTEGER, &resizehints },
+		{ "mfact",      	 	FLOAT,   &mfact },
+};
+
 static const Key keys[] = {
 	/* modifier                     key        function        argument */
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
 	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+	STACKKEYS(MODKEY,                          focus)
+	STACKKEYS(MODKEY|ShiftMask,                push)
 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
+	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
@@ -79,12 +173,16 @@ static const Key keys[] = {
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
 	TAGKEYS(                        XK_1,                      0)
 	TAGKEYS(                        XK_2,                      1)
 	TAGKEYS(                        XK_3,                      2)
@@ -94,7 +192,8 @@ static const Key keys[] = {
 	TAGKEYS(                        XK_7,                      6)
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+	{ MODKEY,                       XK_s,      togglesticky,   {0} },
 };
 
 /* button definitions */
@@ -103,11 +202,12 @@ static const Button buttons[] = {
 	/* click                event mask      button          function        argument */
 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
 	{ ClkTagBar,            0,              Button1,        view,           {0} },
 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..303596c
--- /dev/null
+++ b/config.h
@@ -0,0 +1,365 @@
+/* See LICENSE file for copyright and license details. */
+
+/* Constants */
+/* #define TERMINAL "st" */
+/* #define TERMCLASS "St" */
+/* #define TERMINAL "urxvt" */
+/* #define TERMCLASS "Urxvt" */
+/* #define TERMINAL "alacritty" */
+/* #define TERMCLASS "alacritty" */
+#define TERMINAL "wezterm"
+#define TERMCLASS "wezterm"
+#define SECTERMINAL "st"
+
+#define FILES "thunar"
+//#define FILEX "ranger"
+#define FILEX "yazi"
+
+/* appearance */
+static unsigned int borderpx    = 3;        /* border pixel of windows */
+static const unsigned int gappx = 10;       /* default gap between windows in pixels */
+static unsigned int snap        = 32;       /* snap pixel */
+static unsigned int gappih      = 20;       /* horiz inner gap between windows */
+static unsigned int gappiv      = 20;       /* vert inner gap between windows */
+static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
+static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
+static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
+static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
+static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
+static int showbar              = 1;        /* 0 means no bar */
+static int topbar               = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
+/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
+/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
+static char normbgcolor[]       = "#282828";
+static char normbordercolor[]   = "#282828";
+static char normfgcolor[]       = "#ebdbb2";
+static char selfgcolor[]        = "#ebdbb2";
+static char selbordercolor[]    = "#ebdbb2";
+static char selbgcolor[]        = "#282828";
+static const char col1[]        = "#98971a";
+static const char col21[]       = "#fb4934";
+static const char col22[]       = "#ebdbb2";
+static const char col23[]       = "#458588";
+static const char col24[]       = "#ebdbb2";
+static const char col3[]        = "#fabd2f";
+static const char col4[]        = "#83a598";
+static const char col5[]        = "#d3869b";
+static const char col6[]        = "#8ec07c";
+static char *colors[][3]        = {
+    /*               fg              bg              border   */
+    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
+    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
+};
+
+typedef struct {
+    const char *name;
+    const void *cmd;
+} Sp;
+//const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
+//const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
+const char *spcmd1[] = {"st", "-n", "spterm", "-e", "python3", NULL };
+const char *spcmd2[] = {"st", "-n", "spcalc", NULL };
+/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
+static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spcalc",      spcmd2},
+};
+
+/* tagging */
+static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
+
+static const Rule rules[] = {
+    /* xprop(1):
+     *    WM_CLASS(STRING) = instance, class
+     *    WM_NAME(STRING) = title
+     */
+    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
+    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
+    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
+    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
+    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
+    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
+    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
+    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
+};
+
+/* layout(s) */
+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static int nmaster     = 1;    /* number of clients in master area */
+static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+#include "vanitygaps.c"
+static const Layout layouts[] = {
+    /* symbol       arrange function */
+    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
+    { "[]=",        tile },                     /* Master on left, slaves on right */
+    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
+    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
+    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
+    { "[M]",        monocle },                  /* All windows on top of eachother */
+    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
+    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
+    { "><>",        NULL },                     /* no layout function means floating behavior */
+    { NULL,         NULL },
+};
+
+/* key definitions */
+#define MODKEY Mod4Mask
+#define MODKEY1 Mod1Mask
+#define TAGKEYS(KEY,TAG) \
+{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
+{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
+{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
+{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
+/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
+#define STACKKEYS(MOD,ACTION) \
+{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
+{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
+{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
+{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
+/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
+/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
+
+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+#define STATUSBAR "dwmblocks"
+
+/* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+static const char *termcmd[]  = { TERMINAL, NULL };
+//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
+
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+    { "color0",             STRING,     &normbordercolor },
+    { "foreground",         STRING,     &selbordercolor },
+    /* { "color8",             STRING,     &selbordercolor }, */
+    { "color0",             STRING,     &normbgcolor },
+    { "foreground",         STRING,     &normfgcolor },
+    { "color0",             STRING,     &selfgcolor },
+    { "foreground",         STRING,     &selbgcolor },
+    { "borderpx",           INTEGER,    &borderpx },
+    { "snap",               INTEGER,    &snap },
+    { "showbar",            INTEGER,    &showbar },
+    { "topbar",             INTEGER,    &topbar },
+    { "nmaster",            INTEGER,    &nmaster },
+    { "resizehints",        INTEGER,    &resizehints },
+    { "mfact",              FLOAT,      &mfact },
+    { "gappih",             INTEGER,    &gappih },
+    { "gappiv",             INTEGER,    &gappiv },
+    { "gappoh",             INTEGER,    &gappoh },
+    { "gappov",             INTEGER,    &gappov },
+    { "swallowfloating",    INTEGER,    &swallowfloating },
+    { "smartgaps",          INTEGER,    &smartgaps },
+};
+
+#include <X11/XF86keysym.h>
+
+static const Key keys[] = {
+    /*  modifier                    key                 function            argument */
+        STACKKEYS(MODKEY,                               focus)
+        STACKKEYS(MODKEY|ShiftMask,                     push)
+        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
+        TAGKEYS(                    XK_1,               0)
+        TAGKEYS(                    XK_2,               1)
+        TAGKEYS(                    XK_3,               2)
+        TAGKEYS(                    XK_4,               3)
+        TAGKEYS(                    XK_5,               4)
+        TAGKEYS(                    XK_6,               5)
+        TAGKEYS(                    XK_7,               6)
+        TAGKEYS(                    XK_8,               7)
+        TAGKEYS(                    XK_9,               8)
+        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
+        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
+
+        /* Layouts */
+        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
+        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
+        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
+        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
+        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
+        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
+        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
+        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
+        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
+        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
+        { MODKEY,                   XK_f,               togglefullscr,      {0} },
+        { MODKEY,                   XK_space,           togglefloating,     {0} },
+        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
+        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
+        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
+        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
+        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
+        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
+        { MODKEY,                   XK_x,               defaultgaps,        {0} },
+        { MODKEY,                   XK_z,               togglegaps,         {0} },
+        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
+        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
+        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
+        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+        { MODKEY,                   XK_q,               killclient,         {0} },
+        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
+        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
+        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
+        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
+        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
+        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
+        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
+        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
+        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
+        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
+        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
+        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
+
+        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
+        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
+        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
+        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
+        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
+        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
+        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
+        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
+        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
+        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
+        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
+        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
+        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
+        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
+        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
+        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
+        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
+        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
+        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
+        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/files_wd.sh") },
+        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
+        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
+        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
+        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
+        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
+        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
+        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
+        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
+        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
+        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
+        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
+        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
+        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
+        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
+        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
+        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
+        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
+
+        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
+        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
+        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
+        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
+        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
+        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
+        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
+        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
+        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
+        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
+
+        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
+        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
+        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
+        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
+        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
+        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
+        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
+        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
+        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
+        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
+        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
+        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
+        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
+
+        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
+        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
+        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
+        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
+        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
+        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
+        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
+        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
+        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
+        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
+        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
+        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
+        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
+        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
+        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
+        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
+        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
+        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
+        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
+        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
+        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
+        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
+        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
+        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
+        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
+        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
+};
+
+#define STATUSBAR "dwmblocks"
+
+/* button definitions */
+/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
+static const Button buttons[] = {
+    /* click                event mask      button          function        argument */
+#ifndef __OpenBSD__
+    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
+#endif
+    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
+    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
+    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
+    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
+    { ClkTagBar,            0,              Button1,        view,           {0} },
+    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
+    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
+    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
+};
diff --git a/config.mk b/config.mk
index 8efca9a..a933c0b 100644
--- a/config.mk
+++ b/config.mk
@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
 #FREETYPEINC = ${X11INC}/freetype2
 #MANPREFIX = ${PREFIX}/man
+#KVMLIB = -lkvm
 
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
 
 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
diff --git a/diff_bkp.diff b/diff_bkp.diff
new file mode 100644
index 0000000..f618161
--- /dev/null
+++ b/diff_bkp.diff
@@ -0,0 +1,7460 @@
+diff --git a/LICENSE b/LICENSE
+index 1e1b5a4..995172f 100644
+--- a/LICENSE
++++ b/LICENSE
+@@ -17,7 +17,7 @@ MIT/X Consortium License
+ © 2015-2016 Quentin Rameau <quinq@fifth.space>
+ © 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
+ © 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
+-© 2019-2020 Luke Smith <luke@lukesmith.xyz>
++© 2020-2022 Chris Down <chris@chrisdown.name>
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the "Software"),
+diff --git a/Makefile b/Makefile
+index 63569d7..ffa69b4 100644
+--- a/Makefile
++++ b/Makefile
+@@ -13,16 +13,19 @@ all: dwm
+ 
+ ${OBJ}: config.h config.mk
+ 
++config.h:
++	cp config.def.h $@
++
+ dwm: ${OBJ}
+ 	${CC} -o $@ ${OBJ} ${LDFLAGS}
+ 
+ clean:
+-	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
++	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
+ 
+ dist: clean
+ 	mkdir -p dwm-${VERSION}
+-	cp -R LICENSE Makefile README config.mk\
+-		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
++	cp -R LICENSE Makefile README config.def.h config.mk\
++		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
+ 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
+ 	gzip dwm-${VERSION}.tar
+ 	rm -rf dwm-${VERSION}
+@@ -34,7 +37,6 @@ install: all
+ 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
+ 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
+ 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
+-	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
+ 
+ uninstall:
+ 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
+diff --git a/README b/README
+index 482b545..95d4fd0 100644
+--- a/README
++++ b/README
+@@ -1,13 +1,5 @@
+-See patches in dir 'patches'.
+-
+-I also continously add fixes from suckless git log:
+-https://git.suckless.org/
+-https://dwm.suckless.org/
+-
+-============================
+ dwm - dynamic window manager
+ ============================
+-
+ dwm is an extremely fast, small, and dynamic window manager for X.
+ 
+ 
+diff --git a/config.h b/config.h
+index 342750a..4613e1b 100644
+--- a/config.h
++++ b/config.h
+@@ -28,13 +28,15 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
+ static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
+ static int showbar              = 1;        /* 0 means no bar */
+ static int topbar               = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
+ /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+ static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
+-static char normbgcolor[]       = "#222222";
+-static char normbordercolor[]   = "#444444";
+-static char normfgcolor[]       = "#bbbbbb";
+-static char selfgcolor[]        = "#eeeeee";
++//static char normbgcolor[]       = "#222222";
++static char normbgcolor[]       = "#282828";
++static char normbordercolor[]   = "#ebdbb2";
++static char normfgcolor[]       = "#ebdbb2";
++static char selfgcolor[]        = "#ebdbb2";
+ static char selbordercolor[]    = "#770000";
+ static char selbgcolor[]        = "#005577";
+ static const char col1[]        = "#98971a";
+@@ -127,8 +129,13 @@ static const Layout layouts[] = {
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
++static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *termcmd[]  = { TERMINAL, NULL };
++//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
+ 
+ /*
+  * Xresources preferences to load at startup
+@@ -157,7 +164,6 @@ ResourcePref resources[] = {
+ };
+ 
+ #include <X11/XF86keysym.h>
+-#include "shiftview.c"
+ 
+ static const Key keys[] = {
+     /*  modifier                    key                 function            argument */
+@@ -203,12 +209,12 @@ static const Key keys[] = {
+         { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+         { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+         { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+-        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
+-        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
++        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
++        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         { MODKEY,                   XK_q,               killclient,         {0} },
+-        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
++        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
+         { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+         { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+         { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+@@ -328,17 +334,19 @@ static const Key keys[] = {
+         /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
+ };
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
+ static const Button buttons[] = {
+     /* click                event mask      button          function        argument */
+ #ifndef __OpenBSD__
+-    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
+-    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
+-    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
+-    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
+-    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
+-    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
++    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
++    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
++    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
+ #endif
+     { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
+     { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+diff --git a/config.mk b/config.mk
+index 1fc4bf1..a933c0b 100644
+--- a/config.mk
++++ b/config.mk
+@@ -19,10 +19,12 @@ FREETYPELIBS = -lfontconfig -lXft
+ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
++#MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/drw.c b/drw.c
+index d43d8c2..6be5dee 100644
+--- a/drw.c
++++ b/drw.c
+@@ -13,7 +13,6 @@
+ static int
+ utf8decode(const char *s_in, long *u, int *err)
+ {
+-
+ 	static const unsigned char lens[] = {
+ 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+ 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
+@@ -27,63 +26,63 @@ utf8decode(const char *s_in, long *u, int *err)
+ 
+ 	const unsigned char *s = (const unsigned char *)s_in;
+ 	int len = lens[*s >> 3];
+-
+-    *u = UTF_INVALID;
++	*u = UTF_INVALID;
+ 	*err = 1;
+ 	if (len == 0)
+-        return 1;
++		return 1;
+ 
+ 	long cp = s[0] & leading_mask[len - 1];
+ 	for (int i = 1; i < len; ++i) {
+ 		if (s[i] == '\0' || (s[i] & 0xC0) != 0x80)
+ 			return i;
+ 		cp = (cp << 6) | (s[i] & 0x3F);
+-    }
++	}
+ 	/* out of range, surrogate, overlong encoding */
+ 	if (cp > 0x10FFFF || (cp >> 11) == 0x1B || cp < overlong[len - 1])
+ 		return len;
+ 
+ 	*err = 0;
+ 	*u = cp;
+-    return len;
++	return len;
+ }
+ 
+ Drw *
+ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
+ {
+-    Drw *drw = ecalloc(1, sizeof(Drw));
+-
+-    drw->dpy = dpy;
+-    drw->screen = screen;
+-    drw->root = root;
+-    drw->w = w;
+-    drw->h = h;
+-    drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+-    drw->gc = XCreateGC(dpy, root, 0, NULL);
+-    XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+-
+-    return drw;
++	Drw *drw = ecalloc(1, sizeof(Drw));
++
++	drw->dpy = dpy;
++	drw->screen = screen;
++	drw->root = root;
++	drw->w = w;
++	drw->h = h;
++	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
++	drw->gc = XCreateGC(dpy, root, 0, NULL);
++	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
++
++	return drw;
+ }
+ 
+ void
+ drw_resize(Drw *drw, unsigned int w, unsigned int h)
+ {
+-    if (!drw)
+-        return;
+-
+-    drw->w = w;
+-    drw->h = h;
+-    if (drw->drawable)
+-        XFreePixmap(drw->dpy, drw->drawable);
+-    drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++	if (!drw)
++		return;
++
++	drw->w = w;
++	drw->h = h;
++	if (drw->drawable)
++		XFreePixmap(drw->dpy, drw->drawable);
++	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
+ }
+ 
+ void
+ drw_free(Drw *drw)
+ {
+-    XFreePixmap(drw->dpy, drw->drawable);
+-    XFreeGC(drw->dpy, drw->gc);
+-    free(drw);
++	XFreePixmap(drw->dpy, drw->drawable);
++	XFreeGC(drw->dpy, drw->gc);
++	drw_fontset_free(drw->fonts);
++	free(drw);
+ }
+ 
+ /* This function is an implementation detail. Library users should use
+@@ -92,93 +91,91 @@ drw_free(Drw *drw)
+ static Fnt *
+ xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
+ {
+-    Fnt *font;
+-    XftFont *xfont = NULL;
+-    FcPattern *pattern = NULL;
+-
+-    if (fontname) {
+-        /* Using the pattern found at font->xfont->pattern does not yield the
+-         * same substitution results as using the pattern returned by
+-         * FcNameParse; using the latter results in the desired fallback
+-         * behaviour whereas the former just results in missing-character
+-         * rectangles being drawn, at least with some fonts. */
+-        if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
+-            fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
+-            return NULL;
+-        }
+-        if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
+-            fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
+-            XftFontClose(drw->dpy, xfont);
+-            return NULL;
+-        }
+-    } else if (fontpattern) {
+-        if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
+-            fprintf(stderr, "error, cannot load font from pattern.\n");
+-            return NULL;
+-        }
+-    } else {
+-        die("no font specified.");
+-    }
+-
+-    font = ecalloc(1, sizeof(Fnt));
+-    font->xfont = xfont;
+-    font->pattern = pattern;
+-    font->h = xfont->ascent + xfont->descent;
+-    font->dpy = drw->dpy;
+-
+-    return font;
++	Fnt *font;
++	XftFont *xfont = NULL;
++	FcPattern *pattern = NULL;
++
++	if (fontname) {
++		/* Using the pattern found at font->xfont->pattern does not yield the
++		 * same substitution results as using the pattern returned by
++		 * FcNameParse; using the latter results in the desired fallback
++		 * behaviour whereas the former just results in missing-character
++		 * rectangles being drawn, at least with some fonts. */
++		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
++			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
++			return NULL;
++		}
++		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
++			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
++			XftFontClose(drw->dpy, xfont);
++			return NULL;
++		}
++	} else if (fontpattern) {
++		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
++			fprintf(stderr, "error, cannot load font from pattern.\n");
++			return NULL;
++		}
++	} else {
++		die("no font specified.");
++	}
++
++	font = ecalloc(1, sizeof(Fnt));
++	font->xfont = xfont;
++	font->pattern = pattern;
++	font->h = xfont->ascent + xfont->descent;
++	font->dpy = drw->dpy;
++
++	return font;
+ }
+ 
+ static void
+ xfont_free(Fnt *font)
+ {
+-    if (!font)
+-        return;
+-    if (font->pattern)
+-        FcPatternDestroy(font->pattern);
+-    XftFontClose(font->dpy, font->xfont);
+-    free(font);
++	if (!font)
++		return;
++	if (font->pattern)
++		FcPatternDestroy(font->pattern);
++	XftFontClose(font->dpy, font->xfont);
++	free(font);
+ }
+ 
+ Fnt*
+ drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
+ {
+-    Fnt *cur, *ret = NULL;
+-    size_t i;
+-
+-    if (!drw || !fonts)
+-        return NULL;
+-
+-    for (i = 1; i <= fontcount; i++) {
+-        if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
+-            cur->next = ret;
+-            ret = cur;
+-        }
+-    }
+-    return (drw->fonts = ret);
++	Fnt *cur, *ret = NULL;
++	size_t i;
++
++	if (!drw || !fonts)
++		return NULL;
++
++	for (i = 1; i <= fontcount; i++) {
++		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
++			cur->next = ret;
++			ret = cur;
++		}
++	}
++	return (drw->fonts = ret);
+ }
+ 
+ void
+ drw_fontset_free(Fnt *font)
+ {
+-    if (font) {
+-        drw_fontset_free(font->next);
+-        xfont_free(font);
+-    }
++	if (font) {
++		drw_fontset_free(font->next);
++		xfont_free(font);
++	}
+ }
+ 
+ void
+ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ {
+-    if (!drw || !dest || !clrname)
+-        return;
+-
+-    if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+-                DefaultColormap(drw->dpy, drw->screen),
+-                clrname, dest))
+-        die("error, cannot allocate color '%s'", clrname);
++	if (!drw || !dest || !clrname)
++		return;
+ 
+-    dest->pixel |= 0xff << 24;
++	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
++	                       DefaultColormap(drw->dpy, drw->screen),
++	                       clrname, dest))
++		die("error, cannot allocate color '%s'", clrname);
+ }
+ 
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+@@ -186,42 +183,42 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ Clr *
+ drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+-    size_t i;
+-    Clr *ret;
++	size_t i;
++	Clr *ret;
+ 
+-    /* need at least two colors for a scheme */
+-    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
+-        return NULL;
++	/* need at least two colors for a scheme */
++	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
++		return NULL;
+ 
+-    for (i = 0; i < clrcount; i++)
+-        drw_clr_create(drw, &ret[i], clrnames[i]);
+-    return ret;
++	for (i = 0; i < clrcount; i++)
++		drw_clr_create(drw, &ret[i], clrnames[i]);
++	return ret;
+ }
+ 
+ void
+ drw_setfontset(Drw *drw, Fnt *set)
+ {
+-    if (drw)
+-        drw->fonts = set;
++	if (drw)
++		drw->fonts = set;
+ }
+ 
+ void
+ drw_setscheme(Drw *drw, Clr *scm)
+ {
+-    if (drw)
+-        drw->scheme = scm;
++	if (drw)
++		drw->scheme = scm;
+ }
+ 
+ void
+ drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
+ {
+-    if (!drw || !drw->scheme)
+-        return;
+-    XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
+-    if (filled)
+-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+-    else
+-        XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
++	if (!drw || !drw->scheme)
++		return;
++	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
++	if (filled)
++		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++	else
++		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
+ }
+ 
+ int
+@@ -229,52 +226,51 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ {
+ 	int ty, ellipsis_x = 0;
+ 	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len, hash, h0, h1;
+-    XftDraw *d = NULL;
+-    Fnt *usedfont, *curfont, *nextfont;
+-    int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
+-    long utf8codepoint = 0;
+-    const char *utf8str;
+-    FcCharSet *fccharset;
+-    FcPattern *fcpattern;
+-    FcPattern *match;
+-    XftResult result;
++	XftDraw *d = NULL;
++	Fnt *usedfont, *curfont, *nextfont;
++	int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
++	long utf8codepoint = 0;
++	const char *utf8str;
++	FcCharSet *fccharset;
++	FcPattern *fcpattern;
++	FcPattern *match;
++	XftResult result;
+ 	int charexists = 0, overflow = 0;
+ 	/* keep track of a couple codepoints for which we have no match. */
+ 	static unsigned int nomatches[128], ellipsis_width, invalid_width;
+ 	static const char invalid[] = "�";
+ 
+-    if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
+-        return 0;
++	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
++		return 0;
+ 
+-    if (!render) {
+-        w = invert ? invert : ~invert;
+-    } else {
+-        XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++	if (!render) {
++		w = invert ? invert : ~invert;
++	} else {
++		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
++		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+ 		if (w < lpad)
+ 			return x + w;
+-        d = XftDrawCreate(drw->dpy, drw->drawable,
+-                DefaultVisual(drw->dpy, drw->screen),
+-                DefaultColormap(drw->dpy, drw->screen));
+-        x += lpad;
+-        w -= lpad;
+-    }
+-
+-    usedfont = drw->fonts;
++		d = XftDrawCreate(drw->dpy, drw->drawable,
++		                  DefaultVisual(drw->dpy, drw->screen),
++		                  DefaultColormap(drw->dpy, drw->screen));
++		x += lpad;
++		w -= lpad;
++	}
++
++	usedfont = drw->fonts;
+ 	if (!ellipsis_width && render)
+ 		ellipsis_width = drw_fontset_getwidth(drw, "...");
+ 	if (!invalid_width && render)
+ 		invalid_width = drw_fontset_getwidth(drw, invalid);
+-    while (1) {
+-        utf8strlen = 0;
+-        ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
+-        utf8str = text;
+-        nextfont = NULL;
+-        while (*text) {
+-            utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
+-            for (curfont = drw->fonts; curfont; curfont = curfont->next) {
+-                charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
+-                if (charexists) {
++	while (1) {
++		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
++		utf8str = text;
++		nextfont = NULL;
++		while (*text) {
++			utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
++			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
++				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
++				if (charexists) {
+ 					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
+ 					if (ew + ellipsis_width <= w) {
+ 						/* keep track where the ellipsis still fits */
+@@ -293,31 +289,31 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ 						else
+ 							utf8strlen = ellipsis_len;
+ 					} else if (curfont == usedfont) {
+-                        text += utf8charlen;
++						text += utf8charlen;
+ 						utf8strlen += utf8err ? 0 : utf8charlen;
+ 						ew += utf8err ? 0 : tmpw;
+-                    } else {
+-                        nextfont = curfont;
+-                    }
+-                    break;
+-                }
+-            }
+-
+-            if (overflow || !charexists || nextfont || utf8err)
+-                break;
+-            else
+-                charexists = 0;
+-        }
+-
+-        if (utf8strlen) {
++					} else {
++						nextfont = curfont;
++					}
++					break;
++				}
++			}
++
++			if (overflow || !charexists || nextfont || utf8err)
++				break;
++			else
++				charexists = 0;
++		}
++
++		if (utf8strlen) {
+ 			if (render) {
+ 				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
+ 				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
+ 				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
+-            }
++			}
+ 			x += ew;
+ 			w -= ew;
+-        }
++		}
+ 		if (utf8err && (!render || invalid_width < w)) {
+ 			if (render)
+ 				drw_text(drw, x, y, w, h, 0, invalid, invert);
+@@ -327,15 +323,15 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ 		if (render && overflow)
+ 			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
+ 
+-        if (!*text || overflow) {
+-            break;
+-        } else if (nextfont) {
+-            charexists = 0;
+-            usedfont = nextfont;
+-        } else {
+-            /* Regardless of whether or not a fallback font is found, the
+-             * character must be drawn. */
+-            charexists = 1;
++		if (!*text || overflow) {
++			break;
++		} else if (nextfont) {
++			charexists = 0;
++			usedfont = nextfont;
++		} else {
++			/* Regardless of whether or not a fallback font is found, the
++			 * character must be drawn. */
++			charexists = 1;
+ 
+ 			hash = (unsigned int)utf8codepoint;
+ 			hash = ((hash >> 16) ^ hash) * 0x21F0AAAD;
+@@ -346,63 +342,62 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ 			if (nomatches[h0] == utf8codepoint || nomatches[h1] == utf8codepoint)
+ 				goto no_match;
+ 
+-            fccharset = FcCharSetCreate();
+-            FcCharSetAddChar(fccharset, utf8codepoint);
+-
+-            if (!drw->fonts->pattern) {
+-                /* Refer to the comment in xfont_create for more information. */
+-                die("the first font in the cache must be loaded from a font string.");
+-            }
+-
+-            fcpattern = FcPatternDuplicate(drw->fonts->pattern);
+-            FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
+-            FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
+-            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
+-
+-            FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
+-            FcDefaultSubstitute(fcpattern);
+-            match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
+-
+-            FcCharSetDestroy(fccharset);
+-            FcPatternDestroy(fcpattern);
+-
+-            if (match) {
+-                usedfont = xfont_create(drw, NULL, match);
+-                if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
+-                    for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
+-                        ; /* NOP */
+-                    curfont->next = usedfont;
+-                } else {
+-                    xfont_free(usedfont);
+-                    nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
++			fccharset = FcCharSetCreate();
++			FcCharSetAddChar(fccharset, utf8codepoint);
++
++			if (!drw->fonts->pattern) {
++				/* Refer to the comment in xfont_create for more information. */
++				die("the first font in the cache must be loaded from a font string.");
++			}
++
++			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
++			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
++			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
++
++			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
++			FcDefaultSubstitute(fcpattern);
++			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
++
++			FcCharSetDestroy(fccharset);
++			FcPatternDestroy(fcpattern);
++
++			if (match) {
++				usedfont = xfont_create(drw, NULL, match);
++				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
++					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
++						; /* NOP */
++					curfont->next = usedfont;
++				} else {
++					xfont_free(usedfont);
++					nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
+ no_match:
+-                    usedfont = drw->fonts;
+-                }
+-            }
+-        }
+-    }
+-    if (d)
+-        XftDrawDestroy(d);
+-
+-    return x + (render ? w : 0);
++					usedfont = drw->fonts;
++				}
++			}
++		}
++	}
++	if (d)
++		XftDrawDestroy(d);
++
++	return x + (render ? w : 0);
+ }
+ 
+ void
+ drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
+ {
+-    if (!drw)
+-        return;
++	if (!drw)
++		return;
+ 
+-    XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
+-    XSync(drw->dpy, False);
++	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
++	XSync(drw->dpy, False);
+ }
+ 
+ unsigned int
+ drw_fontset_getwidth(Drw *drw, const char *text)
+ {
+-    if (!drw || !drw->fonts || !text)
+-        return 0;
+-    return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
++	if (!drw || !drw->fonts || !text)
++		return 0;
++	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+ }
+ 
+ unsigned int
+@@ -417,37 +412,37 @@ drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
+ void
+ drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
+ {
+-    XGlyphInfo ext;
++	XGlyphInfo ext;
+ 
+-    if (!font || !text)
+-        return;
++	if (!font || !text)
++		return;
+ 
+-    XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
+-    if (w)
+-        *w = ext.xOff;
+-    if (h)
+-        *h = font->h;
++	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
++	if (w)
++		*w = ext.xOff;
++	if (h)
++		*h = font->h;
+ }
+ 
+ Cur *
+ drw_cur_create(Drw *drw, int shape)
+ {
+-    Cur *cur;
++	Cur *cur;
+ 
+-    if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
+-        return NULL;
++	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
++		return NULL;
+ 
+-    cur->cursor = XCreateFontCursor(drw->dpy, shape);
++	cur->cursor = XCreateFontCursor(drw->dpy, shape);
+ 
+-    return cur;
++	return cur;
+ }
+ 
+ void
+ drw_cur_free(Drw *drw, Cur *cursor)
+ {
+-    if (!cursor)
+-        return;
++	if (!cursor)
++		return;
+ 
+-    XFreeCursor(drw->dpy, cursor->cursor);
+-    free(cursor);
++	XFreeCursor(drw->dpy, cursor->cursor);
++	free(cursor);
+ }
+diff --git a/drw.h b/drw.h
+index ea76849..bdbf950 100644
+--- a/drw.h
++++ b/drw.h
+@@ -1,29 +1,29 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ typedef struct {
+-    Cursor cursor;
++	Cursor cursor;
+ } Cur;
+ 
+ typedef struct Fnt {
+-    Display *dpy;
+-    unsigned int h;
+-    XftFont *xfont;
+-    FcPattern *pattern;
+-    struct Fnt *next;
++	Display *dpy;
++	unsigned int h;
++	XftFont *xfont;
++	FcPattern *pattern;
++	struct Fnt *next;
+ } Fnt;
+ 
+ enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
+ typedef XftColor Clr;
+ 
+ typedef struct {
+-    unsigned int w, h;
+-    Display *dpy;
+-    int screen;
+-    Window root;
+-    Drawable drawable;
+-    GC gc;
+-    Clr *scheme;
+-    Fnt *fonts;
++	unsigned int w, h;
++	Display *dpy;
++	int screen;
++	Window root;
++	Drawable drawable;
++	GC gc;
++	Clr *scheme;
++	Fnt *fonts;
+ } Drw;
+ 
+ /* Drawable abstraction */
+diff --git a/dwm.1 b/dwm.1
+index 7feba78..d04bec6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -1,16 +1,21 @@
+ .TH DWM 1 dwm\-VERSION
+ .SH NAME
+-dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
++dwm \- dynamic window manager
+ .SH SYNOPSIS
+ .B dwm
+ .RB [ \-v ]
+ .SH DESCRIPTION
+-dwm is a dynamic window manager for X.
++dwm is a dynamic window manager for X. It manages windows in tiled, monocle
++and floating layouts. Either layout can be applied dynamically, optimising the
++environment for the application in use and the task performed.
+ .P
+-dwm "orders" windows based on recency and primacy, while dwm layouts may
+-change, the most recent "master" window is shown in the most prominent
+-position. There are bindings for cycling through and promoting windows to the
+-master position.
++In tiled layouts windows are managed in a master and stacking area. The master
++area on the left contains one window by default, and the stacking area on the
++right contains all other windows. The number of master area windows can be
++adjusted from zero to an arbitrary number. In monocle layout all windows are
++maximised to the screen size. In floating layout windows can be resized and
++moved freely. Dialog windows are always managed floating, regardless of the
++layout applied.
+ .P
+ Windows are grouped by tags. Each window can be tagged with one or multiple
+ tags. Selecting certain tags displays all windows with these tags.
+@@ -26,18 +31,17 @@ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
+ .P
+-.I
+-libxft-bgra
+-should be installed for this build of dwm. Arch users may install it via the
+-AUR. Color characters and emoji are enabled, but these will cause crashes
+-without the fix
+-.I
+-libxft-bgra
+-offers.
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+-prints version information to standard output, then exits.
++prints version information to stderr, then exits.
+ .SH USAGE
+ .SS Status bar
+ .TP
+@@ -46,142 +50,118 @@ is read and displayed in the status text area. It can be set with the
+ .BR xsetroot (1)
+ command.
+ .TP
+-.B Left click
++.B Button1
+ click on a tag label to display all windows with that tag, click on the layout
+ label toggles between tiled and floating layout.
+ .TP
+-.B Right click
++.B Button3
+ click on a tag label adds/removes all windows with that tag to/from the view.
+ .TP
+-.B Super\-Left click
++.B Mod1\-Button1
+ click on a tag label applies that tag to the focused window.
+ .TP
+-.B Super\-Right click
++.B Mod1\-Button3
+ click on a tag label adds/removes that tag to/from the focused window.
+ .SS Keyboard commands
+ .TP
+-.B Super\-Return
+-Start terminal,
++.B Mod1\-Shift\-Return
++Start
+ .BR st(1).
+ .TP
+-.B Super\-d
++.B Mod1\-p
+ Spawn
+ .BR dmenu(1)
+ for launching other programs.
+ .TP
+-.B Super\-b
+-Toggles bar on and off.
++.B Mod1\-,
++Focus previous screen, if any.
+ .TP
+-.B Super\-q
+-Close focused window.
++.B Mod1\-.
++Focus next screen, if any.
+ .TP
+-.B Super\-t/T
+-Sets tiled/bstack layouts.
++.B Mod1\-Shift\-,
++Send focused window to previous screen, if any.
+ .TP
+-.B Super\-f
+-Toggle fullscreen window.
++.B Mod1\-Shift\-.
++Send focused window to next screen, if any.
+ .TP
+-.B Super\-F
+-Toggle floating layout.
++.B Mod1\-b
++Toggles bar on and off.
++.TP
++.B Mod1\-t
++Sets tiled layout.
+ .TP
+-.B Super\-y/Y
+-Sets Fibonacci spiral/dwinde layouts.
++.B Mod1\-f
++Sets floating layout.
+ .TP
+-.B Super\-u/U
+-Sets centered master layout.
++.B Mod1\-m
++Sets monocle layout.
+ .TP
+-.B Super\-i/I
+-Sets centered master or floating master layouts.
++.B Mod1\-space
++Toggles between current and previous layout.
+ .TP
+-.B Super\-space
+-Zooms/cycles focused window to/from master area.
++.B Mod1\-j
++Focus next window.
+ .TP
+-.B Super\-j/k
+-Focus next/previous window.
++.B Mod1\-k
++Focus previous window.
+ .TP
+-.B Super\-Shift\-j/k
+-Move selected window down/up in stack.
++.B Mod1\-i
++Increase number of windows in master area.
+ .TP
+-.B Super\-o/O
+-Increase/decrease number of windows in master area.
++.B Mod1\-d
++Decrease number of windows in master area.
+ .TP
+-.B Super\-l
++.B Mod1\-l
+ Increase master area size.
+ .TP
+-.B Super\-h
++.B Mod1\-h
+ Decrease master area size.
+ .TP
+-.B Super\-Shift\-space
+-Toggle focused window between tiled and floating state.
+-.TP
+-.B Super\-Tab
+-Toggles to the previously selected tags.
+-.TP
+-.B Super\-g
+-Moves to the previous tag.
+-.TP
+-.B Super\-Shift\-g
+-Moves selected window to the previous tag.
+-.TP
+-.B Super\-;
+-Moves to the next tag.
++.B Mod1\-Return
++Zooms/cycles focused window to/from master area (tiled layouts only).
+ .TP
+-.B Super\-Shift\-;
+-Moves selected window to the next tag.
+-.TP
+-.B Super\-PageUp
+-Moves to the previous tag.
+-.TP
+-.B Super\-Shift\-PageUp
+-Moves selected window to the previous tag.
+-.TP
+-.B Super\-Pagedown
+-Moves to the next tag.
+-.TP
+-.B Super\-Shift\-PageDown
+-Moves selected window to the next tag.
++.B Mod1\-Shift\-c
++Close focused window.
+ .TP
+-.B Super\-a
+-Toggle gaps.
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
+ .TP
+-.B Super\-z
+-Increase gaps between windows.
++.B Mod1\-Shift\-space
++Toggle focused window between tiled and floating state.
+ .TP
+-.B Super\-x
+-Decrease gaps between windows.
++.B Mod1\-Tab
++Toggles to the previously selected tags.
+ .TP
+-.B Super\-Shift\-[1..n]
++.B Mod1\-Shift\-[1..n]
+ Apply nth tag to focused window.
+ .TP
+-.B Super\-Shift\-0
++.B Mod1\-Shift\-0
+ Apply all tags to focused window.
+ .TP
+-.B Super\-Control\-Shift\-[1..n]
++.B Mod1\-Control\-Shift\-[1..n]
+ Add/remove nth tag to/from focused window.
+ .TP
+-.B Super\-[1..n]
++.B Mod1\-[1..n]
+ View all windows with nth tag.
+ .TP
+-.B Super\-0
++.B Mod1\-0
+ View all windows with any tag.
+ .TP
+-.B Super\-Control\-[1..n]
++.B Mod1\-Control\-[1..n]
+ Add/remove all windows with nth tag to/from the view.
+ .TP
+-.B Super\-Shift\-q
++.B Mod1\-Shift\-q
+ Quit dwm.
+-.TP
+-.B Mod1\-Control\-Shift\-q
+-Menu to refresh/quit/reboot/shutdown.
+ .SS Mouse commands
+ .TP
+-.B Super\-Left click
++.B Mod1\-Button1
+ Move focused window while dragging. Tiled windows will be toggled to the floating state.
+ .TP
+-.B Super\-Middle click
++.B Mod1\-Button2
+ Toggles focused window between floating and tiled state.
+ .TP
+-.B Super\-Right click
++.B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+ .SH FILES
+ The files containing programs to be started along with dwm are searched for in
+@@ -201,13 +181,6 @@ This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+-.SH SIGNALS
+-.TP
+-.B SIGHUP - 1
+-Restart the dwm process.
+-.TP
+-.B SIGTERM - 15
+-Cleanly terminate the dwm process.
+ .SH SEE ALSO
+ .BR dmenu (1),
+ .BR st (1)
+diff --git a/dwm.c b/dwm.c
+index 9086e16..c072985 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -43,6 +44,10 @@
+ #include <X11/Xft/Xft.h>
+ #include <X11/Xlib-xcb.h>
+ #include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -53,18 +58,18 @@
+ #define GETINC(X)               ((X) - 2000)
+ #define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+-        * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+ #define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define PREVSEL                 3000
+-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
+-#define TAGMASK			((1 << NUMTAGS) - 1)
+-#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
+-#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+@@ -72,106 +77,107 @@
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+-    NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
++       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+-    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+-    int i;
+-    unsigned int ui;
+-    float f;
+-    const void *v;
++	int i;
++	unsigned int ui;
++	float f;
++	const void *v;
+ } Arg;
+ 
+ typedef struct {
+-    unsigned int click;
+-    unsigned int mask;
+-    unsigned int button;
+-    void (*func)(const Arg *arg);
+-    const Arg arg;
++	unsigned int click;
++	unsigned int mask;
++	unsigned int button;
++	void (*func)(const Arg *arg);
++	const Arg arg;
+ } Button;
+ 
+ typedef struct Monitor Monitor;
+ typedef struct Client Client;
+ struct Client {
+-    char name[256];
+-    float mina, maxa;
+-    int x, y, w, h;
+-    int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+-    int oldx, oldy, oldw, oldh;
+-    int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+-    int bw, oldbw;
+-    unsigned int tags;
+-    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
++	char name[256];
++	float mina, maxa;
++	float cfact;
++	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++	int oldx, oldy, oldw, oldh;
++	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++	int bw, oldbw;
++	unsigned int tags;
++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+     pid_t pid;
+-    Client *next;
+-    Client *snext;
++	Client *next;
++	Client *snext;
+     Client *swallowing;
+-    Monitor *mon;
+-    Window win;
++	Monitor *mon;
++	Window win;
+ };
+ 
+ typedef struct {
+-    unsigned int mod;
+-    KeySym keysym;
+-    void (*func)(const Arg *);
+-    const Arg arg;
++	unsigned int mod;
++	KeySym keysym;
++	void (*func)(const Arg *);
++	const Arg arg;
+ } Key;
+ 
+ typedef struct {
+-    const char *symbol;
+-    void (*arrange)(Monitor *);
++	const char *symbol;
++	void (*arrange)(Monitor *);
+ } Layout;
+ 
+ struct Monitor {
+-    char ltsymbol[16];
+-    float mfact;
+-    int nmaster;
+-    int num;
+-    int by;               /* bar geometry */
+-    int mx, my, mw, mh;   /* screen size */
+-    int wx, wy, ww, wh;   /* window area  */
+-    int gappih;           /* horizontal gap between windows */
+-    int gappiv;           /* vertical gap between windows */
+-    int gappoh;           /* horizontal outer gaps */
+-    int gappov;           /* vertical outer gaps */
+-    unsigned int seltags;
+-    unsigned int sellt;
+-    unsigned int tagset[2];
+-    int showbar;
+-    int topbar;
+-    Client *clients;
+-    Client *sel;
+-    Client *stack;
+-    Monitor *next;
+-    Window barwin;
+-    const Layout *lt[2];
++	char ltsymbol[16];
++	float mfact;
++	int nmaster;
++	int num;
++	int by;               /* bar geometry */
++	int mx, my, mw, mh;   /* screen size */
++	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
++	unsigned int seltags;
++	unsigned int sellt;
++	unsigned int tagset[2];
++	int showbar;
++	int topbar;
++	Client *clients;
++	Client *sel;
++	Client *stack;
++	Monitor *next;
++	Window barwin;
++	const Layout *lt[2];
+ };
+ 
+ typedef struct {
+-    const char *class;
+-    const char *instance;
+-    const char *title;
+-    unsigned int tags;
+-    int isfloating;
+-    int isterminal;
+-    int noswallow;
+-    int monitor;
++	const char *class;
++	const char *instance;
++	const char *title;
++	unsigned int tags;
++	int isfloating;
++	int isterminal;
++	int noswallow;
++	int monitor;
+ } Rule;
+ 
+ /* Xresources preferences */
+ enum resource_type {
+-    STRING = 0,
+-    INTEGER = 1,
+-    FLOAT = 2
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
+ };
+ 
+ typedef struct {
+-    char *name;
+-    enum resource_type type;
+-    void *dst;
++	char *name;
++	enum resource_type type;
++	void *dst;
+ } ResourcePref;
+ 
+ /* function declarations */
+@@ -189,12 +195,12 @@ static void clientmessage(XEvent *e);
+ static void configure(Client *c);
+ static void configurenotify(XEvent *e);
+ static void configurerequest(XEvent *e);
+-static void copyvalidchars(char *text, char *rawtext);
+ static Monitor *createmon(void);
+ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
++static Monitor *numtomon(int num);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+@@ -202,10 +208,12 @@ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
++static void focusnthmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -216,7 +224,6 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+@@ -229,7 +236,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
+-static void runAutostart(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -237,24 +244,34 @@ static void sendmonview(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shifttag(const Arg *arg);
++static void shifttagclients(const Arg *arg);
++static void shiftview(const Arg *arg);
++static void shiftviewclients(const Arg *arg);
++static void shiftboth(const Arg *arg);
++static void swaptags(const Arg *arg);
++static void shiftswaptags(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void showhide(Client *c);
+-#ifndef __OpenBSD__
+-static int getdwmblockspid();
+-static void sigdwmblocks(const Arg *arg);
+-#endif
+-static void sighup(int unused);
+-static void sigterm(int unused);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+ static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagview(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tagmonview(const Arg *arg);
++static void tagnextmon(const Arg *arg);
++static void tagnewmon(const Arg *arg);
++static void tagnthmon(const Arg *arg);
++static void tagnthmonview(const Arg *arg);
+ static void togglebar(const Arg *arg);
++static void togglebars(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglescratch(const Arg *arg);
+ static void togglesticky(const Arg *arg);
+@@ -291,12 +308,15 @@ static Client *termforwin(const Client *c);
+ static pid_t winpid(Window w);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
+-static char stext[256];
+-/* static char stext[1024]; */
+-static char rawstext[256];
+-static int dwmblockssig;
+-pid_t dwmblockspid = 0;
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
++static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -304,22 +324,20 @@ static int lrpad;            /* sum of left and right padding for text */
+ static int (*xerrorxlib)(Display *, XErrorEvent *);
+ static unsigned int numlockmask = 0;
+ static void (*handler[LASTEvent]) (XEvent *) = {
+-    [ButtonPress] = buttonpress,
+-    [ClientMessage] = clientmessage,
+-    [ConfigureRequest] = configurerequest,
+-    [ConfigureNotify] = configurenotify,
+-    [DestroyNotify] = destroynotify,
+-    [Expose] = expose,
+-    [FocusIn] = focusin,
+-    [KeyPress] = keypress,
+-    [MappingNotify] = mappingnotify,
+-    [MapRequest] = maprequest,
+-    [MotionNotify] = motionnotify,
+-    [PropertyNotify] = propertynotify,
+-    [UnmapNotify] = unmapnotify
++	[ButtonPress] = buttonpress,
++	[ClientMessage] = clientmessage,
++	[ConfigureRequest] = configurerequest,
++	[ConfigureNotify] = configurenotify,
++	[DestroyNotify] = destroynotify,
++	[Expose] = expose,
++	[FocusIn] = focusin,
++	[KeyPress] = keypress,
++	[MappingNotify] = mappingnotify,
++	[MapRequest] = maprequest,
++	[PropertyNotify] = propertynotify,
++	[UnmapNotify] = unmapnotify
+ };
+ static Atom wmatom[WMLast], netatom[NetLast];
+-static int restart = 0;
+ static int running = 1;
+ static Cur *cursor[CurLast];
+ static Clr **scheme;
+@@ -340,528 +358,529 @@ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ void
+ applyrules(Client *c)
+ {
+-    const char *class, *instance;
+-    unsigned int i;
+-    const Rule *r;
+-    Monitor *m;
+-    XClassHint ch = { NULL, NULL };
+-
+-    /* rule matching */
+-    c->isfloating = 0;
+-    c->tags = 0;
+-    XGetClassHint(dpy, c->win, &ch);
+-    class    = ch.res_class ? ch.res_class : broken;
+-    instance = ch.res_name  ? ch.res_name  : broken;
+-
+-    for (i = 0; i < LENGTH(rules); i++) {
+-        r = &rules[i];
+-        if ((!r->title || strstr(c->name, r->title))
+-                && (!r->class || strstr(class, r->class))
+-                && (!r->instance || strstr(instance, r->instance)))
+-        {
+-            c->isterminal = r->isterminal;
+-            c->isfloating = r->isfloating;
+-            c->noswallow  = r->noswallow;
+-            c->tags |= r->tags;
+-            if ((r->tags & SPTAGMASK) && r->isfloating) {
+-                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
+-                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+-            }
+-
+-            for (m = mons; m && m->num != r->monitor; m = m->next);
+-            if (m)
+-                c->mon = m;
+-        }
+-    }
+-    if (ch.res_class)
+-        XFree(ch.res_class);
+-    if (ch.res_name)
+-        XFree(ch.res_name);
+-    c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++	const char *class, *instance;
++	unsigned int i;
++	const Rule *r;
++	Monitor *m;
++	XClassHint ch = { NULL, NULL };
++
++	/* rule matching */
++	c->isfloating = 0;
++	c->tags = 0;
++	XGetClassHint(dpy, c->win, &ch);
++	class    = ch.res_class ? ch.res_class : broken;
++	instance = ch.res_name  ? ch.res_name  : broken;
++
++	for (i = 0; i < LENGTH(rules); i++) {
++		r = &rules[i];
++		if ((!r->title || strstr(c->name, r->title))
++		&& (!r->class || strstr(class, r->class))
++		&& (!r->instance || strstr(instance, r->instance)))
++		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
++			c->isfloating = r->isfloating;
++			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
++			for (m = mons; m && m->num != r->monitor; m = m->next);
++			if (m)
++				c->mon = m;
++		}
++	}
++	if (ch.res_class)
++		XFree(ch.res_class);
++	if (ch.res_name)
++		XFree(ch.res_name);
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+ applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
+ {
+-    int baseismin;
+-    Monitor *m = c->mon;
+-
+-    /* set minimum possible */
+-    *w = MAX(1, *w);
+-    *h = MAX(1, *h);
+-    if (interact) {
+-        if (*x > sw)
+-            *x = sw - WIDTH(c);
+-        if (*y > sh)
+-            *y = sh - HEIGHT(c);
+-        if (*x + *w + 2 * c->bw < 0)
+-            *x = 0;
+-        if (*y + *h + 2 * c->bw < 0)
+-            *y = 0;
+-    } else {
+-        if (*x >= m->wx + m->ww)
+-            *x = m->wx + m->ww - WIDTH(c);
+-        if (*y >= m->wy + m->wh)
+-            *y = m->wy + m->wh - HEIGHT(c);
+-        if (*x + *w + 2 * c->bw <= m->wx)
+-            *x = m->wx;
+-        if (*y + *h + 2 * c->bw <= m->wy)
+-            *y = m->wy;
+-    }
+-    if (*h < bh)
+-        *h = bh;
+-    if (*w < bh)
+-        *w = bh;
+-    if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
+-        if (!c->hintsvalid)
+-            updatesizehints(c);
+-        /* see last two sentences in ICCCM 4.1.2.3 */
+-        baseismin = c->basew == c->minw && c->baseh == c->minh;
+-        if (!baseismin) { /* temporarily remove base dimensions */
+-            *w -= c->basew;
+-            *h -= c->baseh;
+-        }
+-        /* adjust for aspect limits */
+-        if (c->mina > 0 && c->maxa > 0) {
+-            if (c->maxa < (float)*w / *h)
+-                *w = *h * c->maxa + 0.5;
+-            else if (c->mina < (float)*h / *w)
+-                *h = *w * c->mina + 0.5;
+-        }
+-        if (baseismin) { /* increment calculation requires this */
+-            *w -= c->basew;
+-            *h -= c->baseh;
+-        }
+-        /* adjust for increment value */
+-        if (c->incw)
+-            *w -= *w % c->incw;
+-        if (c->inch)
+-            *h -= *h % c->inch;
+-        /* restore base dimensions */
+-        *w = MAX(*w + c->basew, c->minw);
+-        *h = MAX(*h + c->baseh, c->minh);
+-        if (c->maxw)
+-            *w = MIN(*w, c->maxw);
+-        if (c->maxh)
+-            *h = MIN(*h, c->maxh);
+-    }
+-    return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
++	int baseismin;
++	Monitor *m = c->mon;
++
++	/* set minimum possible */
++	*w = MAX(1, *w);
++	*h = MAX(1, *h);
++	if (interact) {
++		if (*x > sw)
++			*x = sw - WIDTH(c);
++		if (*y > sh)
++			*y = sh - HEIGHT(c);
++		if (*x + *w + 2 * c->bw < 0)
++			*x = 0;
++		if (*y + *h + 2 * c->bw < 0)
++			*y = 0;
++	} else {
++		if (*x >= m->wx + m->ww)
++			*x = m->wx + m->ww - WIDTH(c);
++		if (*y >= m->wy + m->wh)
++			*y = m->wy + m->wh - HEIGHT(c);
++		if (*x + *w + 2 * c->bw <= m->wx)
++			*x = m->wx;
++		if (*y + *h + 2 * c->bw <= m->wy)
++			*y = m->wy;
++	}
++	if (*h < bh)
++		*h = bh;
++	if (*w < bh)
++		*w = bh;
++	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
++		if (!c->hintsvalid)
++			updatesizehints(c);
++		/* see last two sentences in ICCCM 4.1.2.3 */
++		baseismin = c->basew == c->minw && c->baseh == c->minh;
++		if (!baseismin) { /* temporarily remove base dimensions */
++			*w -= c->basew;
++			*h -= c->baseh;
++		}
++		/* adjust for aspect limits */
++		if (c->mina > 0 && c->maxa > 0) {
++			if (c->maxa < (float)*w / *h)
++				*w = *h * c->maxa + 0.5;
++			else if (c->mina < (float)*h / *w)
++				*h = *w * c->mina + 0.5;
++		}
++		if (baseismin) { /* increment calculation requires this */
++			*w -= c->basew;
++			*h -= c->baseh;
++		}
++		/* adjust for increment value */
++		if (c->incw)
++			*w -= *w % c->incw;
++		if (c->inch)
++			*h -= *h % c->inch;
++		/* restore base dimensions */
++		*w = MAX(*w + c->basew, c->minw);
++		*h = MAX(*h + c->baseh, c->minh);
++		if (c->maxw)
++			*w = MIN(*w, c->maxw);
++		if (c->maxh)
++			*h = MIN(*h, c->maxh);
++	}
++	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
+ }
+ 
+ void
+ arrange(Monitor *m)
+ {
+-    if (m)
+-        showhide(m->stack);
+-    else for (m = mons; m; m = m->next)
+-        showhide(m->stack);
+-    if (m) {
+-        arrangemon(m);
+-        restack(m);
+-    } else for (m = mons; m; m = m->next)
+-        arrangemon(m);
++	if (m)
++		showhide(m->stack);
++	else for (m = mons; m; m = m->next)
++		showhide(m->stack);
++	if (m) {
++		arrangemon(m);
++		restack(m);
++	} else for (m = mons; m; m = m->next)
++		arrangemon(m);
+ }
+ 
+ void
+ arrangemon(Monitor *m)
+ {
+-    strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+-    if (m->lt[m->sellt]->arrange)
+-        m->lt[m->sellt]->arrange(m);
++	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
++	if (m->lt[m->sellt]->arrange)
++		m->lt[m->sellt]->arrange(m);
+ }
+ 
+ void
+ attach(Client *c)
+ {
+-    c->next = c->mon->clients;
+-    c->mon->clients = c;
++	c->next = c->mon->clients;
++	c->mon->clients = c;
+ }
+ 
+ void
+ attachstack(Client *c)
+ {
+-    c->snext = c->mon->stack;
+-    c->mon->stack = c;
++	c->snext = c->mon->stack;
++	c->mon->stack = c;
+ }
+ 
+ void
+ swallow(Client *p, Client *c)
+ {
+-    if (c->noswallow || c->isterminal)
+-        return;
+-    if (!swallowfloating && c->isfloating)
+-        return;
+-
+-    detach(c);
+-    detachstack(c);
+ 
+-    setclientstate(c, WithdrawnState);
+-    XUnmapWindow(dpy, p->win);
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
+ 
+-    p->swallowing = c;
+-    c->mon = p->mon;
++	detach(c);
++	detachstack(c);
+ 
+-    Window w = p->win;
+-    p->win = c->win;
+-    c->win = w;
+-    updatetitle(p);
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
+ 
+-    XWindowChanges wc;
+-    wc.border_width = p->bw;
+-    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
+-    XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+-    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
++	p->swallowing = c;
++	c->mon = p->mon;
+ 
+-    arrange(p->mon);
+-    configure(p);
+-    updateclientlist();
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
+ }
+ 
+ void
+ unswallow(Client *c)
+ {
+-    c->win = c->swallowing->win;
+-
+-    free(c->swallowing);
+-    c->swallowing = NULL;
++	c->win = c->swallowing->win;
+ 
+-    /* unfullscreen the client */
+-    setfullscreen(c, 0);
+-    updatetitle(c);
+-    arrange(c->mon);
+-    XMapWindow(dpy, c->win);
+-
+-    XWindowChanges wc;
+-    wc.border_width = c->bw;
+-    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
+-    XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++	free(c->swallowing);
++	c->swallowing = NULL;
+ 
+-    setclientstate(c, NormalState);
+-    focus(NULL);
+-    arrange(c->mon);
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
+ }
+ 
+ void
+ buttonpress(XEvent *e)
+ {
+-    unsigned int i, x, click, occ = 0;
+-    Arg arg = {0};
+-    Client *c;
+-    Monitor *m;
+-    XButtonPressedEvent *ev = &e->xbutton;
+-
+-    click = ClkRootWin;
+-    /* focus monitor if necessary */
+-    if ((m = wintomon(ev->window)) && m != selmon) {
+-        unfocus(selmon->sel, 1);
+-        selmon = m;
+-        focus(NULL);
+-    }
+-    if (ev->window == selmon->barwin) {
+-        i = x = 0;
+-        for (c = m->clients; c; c = c->next)
+-            occ |= c->tags == 255 ? 0 : c->tags;
+-        do {
+-            /* do not reserve space for vacant tags */
+-            if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+-                continue;
+-            x += TEXTW(tags[i]);
+-        } while (ev->x >= x && ++i < LENGTH(tags));
+-        if (i < LENGTH(tags)) {
+-            click = ClkTagBar;
+-            arg.ui = 1 << i;
+-        } else if (ev->x < x + TEXTW(selmon->ltsymbol))
+-            click = ClkLtSymbol;
+-        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
++	unsigned int i, x, click;
++	Arg arg = {0};
++	Client *c;
++	Monitor *m;
++	XButtonPressedEvent *ev = &e->xbutton;
++
++	click = ClkRootWin;
++	/* focus monitor if necessary */
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++		unfocus(selmon->sel, 1);
++		selmon = m;
++		focus(NULL);
++	}
++	if (ev->window == selmon->barwin) {
++		i = x = 0;
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
++			x += TEXTW(tags[i]);
++		} while (ev->x >= x && ++i < LENGTH(tags));
++		if (i < LENGTH(tags)) {
++			click = ClkTagBar;
++			arg.ui = 1 << i;
++		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++			click = ClkLtSymbol;
++        } else if (ev->x > selmon->ww - statusw) {
++            x = selmon->ww - statusw;
+             click = ClkStatusText;
+ 
+-            char *text = rawstext;
+-            int i = -1;
+-            char ch;
+-            dwmblockssig = 0;
+-            while (text[++i]) {
+-                if ((unsigned char)text[i] < ' ') {
+-                    ch = text[i];
+-                    text[i] = '\0';
+-                    x += TEXTW(text) - lrpad;
+-                    text[i] = ch;
+-                    text += i+1;
+-                    i = -1;
+-                    if (x >= ev->x) break;
+-                    dwmblockssig = ch;
+-                }
+-            }
+-        } else
+-            click = ClkWinTitle;
+-    } else if ((c = wintoclient(ev->window))) {
+-        focus(c);
+-        restack(selmon);
+-        XAllowEvents(dpy, ReplayPointer, CurrentTime);
+-        click = ClkClientWin;
+-    }
+-    for (i = 0; i < LENGTH(buttons); i++)
+-        if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
+-                && CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
+-            buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
++	} else if ((c = wintoclient(ev->window))) {
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
++		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++		click = ClkClientWin;
++	}
++	for (i = 0; i < LENGTH(buttons); i++)
++		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
++		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
++			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
+ }
+ 
+ void
+ checkotherwm(void)
+ {
+-    xerrorxlib = XSetErrorHandler(xerrorstart);
+-    /* this causes an error if some other window manager is running */
+-    XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
+-    XSync(dpy, False);
+-    XSetErrorHandler(xerror);
+-    XSync(dpy, False);
++	xerrorxlib = XSetErrorHandler(xerrorstart);
++	/* this causes an error if some other window manager is running */
++	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
++	XSync(dpy, False);
++	XSetErrorHandler(xerror);
++	XSync(dpy, False);
+ }
+ 
+ void
+ cleanup(void)
+ {
+-    Arg a = {.ui = ~0};
+-    Layout foo = { "", NULL };
+-    Monitor *m;
+-    size_t i;
+-
+-    view(&a);
+-    selmon->lt[selmon->sellt] = &foo;
+-    for (m = mons; m; m = m->next)
+-        while (m->stack)
+-            unmanage(m->stack, 0);
+-    XUngrabKey(dpy, AnyKey, AnyModifier, root);
+-    while (mons)
+-        cleanupmon(mons);
+-    for (i = 0; i < CurLast; i++)
+-        drw_cur_free(drw, cursor[i]);
+-    /* for (i = 0; i < LENGTH(colors); i++) */
+-    for (i = 0; i < LENGTH(colors) + 1; i++)
+-        free(scheme[i]);
+-    free(scheme);
+-    XDestroyWindow(dpy, wmcheckwin);
+-    drw_free(drw);
+-    XSync(dpy, False);
+-    XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
+-    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++	Arg a = {.ui = ~0};
++	Layout foo = { "", NULL };
++	Monitor *m;
++	size_t i;
++
++	view(&a);
++	selmon->lt[selmon->sellt] = &foo;
++	for (m = mons; m; m = m->next)
++		while (m->stack)
++			unmanage(m->stack, 0);
++	XUngrabKey(dpy, AnyKey, AnyModifier, root);
++	while (mons)
++		cleanupmon(mons);
++	for (i = 0; i < CurLast; i++)
++		drw_cur_free(drw, cursor[i]);
++	for (i = 0; i < LENGTH(colors) + 1; i++)
++		free(scheme[i]);
++	free(scheme);
++	XDestroyWindow(dpy, wmcheckwin);
++	drw_free(drw);
++	XSync(dpy, False);
++	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
++	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+ }
+ 
+ void
+ cleanupmon(Monitor *mon)
+ {
+-    Monitor *m;
++	Monitor *m;
+ 
+-    if (mon == mons)
+-        mons = mons->next;
+-    else {
+-        for (m = mons; m && m->next != mon; m = m->next);
+-        m->next = mon->next;
+-    }
+-    XUnmapWindow(dpy, mon->barwin);
+-    XDestroyWindow(dpy, mon->barwin);
+-    free(mon);
++	if (mon == mons)
++		mons = mons->next;
++	else {
++		for (m = mons; m && m->next != mon; m = m->next);
++		m->next = mon->next;
++	}
++	XUnmapWindow(dpy, mon->barwin);
++	XDestroyWindow(dpy, mon->barwin);
++	free(mon);
+ }
+ 
+ void
+ clientmessage(XEvent *e)
+ {
+-    XClientMessageEvent *cme = &e->xclient;
+-    Client *c = wintoclient(cme->window);
++	XClientMessageEvent *cme = &e->xclient;
++	Client *c = wintoclient(cme->window);
+ 
+-    if (!c)
+-        return;
+-    if (cme->message_type == netatom[NetWMState]) {
+-        if (cme->data.l[1] == netatom[NetWMFullscreen]
+-                || cme->data.l[2] == netatom[NetWMFullscreen])
+-            setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+-                        || (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+-    } else if (cme->message_type == netatom[NetActiveWindow]) {
+-        if (c != selmon->sel && !c->isurgent)
+-            seturgent(c, 1);
+-    }
++	if (!c)
++		return;
++	if (cme->message_type == netatom[NetWMState]) {
++		if (cme->data.l[1] == netatom[NetWMFullscreen]
++		|| cme->data.l[2] == netatom[NetWMFullscreen])
++			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
++	} else if (cme->message_type == netatom[NetActiveWindow]) {
++		if (c != selmon->sel && !c->isurgent)
++			seturgent(c, 1);
++	}
+ }
+ 
+ void
+ configure(Client *c)
+ {
+-    XConfigureEvent ce;
++	XConfigureEvent ce;
+ 
+-    ce.type = ConfigureNotify;
+-    ce.display = dpy;
+-    ce.event = c->win;
+-    ce.window = c->win;
+-    ce.x = c->x;
+-    ce.y = c->y;
+-    ce.width = c->w;
+-    ce.height = c->h;
+-    ce.border_width = c->bw;
+-    ce.above = None;
+-    ce.override_redirect = False;
+-    XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
++	ce.type = ConfigureNotify;
++	ce.display = dpy;
++	ce.event = c->win;
++	ce.window = c->win;
++	ce.x = c->x;
++	ce.y = c->y;
++	ce.width = c->w;
++	ce.height = c->h;
++	ce.border_width = c->bw;
++	ce.above = None;
++	ce.override_redirect = False;
++	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
+ }
+ 
+ void
+ configurenotify(XEvent *e)
+ {
+-    Monitor *m;
+-    Client *c;
+-    XConfigureEvent *ev = &e->xconfigure;
+-    int dirty;
+-
+-    /* TODO: updategeom handling sucks, needs to be simplified */
+-    if (ev->window == root) {
+-        dirty = (sw != ev->width || sh != ev->height);
+-        sw = ev->width;
+-        sh = ev->height;
+-        if (updategeom() || dirty) {
+-            drw_resize(drw, sw, bh);
+-            updatebars();
+-            for (m = mons; m; m = m->next) {
+-                for (c = m->clients; c; c = c->next)
+-                    if (c->isfullscreen)
+-                        resizeclient(c, m->mx, m->my, m->mw, m->mh);
+-                XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+-            }
+-            focus(NULL);
+-            arrange(NULL);
+-        }
+-    }
++	Monitor *m;
++	Client *c;
++	XConfigureEvent *ev = &e->xconfigure;
++	int dirty;
++
++	/* TODO: updategeom handling sucks, needs to be simplified */
++	if (ev->window == root) {
++		dirty = (sw != ev->width || sh != ev->height);
++		sw = ev->width;
++		sh = ev->height;
++		if (updategeom() || dirty) {
++			drw_resize(drw, sw, bh);
++			updatebars();
++			for (m = mons; m; m = m->next) {
++				for (c = m->clients; c; c = c->next)
++					if (c->isfullscreen)
++						resizeclient(c, m->mx, m->my, m->mw, m->mh);
++				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++			}
++			focus(NULL);
++			arrange(NULL);
++		}
++	}
+ }
+ 
+ void
+ configurerequest(XEvent *e)
+ {
+-    Client *c;
+-    Monitor *m;
+-    XConfigureRequestEvent *ev = &e->xconfigurerequest;
+-    XWindowChanges wc;
+-
+-    if ((c = wintoclient(ev->window))) {
+-        if (ev->value_mask & CWBorderWidth)
+-            c->bw = ev->border_width;
+-        else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
+-            m = c->mon;
+-            if (ev->value_mask & CWX) {
+-                c->oldx = c->x;
+-                c->x = m->mx + ev->x;
+-            }
+-            if (ev->value_mask & CWY) {
+-                c->oldy = c->y;
+-                c->y = m->my + ev->y;
+-            }
+-            if (ev->value_mask & CWWidth) {
+-                c->oldw = c->w;
+-                c->w = ev->width;
+-            }
+-            if (ev->value_mask & CWHeight) {
+-                c->oldh = c->h;
+-                c->h = ev->height;
+-            }
+-            if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
+-                c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
+-            if ((c->y + c->h) > m->my + m->mh && c->isfloating)
+-                c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
+-            if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
+-                configure(c);
+-            if (ISVISIBLE(c))
+-                XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+-        } else
+-            configure(c);
+-    } else {
+-        wc.x = ev->x;
+-        wc.y = ev->y;
+-        wc.width = ev->width;
+-        wc.height = ev->height;
+-        wc.border_width = ev->border_width;
+-        wc.sibling = ev->above;
+-        wc.stack_mode = ev->detail;
+-        XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
+-    }
+-    XSync(dpy, False);
+-}
+-
+-void
+-copyvalidchars(char *text, char *rawtext)
+-{
+-    int i = -1, j = 0;
+-
+-    while(rawtext[++i]) {
+-        if ((unsigned char)rawtext[i] >= ' ') {
+-            text[j++] = rawtext[i];
+-        }
+-    }
+-    text[j] = '\0';
++	Client *c;
++	Monitor *m;
++	XConfigureRequestEvent *ev = &e->xconfigurerequest;
++	XWindowChanges wc;
++
++	if ((c = wintoclient(ev->window))) {
++		if (ev->value_mask & CWBorderWidth)
++			c->bw = ev->border_width;
++		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
++			m = c->mon;
++			if (ev->value_mask & CWX) {
++				c->oldx = c->x;
++				c->x = m->mx + ev->x;
++			}
++			if (ev->value_mask & CWY) {
++				c->oldy = c->y;
++				c->y = m->my + ev->y;
++			}
++			if (ev->value_mask & CWWidth) {
++				c->oldw = c->w;
++				c->w = ev->width;
++			}
++			if (ev->value_mask & CWHeight) {
++				c->oldh = c->h;
++				c->h = ev->height;
++			}
++			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
++				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
++			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
++				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
++			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
++				configure(c);
++			if (ISVISIBLE(c))
++				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++		} else
++			configure(c);
++	} else {
++		wc.x = ev->x;
++		wc.y = ev->y;
++		wc.width = ev->width;
++		wc.height = ev->height;
++		wc.border_width = ev->border_width;
++		wc.sibling = ev->above;
++		wc.stack_mode = ev->detail;
++		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
++	}
++	XSync(dpy, False);
+ }
+ 
+ Monitor *
+ createmon(void)
+ {
+-    Monitor *m;
++	Monitor *m;
+ 
+-    m = ecalloc(1, sizeof(Monitor));
+-    m->tagset[0] = m->tagset[1] = 1;
+-    m->mfact = mfact;
+-    m->nmaster = nmaster;
+-    m->showbar = showbar;
+-    m->topbar = topbar;
+-    m->gappih = gappih;
+-    m->gappiv = gappiv;
+-    m->gappoh = gappoh;
+-    m->gappov = gappov;
+-    m->lt[0] = &layouts[0];
+-    m->lt[1] = &layouts[1 % LENGTH(layouts)];
+-    strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+-    return m;
++	m = ecalloc(1, sizeof(Monitor));
++    if (mons)
++        m->tagset[0] = m->tagset[1] = 2;
++    else
++        m->tagset[0] = m->tagset[1] = 1;
++	m->mfact = mfact;
++	m->nmaster = nmaster;
++	m->showbar = showbar;
++	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
++	m->lt[0] = &layouts[0];
++	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++	return m;
+ }
+ 
+ void
+ destroynotify(XEvent *e)
+ {
+-    Client *c;
+-    XDestroyWindowEvent *ev = &e->xdestroywindow;
++	Client *c;
++	XDestroyWindowEvent *ev = &e->xdestroywindow;
+ 
+-    if ((c = wintoclient(ev->window)))
+-        unmanage(c, 1);
++	if ((c = wintoclient(ev->window)))
++		unmanage(c, 1);
+ 
+-    else if ((c = swallowingclient(ev->window)))
+-        unmanage(c->swallowing, 1);
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+ detach(Client *c)
+ {
+-    Client **tc;
++	Client **tc;
+ 
+-    for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
+-    *tc = c->next;
++	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
++	*tc = c->next;
+ }
+ 
+ void
+ detachstack(Client *c)
+ {
+-    Client **tc, *t;
++	Client **tc, *t;
+ 
+-    for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
+-    *tc = c->snext;
++	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
++	*tc = c->snext;
+ 
+-    if (c == c->mon->sel) {
+-        for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
+-        c->mon->sel = t;
+-    }
++	if (c == c->mon->sel) {
++		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
++		c->mon->sel = t;
++	}
+ }
+ 
+ Monitor *
+ dirtomon(int dir)
++{
++	Monitor *m = NULL;
++
++	if (dir > 0) {
++		if (!(m = selmon->next))
++			m = mons;
++	} else if (selmon == mons)
++		for (m = mons; m->next; m = m->next);
++	else
++		for (m = mons; m->next != selmon; m = m->next);
++	return m;
++}
++
++Monitor *
++numtomon(int num)
+ {
+     Monitor *m = NULL;
++    int i = 0;
+ 
+-    if (dir > 0) {
+-        if (!(m = selmon->next))
+-            m = mons;
+-    } else if (selmon == mons)
+-        for (m = mons; m->next; m = m->next);
+-    else
+-        for (m = mons; m->next != selmon; m = m->next);
++    for(m = mons, i=0; m->next && i < num; m = m->next)
++        i++;
+     return m;
+ }
+ 
+@@ -936,7 +955,7 @@ drawstatusbar(Monitor *m, int bh, char* stext)
+                     if (ptr == NULL) printf("Fail to read wr...");
+                     do{
+                         ch = fgetc(ptr);
+-                        // Check if contains + and 2 (= hot)
++                        // Check if temp is above +20 (= hot)
+                         if (hotbool){
+                             if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
+                                 drw_clr_create(drw, &drw->scheme[ColFg], col21);
+@@ -990,108 +1009,124 @@ drawstatusbar(Monitor *m, int bh, char* stext)
+ void
+ drawbar(Monitor *m)
+ {
+-    if (!m->showbar) return;
+-    int x, w, tw = 0;
+-    int boxs = drw->fonts->h / 9;
+-    int boxw = drw->fonts->h / 6 + 2;
+-    unsigned int i, occ = 0, urg = 0;
+-    Client *c;
++	int x, w, tw = 0;
++	int boxs = drw->fonts->h / 9;
++	int boxw = drw->fonts->h / 6 + 2;
++	unsigned int i, occ = 0, urg = 0;
++	Client *c;
+ 
+-    /* draw status first so it can be overdrawn by tags later */
+-    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
+-    if (m == selmon || 1) { 
+-        tw = m->ww - drawstatusbar(m, bh, stext);
+-    }
+-
+-    for (c = m->clients; c; c = c->next) {
+-        occ |= c->tags == 255 ? 0 : c->tags;
+-        if (c->isurgent)
+-            urg |= c->tags;
+-    }
+-    x = 0;
+-    for (i = 0; i < LENGTH(tags); i++) {
+-        /* do not draw vacant tags */
+-        if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+-            continue;
+-
+-        w = TEXTW(tags[i]);
+-        drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+-        drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-        x += w;
+-    }
+-    w = TEXTW(m->ltsymbol);
+-    drw_setscheme(drw, scheme[SchemeNorm]);
+-    x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++	if (!m->showbar)
++		return;
+ 
+-    if ((w = m->ww - tw - x) > bh) {
+-        drw_setscheme(drw, scheme[SchemeNorm]);
+-        drw_rect(drw, x, 0, w, bh, 1, 1);
+-    }
+-    drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++	/* draw status first so it can be overdrawn by tags later */
++	//if (m == selmon) { /* status is only drawn on selected monitor */
++    if (m == selmon || 1) { 
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
++	}
++
++	for (c = m->clients; c; c = c->next) {
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
++		if (c->isurgent)
++			urg |= c->tags;
++	}
++	x = 0;
++	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
++		w = TEXTW(tags[i]);
++		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++		x += w;
++	}
++	w = TEXTW(m->ltsymbol);
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++
++	if ((w = m->ww - tw - x) > bh) {
++			drw_setscheme(drw, scheme[SchemeNorm]);
++			drw_rect(drw, x, 0, w, bh, 1, 1);
++	}
++	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+ 
+ void
+ drawbars(void)
+ {
+-    Monitor *m;
++	Monitor *m;
+ 
+-    for (m = mons; m; m = m->next)
+-        drawbar(m);
++	for (m = mons; m; m = m->next)
++		drawbar(m);
+ }
+ 
+ void
+ expose(XEvent *e)
+ {
+-    Monitor *m;
+-    XExposeEvent *ev = &e->xexpose;
++	Monitor *m;
++	XExposeEvent *ev = &e->xexpose;
+ 
+-    if (ev->count == 0 && (m = wintomon(ev->window)))
+-        drawbar(m);
++	if (ev->count == 0 && (m = wintomon(ev->window)))
++		drawbar(m);
+ }
+ 
+ void
+ focus(Client *c)
+ {
+-    if (!c || !ISVISIBLE(c))
+-        for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
+-    if (selmon->sel && selmon->sel != c)
+-        unfocus(selmon->sel, 0);
+-    if (c) {
+-        if (c->mon != selmon)
+-            selmon = c->mon;
+-        if (c->isurgent)
+-            seturgent(c, 0);
+-        detachstack(c);
+-        attachstack(c);
+-        grabbuttons(c, 1);
+-        XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+-        setfocus(c);
+-    } else {
+-        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+-        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+-    }
+-    selmon->sel = c;
+-    drawbars();
++	if (!c || !ISVISIBLE(c))
++		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
++	if (selmon->sel && selmon->sel != c)
++		unfocus(selmon->sel, 0);
++	if (c) {
++		if (c->mon != selmon)
++			selmon = c->mon;
++		if (c->isurgent)
++			seturgent(c, 0);
++		detachstack(c);
++		attachstack(c);
++		grabbuttons(c, 1);
++		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
++		setfocus(c);
++	} else {
++		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++	}
++	selmon->sel = c;
++	drawbars();
+ }
+ 
+ /* there are some broken focus acquiring clients needing extra handling */
+ void
+ focusin(XEvent *e)
+ {
+-    XFocusChangeEvent *ev = &e->xfocus;
++	XFocusChangeEvent *ev = &e->xfocus;
+ 
+-    if (selmon->sel && ev->window != selmon->sel->win)
+-        setfocus(selmon->sel);
++	if (selmon->sel && ev->window != selmon->sel->win)
++		setfocus(selmon->sel);
+ }
+ 
+ void
+ focusmon(const Arg *arg)
++{
++	Monitor *m;
++
++	if (!mons->next)
++		return;
++	if ((m = dirtomon(arg->i)) == selmon)
++		return;
++	unfocus(selmon->sel, 0);
++	selmon = m;
++	focus(NULL);
++}
++
++void
++focusnthmon(const Arg *arg)
+ {
+     Monitor *m;
+ 
+     if (!mons->next)
+         return;
+-    if ((m = dirtomon(arg->i)) == selmon)
++
++    if ((m = numtomon(arg->i)) == selmon)
+         return;
+     unfocus(selmon->sel, 0);
+     XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+@@ -1102,622 +1137,669 @@ focusmon(const Arg *arg)
+ void
+ focusstack(const Arg *arg)
+ {
+-    int i = stackpos(arg);
+-    Client *c, *p;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
+-        return;
++	if(i < 0)
++		return;
+ 
+-    for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+-            i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+-    focus(c ? c : p);
+-    restack(selmon);
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+ getatomprop(Client *c, Atom prop)
+ {
+-    int di;
+-    unsigned long dl;
+-    unsigned char *p = NULL;
+-    Atom da, atom = None;
++	int di;
++	unsigned long dl;
++	unsigned char *p = NULL;
++	Atom da, atom = None;
+ 
+-    if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
+-                &da, &di, &dl, &dl, &p) == Success && p) {
+-        atom = *(Atom *)p;
+-        XFree(p);
+-    }
+-    return atom;
++	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
++		&da, &di, &dl, &dl, &p) == Success && p) {
++		atom = *(Atom *)p;
++		XFree(p);
++	}
++	return atom;
+ }
+ 
+-#ifndef __OpenBSD__
+-int getdwmblockspid()
+-{
+-    char buf[16];
+-    FILE *fp = popen("pidof -s dwmblocks", "r");
+-    fgets(buf, sizeof(buf), fp);
+-    pid_t pid = strtoul(buf, NULL, 10);
+-    pclose(fp);
+-    dwmblockspid = pid;
+-    return pid != 0 ? 0 : -1;
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
+ }
+-#endif
+ 
+ int
+ getrootptr(int *x, int *y)
+ {
+-    int di;
+-    unsigned int dui;
+-    Window dummy;
++	int di;
++	unsigned int dui;
++	Window dummy;
+ 
+-    return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
++	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
+ }
+ 
+ long
+ getstate(Window w)
+ {
+-    int format;
+-    long result = -1;
+-    unsigned char *p = NULL;
+-    unsigned long n, extra;
+-    Atom real;
++	int format;
++	long result = -1;
++	unsigned char *p = NULL;
++	unsigned long n, extra;
++	Atom real;
+ 
+-    if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
+-                &real, &format, &n, &extra, (unsigned char **)&p) != Success)
+-        return -1;
+-    if (n != 0)
+-        result = *p;
+-    XFree(p);
+-    return result;
++	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
++		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
++		return -1;
++	if (n != 0)
++		result = *p;
++	XFree(p);
++	return result;
+ }
+ 
+ int
+ gettextprop(Window w, Atom atom, char *text, unsigned int size)
+ {
+-    char **list = NULL;
+-    int n;
+-    XTextProperty name;
+-
+-    if (!text || size == 0)
+-        return 0;
+-    text[0] = '\0';
+-    if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
+-        return 0;
+-    if (name.encoding == XA_STRING)
+-        strncpy(text, (char *)name.value, size - 1);
+-    else {
+-        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+-            strncpy(text, *list, size - 1);
+-            XFreeStringList(list);
+-        }
+-    }
+-    text[size - 1] = '\0';
+-    XFree(name.value);
+-    return 1;
++	char **list = NULL;
++	int n;
++	XTextProperty name;
++
++	if (!text || size == 0)
++		return 0;
++	text[0] = '\0';
++	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++		return 0;
++	if (name.encoding == XA_STRING) {
++		strncpy(text, (char *)name.value, size - 1);
++	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++		strncpy(text, *list, size - 1);
++		XFreeStringList(list);
++	}
++	text[size - 1] = '\0';
++	XFree(name.value);
++	return 1;
+ }
+ 
+ void
+ grabbuttons(Client *c, int focused)
+ {
+-    updatenumlockmask();
+-    {
+-        unsigned int i, j;
+-        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+-        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+-        if (!focused)
+-            XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
+-                    BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
+-        for (i = 0; i < LENGTH(buttons); i++)
+-            if (buttons[i].click == ClkClientWin)
+-                for (j = 0; j < LENGTH(modifiers); j++)
+-                    XGrabButton(dpy, buttons[i].button,
+-                            buttons[i].mask | modifiers[j],
+-                            c->win, False, BUTTONMASK,
+-                            GrabModeAsync, GrabModeSync, None, None);
+-    }
++	updatenumlockmask();
++	{
++		unsigned int i, j;
++		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++		if (!focused)
++			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
++				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
++		for (i = 0; i < LENGTH(buttons); i++)
++			if (buttons[i].click == ClkClientWin)
++				for (j = 0; j < LENGTH(modifiers); j++)
++					XGrabButton(dpy, buttons[i].button,
++						buttons[i].mask | modifiers[j],
++						c->win, False, BUTTONMASK,
++						GrabModeAsync, GrabModeSync, None, None);
++	}
+ }
+ 
+ void
+ grabkeys(void)
+ {
+-    updatenumlockmask();
+-    {
+-        unsigned int i, j, k;
+-        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+-        int start, end, skip;
+-        KeySym *syms;
+-
+-        XUngrabKey(dpy, AnyKey, AnyModifier, root);
+-        XDisplayKeycodes(dpy, &start, &end);
+-        syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
+-        if (!syms)
+-            return;
+-        for (k = start; k <= end; k++)
+-            for (i = 0; i < LENGTH(keys); i++)
+-                /* skip modifier codes, we do that ourselves */
+-                if (keys[i].keysym == syms[(k - start) * skip])
+-                    for (j = 0; j < LENGTH(modifiers); j++)
+-                        XGrabKey(dpy, k,
+-                                keys[i].mod | modifiers[j],
+-                                root, True,
+-                                GrabModeAsync, GrabModeAsync);
+-        XFree(syms);
+-    }
++	updatenumlockmask();
++	{
++		unsigned int i, j, k;
++		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++		int start, end, skip;
++		KeySym *syms;
++
++		XUngrabKey(dpy, AnyKey, AnyModifier, root);
++		XDisplayKeycodes(dpy, &start, &end);
++		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
++		if (!syms)
++			return;
++		for (k = start; k <= end; k++)
++			for (i = 0; i < LENGTH(keys); i++)
++				/* skip modifier codes, we do that ourselves */
++				if (keys[i].keysym == syms[(k - start) * skip])
++					for (j = 0; j < LENGTH(modifiers); j++)
++						XGrabKey(dpy, k,
++							 keys[i].mod | modifiers[j],
++							 root, True,
++							 GrabModeAsync, GrabModeAsync);
++		XFree(syms);
++	}
+ }
+ 
+ void
+ incnmaster(const Arg *arg)
+ {
+-    selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+-    arrange(selmon);
++	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	arrange(selmon);
+ }
+ 
+ #ifdef XINERAMA
+-static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++static int
++isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+ {
+-    while (n--)
+-        if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
+-                && unique[n].width == info->width && unique[n].height == info->height)
+-            return 0;
+-    return 1;
++	while (n--)
++		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++		&& unique[n].width == info->width && unique[n].height == info->height)
++			return 0;
++	return 1;
+ }
+ #endif /* XINERAMA */
+ 
+ void
+ keypress(XEvent *e)
+ {
+-    unsigned int i;
+-    KeySym keysym;
+-    XKeyEvent *ev;
++	unsigned int i;
++	KeySym keysym;
++	XKeyEvent *ev;
+ 
+-    ev = &e->xkey;
+-    keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+-    for (i = 0; i < LENGTH(keys); i++)
+-        if (keysym == keys[i].keysym
+-                && CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
+-                && keys[i].func)
+-            keys[i].func(&(keys[i].arg));
++	ev = &e->xkey;
++	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
++	for (i = 0; i < LENGTH(keys); i++)
++		if (keysym == keys[i].keysym
++		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
++		&& keys[i].func)
++			keys[i].func(&(keys[i].arg));
+ }
+ 
+ void
+ killclient(const Arg *arg)
+ {
+-    if (!selmon->sel)
+-        return;
+-    if (!sendevent(selmon->sel, wmatom[WMDelete])) {
+-        XGrabServer(dpy);
+-        XSetErrorHandler(xerrordummy);
+-        XSetCloseDownMode(dpy, DestroyAll);
+-        XKillClient(dpy, selmon->sel->win);
+-        XSync(dpy, False);
+-        XSetErrorHandler(xerror);
+-        XUngrabServer(dpy);
+-    }
++	if (!selmon->sel)
++		return;
++	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
++		XGrabServer(dpy);
++		XSetErrorHandler(xerrordummy);
++		XSetCloseDownMode(dpy, DestroyAll);
++		XKillClient(dpy, selmon->sel->win);
++		XSync(dpy, False);
++		XSetErrorHandler(xerror);
++		XUngrabServer(dpy);
++	}
+ }
+ 
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-    Client *c, *t = NULL, *term = NULL;
+-    Window trans = None;
+-    XWindowChanges wc;
+-
+-    c = ecalloc(1, sizeof(Client));
+-    c->win = w;
+-    c->pid = winpid(w);
+-    /* geometry */
+-    c->x = c->oldx = wa->x;
+-    c->y = c->oldy = wa->y;
+-    c->w = c->oldw = wa->width;
+-    c->h = c->oldh = wa->height;
+-    c->oldbw = wa->border_width;
+-
+-    updatetitle(c);
+-    if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+-        c->mon = t->mon;
+-        c->tags = t->tags;
+-    } else {
+-        c->mon = selmon;
+-        applyrules(c);
+-        term = termforwin(c);
+-    }
+-
+-    if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+-        c->x = c->mon->wx + c->mon->ww - WIDTH(c);
+-    if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
+-        c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
+-    c->x = MAX(c->x, c->mon->wx);
+-    c->y = MAX(c->y, c->mon->wy);
+-    c->bw = borderpx;
+-    /* if (c->isfloating) c->bw = 0; */
+-
+-    wc.border_width = c->bw;
+-    XConfigureWindow(dpy, w, CWBorderWidth, &wc);
+-    XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+-    configure(c); /* propagates border_width, if size doesn't change */
+-    updatewindowtype(c);
+-    updatewmhints(c);
+-    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+-    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
+-    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
+-    c->sfx = c->x;
+-    c->sfy = c->y;
+-    c->sfw = c->w;
+-    c->sfh = c->h;
+-
+-    XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+-    grabbuttons(c, 0);
+-    if (!c->isfloating)
+-        c->isfloating = c->oldstate = t || c->isfixed;
+-    if (c->isfloating) {
+-        XRaiseWindow(dpy, c->win);
+-        if (strcmp(c->name, "YAD") == 0) {
+-            c->x = 1488;
+-            c->y = 42;
+-            c->w = 405;
+-            c->h = 280;
+-        }
+-    }
+-    attach(c);
+-    attachstack(c);
+-    XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+-            (unsigned char *) &(c->win), 1);
+-    XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
+-    setclientstate(c, NormalState);
+-    if (c->mon == selmon)
+-        unfocus(selmon->sel, 0);
+-    c->mon->sel = c;
+-    XMapWindow(dpy, c->win);
+-    if (term)
+-        swallow(term, c);
+-    arrange(c->mon);
+-    focus(NULL);
++	Client *c, *t = NULL, *term = NULL;
++	Window trans = None;
++	XWindowChanges wc;
++
++	c = ecalloc(1, sizeof(Client));
++	c->win = w;
++	c->pid = winpid(w);
++	/* geometry */
++	c->x = c->oldx = wa->x;
++	c->y = c->oldy = wa->y;
++	c->w = c->oldw = wa->width;
++	c->h = c->oldh = wa->height;
++	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
++
++	updatetitle(c);
++	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++		c->mon = t->mon;
++		c->tags = t->tags;
++	} else {
++		c->mon = selmon;
++		applyrules(c);
++		term = termforwin(c);
++	}
++
++	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
++	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
++		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
++	c->x = MAX(c->x, c->mon->wx);
++	c->y = MAX(c->y, c->mon->wy);
++	c->bw = borderpx;
++
++	wc.border_width = c->bw;
++	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++	configure(c); /* propagates border_width, if size doesn't change */
++	updatewindowtype(c);
++	updatesizehints(c);
++	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
++	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++	grabbuttons(c, 0);
++	if (!c->isfloating)
++		c->isfloating = c->oldstate = trans != None || c->isfixed;
++	if (c->isfloating)
++		XRaiseWindow(dpy, c->win);
++	attach(c);
++	attachstack(c);
++	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++		(unsigned char *) &(c->win), 1);
++	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
++	setclientstate(c, NormalState);
++	if (c->mon == selmon)
++		unfocus(selmon->sel, 0);
++	c->mon->sel = c;
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
++	focus(NULL);
+ }
+ 
+ void
+ mappingnotify(XEvent *e)
+ {
+-    XMappingEvent *ev = &e->xmapping;
++	XMappingEvent *ev = &e->xmapping;
+ 
+-    XRefreshKeyboardMapping(ev);
+-    if (ev->request == MappingKeyboard)
+-        grabkeys();
++	XRefreshKeyboardMapping(ev);
++	if (ev->request == MappingKeyboard)
++		grabkeys();
+ }
+ 
+ void
+ maprequest(XEvent *e)
+ {
+-    static XWindowAttributes wa;
+-    XMapRequestEvent *ev = &e->xmaprequest;
++	static XWindowAttributes wa;
++	XMapRequestEvent *ev = &e->xmaprequest;
+ 
+-    if (!XGetWindowAttributes(dpy, ev->window, &wa))
+-        return;
+-    if (wa.override_redirect)
+-        return;
+-    if (!wintoclient(ev->window))
+-        manage(ev->window, &wa);
++	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
++		return;
++	if (!wintoclient(ev->window))
++		manage(ev->window, &wa);
+ }
+ 
+ void
+ monocle(Monitor *m)
+ {
+-    unsigned int n;
+-    int oh, ov, ih, iv;
+-    Client *c;
++	unsigned int n = 0;
++	Client *c;
+ 
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n > 0) /* override layout symbol */
+-        snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
+-    for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
+-        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
+-}
+-
+-void
+-motionnotify(XEvent *e)
+-{
+-    static Monitor *mon = NULL;
+-    Monitor *m;
+-    XMotionEvent *ev = &e->xmotion;
+-
+-    if (ev->window != root)
+-        return;
+-    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-        unfocus(selmon->sel, 1);
+-        selmon = m;
+-        focus(NULL);
+-    }
+-    mon = m;
++	for (c = m->clients; c; c = c->next)
++		if (ISVISIBLE(c))
++			n++;
++	if (n > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+ void
+ movemouse(const Arg *arg)
+ {
+-    int x, y, ocx, ocy, nx, ny;
+-    Client *c;
+-    Monitor *m;
+-    XEvent ev;
+-    Time lasttime = 0;
+-
+-    if (!(c = selmon->sel))
+-        return;
+-    if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+-        return;
+-    restack(selmon);
+-    ocx = c->x;
+-    ocy = c->y;
+-    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+-                None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+-        return;
+-    if (!getrootptr(&x, &y))
+-        return;
+-    do {
+-        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+-        switch(ev.type) {
+-            case ConfigureRequest:
+-            case Expose:
+-            case MapRequest:
+-                handler[ev.type](&ev);
+-                break;
+-            case MotionNotify:
+-                // Increase display rate when dragging  and resizing floats
+-                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
+-                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
+-                    continue;
+-                lasttime = ev.xmotion.time;
+-
+-                nx = ocx + (ev.xmotion.x - x);
+-                ny = ocy + (ev.xmotion.y - y);
+-                if (abs(selmon->wx - nx) < snap)
+-                    nx = selmon->wx;
+-                else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+-                    nx = selmon->wx + selmon->ww - WIDTH(c);
+-                if (abs(selmon->wy - ny) < snap)
+-                    ny = selmon->wy;
+-                else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+-                    ny = selmon->wy + selmon->wh - HEIGHT(c);
+-                if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+-                        && (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+-                    togglefloating(NULL);
+-                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+-                    resize(c, nx, ny, c->w, c->h, 1);
+-                break;
+-        }
+-    } while (ev.type != ButtonRelease);
+-    XUngrabPointer(dpy, CurrentTime);
+-    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+-        sendmon(c, m);
+-        selmon = m;
+-        focus(NULL);
+-    }
++	int x, y, ocx, ocy, nx, ny;
++	Client *c;
++	Monitor *m;
++	XEvent ev;
++	Time lasttime = 0;
++
++	if (!(c = selmon->sel))
++		return;
++	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++		return;
++	restack(selmon);
++	ocx = c->x;
++	ocy = c->y;
++	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
++		return;
++	if (!getrootptr(&x, &y))
++		return;
++	do {
++		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++		switch(ev.type) {
++		case ConfigureRequest:
++		case Expose:
++		case MapRequest:
++			handler[ev.type](&ev);
++			break;
++		case MotionNotify:
++			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++				continue;
++			lasttime = ev.xmotion.time;
++
++			nx = ocx + (ev.xmotion.x - x);
++			ny = ocy + (ev.xmotion.y - y);
++			if (abs(selmon->wx - nx) < snap)
++				nx = selmon->wx;
++			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
++				nx = selmon->wx + selmon->ww - WIDTH(c);
++			if (abs(selmon->wy - ny) < snap)
++				ny = selmon->wy;
++			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
++				ny = selmon->wy + selmon->wh - HEIGHT(c);
++			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
++				togglefloating(NULL);
++			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++				resize(c, nx, ny, c->w, c->h, 1);
++			break;
++		}
++	} while (ev.type != ButtonRelease);
++	XUngrabPointer(dpy, CurrentTime);
++	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++		sendmon(c, m);
++		selmon = m;
++		focus(NULL);
++	}
+ }
+ 
+ Client *
+ nexttiled(Client *c)
+ {
+-    for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+-    return c;
++	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
++	return c;
+ }
+ 
+ void
+ pop(Client *c)
+ {
+-    detach(c);
+-    attach(c);
+-    focus(c);
+-    arrange(c->mon);
+-}
+-
+-void
+-pushstack(const Arg *arg)
+-{
+-    int i = stackpos(arg);
+-    Client *sel = selmon->sel, *c, *p;
+-
+-    if(i < 0 || !sel)
+-        return;
+-    else if(i == 0) {
+-        detach(sel);
+-        attach(sel);
+-    }
+-    else {
+-        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+-            if(!(i -= (ISVISIBLE(c) && c != sel)))
+-                break;
+-        c = c ? c : p;
+-        detach(sel);
+-        sel->next = c->next;
+-        c->next = sel;
+-    }
+-    arrange(selmon);
++	detach(c);
++	attach(c);
++	focus(c);
++	arrange(c->mon);
+ }
+ 
+ void
+ propertynotify(XEvent *e)
+ {
+-    Client *c;
+-    Window trans;
+-    XPropertyEvent *ev = &e->xproperty;
+-
+-    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
+-        updatestatus();
+-    } else if (ev->state == PropertyDelete) {
+-        return; /* ignore */
+-    } else if ((c = wintoclient(ev->window))) {
+-        switch(ev->atom) {
+-            default: break;
+-            case XA_WM_TRANSIENT_FOR:
+-                     if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
+-                             (c->isfloating = (wintoclient(trans)) != NULL))
+-                         arrange(c->mon);
+-                     break;
+-            case XA_WM_NORMAL_HINTS:
+-                     c->hintsvalid = 0;
+-                     break;
+-            case XA_WM_HINTS:
+-                     updatewmhints(c);
+-                     drawbars();
+-                     break;
+-        }
+-        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
+-            updatetitle(c);
+-            if (c == c->mon->sel)
+-                drawbar(c->mon);
+-        }
+-
+-        if (ev->atom == netatom[NetWMWindowType])
+-            updatewindowtype(c);
+-    }
++	Client *c;
++	Window trans;
++	XPropertyEvent *ev = &e->xproperty;
++
++	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
++		updatestatus();
++	else if (ev->state == PropertyDelete)
++		return; /* ignore */
++	else if ((c = wintoclient(ev->window))) {
++		switch(ev->atom) {
++		default: break;
++		case XA_WM_TRANSIENT_FOR:
++			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
++				(c->isfloating = (wintoclient(trans)) != NULL))
++				arrange(c->mon);
++			break;
++		case XA_WM_NORMAL_HINTS:
++			c->hintsvalid = 0;
++			break;
++		case XA_WM_HINTS:
++			updatewmhints(c);
++			drawbars();
++			break;
++		}
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++			updatetitle(c);
++		if (ev->atom == netatom[NetWMWindowType])
++			updatewindowtype(c);
++	}
++}
++
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
+ }
+ 
+ void
+ quit(const Arg *arg)
+ {
+-    if(arg->i) restart = 1;
+-    running = 0;
++	running = 0;
+ }
+ 
+ Monitor *
+ recttomon(int x, int y, int w, int h)
+ {
+-    Monitor *m, *r = selmon;
+-    int a, area = 0;
++	Monitor *m, *r = selmon;
++	int a, area = 0;
+ 
+-    for (m = mons; m; m = m->next)
+-        if ((a = INTERSECT(x, y, w, h, m)) > area) {
+-            area = a;
+-            r = m;
+-        }
+-    return r;
++	for (m = mons; m; m = m->next)
++		if ((a = INTERSECT(x, y, w, h, m)) > area) {
++			area = a;
++			r = m;
++		}
++	return r;
+ }
+ 
+ void
+ resize(Client *c, int x, int y, int w, int h, int interact)
+ {
+-    if (applysizehints(c, &x, &y, &w, &h, interact))
+-        resizeclient(c, x, y, w, h);
++	if (applysizehints(c, &x, &y, &w, &h, interact))
++		resizeclient(c, x, y, w, h);
+ }
+ 
+ void
+ resizeclient(Client *c, int x, int y, int w, int h)
+ {
+-    XWindowChanges wc;
+-
+-    c->oldx = c->x; c->x = wc.x = x;
+-    c->oldy = c->y; c->y = wc.y = y;
+-    c->oldw = c->w; c->w = wc.width = w;
+-    c->oldh = c->h; c->h = wc.height = h;
+-    wc.border_width = c->bw;
+-    // Don't show border if floating or if only 1 client
+-    if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+-                || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+-            && !c->isfullscreen) {
+-        /* && !c->isfullscreen && !c->isfloating) { */
+-        c->w = wc.width += c->bw * 2;
+-        c->h = wc.height += c->bw * 2;
+-        wc.border_width = 0;
+-    }
++	XWindowChanges wc;
+ 
+-    XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+-    configure(c);
+-    XSync(dpy, False);
++	c->oldx = c->x; c->x = wc.x = x;
++	c->oldy = c->y; c->y = wc.y = y;
++	c->oldw = c->w; c->w = wc.width = w;
++	c->oldh = c->h; c->h = wc.height = h;
++	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
++	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++	configure(c);
++	XSync(dpy, False);
+ }
+ 
+ void
+ resizemouse(const Arg *arg)
+ {
+-    int ocx, ocy, nw, nh;
+-    Client *c;
+-    Monitor *m;
+-    XEvent ev;
+-    Time lasttime = 0;
+-
+-    if (!(c = selmon->sel))
+-        return;
+-    if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+-        return;
+-    restack(selmon);
+-    ocx = c->x;
+-    ocy = c->y;
+-    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+-                None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
+-        return;
+-    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+-    do {
+-        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+-        switch(ev.type) {
+-            case ConfigureRequest:
+-            case Expose:
+-            case MapRequest:
+-                handler[ev.type](&ev);
+-                break;
+-            case MotionNotify:
+-                if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+-                    continue;
+-                lasttime = ev.xmotion.time;
+-
+-                nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
+-                nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+-                if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
+-                        && c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
+-                {
+-                    if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+-                            && (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
+-                        togglefloating(NULL);
+-                }
+-                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+-                    resize(c, c->x, c->y, nw, nh, 1);
+-                break;
+-        }
+-    } while (ev.type != ButtonRelease);
+-    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+-    XUngrabPointer(dpy, CurrentTime);
+-    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+-    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+-        sendmon(c, m);
+-        selmon = m;
+-        focus(NULL);
+-    }
++	int ocx, ocy, nw, nh;
++	Client *c;
++	Monitor *m;
++	XEvent ev;
++	Time lasttime = 0;
++
++	if (!(c = selmon->sel))
++		return;
++	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++		return;
++	restack(selmon);
++	ocx = c->x;
++	ocy = c->y;
++	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
++		return;
++	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++	do {
++		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++		switch(ev.type) {
++		case ConfigureRequest:
++		case Expose:
++		case MapRequest:
++			handler[ev.type](&ev);
++			break;
++		case MotionNotify:
++			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++				continue;
++			lasttime = ev.xmotion.time;
++
++			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
++			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
++			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
++			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
++			{
++				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
++					togglefloating(NULL);
++			}
++			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++				resize(c, c->x, c->y, nw, nh, 1);
++			break;
++		}
++	} while (ev.type != ButtonRelease);
++	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++	XUngrabPointer(dpy, CurrentTime);
++	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++		sendmon(c, m);
++		selmon = m;
++		focus(NULL);
++	}
+ }
+ 
+ void
+ restack(Monitor *m)
+ {
+-    Client *c;
+-    XEvent ev;
+-    XWindowChanges wc;
+-
+-    drawbar(m);
+-    if (!m->sel)
+-        return;
+-    if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+-        XRaiseWindow(dpy, m->sel->win);
+-    if (m->lt[m->sellt]->arrange) {
+-        wc.stack_mode = Below;
+-        wc.sibling = m->barwin;
+-        for (c = m->stack; c; c = c->snext)
+-            if (!c->isfloating && ISVISIBLE(c)) {
+-                XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
+-                wc.sibling = c->win;
+-            }
+-    }
+-    XSync(dpy, False);
+-    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++	Client *c;
++	XEvent ev;
++	XWindowChanges wc;
++
++	drawbar(m);
++	if (!m->sel)
++		return;
++	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
++		XRaiseWindow(dpy, m->sel->win);
++	if (m->lt[m->sellt]->arrange) {
++		wc.stack_mode = Below;
++		wc.sibling = m->barwin;
++		for (c = m->stack; c; c = c->snext)
++			if (!c->isfloating && ISVISIBLE(c)) {
++				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
++				wc.sibling = c->win;
++			}
++	}
++	XSync(dpy, False);
++	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+ }
+ 
+ void
+ run(void)
+ {
+-    XEvent ev;
+-    /* main event loop */
+-    XSync(dpy, False);
+-    while (running && !XNextEvent(dpy, &ev))
+-        if (handler[ev.type])
+-            handler[ev.type](&ev); /* call handler */
+-}
+-
+-void
+-runAutostart(void)
++	XEvent ev;
++	/* main event loop */
++	XSync(dpy, False);
++	while (running && !XNextEvent(dpy, &ev))
++		if (handler[ev.type])
++			handler[ev.type](&ev); /* call handler */
++}
++
++//void
++//runautostart(void)
++//{
++//	char *pathpfx;
++//	char *path;
++//	char *xdgdatahome;
++//	char *home;
++//	struct stat sb;
++//
++//	if ((home = getenv("HOME")) == NULL)
++//		/* this is almost impossible */
++//		return;
++//
++//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++//	 * otherwise use ~/.local/share/dwm as autostart script directory
++//	 */
++//	xdgdatahome = getenv("XDG_DATA_HOME");
++//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++//		/* space for path segments, separators and nul */
++//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++//
++//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	} else {
++//		/* space for path segments, separators and nul */
++//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++//		                     + strlen(dwmdir) + 3);
++//
++//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	}
++//
++//	/* check if the autostart script directory exists */
++//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++//		/* the XDG conformant path does not exist or is no directory
++//		 * so we try ~/.dwm instead
++//		 */
++//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++//		if(pathpfx_new == NULL) {
++//			free(pathpfx);
++//			return;
++//		}
++//		pathpfx = pathpfx_new;
++//
++//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	}
++//
++//	/* try the blocking script first */
++//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++//		free(path);
++//		free(pathpfx);
++//	}
++//
++//	if (access(path, X_OK) == 0)
++//		system(path);
++//
++//	/* now the non-blocking script */
++//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++//		free(path);
++//		free(pathpfx);
++//	}
++//
++//	if (access(path, X_OK) == 0)
++//		system(strcat(path, " &"));
++//
++//	free(pathpfx);
++//	free(path);
++//}
++
++void
++runautostart(void)
+ {
+     system("killall -q dwmblocks; dwmblocks &");
+ }
+@@ -1725,44 +1807,44 @@ runAutostart(void)
+ void
+ scan(void)
+ {
+-    unsigned int i, num;
+-    Window d1, d2, *wins = NULL;
+-    XWindowAttributes wa;
+-
+-    if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
+-        for (i = 0; i < num; i++) {
+-            if (!XGetWindowAttributes(dpy, wins[i], &wa)
+-                    || wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
+-                continue;
+-            if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
+-                manage(wins[i], &wa);
+-        }
+-        for (i = 0; i < num; i++) { /* now the transients */
+-            if (!XGetWindowAttributes(dpy, wins[i], &wa))
+-                continue;
+-            if (XGetTransientForHint(dpy, wins[i], &d1)
+-                    && (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
+-                manage(wins[i], &wa);
+-        }
+-        if (wins)
+-            XFree(wins);
+-    }
++	unsigned int i, num;
++	Window d1, d2, *wins = NULL;
++	XWindowAttributes wa;
++
++	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
++		for (i = 0; i < num; i++) {
++			if (!XGetWindowAttributes(dpy, wins[i], &wa)
++			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
++				continue;
++			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
++				manage(wins[i], &wa);
++		}
++		for (i = 0; i < num; i++) { /* now the transients */
++			if (!XGetWindowAttributes(dpy, wins[i], &wa))
++				continue;
++			if (XGetTransientForHint(dpy, wins[i], &d1)
++			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
++				manage(wins[i], &wa);
++		}
++		if (wins)
++			XFree(wins);
++	}
+ }
+ 
+ void
+ sendmon(Client *c, Monitor *m)
+ {
+-    if (c->mon == m)
+-        return;
+-    unfocus(c, 1);
+-    detach(c);
+-    detachstack(c);
+-    c->mon = m;
+-    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+-    attach(c);
+-    attachstack(c);
+-    focus(NULL);
+-    arrange(NULL);
++	if (c->mon == m)
++		return;
++	unfocus(c, 1);
++	detach(c);
++	detachstack(c);
++	c->mon = m;
++	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++	attach(c);
++	attachstack(c);
++	focus(NULL);
++	arrange(NULL);
+ }
+ 
+ void
+@@ -1787,318 +1869,616 @@ sendmonview(Client *c, Monitor *m)
+ void
+ setclientstate(Client *c, long state)
+ {
+-    long data[] = { state, None };
++	long data[] = { state, None };
+ 
+-    XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
+-            PropModeReplace, (unsigned char *)data, 2);
++	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
++		PropModeReplace, (unsigned char *)data, 2);
+ }
+ 
+ int
+ sendevent(Client *c, Atom proto)
+ {
+-    int n;
+-    Atom *protocols;
+-    int exists = 0;
+-    XEvent ev;
+-
+-    if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
+-        while (!exists && n--)
+-            exists = protocols[n] == proto;
+-        XFree(protocols);
+-    }
+-    if (exists) {
+-        ev.type = ClientMessage;
+-        ev.xclient.window = c->win;
+-        ev.xclient.message_type = wmatom[WMProtocols];
+-        ev.xclient.format = 32;
+-        ev.xclient.data.l[0] = proto;
+-        ev.xclient.data.l[1] = CurrentTime;
+-        XSendEvent(dpy, c->win, False, NoEventMask, &ev);
+-    }
+-    return exists;
++	int n;
++	Atom *protocols;
++	int exists = 0;
++	XEvent ev;
++
++	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
++		while (!exists && n--)
++			exists = protocols[n] == proto;
++		XFree(protocols);
++	}
++	if (exists) {
++		ev.type = ClientMessage;
++		ev.xclient.window = c->win;
++		ev.xclient.message_type = wmatom[WMProtocols];
++		ev.xclient.format = 32;
++		ev.xclient.data.l[0] = proto;
++		ev.xclient.data.l[1] = CurrentTime;
++		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
++	}
++	return exists;
+ }
+ 
+ void
+ setfocus(Client *c)
+ {
+-    if (!c->neverfocus) {
+-        XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
+-        XChangeProperty(dpy, root, netatom[NetActiveWindow],
+-                XA_WINDOW, 32, PropModeReplace,
+-                (unsigned char *) &(c->win), 1);
+-    }
+-    sendevent(c, wmatom[WMTakeFocus]);
++	if (!c->neverfocus) {
++		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
++		XChangeProperty(dpy, root, netatom[NetActiveWindow],
++			XA_WINDOW, 32, PropModeReplace,
++			(unsigned char *) &(c->win), 1);
++	}
++	sendevent(c, wmatom[WMTakeFocus]);
+ }
+ 
+ void
+ setfullscreen(Client *c, int fullscreen)
+ {
+-    if (fullscreen && !c->isfullscreen) {
+-        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+-                PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+-        c->isfullscreen = 1;
+-        c->oldstate = c->isfloating;
+-        c->oldbw = c->bw;
+-        c->bw = 0;
+-        c->isfloating = 1;
+-        resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+-        XRaiseWindow(dpy, c->win);
+-    } else if (!fullscreen && c->isfullscreen){
+-        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+-                PropModeReplace, (unsigned char*)0, 0);
+-        c->isfullscreen = 0;
+-        c->isfloating = c->oldstate;
+-        c->bw = c->oldbw;
+-        c->x = c->oldx;
+-        c->y = c->oldy;
+-        c->w = c->oldw;
+-        c->h = c->oldh;
+-        resizeclient(c, c->x, c->y, c->w, c->h);
+-        arrange(c->mon);
+-    }
++	if (fullscreen && !c->isfullscreen) {
++		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++		c->isfullscreen = 1;
++		c->oldstate = c->isfloating;
++		c->oldbw = c->bw;
++		c->bw = 0;
++		c->isfloating = 1;
++		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++		XRaiseWindow(dpy, c->win);
++	} else if (!fullscreen && c->isfullscreen){
++		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++			PropModeReplace, (unsigned char*)0, 0);
++		c->isfullscreen = 0;
++		c->isfloating = c->oldstate;
++		c->bw = c->oldbw;
++		c->x = c->oldx;
++		c->y = c->oldy;
++		c->w = c->oldw;
++		c->h = c->oldh;
++		resizeclient(c, c->x, c->y, c->w, c->h);
++		arrange(c->mon);
++	}
++}
++
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
++void
++setlayout(const Arg *arg)
++{
++	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
++		selmon->sellt ^= 1;
++	if (arg && arg->v)
++		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
++	if (selmon->sel)
++		arrange(selmon);
++	else
++		drawbar(selmon);
++}
++
++//void
++//shiftview(const Arg *arg) {
++//	Arg shifted;
++//
++//	if(arg->i > 0) /* left circular shift */
++//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++//
++//	else /* right circular shift */
++//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++//
++//	view(&shifted);
++//}
++//
++//void
++//shifttag(const Arg *arg) {
++//	Arg shifted;
++//	Client *c;
++//
++//	if (!selmon->sel)
++//		return;
++//	c = selmon->sel;
++//
++//	if (arg->i > 0) /* left circular shift */
++//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++//			^ (c->tags >> (LENGTH(tags) - arg->i));
++//	else /* right circular shift */
++//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++//			^ (c->tags << (LENGTH(tags) + arg->i));
++//
++//	toggletag(&shifted);
++//}
++
++// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
++// Or this (used below):
++// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
++
++/* Sends a window to the next/prev tag */
++void
++shifttag(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
++	tag(&shifted);
++}
++/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
++void
++shifttagclients(const Arg *arg)
++{
++
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	tag(&shifted);
++}
++/* Navigate to the next/prev tag */
++void
++shiftview(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0) {/* left circular shift */
++		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	} else {	/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	}
++	view(&shifted);
++}
++/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
++void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	view(&shifted);
+ }
++/* move the current active window to the next/prev tag and view it. More like following the window */
++void
++shiftboth(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+ 
+-int
+-stackpos(const Arg *arg)
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	tag(&shifted);
++	view(&shifted);
++}
++//helper function for shiftswaptags found on:
++//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
++// modified to work with scratchpad
++void
++swaptags(const Arg *arg)
+ {
+-    int n, i;
+-    Client *c, *l;
++	Client *c;
++	unsigned int newtag = arg->ui & TAGMASK;
++	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+ 
+-    if(!selmon->clients)
+-        return -1;
++	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
++		return;
+ 
+-    if(arg->i == PREVSEL) {
+-        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+-        if(!l)
+-            return -1;
+-        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+-        return i;
+-    }
+-    else if(ISINC(arg->i)) {
+-        if(!selmon->sel)
+-            return -1;
+-        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+-        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+-        return MOD(i + GETINC(arg->i), n);
+-    }
+-    else if(arg->i < 0) {
+-        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+-        return MAX(i + arg->i, 0);
+-    }
+-    else
+-        return arg->i;
+-}
++	for (c = selmon->clients; c != NULL; c = c->next) {
++		if ((c->tags & newtag) || (c->tags & curtag))
++			c->tags ^= curtag ^ newtag;
+ 
++		if (!c->tags)
++			c->tags = newtag;
++	}
++
++	//move to the swaped tag
++	//selmon->tagset[selmon->seltags] = newtag;
++
++	focus(NULL);
++	arrange(selmon);
++}
++/* swaps "tags" (all the clients) with the next/prev tag. */
+ void
+-setlayout(const Arg *arg)
++shiftswaptags(const Arg *arg)
+ {
+-    if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+-        selmon->sellt ^= 1;
+-    if (arg && arg->v)
+-        selmon->lt[selmon->sellt] = (Layout *)arg->v;
+-    strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+-    if (selmon->sel)
+-        arrange(selmon);
+-    else
+-        drawbar(selmon);
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	swaptags(&shifted);
++	// uncomment if you also want to "go" (view) the tag where the the clients are going
++	//view(&shifted);
++}
++
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
+ }
+ 
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+ {
+-    float f;
++	float f;
+ 
+-    if (!arg || !selmon->lt[selmon->sellt]->arrange)
+-        return;
+-    f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+-    if (f < 0.05 || f > 0.95)
+-        return;
+-    selmon->mfact = f;
+-    arrange(selmon);
++	if (!arg || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
++	if (f < 0.05 || f > 0.95)
++		return;
++	selmon->mfact = f;
++	arrange(selmon);
+ }
+ 
+ void
+ setup(void)
+ {
+-    int i;
+-    XSetWindowAttributes wa;
+-    Atom utf8string;
+-    struct sigaction sa;
+-
+-    /* do not transform children into zombies when they terminate */
+-    sigemptyset(&sa.sa_mask);
+-    sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
+-    sa.sa_handler = SIG_IGN;
+-    sigaction(SIGCHLD, &sa, NULL);
+-
+-    /* clean up any zombies (inherited from .xinitrc etc) immediately */
+-    while (waitpid(-1, NULL, WNOHANG) > 0);
+-
+-    signal(SIGHUP, sighup);
+-    signal(SIGTERM, sigterm);
+-
+-    /* init screen */
+-    screen = DefaultScreen(dpy);
+-    sw = DisplayWidth(dpy, screen);
+-    sh = DisplayHeight(dpy, screen);
+-    root = RootWindow(dpy, screen);
+-    drw = drw_create(dpy, screen, root, sw, sh);
+-    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+-        die("no fonts could be loaded.");
+-    lrpad = drw->fonts->h;
+-    bh = drw->fonts->h + 2;
+-    updategeom();
+-    /* init atoms */
+-    utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+-    wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+-    wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+-    wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
+-    wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
+-    netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
+-    netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+-    netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
+-    netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+-    netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+-    netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+-    netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+-    netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+-    netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+-    /* init cursors */
+-    cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
+-    cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+-    cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+-    /* init appearance */
+-    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
+-    scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+-    scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+-
+-    for (i = 0; i < LENGTH(colors); i++)
+-        scheme[i] = drw_scm_create(drw, colors[i], 3);
+-    /* init bars */
+-    updatebars();
+-    updatestatus();
+-    /* supporting window for NetWMCheck */
+-    wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
+-    XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
+-            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+-    XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
+-            PropModeReplace, (unsigned char *) "dwm", 3);
+-    XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
+-            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+-    /* EWMH support per view */
+-    XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
+-            PropModeReplace, (unsigned char *) netatom, NetLast);
+-    XDeleteProperty(dpy, root, netatom[NetClientList]);
+-    /* select events */
+-    wa.cursor = cursor[CurNormal]->cursor;
+-    wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
+-        |ButtonPressMask|PointerMotionMask|EnterWindowMask
+-        |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
+-    XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
+-    XSelectInput(dpy, root, wa.event_mask);
+-    grabkeys();
+-    focus(NULL);
++	int i;
++	XSetWindowAttributes wa;
++	Atom utf8string;
++	struct sigaction sa;
++
++	/* do not transform children into zombies when they terminate */
++	sigemptyset(&sa.sa_mask);
++	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
++	sa.sa_handler = SIG_IGN;
++	sigaction(SIGCHLD, &sa, NULL);
++
++	/* clean up any zombies (inherited from .xinitrc etc) immediately */
++	while (waitpid(-1, NULL, WNOHANG) > 0);
++
++	/* init screen */
++	screen = DefaultScreen(dpy);
++	sw = DisplayWidth(dpy, screen);
++	sh = DisplayHeight(dpy, screen);
++	root = RootWindow(dpy, screen);
++	drw = drw_create(dpy, screen, root, sw, sh);
++	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++		die("no fonts could be loaded.");
++	lrpad = drw->fonts->h;
++	bh = drw->fonts->h + 2;
++	updategeom();
++	/* init atoms */
++	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
++	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
++	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
++	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
++	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
++	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
++	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
++	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
++	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
++	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++	/* init cursors */
++	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
++	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++	/* init appearance */
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++	for (i = 0; i < LENGTH(colors); i++)
++		scheme[i] = drw_scm_create(drw, colors[i], 3);
++	/* init bars */
++	updatebars();
++	updatestatus();
++	/* supporting window for NetWMCheck */
++	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
++	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
++		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
++		PropModeReplace, (unsigned char *) "dwm", 3);
++	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
++		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++	/* EWMH support per view */
++	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
++		PropModeReplace, (unsigned char *) netatom, NetLast);
++	XDeleteProperty(dpy, root, netatom[NetClientList]);
++	/* select events */
++	wa.cursor = cursor[CurNormal]->cursor;
++	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
++		|ButtonPressMask|PointerMotionMask|EnterWindowMask
++		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
++	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
++	XSelectInput(dpy, root, wa.event_mask);
++	grabkeys();
++	focus(NULL);
+ }
+ 
+ void
+ seturgent(Client *c, int urg)
+ {
+-    XWMHints *wmh;
++	XWMHints *wmh;
+ 
+-    c->isurgent = urg;
+-    if (!(wmh = XGetWMHints(dpy, c->win)))
+-        return;
+-    wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
+-    XSetWMHints(dpy, c->win, wmh);
+-    XFree(wmh);
++	c->isurgent = urg;
++	if (!(wmh = XGetWMHints(dpy, c->win)))
++		return;
++	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
++	XSetWMHints(dpy, c->win, wmh);
++	XFree(wmh);
+ }
+ 
+ void
+ showhide(Client *c)
+ {
+-    if (!c)
+-        return;
+-    if (ISVISIBLE(c)) {
+-        if ((c->tags & SPTAGMASK) && c->isfloating) {
+-            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
+-            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+-        }
+-        /* show clients top down */
+-        XMoveWindow(dpy, c->win, c->x, c->y);
+-        if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+-            resize(c, c->x, c->y, c->w, c->h, 0);
+-        showhide(c->snext);
+-    } else {
+-        /* hide clients bottom up */
+-        showhide(c->snext);
+-        XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+-    }
++	if (!c)
++		return;
++	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
++		/* show clients top down */
++		XMoveWindow(dpy, c->win, c->x, c->y);
++		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++			resize(c, c->x, c->y, c->w, c->h, 0);
++		showhide(c->snext);
++	} else {
++		/* hide clients bottom up */
++		showhide(c->snext);
++		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++	}
+ }
+ 
+ void
+-sighup(int unused)
++sigstatusbar(const Arg *arg)
+ {
+-    Arg a = {.i = 1};
+-    quit(&a);
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+ }
+ 
+ void
+-sigterm(int unused)
++spawn(const Arg *arg)
+ {
+-    Arg a = {.i = 0};
+-    quit(&a);
++	struct sigaction sa;
++
++	if (arg->v == dmenucmd)
++		dmenumon[0] = '0' + selmon->num;
++	if (fork() == 0) {
++		if (dpy)
++			close(ConnectionNumber(dpy));
++		setsid();
++
++		sigemptyset(&sa.sa_mask);
++		sa.sa_flags = 0;
++		sa.sa_handler = SIG_DFL;
++		sigaction(SIGCHLD, &sa, NULL);
++
++		execvp(((char **)arg->v)[0], (char **)arg->v);
++		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
++	}
+ }
+ 
+-#ifndef __OpenBSD__
+-void sigdwmblocks(const Arg *arg)
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
++//void
++//tag(const Arg *arg)
++//{
++//    if (selmon->sel && arg->ui & TAGMASK) {
++//        if (mons && mons->next) {
++//            // Moving to even tag, selected mon != first mon
++//            if ((arg->ui & 341) == 0 && selmon != mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//                // Moving to odd tag, selected mon == first mon
++//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            } else {
++//                tagnextmon(arg);
++//            }
++//        } else {
++//            if (selmon->sel && arg->ui & TAGMASK) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            }
++//        }
++//    }
++//}
++
++void
++tag(const Arg *arg)
+ {
+-    union sigval sv;
+-    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
+-    if (!dwmblockspid)
+-        if (getdwmblockspid() == -1)
+-            return;
++    if (!(selmon->sel && arg->ui & TAGMASK))
++        return;
+ 
+-    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
+-        if (errno == ESRCH) {
+-            if (!getdwmblockspid())
+-                sigqueue(dwmblockspid, SIGUSR1, sv);
++    if (mons && mons->next) {
++        // Moving to even tag, selected mon != first mon
++        if ((arg->ui & 341) == 0 && selmon != mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
+         }
++        // Moving to odd tag, selected mon == first mon
++        else if ((arg->ui & 341) > 0 && selmon == mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        } else {
++            tagnextmon(arg);
++            return;
++        }
++    } else {
++        selmon->sel->tags = arg->ui & TAGMASK;
+     }
++
++    focus(NULL);
++    arrange(selmon);
+ }
+-#endif
+ 
+ void
+-spawn(const Arg *arg)
++tagview(const Arg *arg)
+ {
+-    struct sigaction sa;
+-    if (fork() == 0) {
+-        if (dpy)
+-            close(ConnectionNumber(dpy));
+-        setsid();
++    if (selmon->sel && arg->ui & TAGMASK) {
++        if (mons && mons->next) {
++            // If first monitor and moving to even tag (second mon)
++            if ((arg->ui & 341) == 0 && selmon == mons) {
++                tagnthmonview(&((Arg) { .i = 1 }));
++                tagnewmon(arg);
++                return;
++            } else if ((arg->ui & 341) > 0 && selmon != mons) {
++                tagnthmonview(&((Arg) { .i = 0 }));
++                tagnewmon(arg);
++                return;
++            }
++        }
++        selmon->sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(selmon);
++        view(arg);
++    }
++}
+ 
+-        sigemptyset(&sa.sa_mask);
+-        sa.sa_flags = 0;
+-        sa.sa_handler = SIG_DFL;
+-        sigaction(SIGCHLD, &sa, NULL);
++void
++tagmon(const Arg *arg)
++{
++	if (!selmon->sel || !mons->next)
++		return;
++	sendmon(selmon->sel, dirtomon(arg->i));
++}
+ 
+-        execvp(((char **)arg->v)[0], (char **)arg->v);
+-        die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
+-    }
++void
++tagmonview(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmonview(selmon->sel, dirtomon(arg->i));
+ }
+ 
+ void
+-tag(const Arg *arg)
++tagnextmon(const Arg *arg)
+ {
+-    if (selmon->sel && arg->ui & TAGMASK) {
+-        selmon->sel->tags = arg->ui & TAGMASK;
++    Client *sel;
++    Monitor *newmon;
++
++    if (!selmon->sel || !mons->next)
++        return;
++    sel = selmon->sel;
++    newmon = dirtomon(1);
++    sendmon(sel, newmon);
++    if (sel && arg->ui & TAGMASK) {
++        sel->tags = arg->ui & TAGMASK;
+         focus(NULL);
+-        arrange(selmon);
++        arrange(newmon);
+     }
+ }
+ 
+ void
+-tagview(const Arg *arg)
++tagnewmon(const Arg *arg)
+ {
+     if (selmon->sel && arg->ui & TAGMASK) {
+         selmon->sel->tags = arg->ui & TAGMASK;
+@@ -2109,439 +2489,458 @@ tagview(const Arg *arg)
+ }
+ 
+ void
+-tagmon(const Arg *arg)
++tagnthmon(const Arg *arg)
+ {
+     if (!selmon->sel || !mons->next)
+         return;
+-    sendmon(selmon->sel, dirtomon(arg->i));
++    sendmon(selmon->sel, numtomon(arg->i));
+ }
+ 
+ void
+-tagmonview(const Arg *arg)
++tagnthmonview(const Arg *arg)
+ {
+     if (!selmon->sel || !mons->next)
+         return;
+-    sendmonview(selmon->sel, dirtomon(arg->i));
++    sendmonview(selmon->sel, numtomon(arg->i));
+ }
+ 
+ void
+ togglebar(const Arg *arg)
+ {
+-    selmon->showbar = !selmon->showbar;
+-    updatebarpos(selmon);
+-    XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+-    arrange(selmon);
++	selmon->showbar = !selmon->showbar;
++	updatebarpos(selmon);
++	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++	arrange(selmon);
+ }
+ 
+ void
+-togglefloating(const Arg *arg)
++togglebars(const Arg *arg)
+ {
+-    if (!selmon->sel)
+-        return;
+-    if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+-        return;
+-    selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+-    if (selmon->sel->isfloating) {
+-        /* selmon->sel->bw = 0; */
+-        /* configure(selmon->sel); */
+-        /* restore last known float dimensions */
+-        resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+-                selmon->sel->sfw, selmon->sel->sfh, False);
+-    } else {
+-        /* save last known float dimensions */
+-        selmon->sel->sfx = selmon->sel->x;
+-        selmon->sel->sfy = selmon->sel->y;
+-        selmon->sel->sfw = selmon->sel->w;
+-        selmon->sel->sfh = selmon->sel->h;
++    Monitor *m;
++    for (m = mons; m; m = m->next) {
++        m->showbar = !m->showbar;
++        updatebarpos(m);
++        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++        arrange(m);
+     }
+-    arrange(selmon);
++}
++
++void
++togglefloating(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++		return;
++	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++	if (selmon->sel->isfloating)
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
++	arrange(selmon);
+ }
+ 
+ void
+ togglefullscr(const Arg *arg)
+ {
+-    if(selmon->sel)
+-        setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+ }
+ 
+ void
+ togglesticky(const Arg *arg)
+ {
+-    if (!selmon->sel)
+-        return;
+-    selmon->sel->issticky = !selmon->sel->issticky;
+-    arrange(selmon);
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
++	arrange(selmon);
+ }
+ 
+ void
+ togglescratch(const Arg *arg)
+ {
+-    Client *c;
+-    unsigned int found = 0;
+-    unsigned int scratchtag = SPTAG(arg->ui);
+-    Arg sparg = {.v = scratchpads[arg->ui].cmd};
+-
+-    for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+-    if (found) {
+-        unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+-        if (newtagset) {
+-            selmon->tagset[selmon->seltags] = newtagset;
+-            focus(NULL);
+-            arrange(selmon);
+-        }
+-        if (ISVISIBLE(c)) {
+-            focus(c);
+-            restack(selmon);
+-        }
+-    } else {
+-        selmon->tagset[selmon->seltags] |= scratchtag;
+-        spawn(&sparg);
+-    }
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
+ }
+ 
+ void
+ toggletag(const Arg *arg)
+ {
+-    unsigned int newtags;
++	unsigned int newtags;
+ 
+-    if (!selmon->sel)
+-        return;
+-    newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
+-    if (newtags) {
+-        selmon->sel->tags = newtags;
+-        focus(NULL);
+-        arrange(selmon);
+-    }
++	if (!selmon->sel)
++		return;
++	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
++	if (newtags) {
++		selmon->sel->tags = newtags;
++		focus(NULL);
++		arrange(selmon);
++	}
+ }
+ 
+ void
+ toggleview(const Arg *arg)
+ {
+-    unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+ 
+-    if (newtagset) {
+-        selmon->tagset[selmon->seltags] = newtagset;
+-        focus(NULL);
+-        arrange(selmon);
+-    }
++	if (newtagset) {
++		selmon->tagset[selmon->seltags] = newtagset;
++		focus(NULL);
++		arrange(selmon);
++	}
+ }
+ 
+ void
+ unfocus(Client *c, int setfocus)
+ {
+-    if (!c)
+-        return;
+-    grabbuttons(c, 0);
+-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+-    if (setfocus) {
+-        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+-        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+-    }
++	if (!c)
++		return;
++	grabbuttons(c, 0);
++	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++	if (setfocus) {
++		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++	}
+ }
+ 
+ void
+ unmanage(Client *c, int destroyed)
+ {
+-    Monitor *m = c->mon;
+-    XWindowChanges wc;
+-
+-    if (c->swallowing) {
+-        unswallow(c);
+-        return;
+-    }
+-
+-    Client *s = swallowingclient(c->win);
+-    if (s) {
+-        free(s->swallowing);
+-        s->swallowing = NULL;
+-        arrange(m);
+-        focus(NULL);
+-        return;
+-    }
+-
+-    detach(c);
+-    detachstack(c);
+-    if (!destroyed) {
+-        wc.border_width = c->oldbw;
+-        XGrabServer(dpy); /* avoid race conditions */
+-        XSetErrorHandler(xerrordummy);
+-        XSelectInput(dpy, c->win, NoEventMask);
+-        XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
+-        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+-        setclientstate(c, WithdrawnState);
+-        XSync(dpy, False);
+-        XSetErrorHandler(xerror);
+-        XUngrabServer(dpy);
+-    }
+-    free(c);
+-
+-    if (!s) {
+-        arrange(m);
+-        focus(NULL);
+-        updateclientlist();
+-    }
++	Monitor *m = c->mon;
++	XWindowChanges wc;
++
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
++	detach(c);
++	detachstack(c);
++	if (!destroyed) {
++		wc.border_width = c->oldbw;
++		XGrabServer(dpy); /* avoid race conditions */
++		XSetErrorHandler(xerrordummy);
++		XSelectInput(dpy, c->win, NoEventMask);
++		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
++		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++		setclientstate(c, WithdrawnState);
++		XSync(dpy, False);
++		XSetErrorHandler(xerror);
++		XUngrabServer(dpy);
++	}
++	free(c);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+ unmapnotify(XEvent *e)
+ {
+-    Client *c;
+-    XUnmapEvent *ev = &e->xunmap;
++	Client *c;
++	XUnmapEvent *ev = &e->xunmap;
+ 
+-    if ((c = wintoclient(ev->window))) {
+-        if (ev->send_event)
+-            setclientstate(c, WithdrawnState);
+-        else
+-            unmanage(c, 0);
+-    }
++	if ((c = wintoclient(ev->window))) {
++		if (ev->send_event)
++			setclientstate(c, WithdrawnState);
++		else
++			unmanage(c, 0);
++	}
+ }
+ 
+ void
+ updatebars(void)
+ {
+-    Monitor *m;
+-    XSetWindowAttributes wa = {
+-        .override_redirect = True,
+-        .background_pixmap = ParentRelative,
+-        .event_mask = ButtonPressMask|ExposureMask
+-    };
+-    XClassHint ch = {"dwm", "dwm"};
+-    for (m = mons; m; m = m->next) {
+-        if (m->barwin)
+-            continue;
+-        m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+-                CopyFromParent, DefaultVisual(dpy, screen),
+-                CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+-        XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+-        XMapRaised(dpy, m->barwin);
+-        XSetClassHint(dpy, m->barwin, &ch);
+-    }
++	Monitor *m;
++	XSetWindowAttributes wa = {
++		.override_redirect = True,
++		.background_pixmap = ParentRelative,
++		.event_mask = ButtonPressMask|ExposureMask
++	};
++	XClassHint ch = {"dwm", "dwm"};
++	for (m = mons; m; m = m->next) {
++		if (m->barwin)
++			continue;
++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++				CopyFromParent, DefaultVisual(dpy, screen),
++				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++		XMapRaised(dpy, m->barwin);
++		XSetClassHint(dpy, m->barwin, &ch);
++	}
+ }
+ 
+ void
+ updatebarpos(Monitor *m)
+ {
+-    m->wy = m->my;
+-    m->wh = m->mh;
+-    if (m->showbar) {
+-        m->wh -= bh;
+-        m->by = m->topbar ? m->wy : m->wy + m->wh;
+-        m->wy = m->topbar ? m->wy + bh : m->wy;
+-    } else
+-        m->by = -bh;
++	m->wy = m->my;
++	m->wh = m->mh;
++	if (m->showbar) {
++		m->wh -= bh;
++		m->by = m->topbar ? m->wy : m->wy + m->wh;
++		m->wy = m->topbar ? m->wy + bh : m->wy;
++	} else
++		m->by = -bh;
+ }
+ 
+ void
+ updateclientlist(void)
+ {
+-    Client *c;
+-    Monitor *m;
++	Client *c;
++	Monitor *m;
+ 
+-    XDeleteProperty(dpy, root, netatom[NetClientList]);
+-    for (m = mons; m; m = m->next)
+-        for (c = m->clients; c; c = c->next)
+-            XChangeProperty(dpy, root, netatom[NetClientList],
+-                    XA_WINDOW, 32, PropModeAppend,
+-                    (unsigned char *) &(c->win), 1);
++	XDeleteProperty(dpy, root, netatom[NetClientList]);
++	for (m = mons; m; m = m->next)
++		for (c = m->clients; c; c = c->next)
++			XChangeProperty(dpy, root, netatom[NetClientList],
++				XA_WINDOW, 32, PropModeAppend,
++				(unsigned char *) &(c->win), 1);
+ }
+ 
+ int
+ updategeom(void)
+ {
+-    int dirty = 0;
++	int dirty = 0;
+ 
+ #ifdef XINERAMA
+-    if (XineramaIsActive(dpy)) {
+-        int i, j, n, nn;
+-        Client *c;
+-        Monitor *m;
+-        XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
+-        XineramaScreenInfo *unique = NULL;
+-
+-        for (n = 0, m = mons; m; m = m->next, n++);
+-        /* only consider unique geometries as separate screens */
+-        unique = ecalloc(nn, sizeof(XineramaScreenInfo));
+-        for (i = 0, j = 0; i < nn; i++)
+-            if (isuniquegeom(unique, j, &info[i]))
+-                memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
+-        XFree(info);
+-        nn = j;
+-        if (n <= nn) { /* new monitors available */
+-            for (i = 0; i < (nn - n); i++) {
+-                for (m = mons; m && m->next; m = m->next);
+-                if (m)
+-                    m->next = createmon();
+-                else
+-                    mons = createmon();
+-            }
+-            for (i = 0, m = mons; i < nn && m; m = m->next, i++)
+-                if (i >= n
+-                        || unique[i].x_org != m->mx || unique[i].y_org != m->my
+-                        || unique[i].width != m->mw || unique[i].height != m->mh)
+-                {
+-                    dirty = 1;
+-                    m->num = i;
+-                    m->mx = m->wx = unique[i].x_org;
+-                    m->my = m->wy = unique[i].y_org;
+-                    m->mw = m->ww = unique[i].width;
+-                    m->mh = m->wh = unique[i].height;
+-                    updatebarpos(m);
+-                }
+-        } else { /* less monitors available nn < n */
+-            for (i = nn; i < n; i++) {
+-                for (m = mons; m && m->next; m = m->next);
+-                while ((c = m->clients)) {
+-                    dirty = 1;
+-                    m->clients = c->next;
+-                    detachstack(c);
+-                    c->mon = mons;
+-                    attach(c);
+-                    attachstack(c);
+-                }
+-                if (m == selmon)
+-                    selmon = mons;
+-                cleanupmon(m);
+-            }
+-        }
+-        free(unique);
+-    } else
++	if (XineramaIsActive(dpy)) {
++		int i, j, n, nn;
++		Client *c;
++		Monitor *m;
++		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
++		XineramaScreenInfo *unique = NULL;
++
++		for (n = 0, m = mons; m; m = m->next, n++);
++		/* only consider unique geometries as separate screens */
++		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
++		for (i = 0, j = 0; i < nn; i++)
++			if (isuniquegeom(unique, j, &info[i]))
++				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++		XFree(info);
++		nn = j;
++
++		/* new monitors if nn > n */
++		for (i = n; i < nn; i++) {
++			for (m = mons; m && m->next; m = m->next);
++			if (m)
++				m->next = createmon();
++			else
++				mons = createmon();
++		}
++		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
++			if (i >= n
++			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
++			|| unique[i].width != m->mw || unique[i].height != m->mh)
++			{
++				dirty = 1;
++				m->num = i;
++				m->mx = m->wx = unique[i].x_org;
++				m->my = m->wy = unique[i].y_org;
++				m->mw = m->ww = unique[i].width;
++				m->mh = m->wh = unique[i].height;
++				updatebarpos(m);
++			}
++		/* removed monitors if n > nn */
++		for (i = nn; i < n; i++) {
++			for (m = mons; m && m->next; m = m->next);
++			while ((c = m->clients)) {
++				dirty = 1;
++				m->clients = c->next;
++				detachstack(c);
++				c->mon = mons;
++				attach(c);
++				attachstack(c);
++			}
++			if (m == selmon)
++				selmon = mons;
++			cleanupmon(m);
++		}
++		free(unique);
++	} else
+ #endif /* XINERAMA */
+-    { /* default monitor setup */
+-        if (!mons)
+-            mons = createmon();
+-        if (mons->mw != sw || mons->mh != sh) {
+-            dirty = 1;
+-            mons->mw = mons->ww = sw;
+-            mons->mh = mons->wh = sh;
+-            updatebarpos(mons);
+-        }
+-    }
+-    if (dirty) {
+-        selmon = mons;
+-        selmon = wintomon(root);
+-    }
+-    return dirty;
++	{ /* default monitor setup */
++		if (!mons)
++			mons = createmon();
++		if (mons->mw != sw || mons->mh != sh) {
++			dirty = 1;
++			mons->mw = mons->ww = sw;
++			mons->mh = mons->wh = sh;
++			updatebarpos(mons);
++		}
++	}
++	if (dirty) {
++		selmon = mons;
++		selmon = wintomon(root);
++	}
++	return dirty;
+ }
+ 
+ void
+ updatenumlockmask(void)
+ {
+-    unsigned int i, j;
+-    XModifierKeymap *modmap;
++	unsigned int i, j;
++	XModifierKeymap *modmap;
+ 
+-    numlockmask = 0;
+-    modmap = XGetModifierMapping(dpy);
+-    for (i = 0; i < 8; i++)
+-        for (j = 0; j < modmap->max_keypermod; j++)
+-            if (modmap->modifiermap[i * modmap->max_keypermod + j]
+-                    == XKeysymToKeycode(dpy, XK_Num_Lock))
+-                numlockmask = (1 << i);
+-    XFreeModifiermap(modmap);
++	numlockmask = 0;
++	modmap = XGetModifierMapping(dpy);
++	for (i = 0; i < 8; i++)
++		for (j = 0; j < modmap->max_keypermod; j++)
++			if (modmap->modifiermap[i * modmap->max_keypermod + j]
++				== XKeysymToKeycode(dpy, XK_Num_Lock))
++				numlockmask = (1 << i);
++	XFreeModifiermap(modmap);
+ }
+ 
+ void
+ updatesizehints(Client *c)
+ {
+-    long msize;
+-    XSizeHints size;
+-
+-    if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
+-        /* size is uninitialized, ensure that size.flags aren't used */
+-        size.flags = PSize;
+-    if (size.flags & PBaseSize) {
+-        c->basew = size.base_width;
+-        c->baseh = size.base_height;
+-    } else if (size.flags & PMinSize) {
+-        c->basew = size.min_width;
+-        c->baseh = size.min_height;
+-    } else
+-        c->basew = c->baseh = 0;
+-    if (size.flags & PResizeInc) {
+-        c->incw = size.width_inc;
+-        c->inch = size.height_inc;
+-    } else
+-        c->incw = c->inch = 0;
+-    if (size.flags & PMaxSize) {
+-        c->maxw = size.max_width;
+-        c->maxh = size.max_height;
+-    } else
+-        c->maxw = c->maxh = 0;
+-    if (size.flags & PMinSize) {
+-        c->minw = size.min_width;
+-        c->minh = size.min_height;
+-    } else if (size.flags & PBaseSize) {
+-        c->minw = size.base_width;
+-        c->minh = size.base_height;
+-    } else
+-        c->minw = c->minh = 0;
+-    if (size.flags & PAspect) {
+-        c->mina = (float)size.min_aspect.y / size.min_aspect.x;
+-        c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
+-    } else
+-        c->maxa = c->mina = 0.0;
+-    c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
+-    c->hintsvalid = 1;
++	long msize;
++	XSizeHints size;
++
++	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
++		/* size is uninitialized, ensure that size.flags aren't used */
++		size.flags = PSize;
++	if (size.flags & PBaseSize) {
++		c->basew = size.base_width;
++		c->baseh = size.base_height;
++	} else if (size.flags & PMinSize) {
++		c->basew = size.min_width;
++		c->baseh = size.min_height;
++	} else
++		c->basew = c->baseh = 0;
++	if (size.flags & PResizeInc) {
++		c->incw = size.width_inc;
++		c->inch = size.height_inc;
++	} else
++		c->incw = c->inch = 0;
++	if (size.flags & PMaxSize) {
++		c->maxw = size.max_width;
++		c->maxh = size.max_height;
++	} else
++		c->maxw = c->maxh = 0;
++	if (size.flags & PMinSize) {
++		c->minw = size.min_width;
++		c->minh = size.min_height;
++	} else if (size.flags & PBaseSize) {
++		c->minw = size.base_width;
++		c->minh = size.base_height;
++	} else
++		c->minw = c->minh = 0;
++	if (size.flags & PAspect) {
++		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
++		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
++	} else
++		c->maxa = c->mina = 0.0;
++	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
++	c->hintsvalid = 1;
+ }
+ 
+ void
+ updatestatus(void)
+ {
+-    Monitor* m;
+-    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
+-        strcpy(stext, "dwm-"VERSION);
+-    else
+-        copyvalidchars(stext, rawstext);
+-    /* drawbar(selmon); */
+-    for(m = mons; m; m = m->next)
+-        drawbar(m);
++	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
++		strcpy(stext, "dwm-"VERSION);
++	drawbar(selmon);
+ }
+ 
+ void
+ updatetitle(Client *c)
+ {
+-    if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
+-        gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
+-    if (c->name[0] == '\0') /* hack to mark broken clients */
+-        strcpy(c->name, broken);
++	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
++		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
++	if (c->name[0] == '\0') /* hack to mark broken clients */
++		strcpy(c->name, broken);
+ }
+ 
+ void
+ updatewindowtype(Client *c)
+ {
+-    Atom state = getatomprop(c, netatom[NetWMState]);
+-    Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
++	Atom state = getatomprop(c, netatom[NetWMState]);
++	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
+ 
+-    if (state == netatom[NetWMFullscreen])
+-        setfullscreen(c, 1);
+-    if (wtype == netatom[NetWMWindowTypeDialog])
+-        c->isfloating = 1;
++	if (state == netatom[NetWMFullscreen])
++		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
++	if (wtype == netatom[NetWMWindowTypeDialog])
++		c->isfloating = 1;
+ }
+ 
+ void
+ updatewmhints(Client *c)
+ {
+-    XWMHints *wmh;
++	XWMHints *wmh;
+ 
+-    if ((wmh = XGetWMHints(dpy, c->win))) {
+-        if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+-            wmh->flags &= ~XUrgencyHint;
+-            XSetWMHints(dpy, c->win, wmh);
+-        } else
+-            c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+-        if (wmh->flags & InputHint)
+-            c->neverfocus = !wmh->input;
+-        else
+-            c->neverfocus = 0;
+-        XFree(wmh);
+-    }
++	if ((wmh = XGetWMHints(dpy, c->win))) {
++		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
++			wmh->flags &= ~XUrgencyHint;
++			XSetWMHints(dpy, c->win, wmh);
++		} else
++			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++		if (wmh->flags & InputHint)
++			c->neverfocus = !wmh->input;
++		else
++			c->neverfocus = 0;
++		XFree(wmh);
++	}
+ }
+ 
+ void
+ view(const Arg *arg)
+ {
+-    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
+-        view(&((Arg) { .ui = 0 }));
+-        return;
++    if (mons && mons->next) {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++            return;
++
++        // GENIUS 101010101
++        if ((arg->ui & 341) == 0)
++            focusnthmon(&((Arg) { .i = 1 }));
++        else
++            focusnthmon(&((Arg) { .i = 0 }));
++    } else {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
++            view(&((Arg) { .ui = 0 })); 
++            return; 
++        } 
+     }
+ 
+     selmon->seltags ^= 1; /* toggle sel tagset */
+@@ -2554,135 +2953,161 @@ view(const Arg *arg)
+ pid_t
+ winpid(Window w)
+ {
+-    pid_t result = 0;
+ 
+-    xcb_res_client_id_spec_t spec = {0};
+-    spec.client = w;
+-    spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++	pid_t result = 0;
+ 
+-    xcb_generic_error_t *e = NULL;
+-    xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+-    xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+ 
+-    if (!r)
+-        return (pid_t)0;
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+ 
+-    xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+-    for (; i.rem; xcb_res_client_id_value_next(&i)) {
+-        spec = i.data->spec;
+-        if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+-            uint32_t *t = xcb_res_client_id_value_value(i.data);
+-            result = *t;
+-            break;
+-        }
+-    }
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
+ 
+-    free(r);
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
+ 
+-    if (result == (pid_t)-1)
+-        result = 0;
+-    return result;
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
+ }
+ 
+ pid_t
+ getparentprocess(pid_t p)
+ {
+-    unsigned int v = 0;
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
+ 
+-#if defined(__linux__)
+-    FILE *f;
+-    char buf[256];
+-    snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
+ 
+-    if (!(f = fopen(buf, "r")))
+-        return (pid_t)0;
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
+ 
+-    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
+-        v = (pid_t)0;
+-    fclose(f);
+-#elif defined(__FreeBSD__)
+-    struct kinfo_proc *proc = kinfo_getproc(p);
+-    if (!proc)
+-        return (pid_t)0;
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
+ 
+-    v = proc->ki_ppid;
+-    free(proc);
+-#endif
+-    return (pid_t)v;
++	return (pid_t)v;
+ }
+ 
+ int
+ isdescprocess(pid_t p, pid_t c)
+ {
+-    while (p != c && c != 0)
+-        c = getparentprocess(c);
++	while (p != c && c != 0)
++		c = getparentprocess(c);
+ 
+-    return (int)c;
++	return (int)c;
+ }
+ 
+ Client *
+ termforwin(const Client *w)
+ {
+-    Client *c;
+-    Monitor *m;
++	Client *c;
++	Monitor *m;
+ 
+-    if (!w->pid || w->isterminal)
+-        return NULL;
++	if (!w->pid || w->isterminal)
++		return NULL;
+ 
+-    for (m = mons; m; m = m->next) {
+-        for (c = m->clients; c; c = c->next) {
+-            if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+-                return c;
+-        }
+-    }
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
+ 
+-    return NULL;
++	return NULL;
+ }
+ 
+ Client *
+ swallowingclient(Window w)
+ {
+-    Client *c;
+-    Monitor *m;
++	Client *c;
++	Monitor *m;
+ 
+-    for (m = mons; m; m = m->next) {
+-        for (c = m->clients; c; c = c->next) {
+-            if (c->swallowing && c->swallowing->win == w)
+-                return c;
+-        }
+-    }
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
+ 
+-    return NULL;
++	return NULL;
+ }
+ 
+ Client *
+ wintoclient(Window w)
+ {
+-    Client *c;
+-    Monitor *m;
++	Client *c;
++	Monitor *m;
+ 
+-    for (m = mons; m; m = m->next)
+-        for (c = m->clients; c; c = c->next)
+-            if (c->win == w)
+-                return c;
+-    return NULL;
++	for (m = mons; m; m = m->next)
++		for (c = m->clients; c; c = c->next)
++			if (c->win == w)
++				return c;
++	return NULL;
+ }
+ 
+ Monitor *
+ wintomon(Window w)
+ {
+-    int x, y;
+-    Client *c;
+-    Monitor *m;
++	int x, y;
++	Client *c;
++	Monitor *m;
+ 
+-    if (w == root && getrootptr(&x, &y))
+-        return recttomon(x, y, 1, 1);
+-    for (m = mons; m; m = m->next)
+-        if (w == m->barwin)
+-            return m;
+-    if ((c = wintoclient(w)))
+-        return c->mon;
+-    return selmon;
++	if (w == root && getrootptr(&x, &y))
++		return recttomon(x, y, 1, 1);
++	for (m = mons; m; m = m->next)
++		if (w == m->barwin)
++			return m;
++	if ((c = wintoclient(w)))
++		return c->mon;
++	return selmon;
+ }
+ 
+ /* There's no way to check accesses to destroyed windows, thus those cases are
+@@ -2691,25 +3116,25 @@ wintomon(Window w)
+ int
+ xerror(Display *dpy, XErrorEvent *ee)
+ {
+-    if (ee->error_code == BadWindow
+-            || (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
+-            || (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
+-            || (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
+-            || (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
+-            || (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
+-            || (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
+-            || (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
+-            || (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
+-        return 0;
+-    fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
+-            ee->request_code, ee->error_code);
+-    return xerrorxlib(dpy, ee); /* may call exit */
++	if (ee->error_code == BadWindow
++	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
++	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
++	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
++	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
++	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
++		return 0;
++	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
++		ee->request_code, ee->error_code);
++	return xerrorxlib(dpy, ee); /* may call exit */
+ }
+ 
+ int
+ xerrordummy(Display *dpy, XErrorEvent *ee)
+ {
+-    return 0;
++	return 0;
+ }
+ 
+ /* Startup Error handler to check if another window manager
+@@ -2717,107 +3142,103 @@ xerrordummy(Display *dpy, XErrorEvent *ee)
+ int
+ xerrorstart(Display *dpy, XErrorEvent *ee)
+ {
+-    die("dwm: another window manager is already running");
+-    return -1;
++	die("dwm: another window manager is already running");
++	return -1;
+ }
+ 
+ void
+ zoom(const Arg *arg)
+ {
+-    Client *c = selmon->sel;
++	Client *c = selmon->sel;
+ 
+-    if (!selmon->lt[selmon->sellt]->arrange
+-            || (selmon->sel && selmon->sel->isfloating))
+-        return;
+-    if (c == nexttiled(selmon->clients))
+-        if (!c || !(c = nexttiled(c->next)))
+-            return;
+-    pop(c);
++	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
++		return;
++	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
++		return;
++	pop(c);
+ }
+ 
+ void
+ resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+ {
+-    char *sdst = NULL;
+-    int *idst = NULL;
+-    float *fdst = NULL;
+-
+-    sdst = dst;
+-    idst = dst;
+-    fdst = dst;
+-
+-    char fullname[256];
+-    char *type;
+-    XrmValue ret;
+-
+-    snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+-    fullname[sizeof(fullname) - 1] = '\0';
+-
+-    XrmGetResource(db, fullname, "*", &type, &ret);
+-    if (!(ret.addr == NULL || strncmp("String", type, 64)))
+-    {
+-        switch (rtype) {
+-            case STRING:
+-                strcpy(sdst, ret.addr);
+-                break;
+-            case INTEGER:
+-                *idst = strtoul(ret.addr, NULL, 10);
+-                break;
+-            case FLOAT:
+-                *fdst = strtof(ret.addr, NULL);
+-                break;
+-        }
+-    }
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
+ }
+ 
+ void
+ load_xresources(void)
+ {
+-    Display *display;
+-    char *resm;
+-    XrmDatabase db;
+-    ResourcePref *p;
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
+ 
+-    display = XOpenDisplay(NULL);
+-    resm = XResourceManagerString(display);
+-    if (!resm)
+-        return;
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
+ 
+-    db = XrmGetStringDatabase(resm);
+-    for (p = resources; p < resources + LENGTH(resources); p++)
+-        resource_load(db, p->name, p->type, p->dst);
+-    XCloseDisplay(display);
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
+ }
+ 
+ int
+ main(int argc, char *argv[])
+ {
+-    if (argc == 2 && !strcmp("-v", argv[1]))
+-        die("dwm-"VERSION);
+-    else if (argc != 1)
+-        die("usage: dwm [-v]");
+-    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+-        fputs("warning: no locale support\n", stderr);
+-    if (!(dpy = XOpenDisplay(NULL)))
+-        die("dwm: cannot open display");
+-    if (!(xcon = XGetXCBConnection(dpy)))
+-        die("dwm: cannot get xcb connection\n");
+-    checkotherwm();
+-    XrmInitialize();
+-    load_xresources();
+-    setup();
++	if (argc == 2 && !strcmp("-v", argv[1]))
++		die("dwm-"VERSION);
++	else if (argc != 1)
++		die("usage: dwm [-v]");
++	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
++		fputs("warning: no locale support\n", stderr);
++	if (!(dpy = XOpenDisplay(NULL)))
++		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
++	checkotherwm();
++	XrmInitialize();
++	load_xresources();
++	setup();
+ #ifdef __OpenBSD__
+-    if (pledge("stdio rpath proc exec", NULL) == -1)
+-        die("pledge");
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++		die("pledge");
+ #endif /* __OpenBSD__ */
+-    scan();
+-    runAutostart();
+-    /* runautostart(); */
+-    enablegaps = 1;
++	scan();
++	runautostart();
+     arrange(selmon);
+-    run();
+-    if(restart) execvp(argv[0], argv);
+-    cleanup();
+-    XCloseDisplay(dpy);
+-    return EXIT_SUCCESS;
++	run();
++	cleanup();
++	XCloseDisplay(dpy);
++	return EXIT_SUCCESS;
+ }
++
+diff --git a/dwm.png b/dwm.png
+new file mode 100644
+index 0000000..b1f9ba7
+Binary files /dev/null and b/dwm.png differ
+diff --git a/shiftview.c b/shiftview.c
+deleted file mode 100644
+index 7905a6d..0000000
+--- a/shiftview.c
++++ /dev/null
+@@ -1,64 +0,0 @@
+-/** Function to shift the current view to the left/right
+- *
+- * @param: "arg->i" stores the number of tags to shift right (positive value)
+- *          or left (negative value)
+- */
+-void
+-shiftview(const Arg *arg)
+-{
+-    Arg shifted;
+-    Client *c;
+-    unsigned int tagmask = 0;
+-
+-    for (c = selmon->clients; c; c = c->next)
+-        if (!(c->tags & SPTAGMASK))
+-            tagmask = tagmask | c->tags;
+-
+-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+-    if (arg->i > 0) /* left circular shift */
+-        do {
+-            shifted.ui = (shifted.ui << arg->i)
+-                | (shifted.ui >> (LENGTH(tags) - arg->i));
+-            shifted.ui &= ~SPTAGMASK;
+-        } while (tagmask && !(shifted.ui & tagmask));
+-    else /* right circular shift */
+-        do {
+-            shifted.ui = (shifted.ui >> (- arg->i)
+-                    | shifted.ui << (LENGTH(tags) + arg->i));
+-            shifted.ui &= ~SPTAGMASK;
+-        } while (tagmask && !(shifted.ui & tagmask));
+-
+-    view(&shifted);
+-}
+-
+-void
+-shifttag(const Arg *arg)
+-{
+-    Arg a;
+-    Client *c;
+-    unsigned visible = 0;
+-    int i = arg->i;
+-    int count = 0;
+-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
+-
+-    do {
+-        if(i > 0) // left circular shift
+-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
+-
+-        else // right circular shift
+-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
+-
+-        // Check if tag is visible
+-        for (c = selmon->clients; c && !visible; c = c->next)
+-            if (nextseltags & c->tags) {
+-                visible = 1;
+-                break;
+-            }
+-        i += arg->i;
+-    } while (!visible && ++count < 10);
+-
+-    if (count < 10) {
+-        a.i = nextseltags;
+-        tag(&a);
+-    }
+-}
+diff --git a/test.c b/test.c
+deleted file mode 100644
+index 50e4cba..0000000
+--- a/test.c
++++ /dev/null
+@@ -1,37 +0,0 @@
+-#include <stdio.h>
+-#include <string.h>
+-
+-int
+-main()
+-{
+-    char s[1000];
+-    int i, alphabets=0, digits=0, specialchars=0;
+-    /* printf("Enter string"); */
+-    /* gets(s); */
+-
+-    FILE *ptr;
+-    char ch;
+-    ptr = fopen("/home/jonas/test.txt", "r");
+-    if (ptr == NULL) printf("Fail...");
+-    do{
+-        ch = fgetc(ptr);
+-        /* printf("%c", ch); */
+-        /* printf("%c %d \n", ch, ch); */
+-        printf("%d\n", ch);
+-        /* printf("%d", ch); */
+-    } while (ch != EOF);
+-    fclose(ptr);
+-
+-    /* for(int i = 0;s[i]; i++){ */
+-    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
+-    /*         alphabets++; */
+-    /*     else if (s[i]>48 && s[i] <=57) digits++; */
+-    /*     else specialchars++; */
+-
+-    /* } */
+-    /* printf("Alphas = %d}n", alphabets); */
+-    /* printf("Digits = %d\n", digits); */
+-    /* printf("Spec chars = %d", specialchars); */
+-
+-    return 0;
+-}
+diff --git a/transient.c b/transient.c
+index 802b66a..040adb5 100644
+--- a/transient.c
++++ b/transient.c
+@@ -6,37 +6,37 @@
+ #include <X11/Xutil.h>
+ 
+ int main(void) {
+-    Display *d;
+-    Window r, f, t = None;
+-    XSizeHints h;
+-    XEvent e;
++	Display *d;
++	Window r, f, t = None;
++	XSizeHints h;
++	XEvent e;
+ 
+-    d = XOpenDisplay(NULL);
+-    if (!d)
+-        exit(1);
+-    r = DefaultRootWindow(d);
++	d = XOpenDisplay(NULL);
++	if (!d)
++		exit(1);
++	r = DefaultRootWindow(d);
+ 
+-    f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
+-    h.min_width = h.max_width = h.min_height = h.max_height = 400;
+-    h.flags = PMinSize | PMaxSize;
+-    XSetWMNormalHints(d, f, &h);
+-    XStoreName(d, f, "floating");
+-    XMapWindow(d, f);
++	f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
++	h.min_width = h.max_width = h.min_height = h.max_height = 400;
++	h.flags = PMinSize | PMaxSize;
++	XSetWMNormalHints(d, f, &h);
++	XStoreName(d, f, "floating");
++	XMapWindow(d, f);
+ 
+-    XSelectInput(d, f, ExposureMask);
+-    while (1) {
+-        XNextEvent(d, &e);
++	XSelectInput(d, f, ExposureMask);
++	while (1) {
++		XNextEvent(d, &e);
+ 
+-        if (t == None) {
+-            sleep(5);
+-            t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
+-            XSetTransientForHint(d, t, f);
+-            XStoreName(d, t, "transient");
+-            XMapWindow(d, t);
+-            XSelectInput(d, t, ExposureMask);
+-        }
+-    }
++		if (t == None) {
++			sleep(5);
++			t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
++			XSetTransientForHint(d, t, f);
++			XStoreName(d, t, "transient");
++			XMapWindow(d, t);
++			XSelectInput(d, t, ExposureMask);
++		}
++	}
+ 
+-    XCloseDisplay(d);
+-    exit(0);
++	XCloseDisplay(d);
++	exit(0);
+ }
+diff --git a/util.c b/util.c
+index c8b1dcd..8e26a51 100644
+--- a/util.c
++++ b/util.c
+@@ -7,29 +7,31 @@
+ 
+ #include "util.h"
+ 
+-void *
+-ecalloc(size_t nmemb, size_t size)
++void
++die(const char *fmt, ...)
+ {
+-    void *p;
+-
+-    if (!(p = calloc(nmemb, size)))
+-        die("calloc:");
+-    return p;
+-}
+-
+-void die(const char *fmt, ...) {
+-    va_list ap;
++	va_list ap;
+ 	int saved_errno;
+ 
+ 	saved_errno = errno;
+ 
+-    va_start(ap, fmt);
+-    vfprintf(stderr, fmt, ap);
+-    va_end(ap);
++	va_start(ap, fmt);
++	vfprintf(stderr, fmt, ap);
++	va_end(ap);
+ 
+ 	if (fmt[0] && fmt[strlen(fmt)-1] == ':')
+ 		fprintf(stderr, " %s", strerror(saved_errno));
+ 	fputc('\n', stderr);
+ 
+-    exit(1);
++	exit(1);
++}
++
++void *
++ecalloc(size_t nmemb, size_t size)
++{
++	void *p;
++
++	if (!(p = calloc(nmemb, size)))
++		die("calloc:");
++	return p;
+ }
+diff --git a/vanitygaps.c b/vanitygaps.c
+index 7b64fd2..5acce38 100644
+--- a/vanitygaps.c
++++ b/vanitygaps.c
+@@ -1,53 +1,60 @@
+ /* Key binding functions */
+ static void defaultgaps(const Arg *arg);
+ static void incrgaps(const Arg *arg);
+-/* static void incrigaps(const Arg *arg); */
+-/* static void incrogaps(const Arg *arg); */
+-/* static void incrohgaps(const Arg *arg); */
+-/* static void incrovgaps(const Arg *arg); */
+-/* static void incrihgaps(const Arg *arg); */
+-/* static void incrivgaps(const Arg *arg); */
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
+ static void togglegaps(const Arg *arg);
+ static void togglebgaps(const Arg *arg);
+-
+-/* Layouts */
++/* Layouts (delete the ones you do not need) */
+ static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
+ static void centeredmaster(Monitor *m);
+ static void centeredfloatingmaster(Monitor *m);
+ static void deck(Monitor *m);
+ static void dwindle(Monitor *m);
+ static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
+ static void spiral(Monitor *m);
+ static void tile(Monitor *m);
+-
+ /* Internals */
+ static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+ static void setgaps(int oh, int ov, int ih, int iv);
+ 
+ /* Settings */
++#if !PERTAG_PATCH
+ static int enablegaps = 1;
++#endif // PERTAG_PATCH
+ 
+-static void
++void
+ setgaps(int oh, int ov, int ih, int iv)
+ {
+-    if (oh < 0) oh = 0;
+-    if (ov < 0) ov = 0;
+-    if (ih < 0) ih = 0;
+-    if (iv < 0) iv = 0;
+-
+-    selmon->gappoh = oh;
+-    selmon->gappov = ov;
+-    selmon->gappih = ih;
+-    selmon->gappiv = iv;
+-    arrange(selmon);
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
+ }
+ 
+-static void
++void
+ togglegaps(const Arg *arg)
+ {
+-    enablegaps = !enablegaps;
+-    /* arrange(NULL); */
+-    arrange(selmon);
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
+ }
+ 
+ static void
+@@ -57,135 +64,143 @@ togglebgaps(const Arg *arg)
+     arrange(NULL);
+ }
+ 
+-static void
++void
+ defaultgaps(const Arg *arg)
+ {
+-    setgaps(gappoh, gappov, gappih, gappiv);
++	setgaps(gappoh, gappov, gappih, gappiv);
+ }
+ 
+-static void
++void
+ incrgaps(const Arg *arg)
+ {
+-    setgaps(
+-            selmon->gappoh + arg->i,
+-            selmon->gappov + arg->i,
+-            selmon->gappih + arg->i,
+-            selmon->gappiv + arg->i
+-           );
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
+ }
+ 
+-/* static void */
+-/* incrigaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh, */
+-/* 		selmon->gappov, */
+-/* 		selmon->gappih + arg->i, */
+-/* 		selmon->gappiv + arg->i */
+-/* 	); */
+-/* } */
+-
+-/* static void */
+-/* incrogaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh + arg->i, */
+-/* 		selmon->gappov + arg->i, */
+-/* 		selmon->gappih, */
+-/* 		selmon->gappiv */
+-/* 	); */
+-/* } */
+-
+-/* static void */
+-/* incrohgaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh + arg->i, */
+-/* 		selmon->gappov, */
+-/* 		selmon->gappih, */
+-/* 		selmon->gappiv */
+-/* 	); */
+-/* } */
+-
+-/* static void */
+-/* incrovgaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh, */
+-/* 		selmon->gappov + arg->i, */
+-/* 		selmon->gappih, */
+-/* 		selmon->gappiv */
+-/* 	); */
+-/* } */
+-
+-/* static void */
+-/* incrihgaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh, */
+-/* 		selmon->gappov, */
+-/* 		selmon->gappih + arg->i, */
+-/* 		selmon->gappiv */
+-/* 	); */
+-/* } */
+-
+-/* static void */
+-/* incrivgaps(const Arg *arg) */
+-/* { */
+-/* 	setgaps( */
+-/* 		selmon->gappoh, */
+-/* 		selmon->gappov, */
+-/* 		selmon->gappih, */
+-/* 		selmon->gappiv + arg->i */
+-/* 	); */
+-/* } */
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
+ 
+-static void
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
+ getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+ {
+-    unsigned int n, oe, ie;
+-    oe = ie = enablegaps;
+-    Client *c;
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
+ 
+-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-    /* if (smartgaps && n == 1) { */
+     if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+         oe = 0; // outer gaps disabled when only one client (and it's Firefox)
++        if (TAGMASK == (1 << 8)){
++            setgaps(gappoh, gappov, gappih, gappiv);
++        }
+     }
+ 
+-    if (TAGMASK == (1 << 8)){
+-        setgaps(gappoh, gappov, gappih, gappiv);
+-    }
+-
+-    *oh = m->gappoh*oe; // outer horizontal gap
+-    *ov = m->gappov*oe; // outer vertical gap
+-    *ih = m->gappih*ie; // inner horizontal gap
+-    *iv = m->gappiv*ie; // inner vertical gap
+-    *nc = n;            // number of clients
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
+ }
+ 
+ void
+ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+ {
+-    unsigned int n;
+-    float mfacts, sfacts;
+-    int mtotal = 0, stotal = 0;
+-    Client *c;
+-
+-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-    mfacts = MIN(n, m->nmaster);
+-    sfacts = n - m->nmaster;
+-
+-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+-        if (n < m->nmaster)
+-            mtotal += msize / mfacts;
+-        else
+-            stotal += ssize / sfacts;
+-
+-    *mf = mfacts; // total factor of master area
+-    *sf = sfacts; // total factor of stack area
+-    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
+-    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+ }
+ 
+ /***
+@@ -196,360 +211,627 @@ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *s
+  * Bottomstack layout + gaps
+  * https://dwm.suckless.org/patches/bottomstack/
+  */
+-
+ static void
+ bstack(Monitor *m)
+ {
+-    unsigned int i, n;
+-    int mx = 0, my = 0, mh = 0, mw = 0;
+-    int sx = 0, sy = 0, sh = 0, sw = 0;
+-    float mfacts, sfacts;
+-    int mrest, srest;
+-    Client *c;
+-
+-    int oh, ov, ih, iv;
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    sx = mx = m->wx + ov;
+-    sy = my = m->wy + oh;
+-    sh = mh = m->wh - 2*oh;
+-    mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+-    sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+-
+-    if (m->nmaster && n > m->nmaster) {
+-        sh = (mh - ih) * (1 - m->mfact);
+-        mh = (mh - ih) * m->mfact;
+-        sx = mx;
+-        sy = my + mh + ih;
+-    }
+-
+-    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
+ 
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+-        if (i < m->nmaster) {
+-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+-            mx += WIDTH(c) + iv;
+-        } else {
+-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+-            sx += WIDTH(c) + iv;
+-        }
+-    }
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
+ }
+ 
+ /*
+  * Centred master layout + gaps
+  * https://dwm.suckless.org/patches/centeredmaster/
+  */
+-
+ void
+ centeredmaster(Monitor *m)
+ {
+-    unsigned int i, n;
+-    int mx = 0, my = 0, mh = 0, mw = 0;
+-    int lx = 0, ly = 0, lw = 0, lh = 0;
+-    int rx = 0, ry = 0, rw = 0, rh = 0;
+-    float mfacts = 0, lfacts = 0, rfacts = 0;
+-    int mtotal = 0, ltotal = 0, rtotal = 0;
+-    int mrest = 0, lrest = 0, rrest = 0;
+-    Client *c;
+-
+-    int oh, ov, ih, iv;
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    /* initialize areas */
+-    mx = m->wx + ov;
+-    my = m->wy + oh;
+-    mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+-    mw = m->ww - 2*ov;
+-    lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+-    rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+-
+-    if (m->nmaster && n > m->nmaster) {
+-        /* go mfact box in the center if more than nmaster clients */
+-        if (n - m->nmaster > 1) {
+-            /* ||<-S->|<---M--->|<-S->|| */
+-            mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+-            lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+-            mx += lw + iv;
+-        } else {
+-            /* ||<---M--->|<-S->|| */
+-            mw = (mw - iv) * m->mfact;
+-            lw = m->ww - mw - iv - 2*ov;
+-        }
+-        rw = lw;
+-        lx = m->wx + ov;
+-        ly = m->wy + oh;
+-        rx = mx + mw + iv;
+-        ry = m->wy + oh;
+-    }
+-
+-    /* calculate facts */
+-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+-        if (!m->nmaster || n < m->nmaster)
+-            mfacts += 1;
+-        else if ((n - m->nmaster) % 2)
+-            lfacts += 1; // total factor of left hand stack area
+-        else
+-            rfacts += 1; // total factor of right hand stack area
+-    }
+-
+-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+-        if (!m->nmaster || n < m->nmaster)
+-            mtotal += mh / mfacts;
+-        else if ((n - m->nmaster) % 2)
+-            ltotal += lh / lfacts;
+-        else
+-            rtotal += rh / rfacts;
+-
+-    mrest = mh - mtotal;
+-    lrest = lh - ltotal;
+-    rrest = rh - rtotal;
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+-        if (!m->nmaster || i < m->nmaster) {
+-            /* nmaster clients are stacked vertically, in the center of the screen */
+-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+-            my += HEIGHT(c) + ih;
+-        } else {
+-            /* stack clients are stacked vertically */
+-            if ((i - m->nmaster) % 2 ) {
+-                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+-                ly += HEIGHT(c) + ih;
+-            } else {
+-                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+-                ry += HEIGHT(c) + ih;
+-            }
+-        }
+-    }
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
+ }
+ 
+ void
+ centeredfloatingmaster(Monitor *m)
+ {
+-    unsigned int i, n;
+-    float mfacts, sfacts;
+-    int mrest, srest;
+-    int mx = 0, my = 0, mh = 0, mw = 0;
+-    int sx = 0, sy = 0, sh = 0, sw = 0;
+-    Client *c;
+-
+-    float mivf = 1.0; // master inner vertical gap factor
+-    int oh, ov, ih, iv;
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    sx = mx = m->wx + ov;
+-    sy = my = m->wy + oh;
+-    sh = mh = m->wh - 2*oh;
+-    mw = m->ww - 2*ov - iv*(n - 1);
+-    sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+-
+-    if (m->nmaster && n > m->nmaster) {
+-        mivf = 0.8;
+-        /* go mfact box in the center if more than nmaster clients */
+-        if (m->ww > m->wh) {
+-            mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+-            mh = m->wh * 0.9 - 2*oh;
+-        } else {
+-            mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+-            mh = m->wh * m->mfact;
+-        }
+-        mx = m->wx + (m->ww - mw) / 2;
+-        my = m->wy + (m->wh - mh) / 2;
+-
+-        sx = m->wx + ov;
+-        sy = m->wy + oh;
+-        sh = m->wh - 2*oh;
+-    }
+-
+-    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-        if (i < m->nmaster) {
+-            /* nmaster clients are stacked horizontally, in the center of the screen */
+-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+-            mx += WIDTH(c) + iv*mivf;
+-        } else {
+-            /* stack clients are stacked horizontally */
+-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+-            sx += WIDTH(c) + iv;
+-        }
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
+ }
+ 
+ /*
+  * Deck layout + gaps
+  * https://dwm.suckless.org/patches/deck/
+  */
+-
+-static void
++void
+ deck(Monitor *m)
+ {
+-    unsigned int i, n;
+-    int mx = 0, my = 0, mh = 0, mw = 0;
+-    int sx = 0, sy = 0, sh = 0, sw = 0;
+-    float mfacts, sfacts;
+-    int mrest, srest;
+-    Client *c;
+-
+-    int oh, ov, ih, iv;
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    sx = mx = m->wx + ov;
+-    sy = my = m->wy + oh;
+-    sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+-    sw = mw = m->ww - 2*ov;
+-
+-    if (m->nmaster && n > m->nmaster) {
+-        sw = (mw - iv) * (1 - m->mfact);
+-        mw = (mw - iv) * m->mfact;
+-        sx = mx + mw + iv;
+-        sh = m->wh - 2*oh;
+-    }
+-
+-    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+-
+-    if (n - m->nmaster > 0) /* override layout symbol */
+-        snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-        if (i < m->nmaster) {
+-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+-            my += HEIGHT(c) + ih;
+-        } else {
+-            resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+-        }
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
+ }
+ 
+ /*
+  * Fibonacci layout + gaps
+  * https://dwm.suckless.org/patches/fibonacci/
+  */
+-
+-static void
++void
+ fibonacci(Monitor *m, int s)
+ {
+-    unsigned int i, n;
+-    int nx, ny, nw, nh;
+-    int oh, ov, ih, iv;
+-    Client *c;
+-
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    nx = m->wx + ov;
+-    ny = oh;
+-    nw = m->ww - 2*ov;
+-    nh = m->wh - 2*oh;
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+-        if ((i % 2 && nh / 2 > 2*c->bw)
+-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
+-            if (i < n - 1) {
+-                if (i % 2)
+-                    nh = (nh - ih) / 2;
+-                else
+-                    nw = (nw - iv) / 2;
+-
+-                if ((i % 4) == 2 && !s)
+-                    nx += nw + iv;
+-                else if ((i % 4) == 3 && !s)
+-                    ny += nh + ih;
+-            }
+-            if ((i % 4) == 0) {
+-                if (s)
+-                    ny += nh + ih;
+-                else
+-                    ny -= nh + ih;
+-            }
+-            else if ((i % 4) == 1)
+-                nx += nw + iv;
+-            else if ((i % 4) == 2)
+-                ny += nh + ih;
+-            else if ((i % 4) == 3) {
+-                if (s)
+-                    nx += nw + iv;
+-                else
+-                    nx -= nw + iv;
+-            }
+-            if (i == 0)	{
+-                if (n != 1)
+-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+-                ny = m->wy + oh;
+-            }
+-            else if (i == 1)
+-                nw = m->ww - nw - iv - 2*ov;
+-            i++;
+-        }
+-
+-        resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+-    }
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
+ }
+ 
+-static void
++void
+ dwindle(Monitor *m)
+ {
+-    fibonacci(m, 1);
++	fibonacci(m, 1);
+ }
+ 
+-static void
++void
+ spiral(Monitor *m)
+ {
+-    fibonacci(m, 0);
++	fibonacci(m, 0);
+ }
+ 
+ /*
+- * Default tile layout + gaps
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
+  */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
+ 
++/*
++ * Default tile layout + gaps
++ */
+ static void
+ tile(Monitor *m)
+ {
+-    unsigned int i, n;
+-    int mx = 0, my = 0, mh = 0, mw = 0;
+-    int sx = 0, sy = 0, sh = 0, sw = 0;
+-    float mfacts, sfacts;
+-    int mrest, srest;
+-    Client *c;
+-
+-    int oh, ov, ih, iv;
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    sx = mx = m->wx + ov;
+-    sy = my = m->wy + oh;
+-    mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+-    sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+-    sw = mw = m->ww - 2*ov;
+-
+-    if (m->nmaster && n > m->nmaster) {
+-        sw = (mw - iv) * (1 - m->mfact);
+-        mw = (mw - iv) * m->mfact;
+-        sx = mx + mw + iv;
+-    }
+-
+-    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-        if (i < m->nmaster) {
+-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+-            my += HEIGHT(c) + ih;
+-        } else {
+-            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+-            sy += HEIGHT(c) + ih;
+-        }
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
+ }
diff --git a/diff_new.diff b/diff_new.diff
new file mode 100644
index 0000000..cb3c126
--- /dev/null
+++ b/diff_new.diff
@@ -0,0 +1,1157 @@
+diff --git a/README b/README
+index 482b545..95d4fd0 100644
+--- a/README
++++ b/README
+@@ -1,13 +1,5 @@
+-See patches in dir 'patches'.
+-
+-I also continously add fixes from suckless git log:
+-https://git.suckless.org/
+-https://dwm.suckless.org/
+-
+-============================
+ dwm - dynamic window manager
+ ============================
+-
+ dwm is an extremely fast, small, and dynamic window manager for X.
+ 
+ 
+diff --git a/config.h b/config.h
+index 3d14213..4613e1b 100644
+--- a/config.h
++++ b/config.h
+@@ -28,6 +28,7 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
+ static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
+ static int showbar              = 1;        /* 0 means no bar */
+ static int topbar               = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
+ /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+ static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
+@@ -163,7 +164,6 @@ ResourcePref resources[] = {
+ };
+ 
+ #include <X11/XF86keysym.h>
+-#include "shiftview.c"
+ 
+ static const Key keys[] = {
+     /*  modifier                    key                 function            argument */
+@@ -209,12 +209,12 @@ static const Key keys[] = {
+         { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+         { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+         { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+-        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
+-        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
++        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
++        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         { MODKEY,                   XK_q,               killclient,         {0} },
+-        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
++        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
+         { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+         { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+         { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+diff --git a/dwm.c b/dwm.c
+index 1ce4a38..c072985 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -62,8 +62,8 @@
+ #define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define PREVSEL                 3000
+-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+@@ -111,7 +111,7 @@ struct Client {
+ 	int bw, oldbw;
+ 	unsigned int tags;
+     int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+-	pid_t pid;
++    pid_t pid;
+ 	Client *next;
+ 	Client *snext;
+     Client *swallowing;
+@@ -200,6 +200,7 @@ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
++static Monitor *numtomon(int num);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+@@ -207,6 +208,7 @@ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
++static void focusnthmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+@@ -248,6 +250,14 @@ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shifttag(const Arg *arg);
++static void shifttagclients(const Arg *arg);
++static void shiftview(const Arg *arg);
++static void shiftviewclients(const Arg *arg);
++static void shiftboth(const Arg *arg);
++static void swaptags(const Arg *arg);
++static void shiftswaptags(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+@@ -256,7 +266,12 @@ static void tag(const Arg *arg);
+ static void tagview(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tagmonview(const Arg *arg);
++static void tagnextmon(const Arg *arg);
++static void tagnewmon(const Arg *arg);
++static void tagnthmon(const Arg *arg);
++static void tagnthmonview(const Arg *arg);
+ static void togglebar(const Arg *arg);
++static void togglebars(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglescratch(const Arg *arg);
+ static void togglesticky(const Arg *arg);
+@@ -545,9 +560,8 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	//if ((m = wintomon(ev->window)) && m != selmon
+-	//    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+-    if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+@@ -566,12 +580,12 @@ buttonpress(XEvent *e)
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+-		} //else if (ev->x < x + TEXTW(selmon->ltsymbol))
+-			//click = ClkLtSymbol;
+-		//else
+-		else if (ev->x > selmon->ww - statusw) {
+-			x = selmon->ww - statusw;
+-			click = ClkStatusText;
++		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++			click = ClkLtSymbol;
++        } else if (ev->x > selmon->ww - statusw) {
++            x = selmon->ww - statusw;
++            click = ClkStatusText;
++
+ 			char *text, *s, ch;
+ 			statussig = 0;
+ 			for (text = s = stext; *s && x <= ev->x; s++) {
+@@ -595,11 +609,9 @@ buttonpress(XEvent *e)
+ 					s--;
+ 				}
+ 			}
+-		}
+ 	} else if ((c = wintoclient(ev->window))) {
+-		//if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+-		//	focus(c);
+-        focus(c);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -792,7 +804,10 @@ createmon(void)
+ 	Monitor *m;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+-	m->tagset[0] = m->tagset[1] = 1;
++    if (mons)
++        m->tagset[0] = m->tagset[1] = 2;
++    else
++        m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+@@ -858,118 +873,16 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
+-//int
+-//drawstatusbar(Monitor *m, int bh, char* stext) {
+-//	int ret, i, j, w, x, len;
+-//	short isCode = 0;
+-//	char *text;
+-//	char *p;
+-//
+-//	len = strlen(stext) + 1 ;
+-//	if (!(text = (char*) malloc(sizeof(char)*len)))
+-//		die("malloc");
+-//	p = text;
+-//
+-//	i = -1, j = 0;
+-//	while (stext[++i])
+-//		if ((unsigned char)stext[i] >= ' ')
+-//			text[j++] = stext[i];
+-//	text[j] = '\0';
+-//
+-//	/* compute width of the status text */
+-//	w = 0;
+-//	i = -1;
+-//	while (text[++i]) {
+-//		if (text[i] == '^') {
+-//			if (!isCode) {
+-//				isCode = 1;
+-//				text[i] = '\0';
+-//				w += TEXTW(text) - lrpad;
+-//				text[i] = '^';
+-//				if (text[++i] == 'f')
+-//					w += atoi(text + ++i);
+-//			} else {
+-//				isCode = 0;
+-//				text = text + i + 1;
+-//				i = -1;
+-//			}
+-//		}
+-//	}
+-//	if (!isCode)
+-//		w += TEXTW(text) - lrpad;
+-//	else
+-//		isCode = 0;
+-//	text = p;
+-//
+-//	w += 2; /* 1px padding on both sides */
+-//	ret = x = m->ww - w;
+-//
+-//	drw_setscheme(drw, scheme[LENGTH(colors)]);
+-//	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+-//	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+-//	drw_rect(drw, x, 0, w, bh, 1, 1);
+-//	x++;
+-//
+-//	/* process status text */
+-//	i = -1;
+-//	while (text[++i]) {
+-//		if (text[i] == '^' && !isCode) {
+-//			isCode = 1;
+-//
+-//			text[i] = '\0';
+-//			w = TEXTW(text) - lrpad;
+-//			drw_text(drw, x, 0, w, bh, 0, text, 0);
+-//
+-//			x += w;
+-//
+-//			/* process code */
+-//			while (text[++i] != '^') {
+-//				if (text[i] == 'c') {
+-//					char buf[8];
+-//					memcpy(buf, (char*)text+i+1, 7);
+-//					buf[7] = '\0';
+-//					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+-//					i += 7;
+-//				} else if (text[i] == 'b') {
+-//					char buf[8];
+-//					memcpy(buf, (char*)text+i+1, 7);
+-//					buf[7] = '\0';
+-//					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+-//					i += 7;
+-//				} else if (text[i] == 'd') {
+-//					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+-//					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+-//				} else if (text[i] == 'r') {
+-//					int rx = atoi(text + ++i);
+-//					while (text[++i] != ',');
+-//					int ry = atoi(text + ++i);
+-//					while (text[++i] != ',');
+-//					int rw = atoi(text + ++i);
+-//					while (text[++i] != ',');
+-//					int rh = atoi(text + ++i);
+-//
+-//					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+-//				} else if (text[i] == 'f') {
+-//					x += atoi(text + ++i);
+-//				}
+-//			}
+-//
+-//			text = text + i + 1;
+-//			i=-1;
+-//			isCode = 0;
+-//		}
+-//	}
+-//
+-//	if (!isCode) {
+-//		w = TEXTW(text) - lrpad;
+-//		drw_text(drw, x, 0, w, bh, 0, text, 0);
+-//	}
+-//
+-//	drw_setscheme(drw, scheme[SchemeNorm]);
+-//	free(p);
+-//
+-//	return ret;
+-//}
++Monitor *
++numtomon(int num)
++{
++    Monitor *m = NULL;
++    int i = 0;
++
++    for(m = mons, i=0; m->next && i < num; m = m->next)
++        i++;
++    return m;
++}
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext)
+@@ -1093,130 +1006,6 @@ drawstatusbar(Monitor *m, int bh, char* stext)
+     return ret;
+ }
+ 
+-//typedef struct {
+-//    char key;
+-//    const char *color;
+-//} ColorMapping;
+-//
+-//int is_hot_weather(const char *filepath) {
+-//    FILE *ptr = fopen(filepath, "r");
+-//    if (!ptr) {
+-//        printf("Failed to read weather report...\n");
+-//        return 0;
+-//    }
+-//
+-//    char ch;
+-//    int hot = 0;
+-//    while ((ch = fgetc(ptr)) != EOF) {
+-//        if (ch == '+') {
+-//            hot = 1;
+-//        } else if (hot && (ch == '2' || ch == '3') && fgetc(ptr) <= '9') {
+-//            fclose(ptr);
+-//            return 1; // Hot weather
+-//        } else if (ch == '-') {
+-//            fclose(ptr);
+-//            return -1; // Cold weather
+-//        }
+-//    }
+-//    fclose(ptr);
+-//    return 0; // Neutral or unknown weather
+-//}
+-//
+-//void set_color(char key, const char *weather_path, Drw *drw) {
+-//    static const ColorMapping color_map[] = {
+-//        {'3', col3}, {'4', col4}, {'5', col5}, {'6', col6}
+-//    };
+-//
+-//    if (key == '2') {
+-//        int weather_status = is_hot_weather(weather_path);
+-//        if (weather_status > 0) {
+-//            drw_clr_create(drw, &drw->scheme[ColFg], col21); // Hot
+-//        } else if (weather_status < 0) {
+-//            drw_clr_create(drw, &drw->scheme[ColFg], col23); // Cold
+-//        } else {
+-//            drw_clr_create(drw, &drw->scheme[ColFg], col24); // Neutral
+-//        }
+-//    } else {
+-//        for (size_t i = 0; i < sizeof(color_map) / sizeof(color_map[0]); i++) {
+-//            if (color_map[i].key == key) {
+-//                drw_clr_create(drw, &drw->scheme[ColFg], color_map[i].color);
+-//                return;
+-//            }
+-//        }
+-//    }
+-//}
+-//
+-//int drawstatusbar(Monitor *m, int bh, char *stext) {
+-//    int ret, i, w, x, len;
+-//    short isCode = 0;
+-//    char *text, *p;
+-//    
+-//    len = strlen(stext) + 1;
+-//    if (!(text = malloc(len))) die("malloc");
+-//    p = text;
+-//    memcpy(text, stext, len);
+-//
+-//    // Compute the width of the status text
+-//    w = 0;
+-//    for (i = 0; text[i]; i++) {
+-//        if (text[i] == '^') {
+-//            if (!isCode) {
+-//                isCode = 1;
+-//                text[i] = '\0';
+-//                w += TEXTW(text) - lrpad;
+-//                text[i] = '^';
+-//                if (text[++i] == 'f')
+-//                    w += atoi(text + ++i);
+-//            } else {
+-//                isCode = 0;
+-//                text += i + 1;
+-//                i = -1;
+-//            }
+-//        }
+-//    }
+-//    if (!isCode) w += TEXTW(text) - lrpad;
+-//
+-//    w += 2; // Padding
+-//    ret = x = m->ww - w;
+-//
+-//    drw_setscheme(drw, scheme[LENGTH(colors)]);
+-//    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+-//    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+-//    drw_rect(drw, x, 0, w, bh, 1, 1);
+-//    x++;
+-//
+-//    // Process status text
+-//    text = p;
+-//    for (i = 0; text[i]; i++) {
+-//        if (text[i] == '^' && !isCode) {
+-//            isCode = 1;
+-//
+-//            text[i] = '\0';
+-//            w = TEXTW(text) - lrpad;
+-//            drw_text(drw, x, 0, w, bh, 0, text, 0);
+-//            x += w;
+-//
+-//            while (text[++i] != '^') {
+-//                set_color(text[i], "/home/jonas/.local/share/weatherreport", drw);
+-//            }
+-//
+-//            text += i + 1;
+-//            i = -1;
+-//            isCode = 0;
+-//        }
+-//    }
+-//
+-//    if (!isCode) {
+-//        w = TEXTW(text) - lrpad;
+-//        drw_text(drw, x, 0, w, bh, 0, text, 0);
+-//    }
+-//
+-//    drw_setscheme(drw, scheme[SchemeNorm]);
+-//    free(p);
+-//
+-//    return ret;
+-//}
+-
+ void
+ drawbar(Monitor *m)
+ {
+@@ -1329,6 +1118,22 @@ focusmon(const Arg *arg)
+ 	focus(NULL);
+ }
+ 
++void
++focusnthmon(const Arg *arg)
++{
++    Monitor *m;
++
++    if (!mons->next)
++        return;
++
++    if ((m = numtomon(arg->i)) == selmon)
++        return;
++    unfocus(selmon->sel, 0);
++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++    selmon = m;
++    focus(NULL);
++}
++
+ void
+ focusstack(const Arg *arg)
+ {
+@@ -2166,6 +1971,188 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++//void
++//shiftview(const Arg *arg) {
++//	Arg shifted;
++//
++//	if(arg->i > 0) /* left circular shift */
++//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++//
++//	else /* right circular shift */
++//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++//
++//	view(&shifted);
++//}
++//
++//void
++//shifttag(const Arg *arg) {
++//	Arg shifted;
++//	Client *c;
++//
++//	if (!selmon->sel)
++//		return;
++//	c = selmon->sel;
++//
++//	if (arg->i > 0) /* left circular shift */
++//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++//			^ (c->tags >> (LENGTH(tags) - arg->i));
++//	else /* right circular shift */
++//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++//			^ (c->tags << (LENGTH(tags) + arg->i));
++//
++//	toggletag(&shifted);
++//}
++
++// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
++// Or this (used below):
++// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
++
++/* Sends a window to the next/prev tag */
++void
++shifttag(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
++	tag(&shifted);
++}
++/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
++void
++shifttagclients(const Arg *arg)
++{
++
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	tag(&shifted);
++}
++/* Navigate to the next/prev tag */
++void
++shiftview(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0) {/* left circular shift */
++		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	} else {	/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	}
++	view(&shifted);
++}
++/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
++void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	view(&shifted);
++}
++/* move the current active window to the next/prev tag and view it. More like following the window */
++void
++shiftboth(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	tag(&shifted);
++	view(&shifted);
++}
++//helper function for shiftswaptags found on:
++//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
++// modified to work with scratchpad
++void
++swaptags(const Arg *arg)
++{
++	Client *c;
++	unsigned int newtag = arg->ui & TAGMASK;
++	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
++		return;
++
++	for (c = selmon->clients; c != NULL; c = c->next) {
++		if ((c->tags & newtag) || (c->tags & curtag))
++			c->tags ^= curtag ^ newtag;
++
++		if (!c->tags)
++			c->tags = newtag;
++	}
++
++	//move to the swaped tag
++	//selmon->tagset[selmon->seltags] = newtag;
++
++	focus(NULL);
++	arrange(selmon);
++}
++/* swaps "tags" (all the clients) with the next/prev tag. */
++void
++shiftswaptags(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	swaptags(&shifted);
++	// uncomment if you also want to "go" (view) the tag where the the clients are going
++	//view(&shifted);
++}
++
+ void
+ setcfact(const Arg *arg) {
+ 	float f;
+@@ -2379,20 +2366,76 @@ stackpos(const Arg *arg) {
+ 		return arg->i;
+ }
+ 
++//void
++//tag(const Arg *arg)
++//{
++//    if (selmon->sel && arg->ui & TAGMASK) {
++//        if (mons && mons->next) {
++//            // Moving to even tag, selected mon != first mon
++//            if ((arg->ui & 341) == 0 && selmon != mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//                // Moving to odd tag, selected mon == first mon
++//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            } else {
++//                tagnextmon(arg);
++//            }
++//        } else {
++//            if (selmon->sel && arg->ui & TAGMASK) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            }
++//        }
++//    }
++//}
++
+ void
+ tag(const Arg *arg)
+ {
+-	if (selmon->sel && arg->ui & TAGMASK) {
+-		selmon->sel->tags = arg->ui & TAGMASK;
+-		focus(NULL);
+-		arrange(selmon);
+-	}
++    if (!(selmon->sel && arg->ui & TAGMASK))
++        return;
++
++    if (mons && mons->next) {
++        // Moving to even tag, selected mon != first mon
++        if ((arg->ui & 341) == 0 && selmon != mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        }
++        // Moving to odd tag, selected mon == first mon
++        else if ((arg->ui & 341) > 0 && selmon == mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        } else {
++            tagnextmon(arg);
++            return;
++        }
++    } else {
++        selmon->sel->tags = arg->ui & TAGMASK;
++    }
++
++    focus(NULL);
++    arrange(selmon);
+ }
+ 
+ void
+ tagview(const Arg *arg)
+ {
+     if (selmon->sel && arg->ui & TAGMASK) {
++        if (mons && mons->next) {
++            // If first monitor and moving to even tag (second mon)
++            if ((arg->ui & 341) == 0 && selmon == mons) {
++                tagnthmonview(&((Arg) { .i = 1 }));
++                tagnewmon(arg);
++                return;
++            } else if ((arg->ui & 341) > 0 && selmon != mons) {
++                tagnthmonview(&((Arg) { .i = 0 }));
++                tagnewmon(arg);
++                return;
++            }
++        }
+         selmon->sel->tags = arg->ui & TAGMASK;
+         focus(NULL);
+         arrange(selmon);
+@@ -2416,6 +2459,51 @@ tagmonview(const Arg *arg)
+     sendmonview(selmon->sel, dirtomon(arg->i));
+ }
+ 
++void
++tagnextmon(const Arg *arg)
++{
++    Client *sel;
++    Monitor *newmon;
++
++    if (!selmon->sel || !mons->next)
++        return;
++    sel = selmon->sel;
++    newmon = dirtomon(1);
++    sendmon(sel, newmon);
++    if (sel && arg->ui & TAGMASK) {
++        sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(newmon);
++    }
++}
++
++void
++tagnewmon(const Arg *arg)
++{
++    if (selmon->sel && arg->ui & TAGMASK) {
++        selmon->sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(selmon);
++        view(arg);
++    }
++}
++
++void
++tagnthmon(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmon(selmon->sel, numtomon(arg->i));
++}
++
++void
++tagnthmonview(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmonview(selmon->sel, numtomon(arg->i));
++}
++
+ void
+ togglebar(const Arg *arg)
+ {
+@@ -2425,6 +2513,18 @@ togglebar(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglebars(const Arg *arg)
++{
++    Monitor *m;
++    for (m = mons; m; m = m->next) {
++        m->showbar = !m->showbar;
++        updatebarpos(m);
++        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++        arrange(m);
++    }
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+@@ -2827,16 +2927,27 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
+-    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
+-        view(&((Arg) { .ui = 0 }));
+-        return;
++    if (mons && mons->next) {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++            return;
++
++        // GENIUS 101010101
++        if ((arg->ui & 341) == 0)
++            focusnthmon(&((Arg) { .i = 1 }));
++        else
++            focusnthmon(&((Arg) { .i = 0 }));
++    } else {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
++            view(&((Arg) { .ui = 0 })); 
++            return; 
++        } 
+     }
+ 
+-	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
+-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+-	focus(NULL);
+-	arrange(selmon);
++    selmon->seltags ^= 1; /* toggle sel tagset */
++    if (arg->ui & TAGMASK)
++        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++    focus(NULL);
++    arrange(selmon);
+ }
+ 
+ pid_t
+diff --git a/shiftview.c b/shiftview.c
+deleted file mode 100644
+index 7905a6d..0000000
+--- a/shiftview.c
++++ /dev/null
+@@ -1,64 +0,0 @@
+-/** Function to shift the current view to the left/right
+- *
+- * @param: "arg->i" stores the number of tags to shift right (positive value)
+- *          or left (negative value)
+- */
+-void
+-shiftview(const Arg *arg)
+-{
+-    Arg shifted;
+-    Client *c;
+-    unsigned int tagmask = 0;
+-
+-    for (c = selmon->clients; c; c = c->next)
+-        if (!(c->tags & SPTAGMASK))
+-            tagmask = tagmask | c->tags;
+-
+-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+-    if (arg->i > 0) /* left circular shift */
+-        do {
+-            shifted.ui = (shifted.ui << arg->i)
+-                | (shifted.ui >> (LENGTH(tags) - arg->i));
+-            shifted.ui &= ~SPTAGMASK;
+-        } while (tagmask && !(shifted.ui & tagmask));
+-    else /* right circular shift */
+-        do {
+-            shifted.ui = (shifted.ui >> (- arg->i)
+-                    | shifted.ui << (LENGTH(tags) + arg->i));
+-            shifted.ui &= ~SPTAGMASK;
+-        } while (tagmask && !(shifted.ui & tagmask));
+-
+-    view(&shifted);
+-}
+-
+-void
+-shifttag(const Arg *arg)
+-{
+-    Arg a;
+-    Client *c;
+-    unsigned visible = 0;
+-    int i = arg->i;
+-    int count = 0;
+-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
+-
+-    do {
+-        if(i > 0) // left circular shift
+-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
+-
+-        else // right circular shift
+-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
+-
+-        // Check if tag is visible
+-        for (c = selmon->clients; c && !visible; c = c->next)
+-            if (nextseltags & c->tags) {
+-                visible = 1;
+-                break;
+-            }
+-        i += arg->i;
+-    } while (!visible && ++count < 10);
+-
+-    if (count < 10) {
+-        a.i = nextseltags;
+-        tag(&a);
+-    }
+-}
+diff --git a/vanitygaps.c b/vanitygaps.c
+index 6f2407d..5acce38 100644
+--- a/vanitygaps.c
++++ b/vanitygaps.c
+@@ -162,6 +162,7 @@ getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+ 	if (smartgaps && n == 1) {
+ 		oe = 0; // outer gaps disabled when only one client
+ 	}
++
+     if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+         oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+         if (TAGMASK == (1 << 8)){
+@@ -484,153 +485,91 @@ deck(Monitor *m)
+  * Fibonacci layout + gaps
+  * https://dwm.suckless.org/patches/fibonacci/
+  */
+-//void
+-//fibonacci(Monitor *m, int s)
+-//{
+-//	unsigned int i, n;
+-//	int nx, ny, nw, nh;
+-//	int oh, ov, ih, iv;
+-//	int nv, hrest = 0, wrest = 0, r = 1;
+-//	Client *c;
+-//
+-//	getgaps(m, &oh, &ov, &ih, &iv, &n);
+-//	if (n == 0)
+-//		return;
+-//
+-//	nx = m->wx + ov;
+-//	ny = m->wy + oh;
+-//	nw = m->ww - 2*ov;
+-//	nh = m->wh - 2*oh;
+-//
+-//	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+-//		if (r) {
+-//			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+-//			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+-//				r = 0;
+-//			}
+-//			if (r && i < n - 1) {
+-//				if (i % 2) {
+-//					nv = (nh - ih) / 2;
+-//					hrest = nh - 2*nv - ih;
+-//					nh = nv;
+-//				} else {
+-//					nv = (nw - iv) / 2;
+-//					wrest = nw - 2*nv - iv;
+-//					nw = nv;
+-//				}
+-//
+-//				if ((i % 4) == 2 && !s)
+-//					nx += nw + iv;
+-//				else if ((i % 4) == 3 && !s)
+-//					ny += nh + ih;
+-//			}
+-//
+-//			if ((i % 4) == 0) {
+-//				if (s) {
+-//					ny += nh + ih;
+-//					nh += hrest;
+-//				}
+-//				else {
+-//					nh -= hrest;
+-//					ny -= nh + ih;
+-//				}
+-//			}
+-//			else if ((i % 4) == 1) {
+-//				nx += nw + iv;
+-//				nw += wrest;
+-//			}
+-//			else if ((i % 4) == 2) {
+-//				ny += nh + ih;
+-//				nh += hrest;
+-//				if (i < n - 1)
+-//					nw += wrest;
+-//			}
+-//			else if ((i % 4) == 3) {
+-//				if (s) {
+-//					nx += nw + iv;
+-//					nw -= wrest;
+-//				} else {
+-//					nw -= wrest;
+-//					nx -= nw + iv;
+-//					nh += hrest;
+-//				}
+-//			}
+-//			if (i == 0)	{
+-//				if (n != 1) {
+-//					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+-//					wrest = 0;
+-//				}
+-//				ny = m->wy + oh;
+-//			}
+-//			else if (i == 1)
+-//				nw = m->ww - nw - iv - 2*ov;
+-//			i++;
+-//		}
+-//
+-//		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+-//	}
+-//}
+-
+-static void
++void
+ fibonacci(Monitor *m, int s)
+ {
+-    unsigned int i, n;
+-    int nx, ny, nw, nh;
+-    int oh, ov, ih, iv;
+-    Client *c;
+-
+-    getgaps(m, &oh, &ov, &ih, &iv, &n);
+-
+-    if (n == 0)
+-        return;
+-
+-    nx = m->wx + ov;
+-    ny = oh;
+-    nw = m->ww - 2*ov;
+-    nh = m->wh - 2*oh;
+-
+-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+-        if ((i % 2 && nh / 2 > 2*c->bw)
+-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
+-            if (i < n - 1) {
+-                if (i % 2)
+-                    nh = (nh - ih) / 2;
+-                else
+-                    nw = (nw - iv) / 2;
+-
+-                if ((i % 4) == 2 && !s)
+-                    nx += nw + iv;
+-                else if ((i % 4) == 3 && !s)
+-                    ny += nh + ih;
+-            }
+-            if ((i % 4) == 0) {
+-                if (s)
+-                    ny += nh + ih;
+-                else
+-                    ny -= nh + ih;
+-            }
+-            else if ((i % 4) == 1)
+-                nx += nw + iv;
+-            else if ((i % 4) == 2)
+-                ny += nh + ih;
+-            else if ((i % 4) == 3) {
+-                if (s)
+-                    nx += nw + iv;
+-                else
+-                    nx -= nw + iv;
+-            }
+-            if (i == 0)	{
+-                if (n != 1)
+-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+-                ny = m->wy + oh;
+-            }
+-            else if (i == 1)
+-                nw = m->ww - nw - iv - 2*ov;
+-            i++;
+-        }
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
+ 
+-        resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+-    }
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
+ }
+ 
+ void
diff --git a/diff_upstream.diff b/diff_upstream.diff
new file mode 100644
index 0000000..3dea6df
--- /dev/null
+++ b/diff_upstream.diff
@@ -0,0 +1,34002 @@
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..d42c9e0
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1,54 @@
++# Prerequisites
++*.d
++
++# Object files
++*.o
++*.ko
++*.obj
++*.elf
++
++# Linker output
++*.ilk
++*.map
++*.exp
++
++# Precompiled Headers
++*.gch
++*.pch
++
++# Libraries
++*.lib
++*.a
++*.la
++*.lo
++
++# Shared objects (inc. Windows DLLs)
++*.dll
++*.so
++*.so.*
++*.dylib
++
++# Executables
++*.exe
++*.out
++*.app
++*.i*86
++*.x86_64
++*.hex
++
++# Debug files
++*.dSYM/
++*.su
++*.idb
++*.pdb
++
++# Kernel Module Compile Results
++*.mod*
++*.cmd
++.tmp_versions/
++modules.order
++Module.symvers
++Mkfile.old
++dkms.conf
++a.out
++dwm
+diff --git a/config.def.h b/config.def.h
+index 9efa774..0c94360 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -1,21 +1,44 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+-static const unsigned int snap      = 32;       /* snap pixel */
+-static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static unsigned int borderpx  = 1;        /* border pixel of windows */
++static unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
++static int showbar            = 1;        /* 0 means no bar */
++static int topbar             = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
++static char font[]            = "monospace:size=10";
++static char dmenufont[]       = "monospace:size=10";
++static const char *fonts[]          = { font };
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
++};
++
++typedef struct {
++	const char *name;
++	const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++const char *spcmd3[] = {"keepassxc", NULL };
++static Sp scratchpads[] = {
++	/* name          cmd  */
++	{"spterm",      spcmd1},
++	{"spranger",    spcmd2},
++	{"keepassxc",   spcmd3},
+ };
+ 
+ /* tagging */
+@@ -26,22 +49,39 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+-static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+@@ -51,27 +91,81 @@ static const Layout layouts[] = {
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++#define STACKKEYS(MOD,ACTION) \
++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",               STRING,  &font },
++		{ "dmenufont",          STRING,  &dmenufont },
++		{ "normbgcolor",        STRING,  &normbgcolor },
++		{ "normbordercolor",    STRING,  &normbordercolor },
++		{ "normfgcolor",        STRING,  &normfgcolor },
++		{ "selbgcolor",         STRING,  &selbgcolor },
++		{ "selbordercolor",     STRING,  &selbordercolor },
++		{ "selfgcolor",         STRING,  &selfgcolor },
++		{ "borderpx",          	INTEGER, &borderpx },
++		{ "snap",          		INTEGER, &snap },
++		{ "showbar",          	INTEGER, &showbar },
++		{ "topbar",          	INTEGER, &topbar },
++		{ "nmaster",          	INTEGER, &nmaster },
++		{ "resizehints",       	INTEGER, &resizehints },
++		{ "mfact",      	 	FLOAT,   &mfact },
++};
++
+ static const Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++	STACKKEYS(MODKEY,                          focus)
++	STACKKEYS(MODKEY|ShiftMask,                push)
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+@@ -79,12 +173,16 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+@@ -94,7 +192,8 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+ /* button definitions */
+@@ -103,11 +202,12 @@ static const Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+diff --git a/config.h b/config.h
+new file mode 100644
+index 0000000..4613e1b
+--- /dev/null
++++ b/config.h
+@@ -0,0 +1,364 @@
++/* See LICENSE file for copyright and license details. */
++
++/* Constants */
++/* #define TERMINAL "st" */
++/* #define TERMCLASS "St" */
++/* #define TERMINAL "urxvt" */
++/* #define TERMCLASS "Urxvt" */
++/* #define TERMINAL "alacritty" */
++/* #define TERMCLASS "alacritty" */
++#define TERMINAL "wezterm"
++#define TERMCLASS "wezterm"
++#define SECTERMINAL "st"
++
++#define FILES "thunar"
++//#define FILEX "ranger"
++#define FILEX "yazi"
++
++/* appearance */
++static unsigned int borderpx    = 3;        /* border pixel of windows */
++static const unsigned int gappx = 10;       /* default gap between windows in pixels */
++static unsigned int snap        = 32;       /* snap pixel */
++static unsigned int gappih      = 20;       /* horiz inner gap between windows */
++static unsigned int gappiv      = 20;       /* vert inner gap between windows */
++static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
++static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
++static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
++static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
++static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
++static int showbar              = 1;        /* 0 means no bar */
++static int topbar               = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
++/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
++/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
++static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
++//static char normbgcolor[]       = "#222222";
++static char normbgcolor[]       = "#282828";
++static char normbordercolor[]   = "#ebdbb2";
++static char normfgcolor[]       = "#ebdbb2";
++static char selfgcolor[]        = "#ebdbb2";
++static char selbordercolor[]    = "#770000";
++static char selbgcolor[]        = "#005577";
++static const char col1[]        = "#98971a";
++static const char col21[]       = "#fb4934";
++static const char col22[]       = "#ebdbb2";
++static const char col23[]       = "#458588";
++static const char col24[]       = "#ebdbb2";
++static const char col3[]        = "#fabd2f";
++static const char col4[]        = "#83a598";
++static const char col5[]        = "#d3869b";
++static const char col6[]        = "#8ec07c";
++static char *colors[][3]        = {
++    /*               fg              bg              border   */
++    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
++    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
++};
++
++typedef struct {
++    const char *name;
++    const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
++const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
++/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
++static Sp scratchpads[] = {
++    /* name          cmd  */
++    {"spterm",      spcmd1},
++    {"spcalc",      spcmd2},
++};
++
++/* tagging */
++static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
++
++static const Rule rules[] = {
++    /* xprop(1):
++     *    WM_CLASS(STRING) = instance, class
++     *    WM_NAME(STRING) = title
++     */
++    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
++    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
++    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
++    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
++    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
++    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
++    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
++    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
++    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
++    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
++};
++
++/* layout(s) */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
++
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++static const Layout layouts[] = {
++    /* symbol       arrange function */
++    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
++    { "[]=",        tile },                     /* Master on left, slaves on right */
++    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
++    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
++    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
++    { "[M]",        monocle },                  /* All windows on top of eachother */
++    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
++    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
++    { "><>",        NULL },                     /* no layout function means floating behavior */
++    { NULL,         NULL },
++};
++
++/* key definitions */
++#define MODKEY Mod4Mask
++#define MODKEY1 Mod1Mask
++#define TAGKEYS(KEY,TAG) \
++{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
++{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
++{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
++{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
++/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
++#define STACKKEYS(MOD,ACTION) \
++{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
++{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
++{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
++{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
++/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
++/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
++
++/* helper for spawning shell commands in the pre dwm-5.0 fashion */
++#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++
++#define STATUSBAR "dwmblocks"
++
++/* commands */
++static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++static const char *termcmd[]  = { TERMINAL, NULL };
++//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
++
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++    { "color0",             STRING,     &normbordercolor },
++    { "foreground",         STRING,     &selbordercolor },
++    /* { "color8",             STRING,     &selbordercolor }, */
++    { "color0",             STRING,     &normbgcolor },
++    { "foreground",         STRING,     &normfgcolor },
++    { "color0",             STRING,     &selfgcolor },
++    { "foreground",         STRING,     &selbgcolor },
++    { "borderpx",           INTEGER,    &borderpx },
++    { "snap",               INTEGER,    &snap },
++    { "showbar",            INTEGER,    &showbar },
++    { "topbar",             INTEGER,    &topbar },
++    { "nmaster",            INTEGER,    &nmaster },
++    { "resizehints",        INTEGER,    &resizehints },
++    { "mfact",              FLOAT,      &mfact },
++    { "gappih",             INTEGER,    &gappih },
++    { "gappiv",             INTEGER,    &gappiv },
++    { "gappoh",             INTEGER,    &gappoh },
++    { "gappov",             INTEGER,    &gappov },
++    { "swallowfloating",    INTEGER,    &swallowfloating },
++    { "smartgaps",          INTEGER,    &smartgaps },
++};
++
++#include <X11/XF86keysym.h>
++
++static const Key keys[] = {
++    /*  modifier                    key                 function            argument */
++        STACKKEYS(MODKEY,                               focus)
++        STACKKEYS(MODKEY|ShiftMask,                     push)
++        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
++        TAGKEYS(                    XK_1,               0)
++        TAGKEYS(                    XK_2,               1)
++        TAGKEYS(                    XK_3,               2)
++        TAGKEYS(                    XK_4,               3)
++        TAGKEYS(                    XK_5,               4)
++        TAGKEYS(                    XK_6,               5)
++        TAGKEYS(                    XK_7,               6)
++        TAGKEYS(                    XK_8,               7)
++        TAGKEYS(                    XK_9,               8)
++        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
++        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
++
++        /* Layouts */
++        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
++        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
++        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
++        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
++        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
++        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
++        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
++        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
++        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
++        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
++        { MODKEY,                   XK_f,               togglefullscr,      {0} },
++        { MODKEY,                   XK_space,           togglefloating,     {0} },
++        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
++        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
++        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
++        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
++        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
++        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
++        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
++        { MODKEY,                   XK_x,               defaultgaps,        {0} },
++        { MODKEY,                   XK_z,               togglegaps,         {0} },
++        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
++        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
++        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
++        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
++        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
++        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
++        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
++        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++        { MODKEY,                   XK_q,               killclient,         {0} },
++        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
++        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
++        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
++        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
++        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
++        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
++        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
++        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
++        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
++        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
++        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
++        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
++        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
++        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
++        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
++        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
++
++        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
++        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
++        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
++        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
++        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
++        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
++        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
++        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
++        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
++        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
++        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
++        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
++        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
++        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
++        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
++        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
++        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
++        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
++        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
++        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
++        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
++        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/files_wd.sh") },
++        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
++        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
++        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
++        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
++        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
++        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
++        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
++        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
++        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
++        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
++        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
++        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
++        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
++        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
++        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
++        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
++        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
++        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
++        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
++        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
++        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
++
++        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
++        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
++        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
++        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
++        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
++        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
++        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
++        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
++        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
++        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
++
++        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
++        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
++        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
++        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
++        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
++        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
++        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
++        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
++        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
++        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
++        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
++        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
++        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
++        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
++        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
++        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
++
++        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
++        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
++        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
++        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
++        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
++        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
++        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
++        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
++        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
++        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
++        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
++        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
++        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
++        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
++        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
++        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
++        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
++        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
++        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
++        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
++        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
++        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
++        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
++        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
++        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
++        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
++        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
++        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
++        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
++};
++
++#define STATUSBAR "dwmblocks"
++
++/* button definitions */
++/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
++static const Button buttons[] = {
++    /* click                event mask      button          function        argument */
++#ifndef __OpenBSD__
++    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
++    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
++    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
++#endif
++    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
++    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
++    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
++    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
++    { ClkTagBar,            0,              Button1,        view,           {0} },
++    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
++    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
++    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
++    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
++    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
++};
+diff --git a/config.mk b/config.mk
+index 8efca9a..a933c0b 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/diff_bkp.diff b/diff_bkp.diff
+new file mode 100644
+index 0000000..fe82587
+--- /dev/null
++++ b/diff_bkp.diff
+@@ -0,0 +1,12338 @@
++diff --git a/LICENSE b/LICENSE
++index 1e1b5a4..995172f 100644
++--- a/LICENSE
+++++ b/LICENSE
++@@ -17,7 +17,7 @@ MIT/X Consortium License
++ © 2015-2016 Quentin Rameau <quinq@fifth.space>
++ © 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
++ © 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
++-© 2019-2020 Luke Smith <luke@lukesmith.xyz>
+++© 2020-2022 Chris Down <chris@chrisdown.name>
++ 
++ Permission is hereby granted, free of charge, to any person obtaining a
++ copy of this software and associated documentation files (the "Software"),
++diff --git a/Makefile b/Makefile
++index 63569d7..ffa69b4 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -13,16 +13,19 @@ all: dwm
++ 
++ ${OBJ}: config.h config.mk
++ 
+++config.h:
+++	cp config.def.h $@
+++
++ dwm: ${OBJ}
++ 	${CC} -o $@ ${OBJ} ${LDFLAGS}
++ 
++ clean:
++-	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
+++	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
++ 
++ dist: clean
++ 	mkdir -p dwm-${VERSION}
++-	cp -R LICENSE Makefile README config.mk\
++-		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
+++	cp -R LICENSE Makefile README config.def.h config.mk\
+++		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
++ 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
++ 	gzip dwm-${VERSION}.tar
++ 	rm -rf dwm-${VERSION}
++@@ -34,7 +37,6 @@ install: all
++ 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
++ 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
++ 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
++-	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
++ 
++ uninstall:
++ 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
++diff --git a/README b/README
++index 482b545..95d4fd0 100644
++--- a/README
+++++ b/README
++@@ -1,13 +1,5 @@
++-See patches in dir 'patches'.
++-
++-I also continously add fixes from suckless git log:
++-https://git.suckless.org/
++-https://dwm.suckless.org/
++-
++-============================
++ dwm - dynamic window manager
++ ============================
++-
++ dwm is an extremely fast, small, and dynamic window manager for X.
++ 
++ 
++diff --git a/changes.diff b/changes.diff
++deleted file mode 100644
++index c47ac32..0000000
++--- a/changes.diff
+++++ /dev/null
++@@ -1,9560 +0,0 @@
++-diff --git a/.gitignore b/.gitignore
++-new file mode 100644
++-index 0000000..d42c9e0
++---- /dev/null
++-+++ b/.gitignore
++-@@ -0,0 +1,54 @@
++-+# Prerequisites
++-+*.d
++-+
++-+# Object files
++-+*.o
++-+*.ko
++-+*.obj
++-+*.elf
++-+
++-+# Linker output
++-+*.ilk
++-+*.map
++-+*.exp
++-+
++-+# Precompiled Headers
++-+*.gch
++-+*.pch
++-+
++-+# Libraries
++-+*.lib
++-+*.a
++-+*.la
++-+*.lo
++-+
++-+# Shared objects (inc. Windows DLLs)
++-+*.dll
++-+*.so
++-+*.so.*
++-+*.dylib
++-+
++-+# Executables
++-+*.exe
++-+*.out
++-+*.app
++-+*.i*86
++-+*.x86_64
++-+*.hex
++-+
++-+# Debug files
++-+*.dSYM/
++-+*.su
++-+*.idb
++-+*.pdb
++-+
++-+# Kernel Module Compile Results
++-+*.mod*
++-+*.cmd
++-+.tmp_versions/
++-+modules.order
++-+Module.symvers
++-+Mkfile.old
++-+dkms.conf
++-+a.out
++-+dwm
++-diff --git a/LICENSE b/LICENSE
++-deleted file mode 100644
++-index 995172f..0000000
++---- a/LICENSE
++-+++ /dev/null
++-@@ -1,38 +0,0 @@
++--MIT/X Consortium License
++--
++--© 2006-2019 Anselm R Garbe <anselm@garbe.ca>
++--© 2006-2009 Jukka Salmi <jukka at salmi dot ch>
++--© 2006-2007 Sander van Dijk <a dot h dot vandijk at gmail dot com>
++--© 2007-2011 Peter Hartlich <sgkkr at hartlich dot com>
++--© 2007-2009 Szabolcs Nagy <nszabolcs at gmail dot com>
++--© 2007-2009 Christof Musik <christof at sendfax dot de>
++--© 2007-2009 Premysl Hruby <dfenze at gmail dot com>
++--© 2007-2008 Enno Gottox Boland <gottox at s01 dot de>
++--© 2008 Martin Hurton <martin dot hurton at gmail dot com>
++--© 2008 Neale Pickett <neale dot woozle dot org>
++--© 2009 Mate Nagy <mnagy at port70 dot net>
++--© 2010-2016 Hiltjo Posthuma <hiltjo@codemadness.org>
++--© 2010-2012 Connor Lane Smith <cls@lubutu.com>
++--© 2011 Christoph Lohmann <20h@r-36.net>
++--© 2015-2016 Quentin Rameau <quinq@fifth.space>
++--© 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
++--© 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
++--© 2020-2022 Chris Down <chris@chrisdown.name>
++--
++--Permission is hereby granted, free of charge, to any person obtaining a
++--copy of this software and associated documentation files (the "Software"),
++--to deal in the Software without restriction, including without limitation
++--the rights to use, copy, modify, merge, publish, distribute, sublicense,
++--and/or sell copies of the Software, and to permit persons to whom the
++--Software is furnished to do so, subject to the following conditions:
++--
++--The above copyright notice and this permission notice shall be included in
++--all copies or substantial portions of the Software.
++--
++--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
++--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
++--THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
++--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++--FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
++--DEALINGS IN THE SOFTWARE.
++-diff --git a/Makefile b/Makefile
++-index ffa69b4..63569d7 100644
++---- a/Makefile
++-+++ b/Makefile
++-@@ -13,19 +13,16 @@ all: dwm
++- 
++- ${OBJ}: config.h config.mk
++- 
++--config.h:
++--	cp config.def.h $@
++--
++- dwm: ${OBJ}
++- 	${CC} -o $@ ${OBJ} ${LDFLAGS}
++- 
++- clean:
++--	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
++-+	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
++- 
++- dist: clean
++- 	mkdir -p dwm-${VERSION}
++--	cp -R LICENSE Makefile README config.def.h config.mk\
++--		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
++-+	cp -R LICENSE Makefile README config.mk\
++-+		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
++- 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
++- 	gzip dwm-${VERSION}.tar
++- 	rm -rf dwm-${VERSION}
++-@@ -37,6 +34,7 @@ install: all
++- 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
++- 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
++- 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
++-+	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
++- 
++- uninstall:
++- 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
++-diff --git a/README b/README
++-index 95d4fd0..c4f2539 100644
++---- a/README
++-+++ b/README
++-@@ -1,3 +1,34 @@
++-+MY DWM PATCHES:
++-+https://dwm.suckless.org/patches/noborder/
++-+https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
++-+
++-+Added with modifications:
++-+https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
++-+https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
++-+https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
++-+https://dwm.suckless.org/patches/save_floats/
++-+https://dwm.suckless.org/patches/status2d/dwm-status2d-20200508-60bb3df.diff (modified)
++-+
++-+Luke patches:
++-+https://dwm.suckless.org/patches/sticky/dwm-sticky-20160911-ab9571b.diff
++-+https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
++-+https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
++-+https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20210405-67d76bd.diff
++-+https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
++-+https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
++-+https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.3.diff
++-+https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
++-+https://dwm.suckless.org/patches/scratchpad/
++-+https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
++-+Also see:
++-+https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
++-+or:
++-+https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
++-+
++-+I've added the patches to patches dir (although im not 100% sure that those are the exact patches used, they are mostly based on the description below)
++-+
++-+I also continously add fixes from suckless git log.
++-+
++- dwm - dynamic window manager
++- ============================
++- dwm is an extremely fast, small, and dynamic window manager for X.
++-diff --git a/config.def.h b/config.def.h
++-deleted file mode 100644
++-index 9efa774..0000000
++---- a/config.def.h
++-+++ /dev/null
++-@@ -1,116 +0,0 @@
++--/* See LICENSE file for copyright and license details. */
++--
++--/* appearance */
++--static const unsigned int borderpx  = 1;        /* border pixel of windows */
++--static const unsigned int snap      = 32;       /* snap pixel */
++--static const int showbar            = 1;        /* 0 means no bar */
++--static const int topbar             = 1;        /* 0 means bottom bar */
++--static const char *fonts[]          = { "monospace:size=10" };
++--static const char dmenufont[]       = "monospace:size=10";
++--static const char col_gray1[]       = "#222222";
++--static const char col_gray2[]       = "#444444";
++--static const char col_gray3[]       = "#bbbbbb";
++--static const char col_gray4[]       = "#eeeeee";
++--static const char col_cyan[]        = "#005577";
++--static const char *colors[][3]      = {
++--	/*               fg         bg         border   */
++--	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
++--	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++--};
++--
++--/* tagging */
++--static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++--
++--static const Rule rules[] = {
++--	/* xprop(1):
++--	 *	WM_CLASS(STRING) = instance, class
++--	 *	WM_NAME(STRING) = title
++--	 */
++--	/* class      instance    title       tags mask     isfloating   monitor */
++--	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
++--	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++--};
++--
++--/* layout(s) */
++--static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++--static const int nmaster     = 1;    /* number of clients in master area */
++--static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++--static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++--
++--static const Layout layouts[] = {
++--	/* symbol     arrange function */
++--	{ "[]=",      tile },    /* first entry is default */
++--	{ "><>",      NULL },    /* no layout function means floating behavior */
++--	{ "[M]",      monocle },
++--};
++--
++--/* key definitions */
++--#define MODKEY Mod1Mask
++--#define TAGKEYS(KEY,TAG) \
++--	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
++--	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
++--	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
++--	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++--
++--/* helper for spawning shell commands in the pre dwm-5.0 fashion */
++--#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++--
++--/* commands */
++--static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++--static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++--static const char *termcmd[]  = { "st", NULL };
++--
++--static const Key keys[] = {
++--	/* modifier                     key        function        argument */
++--	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++--	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
++--	{ MODKEY,                       XK_b,      togglebar,      {0} },
++--	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
++--	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++--	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++--	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++--	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++--	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++--	{ MODKEY,                       XK_Return, zoom,           {0} },
++--	{ MODKEY,                       XK_Tab,    view,           {0} },
++--	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
++--	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
++--	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
++--	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
++--	{ MODKEY,                       XK_space,  setlayout,      {0} },
++--	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++--	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
++--	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
++--	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
++--	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
++--	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
++--	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++--	TAGKEYS(                        XK_1,                      0)
++--	TAGKEYS(                        XK_2,                      1)
++--	TAGKEYS(                        XK_3,                      2)
++--	TAGKEYS(                        XK_4,                      3)
++--	TAGKEYS(                        XK_5,                      4)
++--	TAGKEYS(                        XK_6,                      5)
++--	TAGKEYS(                        XK_7,                      6)
++--	TAGKEYS(                        XK_8,                      7)
++--	TAGKEYS(                        XK_9,                      8)
++--	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++--};
++--
++--/* button definitions */
++--/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
++--static const Button buttons[] = {
++--	/* click                event mask      button          function        argument */
++--	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++--	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++--	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++--	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++--	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++--	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++--	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++--	{ ClkTagBar,            0,              Button1,        view,           {0} },
++--	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
++--	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++--	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
++--};
++--
++-diff --git a/config.h b/config.h
++-new file mode 100644
++-index 0000000..97e540a
++---- /dev/null
++-+++ b/config.h
++-@@ -0,0 +1,356 @@
++-+/* See LICENSE file for copyright and license details. */
++-+
++-+/* Constants */
++-+/* #define TERMINAL "st" */
++-+/* #define TERMCLASS "St" */
++-+/* #define TERMINAL "urxvt" */
++-+/* #define TERMCLASS "Urxvt" */
++-+/* #define TERMINAL "alacritty" */
++-+/* #define TERMCLASS "alacritty" */
++-+#define TERMINAL "wezterm"
++-+#define TERMCLASS "wezterm"
++-+#define SECTERMINAL "st"
++-+
++-+#define FILES "thunar"
++-+//#define FILEX "ranger"
++-+#define FILEX "yazi"
++-+
++-+/* appearance */
++-+static unsigned int borderpx    = 3;        /* border pixel of windows */
++-+static const unsigned int gappx = 10;       /* default gap between windows in pixels */
++-+static unsigned int snap        = 32;       /* snap pixel */
++-+static unsigned int gappih      = 20;       /* horiz inner gap between windows */
++-+static unsigned int gappiv      = 20;       /* vert inner gap between windows */
++-+static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
++-+static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
++-+static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
++-+static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
++-+static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
++-+static int showbar              = 1;        /* 0 means no bar */
++-+static int topbar               = 1;        /* 0 means bottom bar */
++-+/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
++-+/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
++-+static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
++-+static char normbgcolor[]       = "#222222";
++-+static char normbordercolor[]   = "#444444";
++-+static char normfgcolor[]       = "#bbbbbb";
++-+static char selfgcolor[]        = "#eeeeee";
++-+static char selbordercolor[]    = "#770000";
++-+static char selbgcolor[]        = "#005577";
++-+static const char col1[]        = "#98971a";
++-+static const char col21[]       = "#fb4934";
++-+static const char col22[]       = "#ebdbb2";
++-+static const char col23[]       = "#458588";
++-+static const char col24[]       = "#ebdbb2";
++-+static const char col3[]        = "#fabd2f";
++-+static const char col4[]        = "#83a598";
++-+static const char col5[]        = "#d3869b";
++-+static const char col6[]        = "#8ec07c";
++-+static char *colors[][3]        = {
++-+    /*               fg              bg              border   */
++-+    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
++-+    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
++-+};
++-+
++-+typedef struct {
++-+    const char *name;
++-+    const void *cmd;
++-+} Sp;
++-+const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
++-+const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
++-+/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
++-+static Sp scratchpads[] = {
++-+    /* name          cmd  */
++-+    {"spterm",      spcmd1},
++-+    {"spcalc",      spcmd2},
++-+};
++-+
++-+/* tagging */
++-+static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++-+/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
++-+
++-+static const Rule rules[] = {
++-+    /* xprop(1):
++-+     *    WM_CLASS(STRING) = instance, class
++-+     *    WM_NAME(STRING) = title
++-+     */
++-+    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
++-+    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
++-+    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
++-+    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
++-+    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
++-+    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
++-+    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
++-+    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
++-+    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
++-+    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
++-+};
++-+
++-+/* layout(s) */
++-+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++-+static int nmaster     = 1;    /* number of clients in master area */
++-+static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
++-+
++-+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++-+#include "vanitygaps.c"
++-+static const Layout layouts[] = {
++-+    /* symbol       arrange function */
++-+    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
++-+    { "[]=",        tile },                     /* Master on left, slaves on right */
++-+    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
++-+    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
++-+    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
++-+    { "[M]",        monocle },                  /* All windows on top of eachother */
++-+    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
++-+    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
++-+    { "><>",        NULL },                     /* no layout function means floating behavior */
++-+    { NULL,         NULL },
++-+};
++-+
++-+/* key definitions */
++-+#define MODKEY Mod4Mask
++-+#define MODKEY1 Mod1Mask
++-+#define TAGKEYS(KEY,TAG) \
++-+{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
++-+{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
++-+{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
++-+{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
++-+/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
++-+#define STACKKEYS(MOD,ACTION) \
++-+{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
++-+{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
++-+{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
++-+{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
++-+/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
++-+/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
++-+
++-+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
++-+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++-+
++-+/* commands */
++-+static const char *termcmd[]  = { TERMINAL, NULL };
++-+
++-+/*
++-+ * Xresources preferences to load at startup
++-+ */
++-+ResourcePref resources[] = {
++-+    { "color0",             STRING,     &normbordercolor },
++-+    { "foreground",         STRING,     &selbordercolor },
++-+    /* { "color8",             STRING,     &selbordercolor }, */
++-+    { "color0",             STRING,     &normbgcolor },
++-+    { "foreground",         STRING,     &normfgcolor },
++-+    { "color0",             STRING,     &selfgcolor },
++-+    { "foreground",         STRING,     &selbgcolor },
++-+    { "borderpx",           INTEGER,    &borderpx },
++-+    { "snap",               INTEGER,    &snap },
++-+    { "showbar",            INTEGER,    &showbar },
++-+    { "topbar",             INTEGER,    &topbar },
++-+    { "nmaster",            INTEGER,    &nmaster },
++-+    { "resizehints",        INTEGER,    &resizehints },
++-+    { "mfact",              FLOAT,      &mfact },
++-+    { "gappih",             INTEGER,    &gappih },
++-+    { "gappiv",             INTEGER,    &gappiv },
++-+    { "gappoh",             INTEGER,    &gappoh },
++-+    { "gappov",             INTEGER,    &gappov },
++-+    { "swallowfloating",    INTEGER,    &swallowfloating },
++-+    { "smartgaps",          INTEGER,    &smartgaps },
++-+};
++-+
++-+#include <X11/XF86keysym.h>
++-+#include "shiftview.c"
++-+
++-+static const Key keys[] = {
++-+    /*  modifier                    key                 function            argument */
++-+        STACKKEYS(MODKEY,                               focus)
++-+        STACKKEYS(MODKEY|ShiftMask,                     push)
++-+        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
++-+        TAGKEYS(                    XK_1,               0)
++-+        TAGKEYS(                    XK_2,               1)
++-+        TAGKEYS(                    XK_3,               2)
++-+        TAGKEYS(                    XK_4,               3)
++-+        TAGKEYS(                    XK_5,               4)
++-+        TAGKEYS(                    XK_6,               5)
++-+        TAGKEYS(                    XK_7,               6)
++-+        TAGKEYS(                    XK_8,               7)
++-+        TAGKEYS(                    XK_9,               8)
++-+        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
++-+        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
++-+
++-+        /* Layouts */
++-+        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
++-+        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
++-+        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
++-+        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
++-+        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
++-+        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
++-+        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
++-+        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
++-+        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
++-+        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
++-+        { MODKEY,                   XK_f,               togglefullscr,      {0} },
++-+        { MODKEY,                   XK_space,           togglefloating,     {0} },
++-+        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
++-+        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
++-+        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
++-+        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
++-+        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
++-+        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
++-+        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
++-+        { MODKEY,                   XK_x,               defaultgaps,        {0} },
++-+        { MODKEY,                   XK_z,               togglegaps,         {0} },
++-+        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
++-+        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
++-+        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
++-+        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
++-+        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
++-+        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
++-+        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
++-+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++-+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++-+        { MODKEY,                   XK_q,               killclient,         {0} },
++-+        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
++-+        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
++-+        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
++-+        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
++-+        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
++-+        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
++-+        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
++-+        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
++-+        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
++-+        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
++-+        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
++-+        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
++-+        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
++-+        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
++-+        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
++-+        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
++-+
++-+        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
++-+        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
++-+        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
++-+        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
++-+        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
++-+        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
++-+        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
++-+        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
++-+        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
++-+        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
++-+        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
++-+        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
++-+        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
++-+        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
++-+        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
++-+        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
++-+        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
++-+        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
++-+        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
++-+        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
++-+        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
++-+        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/nautilus_wd.sh") },
++-+        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
++-+        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
++-+        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
++-+        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
++-+        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
++-+        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
++-+        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
++-+        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
++-+        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
++-+        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
++-+        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
++-+        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
++-+        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
++-+        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
++-+        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
++-+        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
++-+        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
++-+        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
++-+        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
++-+        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
++-+        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
++-+
++-+        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
++-+        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
++-+        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
++-+        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
++-+        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
++-+        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
++-+        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
++-+        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
++-+        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
++-+        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
++-+
++-+        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
++-+        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
++-+        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
++-+        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
++-+        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
++-+        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
++-+        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
++-+        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
++-+        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
++-+        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
++-+        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
++-+        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
++-+        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
++-+        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
++-+        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
++-+        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
++-+
++-+        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
++-+        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
++-+        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
++-+        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
++-+        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
++-+        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
++-+        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
++-+        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
++-+        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
++-+        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
++-+        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
++-+        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
++-+        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
++-+        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
++-+        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
++-+        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
++-+        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
++-+        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
++-+        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
++-+        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
++-+        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
++-+        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
++-+        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
++-+        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
++-+        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
++-+        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
++-+        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
++-+        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
++-+        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
++-+};
++-+
++-+/* button definitions */
++-+/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
++-+static const Button buttons[] = {
++-+    /* click                event mask      button          function        argument */
++-+#ifndef __OpenBSD__
++-+    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
++-+    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
++-+    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
++-+    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
++-+    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
++-+    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
++-+#endif
++-+    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
++-+    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++-+    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
++-+    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++-+    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
++-+    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
++-+    { ClkTagBar,            0,              Button1,        view,           {0} },
++-+    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
++-+    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++-+    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
++-+    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
++-+    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
++-+    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
++-+};
++-diff --git a/config.mk b/config.mk
++-index 8efca9a..1fc4bf1 100644
++---- a/config.mk
++-+++ b/config.mk
++-@@ -19,11 +19,10 @@ FREETYPELIBS = -lfontconfig -lXft
++- FREETYPEINC = /usr/include/freetype2
++- # OpenBSD (uncomment)
++- #FREETYPEINC = ${X11INC}/freetype2
++--#MANPREFIX = ${PREFIX}/man
++- 
++- # includes and libs
++- INCS = -I${X11INC} -I${FREETYPEINC}
++--LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++-+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
++- 
++- # flags
++- CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++-diff --git a/drw.c b/drw.c
++-index c41e6af..d43d8c2 100644
++---- a/drw.c
++-+++ b/drw.c
++-@@ -13,6 +13,7 @@
++- static int
++- utf8decode(const char *s_in, long *u, int *err)
++- {
++-+
++- 	static const unsigned char lens[] = {
++- 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
++- 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
++-@@ -26,63 +27,63 @@ utf8decode(const char *s_in, long *u, int *err)
++- 
++- 	const unsigned char *s = (const unsigned char *)s_in;
++- 	int len = lens[*s >> 3];
++--	*u = UTF_INVALID;
++-+
++-+    *u = UTF_INVALID;
++- 	*err = 1;
++- 	if (len == 0)
++--		return 1;
++-+        return 1;
++- 
++- 	long cp = s[0] & leading_mask[len - 1];
++- 	for (int i = 1; i < len; ++i) {
++- 		if (s[i] == '\0' || (s[i] & 0xC0) != 0x80)
++- 			return i;
++- 		cp = (cp << 6) | (s[i] & 0x3F);
++--	}
++-+    }
++- 	/* out of range, surrogate, overlong encoding */
++- 	if (cp > 0x10FFFF || (cp >> 11) == 0x1B || cp < overlong[len - 1])
++- 		return len;
++- 
++- 	*err = 0;
++- 	*u = cp;
++--	return len;
++-+    return len;
++- }
++- 
++- Drw *
++- drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
++- {
++--	Drw *drw = ecalloc(1, sizeof(Drw));
++--
++--	drw->dpy = dpy;
++--	drw->screen = screen;
++--	drw->root = root;
++--	drw->w = w;
++--	drw->h = h;
++--	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
++--	drw->gc = XCreateGC(dpy, root, 0, NULL);
++--	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
++--
++--	return drw;
++-+    Drw *drw = ecalloc(1, sizeof(Drw));
++-+
++-+    drw->dpy = dpy;
++-+    drw->screen = screen;
++-+    drw->root = root;
++-+    drw->w = w;
++-+    drw->h = h;
++-+    drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
++-+    drw->gc = XCreateGC(dpy, root, 0, NULL);
++-+    XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
++-+
++-+    return drw;
++- }
++- 
++- void
++- drw_resize(Drw *drw, unsigned int w, unsigned int h)
++- {
++--	if (!drw)
++--		return;
++--
++--	drw->w = w;
++--	drw->h = h;
++--	if (drw->drawable)
++--		XFreePixmap(drw->dpy, drw->drawable);
++--	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++-+    if (!drw)
++-+        return;
++-+
++-+    drw->w = w;
++-+    drw->h = h;
++-+    if (drw->drawable)
++-+        XFreePixmap(drw->dpy, drw->drawable);
++-+    drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++- }
++- 
++- void
++- drw_free(Drw *drw)
++- {
++--	XFreePixmap(drw->dpy, drw->drawable);
++--	XFreeGC(drw->dpy, drw->gc);
++--	drw_fontset_free(drw->fonts);
++--	free(drw);
++-+    XFreePixmap(drw->dpy, drw->drawable);
++-+    XFreeGC(drw->dpy, drw->gc);
++-+    free(drw);
++- }
++- 
++- /* This function is an implementation detail. Library users should use
++-@@ -91,134 +92,136 @@ drw_free(Drw *drw)
++- static Fnt *
++- xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
++- {
++--	Fnt *font;
++--	XftFont *xfont = NULL;
++--	FcPattern *pattern = NULL;
++--
++--	if (fontname) {
++--		/* Using the pattern found at font->xfont->pattern does not yield the
++--		 * same substitution results as using the pattern returned by
++--		 * FcNameParse; using the latter results in the desired fallback
++--		 * behaviour whereas the former just results in missing-character
++--		 * rectangles being drawn, at least with some fonts. */
++--		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
++--			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
++--			return NULL;
++--		}
++--		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
++--			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
++--			XftFontClose(drw->dpy, xfont);
++--			return NULL;
++--		}
++--	} else if (fontpattern) {
++--		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
++--			fprintf(stderr, "error, cannot load font from pattern.\n");
++--			return NULL;
++--		}
++--	} else {
++--		die("no font specified.");
++--	}
++--
++--	font = ecalloc(1, sizeof(Fnt));
++--	font->xfont = xfont;
++--	font->pattern = pattern;
++--	font->h = xfont->ascent + xfont->descent;
++--	font->dpy = drw->dpy;
++--
++--	return font;
++-+    Fnt *font;
++-+    XftFont *xfont = NULL;
++-+    FcPattern *pattern = NULL;
++-+
++-+    if (fontname) {
++-+        /* Using the pattern found at font->xfont->pattern does not yield the
++-+         * same substitution results as using the pattern returned by
++-+         * FcNameParse; using the latter results in the desired fallback
++-+         * behaviour whereas the former just results in missing-character
++-+         * rectangles being drawn, at least with some fonts. */
++-+        if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
++-+            fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
++-+            return NULL;
++-+        }
++-+        if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
++-+            fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
++-+            XftFontClose(drw->dpy, xfont);
++-+            return NULL;
++-+        }
++-+    } else if (fontpattern) {
++-+        if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
++-+            fprintf(stderr, "error, cannot load font from pattern.\n");
++-+            return NULL;
++-+        }
++-+    } else {
++-+        die("no font specified.");
++-+    }
++-+
++-+    font = ecalloc(1, sizeof(Fnt));
++-+    font->xfont = xfont;
++-+    font->pattern = pattern;
++-+    font->h = xfont->ascent + xfont->descent;
++-+    font->dpy = drw->dpy;
++-+
++-+    return font;
++- }
++- 
++- static void
++- xfont_free(Fnt *font)
++- {
++--	if (!font)
++--		return;
++--	if (font->pattern)
++--		FcPatternDestroy(font->pattern);
++--	XftFontClose(font->dpy, font->xfont);
++--	free(font);
++-+    if (!font)
++-+        return;
++-+    if (font->pattern)
++-+        FcPatternDestroy(font->pattern);
++-+    XftFontClose(font->dpy, font->xfont);
++-+    free(font);
++- }
++- 
++- Fnt*
++- drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
++- {
++--	Fnt *cur, *ret = NULL;
++--	size_t i;
++--
++--	if (!drw || !fonts)
++--		return NULL;
++--
++--	for (i = 1; i <= fontcount; i++) {
++--		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
++--			cur->next = ret;
++--			ret = cur;
++--		}
++--	}
++--	return (drw->fonts = ret);
++-+    Fnt *cur, *ret = NULL;
++-+    size_t i;
++-+
++-+    if (!drw || !fonts)
++-+        return NULL;
++-+
++-+    for (i = 1; i <= fontcount; i++) {
++-+        if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
++-+            cur->next = ret;
++-+            ret = cur;
++-+        }
++-+    }
++-+    return (drw->fonts = ret);
++- }
++- 
++- void
++- drw_fontset_free(Fnt *font)
++- {
++--	if (font) {
++--		drw_fontset_free(font->next);
++--		xfont_free(font);
++--	}
++-+    if (font) {
++-+        drw_fontset_free(font->next);
++-+        xfont_free(font);
++-+    }
++- }
++- 
++- void
++- drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++- {
++--	if (!drw || !dest || !clrname)
++--		return;
++-+    if (!drw || !dest || !clrname)
++-+        return;
++-+
++-+    if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
++-+                DefaultColormap(drw->dpy, drw->screen),
++-+                clrname, dest))
++-+        die("error, cannot allocate color '%s'", clrname);
++- 
++--	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
++--	                       DefaultColormap(drw->dpy, drw->screen),
++--	                       clrname, dest))
++--		die("error, cannot allocate color '%s'", clrname);
++-+    dest->pixel |= 0xff << 24;
++- }
++- 
++- /* Wrapper to create color schemes. The caller has to call free(3) on the
++-  * returned color scheme when done using it. */
++- Clr *
++--drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++-+drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
++- {
++--	size_t i;
++--	Clr *ret;
++-+    size_t i;
++-+    Clr *ret;
++- 
++--	/* need at least two colors for a scheme */
++--	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
++--		return NULL;
++-+    /* need at least two colors for a scheme */
++-+    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
++-+        return NULL;
++- 
++--	for (i = 0; i < clrcount; i++)
++--		drw_clr_create(drw, &ret[i], clrnames[i]);
++--	return ret;
++-+    for (i = 0; i < clrcount; i++)
++-+        drw_clr_create(drw, &ret[i], clrnames[i]);
++-+    return ret;
++- }
++- 
++- void
++- drw_setfontset(Drw *drw, Fnt *set)
++- {
++--	if (drw)
++--		drw->fonts = set;
++-+    if (drw)
++-+        drw->fonts = set;
++- }
++- 
++- void
++- drw_setscheme(Drw *drw, Clr *scm)
++- {
++--	if (drw)
++--		drw->scheme = scm;
++-+    if (drw)
++-+        drw->scheme = scm;
++- }
++- 
++- void
++- drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
++- {
++--	if (!drw || !drw->scheme)
++--		return;
++--	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
++--	if (filled)
++--		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++--	else
++--		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
++-+    if (!drw || !drw->scheme)
++-+        return;
++-+    XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
++-+    if (filled)
++-+        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++-+    else
++-+        XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
++- }
++- 
++- int
++-@@ -226,51 +229,52 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++- {
++- 	int ty, ellipsis_x = 0;
++- 	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len, hash, h0, h1;
++--	XftDraw *d = NULL;
++--	Fnt *usedfont, *curfont, *nextfont;
++--	int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
++--	long utf8codepoint = 0;
++--	const char *utf8str;
++--	FcCharSet *fccharset;
++--	FcPattern *fcpattern;
++--	FcPattern *match;
++--	XftResult result;
++-+    XftDraw *d = NULL;
++-+    Fnt *usedfont, *curfont, *nextfont;
++-+    int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
++-+    long utf8codepoint = 0;
++-+    const char *utf8str;
++-+    FcCharSet *fccharset;
++-+    FcPattern *fcpattern;
++-+    FcPattern *match;
++-+    XftResult result;
++- 	int charexists = 0, overflow = 0;
++- 	/* keep track of a couple codepoints for which we have no match. */
++- 	static unsigned int nomatches[128], ellipsis_width, invalid_width;
++- 	static const char invalid[] = "�";
++- 
++--	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
++--		return 0;
++-+    if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
++-+        return 0;
++- 
++--	if (!render) {
++--		w = invert ? invert : ~invert;
++--	} else {
++--		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
++--		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++-+    if (!render) {
++-+        w = invert ? invert : ~invert;
++-+    } else {
++-+        XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
++-+        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++- 		if (w < lpad)
++- 			return x + w;
++--		d = XftDrawCreate(drw->dpy, drw->drawable,
++--		                  DefaultVisual(drw->dpy, drw->screen),
++--		                  DefaultColormap(drw->dpy, drw->screen));
++--		x += lpad;
++--		w -= lpad;
++--	}
++--
++--	usedfont = drw->fonts;
++-+        d = XftDrawCreate(drw->dpy, drw->drawable,
++-+                DefaultVisual(drw->dpy, drw->screen),
++-+                DefaultColormap(drw->dpy, drw->screen));
++-+        x += lpad;
++-+        w -= lpad;
++-+    }
++-+
++-+    usedfont = drw->fonts;
++- 	if (!ellipsis_width && render)
++- 		ellipsis_width = drw_fontset_getwidth(drw, "...");
++- 	if (!invalid_width && render)
++- 		invalid_width = drw_fontset_getwidth(drw, invalid);
++--	while (1) {
++--		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
++--		utf8str = text;
++--		nextfont = NULL;
++--		while (*text) {
++--			utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
++--			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
++--				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
++--				if (charexists) {
++-+    while (1) {
++-+        utf8strlen = 0;
++-+        ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
++-+        utf8str = text;
++-+        nextfont = NULL;
++-+        while (*text) {
++-+            utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
++-+            for (curfont = drw->fonts; curfont; curfont = curfont->next) {
++-+                charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
++-+                if (charexists) {
++- 					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
++- 					if (ew + ellipsis_width <= w) {
++- 						/* keep track where the ellipsis still fits */
++-@@ -289,31 +293,31 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++- 						else
++- 							utf8strlen = ellipsis_len;
++- 					} else if (curfont == usedfont) {
++--						text += utf8charlen;
++-+                        text += utf8charlen;
++- 						utf8strlen += utf8err ? 0 : utf8charlen;
++- 						ew += utf8err ? 0 : tmpw;
++--					} else {
++--						nextfont = curfont;
++--					}
++--					break;
++--				}
++--			}
++--
++--			if (overflow || !charexists || nextfont || utf8err)
++--				break;
++--			else
++--				charexists = 0;
++--		}
++--
++--		if (utf8strlen) {
++-+                    } else {
++-+                        nextfont = curfont;
++-+                    }
++-+                    break;
++-+                }
++-+            }
++-+
++-+            if (overflow || !charexists || nextfont || utf8err)
++-+                break;
++-+            else
++-+                charexists = 0;
++-+        }
++-+
++-+        if (utf8strlen) {
++- 			if (render) {
++- 				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
++- 				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
++- 				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
++--			}
++-+            }
++- 			x += ew;
++- 			w -= ew;
++--		}
++-+        }
++- 		if (utf8err && (!render || invalid_width < w)) {
++- 			if (render)
++- 				drw_text(drw, x, y, w, h, 0, invalid, invert);
++-@@ -323,15 +327,15 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++- 		if (render && overflow)
++- 			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
++- 
++--		if (!*text || overflow) {
++--			break;
++--		} else if (nextfont) {
++--			charexists = 0;
++--			usedfont = nextfont;
++--		} else {
++--			/* Regardless of whether or not a fallback font is found, the
++--			 * character must be drawn. */
++--			charexists = 1;
++-+        if (!*text || overflow) {
++-+            break;
++-+        } else if (nextfont) {
++-+            charexists = 0;
++-+            usedfont = nextfont;
++-+        } else {
++-+            /* Regardless of whether or not a fallback font is found, the
++-+             * character must be drawn. */
++-+            charexists = 1;
++- 
++- 			hash = (unsigned int)utf8codepoint;
++- 			hash = ((hash >> 16) ^ hash) * 0x21F0AAAD;
++-@@ -342,62 +346,63 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++- 			if (nomatches[h0] == utf8codepoint || nomatches[h1] == utf8codepoint)
++- 				goto no_match;
++- 
++--			fccharset = FcCharSetCreate();
++--			FcCharSetAddChar(fccharset, utf8codepoint);
++--
++--			if (!drw->fonts->pattern) {
++--				/* Refer to the comment in xfont_create for more information. */
++--				die("the first font in the cache must be loaded from a font string.");
++--			}
++--
++--			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
++--			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
++--			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
++--
++--			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
++--			FcDefaultSubstitute(fcpattern);
++--			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
++--
++--			FcCharSetDestroy(fccharset);
++--			FcPatternDestroy(fcpattern);
++--
++--			if (match) {
++--				usedfont = xfont_create(drw, NULL, match);
++--				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
++--					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
++--						; /* NOP */
++--					curfont->next = usedfont;
++--				} else {
++--					xfont_free(usedfont);
++--					nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
++-+            fccharset = FcCharSetCreate();
++-+            FcCharSetAddChar(fccharset, utf8codepoint);
++-+
++-+            if (!drw->fonts->pattern) {
++-+                /* Refer to the comment in xfont_create for more information. */
++-+                die("the first font in the cache must be loaded from a font string.");
++-+            }
++-+
++-+            fcpattern = FcPatternDuplicate(drw->fonts->pattern);
++-+            FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
++-+            FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
++-+            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
++-+
++-+            FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
++-+            FcDefaultSubstitute(fcpattern);
++-+            match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
++-+
++-+            FcCharSetDestroy(fccharset);
++-+            FcPatternDestroy(fcpattern);
++-+
++-+            if (match) {
++-+                usedfont = xfont_create(drw, NULL, match);
++-+                if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
++-+                    for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
++-+                        ; /* NOP */
++-+                    curfont->next = usedfont;
++-+                } else {
++-+                    xfont_free(usedfont);
++-+                    nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
++- no_match:
++--					usedfont = drw->fonts;
++--				}
++--			}
++--		}
++--	}
++--	if (d)
++--		XftDrawDestroy(d);
++--
++--	return x + (render ? w : 0);
++-+                    usedfont = drw->fonts;
++-+                }
++-+            }
++-+        }
++-+    }
++-+    if (d)
++-+        XftDrawDestroy(d);
++-+
++-+    return x + (render ? w : 0);
++- }
++- 
++- void
++- drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
++- {
++--	if (!drw)
++--		return;
++-+    if (!drw)
++-+        return;
++- 
++--	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
++--	XSync(drw->dpy, False);
++-+    XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
++-+    XSync(drw->dpy, False);
++- }
++- 
++- unsigned int
++- drw_fontset_getwidth(Drw *drw, const char *text)
++- {
++--	if (!drw || !drw->fonts || !text)
++--		return 0;
++--	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
++-+    if (!drw || !drw->fonts || !text)
++-+        return 0;
++-+    return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
++- }
++- 
++- unsigned int
++-@@ -412,37 +417,37 @@ drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
++- void
++- drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
++- {
++--	XGlyphInfo ext;
++-+    XGlyphInfo ext;
++- 
++--	if (!font || !text)
++--		return;
++-+    if (!font || !text)
++-+        return;
++- 
++--	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
++--	if (w)
++--		*w = ext.xOff;
++--	if (h)
++--		*h = font->h;
++-+    XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
++-+    if (w)
++-+        *w = ext.xOff;
++-+    if (h)
++-+        *h = font->h;
++- }
++- 
++- Cur *
++- drw_cur_create(Drw *drw, int shape)
++- {
++--	Cur *cur;
++-+    Cur *cur;
++- 
++--	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
++--		return NULL;
++-+    if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
++-+        return NULL;
++- 
++--	cur->cursor = XCreateFontCursor(drw->dpy, shape);
++-+    cur->cursor = XCreateFontCursor(drw->dpy, shape);
++- 
++--	return cur;
++-+    return cur;
++- }
++- 
++- void
++- drw_cur_free(Drw *drw, Cur *cursor)
++- {
++--	if (!cursor)
++--		return;
++-+    if (!cursor)
++-+        return;
++- 
++--	XFreeCursor(drw->dpy, cursor->cursor);
++--	free(cursor);
++-+    XFreeCursor(drw->dpy, cursor->cursor);
++-+    free(cursor);
++- }
++-diff --git a/drw.h b/drw.h
++-index 6471431..ea76849 100644
++---- a/drw.h
++-+++ b/drw.h
++-@@ -1,29 +1,29 @@
++- /* See LICENSE file for copyright and license details. */
++- 
++- typedef struct {
++--	Cursor cursor;
++-+    Cursor cursor;
++- } Cur;
++- 
++- typedef struct Fnt {
++--	Display *dpy;
++--	unsigned int h;
++--	XftFont *xfont;
++--	FcPattern *pattern;
++--	struct Fnt *next;
++-+    Display *dpy;
++-+    unsigned int h;
++-+    XftFont *xfont;
++-+    FcPattern *pattern;
++-+    struct Fnt *next;
++- } Fnt;
++- 
++- enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
++- typedef XftColor Clr;
++- 
++- typedef struct {
++--	unsigned int w, h;
++--	Display *dpy;
++--	int screen;
++--	Window root;
++--	Drawable drawable;
++--	GC gc;
++--	Clr *scheme;
++--	Fnt *fonts;
++-+    unsigned int w, h;
++-+    Display *dpy;
++-+    int screen;
++-+    Window root;
++-+    Drawable drawable;
++-+    GC gc;
++-+    Clr *scheme;
++-+    Fnt *fonts;
++- } Drw;
++- 
++- /* Drawable abstraction */
++-@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
++- 
++- /* Colorscheme abstraction */
++- void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
++--Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++-+Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
++- 
++- /* Cursor abstraction */
++- Cur *drw_cur_create(Drw *drw, int shape);
++-diff --git a/dwm.1 b/dwm.1
++-index ddc8321..7feba78 100644
++---- a/dwm.1
++-+++ b/dwm.1
++-@@ -1,21 +1,16 @@
++- .TH DWM 1 dwm\-VERSION
++- .SH NAME
++--dwm \- dynamic window manager
++-+dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
++- .SH SYNOPSIS
++- .B dwm
++- .RB [ \-v ]
++- .SH DESCRIPTION
++--dwm is a dynamic window manager for X. It manages windows in tiled, monocle
++--and floating layouts. Either layout can be applied dynamically, optimising the
++--environment for the application in use and the task performed.
++-+dwm is a dynamic window manager for X.
++- .P
++--In tiled layouts windows are managed in a master and stacking area. The master
++--area on the left contains one window by default, and the stacking area on the
++--right contains all other windows. The number of master area windows can be
++--adjusted from zero to an arbitrary number. In monocle layout all windows are
++--maximised to the screen size. In floating layout windows can be resized and
++--moved freely. Dialog windows are always managed floating, regardless of the
++--layout applied.
++-+dwm "orders" windows based on recency and primacy, while dwm layouts may
++-+change, the most recent "master" window is shown in the most prominent
++-+position. There are bindings for cycling through and promoting windows to the
++-+master position.
++- .P
++- Windows are grouped by tags. Each window can be tagged with one or multiple
++- tags. Selecting certain tags displays all windows with these tags.
++-@@ -30,10 +25,19 @@ top left corner.  The tags which are applied to one or more windows are
++- indicated with an empty square in the top left corner.
++- .P
++- dwm draws a small border around windows to indicate the focus state.
++-+.P
++-+.I
++-+libxft-bgra
++-+should be installed for this build of dwm. Arch users may install it via the
++-+AUR. Color characters and emoji are enabled, but these will cause crashes
++-+without the fix
++-+.I
++-+libxft-bgra
++-+offers.
++- .SH OPTIONS
++- .TP
++- .B \-v
++--prints version information to stderr, then exits.
++-+prints version information to standard output, then exits.
++- .SH USAGE
++- .SS Status bar
++- .TP
++-@@ -42,119 +46,168 @@ is read and displayed in the status text area. It can be set with the
++- .BR xsetroot (1)
++- command.
++- .TP
++--.B Button1
++-+.B Left click
++- click on a tag label to display all windows with that tag, click on the layout
++- label toggles between tiled and floating layout.
++- .TP
++--.B Button3
++-+.B Right click
++- click on a tag label adds/removes all windows with that tag to/from the view.
++- .TP
++--.B Mod1\-Button1
++-+.B Super\-Left click
++- click on a tag label applies that tag to the focused window.
++- .TP
++--.B Mod1\-Button3
++-+.B Super\-Right click
++- click on a tag label adds/removes that tag to/from the focused window.
++- .SS Keyboard commands
++- .TP
++--.B Mod1\-Shift\-Return
++--Start
++-+.B Super\-Return
++-+Start terminal,
++- .BR st(1).
++- .TP
++--.B Mod1\-p
++-+.B Super\-d
++- Spawn
++- .BR dmenu(1)
++- for launching other programs.
++- .TP
++--.B Mod1\-,
++--Focus previous screen, if any.
++--.TP
++--.B Mod1\-.
++--Focus next screen, if any.
++-+.B Super\-b
++-+Toggles bar on and off.
++- .TP
++--.B Mod1\-Shift\-,
++--Send focused window to previous screen, if any.
++-+.B Super\-q
++-+Close focused window.
++- .TP
++--.B Mod1\-Shift\-.
++--Send focused window to next screen, if any.
++-+.B Super\-t/T
++-+Sets tiled/bstack layouts.
++- .TP
++--.B Mod1\-b
++--Toggles bar on and off.
++-+.B Super\-f
++-+Toggle fullscreen window.
++- .TP
++--.B Mod1\-t
++--Sets tiled layout.
++-+.B Super\-F
++-+Toggle floating layout.
++- .TP
++--.B Mod1\-f
++--Sets floating layout.
++-+.B Super\-y/Y
++-+Sets Fibonacci spiral/dwinde layouts.
++- .TP
++--.B Mod1\-m
++--Sets monocle layout.
++-+.B Super\-u/U
++-+Sets centered master layout.
++- .TP
++--.B Mod1\-space
++--Toggles between current and previous layout.
++-+.B Super\-i/I
++-+Sets centered master or floating master layouts.
++- .TP
++--.B Mod1\-j
++--Focus next window.
++-+.B Super\-space
++-+Zooms/cycles focused window to/from master area.
++- .TP
++--.B Mod1\-k
++--Focus previous window.
++-+.B Super\-j/k
++-+Focus next/previous window.
++- .TP
++--.B Mod1\-i
++--Increase number of windows in master area.
++-+.B Super\-Shift\-j/k
++-+Move selected window down/up in stack.
++- .TP
++--.B Mod1\-d
++--Decrease number of windows in master area.
++-+.B Super\-o/O
++-+Increase/decrease number of windows in master area.
++- .TP
++--.B Mod1\-l
++-+.B Super\-l
++- Increase master area size.
++- .TP
++--.B Mod1\-h
++-+.B Super\-h
++- Decrease master area size.
++- .TP
++--.B Mod1\-Return
++--Zooms/cycles focused window to/from master area (tiled layouts only).
++--.TP
++--.B Mod1\-Shift\-c
++--Close focused window.
++--.TP
++--.B Mod1\-Shift\-space
++-+.B Super\-Shift\-space
++- Toggle focused window between tiled and floating state.
++- .TP
++--.B Mod1\-Tab
++-+.B Super\-Tab
++- Toggles to the previously selected tags.
++- .TP
++--.B Mod1\-Shift\-[1..n]
++-+.B Super\-g
++-+Moves to the previous tag.
++-+.TP
++-+.B Super\-Shift\-g
++-+Moves selected window to the previous tag.
++-+.TP
++-+.B Super\-;
++-+Moves to the next tag.
++-+.TP
++-+.B Super\-Shift\-;
++-+Moves selected window to the next tag.
++-+.TP
++-+.B Super\-PageUp
++-+Moves to the previous tag.
++-+.TP
++-+.B Super\-Shift\-PageUp
++-+Moves selected window to the previous tag.
++-+.TP
++-+.B Super\-Pagedown
++-+Moves to the next tag.
++-+.TP
++-+.B Super\-Shift\-PageDown
++-+Moves selected window to the next tag.
++-+.TP
++-+.B Super\-a
++-+Toggle gaps.
++-+.TP
++-+.B Super\-z
++-+Increase gaps between windows.
++-+.TP
++-+.B Super\-x
++-+Decrease gaps between windows.
++-+.TP
++-+.B Super\-Shift\-[1..n]
++- Apply nth tag to focused window.
++- .TP
++--.B Mod1\-Shift\-0
++-+.B Super\-Shift\-0
++- Apply all tags to focused window.
++- .TP
++--.B Mod1\-Control\-Shift\-[1..n]
++-+.B Super\-Control\-Shift\-[1..n]
++- Add/remove nth tag to/from focused window.
++- .TP
++--.B Mod1\-[1..n]
++-+.B Super\-[1..n]
++- View all windows with nth tag.
++- .TP
++--.B Mod1\-0
++-+.B Super\-0
++- View all windows with any tag.
++- .TP
++--.B Mod1\-Control\-[1..n]
++-+.B Super\-Control\-[1..n]
++- Add/remove all windows with nth tag to/from the view.
++- .TP
++--.B Mod1\-Shift\-q
++-+.B Super\-Shift\-q
++- Quit dwm.
++-+.TP
++-+.B Mod1\-Control\-Shift\-q
++-+Menu to refresh/quit/reboot/shutdown.
++- .SS Mouse commands
++- .TP
++--.B Mod1\-Button1
++-+.B Super\-Left click
++- Move focused window while dragging. Tiled windows will be toggled to the floating state.
++- .TP
++--.B Mod1\-Button2
++-+.B Super\-Middle click
++- Toggles focused window between floating and tiled state.
++- .TP
++--.B Mod1\-Button3
++-+.B Super\-Right click
++- Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++-+.SH FILES
++-+The files containing programs to be started along with dwm are searched for in
++-+the following directories:
++-+.IP "1. $XDG_DATA_HOME/dwm"
++-+.IP "2. $HOME/.local/share/dwm"
++-+.IP "3. $HOME/.dwm"
++-+.P
++-+The first existing directory is scanned for any of the autostart files below.
++-+.TP 15
++-+autostart.sh
++-+This file is started as a shell background process before dwm enters its handler
++-+loop.
++-+.TP 15
++-+autostart_blocking.sh
++-+This file is started before any autostart.sh; dwm waits for its termination.
++- .SH CUSTOMIZATION
++- dwm is customized by creating a custom config.h and (re)compiling the source
++- code. This keeps it fast, secure and simple.
++-+.SH SIGNALS
++-+.TP
++-+.B SIGHUP - 1
++-+Restart the dwm process.
++-+.TP
++-+.B SIGTERM - 15
++-+Cleanly terminate the dwm process.
++- .SH SEE ALSO
++- .BR dmenu (1),
++- .BR st (1)
++-diff --git a/dwm.c b/dwm.c
++-index 1443802..9086e16 100644
++---- a/dwm.c
++-+++ b/dwm.c
++-@@ -36,10 +36,13 @@
++- #include <X11/Xlib.h>
++- #include <X11/Xproto.h>
++- #include <X11/Xutil.h>
++-+#include <X11/Xresource.h>
++- #ifdef XINERAMA
++- #include <X11/extensions/Xinerama.h>
++- #endif /* XINERAMA */
++- #include <X11/Xft/Xft.h>
++-+#include <X11/Xlib-xcb.h>
++-+#include <xcb/res.h>
++- 
++- #include "drw.h"
++- #include "util.h"
++-@@ -47,99 +50,130 @@
++- /* macros */
++- #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++- #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++-+#define GETINC(X)               ((X) - 2000)
++-+#define INC(X)                  ((X) + 2000)
++- #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++--                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++--#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++-+        * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++-+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
++-+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++-+#define PREVSEL                 3000
++- #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++-+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++- #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++- #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++--#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++-+#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
++-+#define TAGMASK			((1 << NUMTAGS) - 1)
++-+#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
++-+#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++- #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++-+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++- 
++- /* enums */
++- enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++- enum { SchemeNorm, SchemeSel }; /* color schemes */
++- enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++--       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++--       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++-+    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++-+    NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++- enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++--enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++--       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++-+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++-+    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
++- 
++- typedef union {
++--	int i;
++--	unsigned int ui;
++--	float f;
++--	const void *v;
++-+    int i;
++-+    unsigned int ui;
++-+    float f;
++-+    const void *v;
++- } Arg;
++- 
++- typedef struct {
++--	unsigned int click;
++--	unsigned int mask;
++--	unsigned int button;
++--	void (*func)(const Arg *arg);
++--	const Arg arg;
++-+    unsigned int click;
++-+    unsigned int mask;
++-+    unsigned int button;
++-+    void (*func)(const Arg *arg);
++-+    const Arg arg;
++- } Button;
++- 
++- typedef struct Monitor Monitor;
++- typedef struct Client Client;
++- struct Client {
++--	char name[256];
++--	float mina, maxa;
++--	int x, y, w, h;
++--	int oldx, oldy, oldw, oldh;
++--	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++--	int bw, oldbw;
++--	unsigned int tags;
++--	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++--	Client *next;
++--	Client *snext;
++--	Monitor *mon;
++--	Window win;
++-+    char name[256];
++-+    float mina, maxa;
++-+    int x, y, w, h;
++-+    int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++-+    int oldx, oldy, oldw, oldh;
++-+    int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++-+    int bw, oldbw;
++-+    unsigned int tags;
++-+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
++-+    pid_t pid;
++-+    Client *next;
++-+    Client *snext;
++-+    Client *swallowing;
++-+    Monitor *mon;
++-+    Window win;
++- };
++- 
++- typedef struct {
++--	unsigned int mod;
++--	KeySym keysym;
++--	void (*func)(const Arg *);
++--	const Arg arg;
++-+    unsigned int mod;
++-+    KeySym keysym;
++-+    void (*func)(const Arg *);
++-+    const Arg arg;
++- } Key;
++- 
++- typedef struct {
++--	const char *symbol;
++--	void (*arrange)(Monitor *);
++-+    const char *symbol;
++-+    void (*arrange)(Monitor *);
++- } Layout;
++- 
++- struct Monitor {
++--	char ltsymbol[16];
++--	float mfact;
++--	int nmaster;
++--	int num;
++--	int by;               /* bar geometry */
++--	int mx, my, mw, mh;   /* screen size */
++--	int wx, wy, ww, wh;   /* window area  */
++--	unsigned int seltags;
++--	unsigned int sellt;
++--	unsigned int tagset[2];
++--	int showbar;
++--	int topbar;
++--	Client *clients;
++--	Client *sel;
++--	Client *stack;
++--	Monitor *next;
++--	Window barwin;
++--	const Layout *lt[2];
++-+    char ltsymbol[16];
++-+    float mfact;
++-+    int nmaster;
++-+    int num;
++-+    int by;               /* bar geometry */
++-+    int mx, my, mw, mh;   /* screen size */
++-+    int wx, wy, ww, wh;   /* window area  */
++-+    int gappih;           /* horizontal gap between windows */
++-+    int gappiv;           /* vertical gap between windows */
++-+    int gappoh;           /* horizontal outer gaps */
++-+    int gappov;           /* vertical outer gaps */
++-+    unsigned int seltags;
++-+    unsigned int sellt;
++-+    unsigned int tagset[2];
++-+    int showbar;
++-+    int topbar;
++-+    Client *clients;
++-+    Client *sel;
++-+    Client *stack;
++-+    Monitor *next;
++-+    Window barwin;
++-+    const Layout *lt[2];
++- };
++- 
++- typedef struct {
++--	const char *class;
++--	const char *instance;
++--	const char *title;
++--	unsigned int tags;
++--	int isfloating;
++--	int monitor;
++-+    const char *class;
++-+    const char *instance;
++-+    const char *title;
++-+    unsigned int tags;
++-+    int isfloating;
++-+    int isterminal;
++-+    int noswallow;
++-+    int monitor;
++- } Rule;
++- 
++-+/* Xresources preferences */
++-+enum resource_type {
++-+    STRING = 0,
++-+    INTEGER = 1,
++-+    FLOAT = 2
++-+};
++-+
++-+typedef struct {
++-+    char *name;
++-+    enum resource_type type;
++-+    void *dst;
++-+} ResourcePref;
++-+
++- /* function declarations */
++- static void applyrules(Client *c);
++- static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++-@@ -155,6 +189,7 @@ static void clientmessage(XEvent *e);
++- static void configure(Client *c);
++- static void configurenotify(XEvent *e);
++- static void configurerequest(XEvent *e);
++-+static void copyvalidchars(char *text, char *rawtext);
++- static Monitor *createmon(void);
++- static void destroynotify(XEvent *e);
++- static void detach(Client *c);
++-@@ -162,7 +197,7 @@ static void detachstack(Client *c);
++- static Monitor *dirtomon(int dir);
++- static void drawbar(Monitor *m);
++- static void drawbars(void);
++--static void enternotify(XEvent *e);
++-+static int drawstatusbar(Monitor *m, int bh, char* text);
++- static void expose(XEvent *e);
++- static void focus(Client *c);
++- static void focusin(XEvent *e);
++-@@ -186,6 +221,7 @@ static void movemouse(const Arg *arg);
++- static Client *nexttiled(Client *c);
++- static void pop(Client *c);
++- static void propertynotify(XEvent *e);
++-+static void pushstack(const Arg *arg);
++- static void quit(const Arg *arg);
++- static Monitor *recttomon(int x, int y, int w, int h);
++- static void resize(Client *c, int x, int y, int w, int h, int interact);
++-@@ -193,9 +229,11 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
++- static void resizemouse(const Arg *arg);
++- static void restack(Monitor *m);
++- static void run(void);
++-+static void runAutostart(void);
++- static void scan(void);
++- static int sendevent(Client *c, Atom proto);
++- static void sendmon(Client *c, Monitor *m);
++-+static void sendmonview(Client *c, Monitor *m);
++- static void setclientstate(Client *c, long state);
++- static void setfocus(Client *c);
++- static void setfullscreen(Client *c, int fullscreen);
++-@@ -204,12 +242,23 @@ static void setmfact(const Arg *arg);
++- static void setup(void);
++- static void seturgent(Client *c, int urg);
++- static void showhide(Client *c);
++-+#ifndef __OpenBSD__
++-+static int getdwmblockspid();
++-+static void sigdwmblocks(const Arg *arg);
++-+#endif
++-+static void sighup(int unused);
++-+static void sigterm(int unused);
++- static void spawn(const Arg *arg);
++-+static int stackpos(const Arg *arg);
++- static void tag(const Arg *arg);
++-+static void tagview(const Arg *arg);
++- static void tagmon(const Arg *arg);
++--static void tile(Monitor *m);
++-+static void tagmonview(const Arg *arg);
++- static void togglebar(const Arg *arg);
++- static void togglefloating(const Arg *arg);
++-+static void togglescratch(const Arg *arg);
++-+static void togglesticky(const Arg *arg);
++-+static void togglefullscr(const Arg *arg);
++- static void toggletag(const Arg *arg);
++- static void toggleview(const Arg *arg);
++- static void unfocus(Client *c, int setfocus);
++-@@ -232,10 +281,22 @@ static int xerror(Display *dpy, XErrorEvent *ee);
++- static int xerrordummy(Display *dpy, XErrorEvent *ee);
++- static int xerrorstart(Display *dpy, XErrorEvent *ee);
++- static void zoom(const Arg *arg);
++-+static void load_xresources(void);
++-+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
++-+
++-+static pid_t getparentprocess(pid_t p);
++-+static int isdescprocess(pid_t p, pid_t c);
++-+static Client *swallowingclient(Window w);
++-+static Client *termforwin(const Client *c);
++-+static pid_t winpid(Window w);
++- 
++- /* variables */
++- static const char broken[] = "broken";
++- static char stext[256];
++-+/* static char stext[1024]; */
++-+static char rawstext[256];
++-+static int dwmblockssig;
++-+pid_t dwmblockspid = 0;
++- static int screen;
++- static int sw, sh;           /* X display screen geometry width, height */
++- static int bh;               /* bar height */
++-@@ -243,22 +304,22 @@ static int lrpad;            /* sum of left and right padding for text */
++- static int (*xerrorxlib)(Display *, XErrorEvent *);
++- static unsigned int numlockmask = 0;
++- static void (*handler[LASTEvent]) (XEvent *) = {
++--	[ButtonPress] = buttonpress,
++--	[ClientMessage] = clientmessage,
++--	[ConfigureRequest] = configurerequest,
++--	[ConfigureNotify] = configurenotify,
++--	[DestroyNotify] = destroynotify,
++--	[EnterNotify] = enternotify,
++--	[Expose] = expose,
++--	[FocusIn] = focusin,
++--	[KeyPress] = keypress,
++--	[MappingNotify] = mappingnotify,
++--	[MapRequest] = maprequest,
++--	[MotionNotify] = motionnotify,
++--	[PropertyNotify] = propertynotify,
++--	[UnmapNotify] = unmapnotify
++-+    [ButtonPress] = buttonpress,
++-+    [ClientMessage] = clientmessage,
++-+    [ConfigureRequest] = configurerequest,
++-+    [ConfigureNotify] = configurenotify,
++-+    [DestroyNotify] = destroynotify,
++-+    [Expose] = expose,
++-+    [FocusIn] = focusin,
++-+    [KeyPress] = keypress,
++-+    [MappingNotify] = mappingnotify,
++-+    [MapRequest] = maprequest,
++-+    [MotionNotify] = motionnotify,
++-+    [PropertyNotify] = propertynotify,
++-+    [UnmapNotify] = unmapnotify
++- };
++- static Atom wmatom[WMLast], netatom[NetLast];
++-+static int restart = 0;
++- static int running = 1;
++- static Cur *cursor[CurLast];
++- static Clr **scheme;
++-@@ -267,6 +328,8 @@ static Drw *drw;
++- static Monitor *mons, *selmon;
++- static Window root, wmcheckwin;
++- 
++-+static xcb_connection_t *xcon;
++-+
++- /* configuration, allows nested code to access above variables */
++- #include "config.h"
++- 
++-@@ -277,1818 +340,2349 @@ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
++- void
++- applyrules(Client *c)
++- {
++--	const char *class, *instance;
++--	unsigned int i;
++--	const Rule *r;
++--	Monitor *m;
++--	XClassHint ch = { NULL, NULL };
++--
++--	/* rule matching */
++--	c->isfloating = 0;
++--	c->tags = 0;
++--	XGetClassHint(dpy, c->win, &ch);
++--	class    = ch.res_class ? ch.res_class : broken;
++--	instance = ch.res_name  ? ch.res_name  : broken;
++--
++--	for (i = 0; i < LENGTH(rules); i++) {
++--		r = &rules[i];
++--		if ((!r->title || strstr(c->name, r->title))
++--		&& (!r->class || strstr(class, r->class))
++--		&& (!r->instance || strstr(instance, r->instance)))
++--		{
++--			c->isfloating = r->isfloating;
++--			c->tags |= r->tags;
++--			for (m = mons; m && m->num != r->monitor; m = m->next);
++--			if (m)
++--				c->mon = m;
++--		}
++--	}
++--	if (ch.res_class)
++--		XFree(ch.res_class);
++--	if (ch.res_name)
++--		XFree(ch.res_name);
++--	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++-+    const char *class, *instance;
++-+    unsigned int i;
++-+    const Rule *r;
++-+    Monitor *m;
++-+    XClassHint ch = { NULL, NULL };
++-+
++-+    /* rule matching */
++-+    c->isfloating = 0;
++-+    c->tags = 0;
++-+    XGetClassHint(dpy, c->win, &ch);
++-+    class    = ch.res_class ? ch.res_class : broken;
++-+    instance = ch.res_name  ? ch.res_name  : broken;
++-+
++-+    for (i = 0; i < LENGTH(rules); i++) {
++-+        r = &rules[i];
++-+        if ((!r->title || strstr(c->name, r->title))
++-+                && (!r->class || strstr(class, r->class))
++-+                && (!r->instance || strstr(instance, r->instance)))
++-+        {
++-+            c->isterminal = r->isterminal;
++-+            c->isfloating = r->isfloating;
++-+            c->noswallow  = r->noswallow;
++-+            c->tags |= r->tags;
++-+            if ((r->tags & SPTAGMASK) && r->isfloating) {
++-+                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
++-+                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
++-+            }
++-+
++-+            for (m = mons; m && m->num != r->monitor; m = m->next);
++-+            if (m)
++-+                c->mon = m;
++-+        }
++-+    }
++-+    if (ch.res_class)
++-+        XFree(ch.res_class);
++-+    if (ch.res_name)
++-+        XFree(ch.res_name);
++-+    c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++- }
++- 
++- int
++- applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
++- {
++--	int baseismin;
++--	Monitor *m = c->mon;
++--
++--	/* set minimum possible */
++--	*w = MAX(1, *w);
++--	*h = MAX(1, *h);
++--	if (interact) {
++--		if (*x > sw)
++--			*x = sw - WIDTH(c);
++--		if (*y > sh)
++--			*y = sh - HEIGHT(c);
++--		if (*x + *w + 2 * c->bw < 0)
++--			*x = 0;
++--		if (*y + *h + 2 * c->bw < 0)
++--			*y = 0;
++--	} else {
++--		if (*x >= m->wx + m->ww)
++--			*x = m->wx + m->ww - WIDTH(c);
++--		if (*y >= m->wy + m->wh)
++--			*y = m->wy + m->wh - HEIGHT(c);
++--		if (*x + *w + 2 * c->bw <= m->wx)
++--			*x = m->wx;
++--		if (*y + *h + 2 * c->bw <= m->wy)
++--			*y = m->wy;
++--	}
++--	if (*h < bh)
++--		*h = bh;
++--	if (*w < bh)
++--		*w = bh;
++--	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
++--		if (!c->hintsvalid)
++--			updatesizehints(c);
++--		/* see last two sentences in ICCCM 4.1.2.3 */
++--		baseismin = c->basew == c->minw && c->baseh == c->minh;
++--		if (!baseismin) { /* temporarily remove base dimensions */
++--			*w -= c->basew;
++--			*h -= c->baseh;
++--		}
++--		/* adjust for aspect limits */
++--		if (c->mina > 0 && c->maxa > 0) {
++--			if (c->maxa < (float)*w / *h)
++--				*w = *h * c->maxa + 0.5;
++--			else if (c->mina < (float)*h / *w)
++--				*h = *w * c->mina + 0.5;
++--		}
++--		if (baseismin) { /* increment calculation requires this */
++--			*w -= c->basew;
++--			*h -= c->baseh;
++--		}
++--		/* adjust for increment value */
++--		if (c->incw)
++--			*w -= *w % c->incw;
++--		if (c->inch)
++--			*h -= *h % c->inch;
++--		/* restore base dimensions */
++--		*w = MAX(*w + c->basew, c->minw);
++--		*h = MAX(*h + c->baseh, c->minh);
++--		if (c->maxw)
++--			*w = MIN(*w, c->maxw);
++--		if (c->maxh)
++--			*h = MIN(*h, c->maxh);
++--	}
++--	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
++-+    int baseismin;
++-+    Monitor *m = c->mon;
++-+
++-+    /* set minimum possible */
++-+    *w = MAX(1, *w);
++-+    *h = MAX(1, *h);
++-+    if (interact) {
++-+        if (*x > sw)
++-+            *x = sw - WIDTH(c);
++-+        if (*y > sh)
++-+            *y = sh - HEIGHT(c);
++-+        if (*x + *w + 2 * c->bw < 0)
++-+            *x = 0;
++-+        if (*y + *h + 2 * c->bw < 0)
++-+            *y = 0;
++-+    } else {
++-+        if (*x >= m->wx + m->ww)
++-+            *x = m->wx + m->ww - WIDTH(c);
++-+        if (*y >= m->wy + m->wh)
++-+            *y = m->wy + m->wh - HEIGHT(c);
++-+        if (*x + *w + 2 * c->bw <= m->wx)
++-+            *x = m->wx;
++-+        if (*y + *h + 2 * c->bw <= m->wy)
++-+            *y = m->wy;
++-+    }
++-+    if (*h < bh)
++-+        *h = bh;
++-+    if (*w < bh)
++-+        *w = bh;
++-+    if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
++-+        if (!c->hintsvalid)
++-+            updatesizehints(c);
++-+        /* see last two sentences in ICCCM 4.1.2.3 */
++-+        baseismin = c->basew == c->minw && c->baseh == c->minh;
++-+        if (!baseismin) { /* temporarily remove base dimensions */
++-+            *w -= c->basew;
++-+            *h -= c->baseh;
++-+        }
++-+        /* adjust for aspect limits */
++-+        if (c->mina > 0 && c->maxa > 0) {
++-+            if (c->maxa < (float)*w / *h)
++-+                *w = *h * c->maxa + 0.5;
++-+            else if (c->mina < (float)*h / *w)
++-+                *h = *w * c->mina + 0.5;
++-+        }
++-+        if (baseismin) { /* increment calculation requires this */
++-+            *w -= c->basew;
++-+            *h -= c->baseh;
++-+        }
++-+        /* adjust for increment value */
++-+        if (c->incw)
++-+            *w -= *w % c->incw;
++-+        if (c->inch)
++-+            *h -= *h % c->inch;
++-+        /* restore base dimensions */
++-+        *w = MAX(*w + c->basew, c->minw);
++-+        *h = MAX(*h + c->baseh, c->minh);
++-+        if (c->maxw)
++-+            *w = MIN(*w, c->maxw);
++-+        if (c->maxh)
++-+            *h = MIN(*h, c->maxh);
++-+    }
++-+    return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
++- }
++- 
++- void
++- arrange(Monitor *m)
++- {
++--	if (m)
++--		showhide(m->stack);
++--	else for (m = mons; m; m = m->next)
++--		showhide(m->stack);
++--	if (m) {
++--		arrangemon(m);
++--		restack(m);
++--	} else for (m = mons; m; m = m->next)
++--		arrangemon(m);
++-+    if (m)
++-+        showhide(m->stack);
++-+    else for (m = mons; m; m = m->next)
++-+        showhide(m->stack);
++-+    if (m) {
++-+        arrangemon(m);
++-+        restack(m);
++-+    } else for (m = mons; m; m = m->next)
++-+        arrangemon(m);
++- }
++- 
++- void
++- arrangemon(Monitor *m)
++- {
++--	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
++--	if (m->lt[m->sellt]->arrange)
++--		m->lt[m->sellt]->arrange(m);
++-+    strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
++-+    if (m->lt[m->sellt]->arrange)
++-+        m->lt[m->sellt]->arrange(m);
++- }
++- 
++- void
++- attach(Client *c)
++- {
++--	c->next = c->mon->clients;
++--	c->mon->clients = c;
++-+    c->next = c->mon->clients;
++-+    c->mon->clients = c;
++- }
++- 
++- void
++- attachstack(Client *c)
++- {
++--	c->snext = c->mon->stack;
++--	c->mon->stack = c;
++-+    c->snext = c->mon->stack;
++-+    c->mon->stack = c;
++-+}
++-+
++-+void
++-+swallow(Client *p, Client *c)
++-+{
++-+    if (c->noswallow || c->isterminal)
++-+        return;
++-+    if (!swallowfloating && c->isfloating)
++-+        return;
++-+
++-+    detach(c);
++-+    detachstack(c);
++-+
++-+    setclientstate(c, WithdrawnState);
++-+    XUnmapWindow(dpy, p->win);
++-+
++-+    p->swallowing = c;
++-+    c->mon = p->mon;
++-+
++-+    Window w = p->win;
++-+    p->win = c->win;
++-+    c->win = w;
++-+    updatetitle(p);
++-+
++-+    XWindowChanges wc;
++-+    wc.border_width = p->bw;
++-+    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
++-+    XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++-+    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
++-+
++-+    arrange(p->mon);
++-+    configure(p);
++-+    updateclientlist();
++-+}
++-+
++-+void
++-+unswallow(Client *c)
++-+{
++-+    c->win = c->swallowing->win;
++-+
++-+    free(c->swallowing);
++-+    c->swallowing = NULL;
++-+
++-+    /* unfullscreen the client */
++-+    setfullscreen(c, 0);
++-+    updatetitle(c);
++-+    arrange(c->mon);
++-+    XMapWindow(dpy, c->win);
++-+
++-+    XWindowChanges wc;
++-+    wc.border_width = c->bw;
++-+    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
++-+    XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++-+    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++-+
++-+    setclientstate(c, NormalState);
++-+    focus(NULL);
++-+    arrange(c->mon);
++- }
++- 
++- void
++- buttonpress(XEvent *e)
++- {
++--	unsigned int i, x, click;
++--	Arg arg = {0};
++--	Client *c;
++--	Monitor *m;
++--	XButtonPressedEvent *ev = &e->xbutton;
++--
++--	click = ClkRootWin;
++--	/* focus monitor if necessary */
++--	if ((m = wintomon(ev->window)) && m != selmon) {
++--		unfocus(selmon->sel, 1);
++--		selmon = m;
++--		focus(NULL);
++--	}
++--	if (ev->window == selmon->barwin) {
++--		i = x = 0;
++--		do
++--			x += TEXTW(tags[i]);
++--		while (ev->x >= x && ++i < LENGTH(tags));
++--		if (i < LENGTH(tags)) {
++--			click = ClkTagBar;
++--			arg.ui = 1 << i;
++--		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++--			click = ClkLtSymbol;
++--		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++--			click = ClkStatusText;
++--		else
++--			click = ClkWinTitle;
++--	} else if ((c = wintoclient(ev->window))) {
++--		focus(c);
++--		restack(selmon);
++--		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++--		click = ClkClientWin;
++--	}
++--	for (i = 0; i < LENGTH(buttons); i++)
++--		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
++--		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
++--			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
++-+    unsigned int i, x, click, occ = 0;
++-+    Arg arg = {0};
++-+    Client *c;
++-+    Monitor *m;
++-+    XButtonPressedEvent *ev = &e->xbutton;
++-+
++-+    click = ClkRootWin;
++-+    /* focus monitor if necessary */
++-+    if ((m = wintomon(ev->window)) && m != selmon) {
++-+        unfocus(selmon->sel, 1);
++-+        selmon = m;
++-+        focus(NULL);
++-+    }
++-+    if (ev->window == selmon->barwin) {
++-+        i = x = 0;
++-+        for (c = m->clients; c; c = c->next)
++-+            occ |= c->tags == 255 ? 0 : c->tags;
++-+        do {
++-+            /* do not reserve space for vacant tags */
++-+            if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++-+                continue;
++-+            x += TEXTW(tags[i]);
++-+        } while (ev->x >= x && ++i < LENGTH(tags));
++-+        if (i < LENGTH(tags)) {
++-+            click = ClkTagBar;
++-+            arg.ui = 1 << i;
++-+        } else if (ev->x < x + TEXTW(selmon->ltsymbol))
++-+            click = ClkLtSymbol;
++-+        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
++-+            click = ClkStatusText;
++-+
++-+            char *text = rawstext;
++-+            int i = -1;
++-+            char ch;
++-+            dwmblockssig = 0;
++-+            while (text[++i]) {
++-+                if ((unsigned char)text[i] < ' ') {
++-+                    ch = text[i];
++-+                    text[i] = '\0';
++-+                    x += TEXTW(text) - lrpad;
++-+                    text[i] = ch;
++-+                    text += i+1;
++-+                    i = -1;
++-+                    if (x >= ev->x) break;
++-+                    dwmblockssig = ch;
++-+                }
++-+            }
++-+        } else
++-+            click = ClkWinTitle;
++-+    } else if ((c = wintoclient(ev->window))) {
++-+        focus(c);
++-+        restack(selmon);
++-+        XAllowEvents(dpy, ReplayPointer, CurrentTime);
++-+        click = ClkClientWin;
++-+    }
++-+    for (i = 0; i < LENGTH(buttons); i++)
++-+        if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
++-+                && CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
++-+            buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
++- }
++- 
++- void
++- checkotherwm(void)
++- {
++--	xerrorxlib = XSetErrorHandler(xerrorstart);
++--	/* this causes an error if some other window manager is running */
++--	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
++--	XSync(dpy, False);
++--	XSetErrorHandler(xerror);
++--	XSync(dpy, False);
++-+    xerrorxlib = XSetErrorHandler(xerrorstart);
++-+    /* this causes an error if some other window manager is running */
++-+    XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
++-+    XSync(dpy, False);
++-+    XSetErrorHandler(xerror);
++-+    XSync(dpy, False);
++- }
++- 
++- void
++- cleanup(void)
++- {
++--	Arg a = {.ui = ~0};
++--	Layout foo = { "", NULL };
++--	Monitor *m;
++--	size_t i;
++--
++--	view(&a);
++--	selmon->lt[selmon->sellt] = &foo;
++--	for (m = mons; m; m = m->next)
++--		while (m->stack)
++--			unmanage(m->stack, 0);
++--	XUngrabKey(dpy, AnyKey, AnyModifier, root);
++--	while (mons)
++--		cleanupmon(mons);
++--	for (i = 0; i < CurLast; i++)
++--		drw_cur_free(drw, cursor[i]);
++--	for (i = 0; i < LENGTH(colors); i++)
++--		free(scheme[i]);
++--	free(scheme);
++--	XDestroyWindow(dpy, wmcheckwin);
++--	drw_free(drw);
++--	XSync(dpy, False);
++--	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
++--	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+    Arg a = {.ui = ~0};
++-+    Layout foo = { "", NULL };
++-+    Monitor *m;
++-+    size_t i;
++-+
++-+    view(&a);
++-+    selmon->lt[selmon->sellt] = &foo;
++-+    for (m = mons; m; m = m->next)
++-+        while (m->stack)
++-+            unmanage(m->stack, 0);
++-+    XUngrabKey(dpy, AnyKey, AnyModifier, root);
++-+    while (mons)
++-+        cleanupmon(mons);
++-+    for (i = 0; i < CurLast; i++)
++-+        drw_cur_free(drw, cursor[i]);
++-+    /* for (i = 0; i < LENGTH(colors); i++) */
++-+    for (i = 0; i < LENGTH(colors) + 1; i++)
++-+        free(scheme[i]);
++-+    free(scheme);
++-+    XDestroyWindow(dpy, wmcheckwin);
++-+    drw_free(drw);
++-+    XSync(dpy, False);
++-+    XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
++-+    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++- }
++- 
++- void
++- cleanupmon(Monitor *mon)
++- {
++--	Monitor *m;
++-+    Monitor *m;
++- 
++--	if (mon == mons)
++--		mons = mons->next;
++--	else {
++--		for (m = mons; m && m->next != mon; m = m->next);
++--		m->next = mon->next;
++--	}
++--	XUnmapWindow(dpy, mon->barwin);
++--	XDestroyWindow(dpy, mon->barwin);
++--	free(mon);
++-+    if (mon == mons)
++-+        mons = mons->next;
++-+    else {
++-+        for (m = mons; m && m->next != mon; m = m->next);
++-+        m->next = mon->next;
++-+    }
++-+    XUnmapWindow(dpy, mon->barwin);
++-+    XDestroyWindow(dpy, mon->barwin);
++-+    free(mon);
++- }
++- 
++- void
++- clientmessage(XEvent *e)
++- {
++--	XClientMessageEvent *cme = &e->xclient;
++--	Client *c = wintoclient(cme->window);
++-+    XClientMessageEvent *cme = &e->xclient;
++-+    Client *c = wintoclient(cme->window);
++- 
++--	if (!c)
++--		return;
++--	if (cme->message_type == netatom[NetWMState]) {
++--		if (cme->data.l[1] == netatom[NetWMFullscreen]
++--		|| cme->data.l[2] == netatom[NetWMFullscreen])
++--			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++--				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++--	} else if (cme->message_type == netatom[NetActiveWindow]) {
++--		if (c != selmon->sel && !c->isurgent)
++--			seturgent(c, 1);
++--	}
++-+    if (!c)
++-+        return;
++-+    if (cme->message_type == netatom[NetWMState]) {
++-+        if (cme->data.l[1] == netatom[NetWMFullscreen]
++-+                || cme->data.l[2] == netatom[NetWMFullscreen])
++-+            setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++-+                        || (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++-+    } else if (cme->message_type == netatom[NetActiveWindow]) {
++-+        if (c != selmon->sel && !c->isurgent)
++-+            seturgent(c, 1);
++-+    }
++- }
++- 
++- void
++- configure(Client *c)
++- {
++--	XConfigureEvent ce;
++-+    XConfigureEvent ce;
++- 
++--	ce.type = ConfigureNotify;
++--	ce.display = dpy;
++--	ce.event = c->win;
++--	ce.window = c->win;
++--	ce.x = c->x;
++--	ce.y = c->y;
++--	ce.width = c->w;
++--	ce.height = c->h;
++--	ce.border_width = c->bw;
++--	ce.above = None;
++--	ce.override_redirect = False;
++--	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
++-+    ce.type = ConfigureNotify;
++-+    ce.display = dpy;
++-+    ce.event = c->win;
++-+    ce.window = c->win;
++-+    ce.x = c->x;
++-+    ce.y = c->y;
++-+    ce.width = c->w;
++-+    ce.height = c->h;
++-+    ce.border_width = c->bw;
++-+    ce.above = None;
++-+    ce.override_redirect = False;
++-+    XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
++- }
++- 
++- void
++- configurenotify(XEvent *e)
++- {
++--	Monitor *m;
++--	Client *c;
++--	XConfigureEvent *ev = &e->xconfigure;
++--	int dirty;
++--
++--	/* TODO: updategeom handling sucks, needs to be simplified */
++--	if (ev->window == root) {
++--		dirty = (sw != ev->width || sh != ev->height);
++--		sw = ev->width;
++--		sh = ev->height;
++--		if (updategeom() || dirty) {
++--			drw_resize(drw, sw, bh);
++--			updatebars();
++--			for (m = mons; m; m = m->next) {
++--				for (c = m->clients; c; c = c->next)
++--					if (c->isfullscreen)
++--						resizeclient(c, m->mx, m->my, m->mw, m->mh);
++--				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++--			}
++--			focus(NULL);
++--			arrange(NULL);
++--		}
++--	}
++-+    Monitor *m;
++-+    Client *c;
++-+    XConfigureEvent *ev = &e->xconfigure;
++-+    int dirty;
++-+
++-+    /* TODO: updategeom handling sucks, needs to be simplified */
++-+    if (ev->window == root) {
++-+        dirty = (sw != ev->width || sh != ev->height);
++-+        sw = ev->width;
++-+        sh = ev->height;
++-+        if (updategeom() || dirty) {
++-+            drw_resize(drw, sw, bh);
++-+            updatebars();
++-+            for (m = mons; m; m = m->next) {
++-+                for (c = m->clients; c; c = c->next)
++-+                    if (c->isfullscreen)
++-+                        resizeclient(c, m->mx, m->my, m->mw, m->mh);
++-+                XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++-+            }
++-+            focus(NULL);
++-+            arrange(NULL);
++-+        }
++-+    }
++- }
++- 
++- void
++- configurerequest(XEvent *e)
++- {
++--	Client *c;
++--	Monitor *m;
++--	XConfigureRequestEvent *ev = &e->xconfigurerequest;
++--	XWindowChanges wc;
++--
++--	if ((c = wintoclient(ev->window))) {
++--		if (ev->value_mask & CWBorderWidth)
++--			c->bw = ev->border_width;
++--		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
++--			m = c->mon;
++--			if (ev->value_mask & CWX) {
++--				c->oldx = c->x;
++--				c->x = m->mx + ev->x;
++--			}
++--			if (ev->value_mask & CWY) {
++--				c->oldy = c->y;
++--				c->y = m->my + ev->y;
++--			}
++--			if (ev->value_mask & CWWidth) {
++--				c->oldw = c->w;
++--				c->w = ev->width;
++--			}
++--			if (ev->value_mask & CWHeight) {
++--				c->oldh = c->h;
++--				c->h = ev->height;
++--			}
++--			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
++--				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
++--			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
++--				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
++--			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
++--				configure(c);
++--			if (ISVISIBLE(c))
++--				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++--		} else
++--			configure(c);
++--	} else {
++--		wc.x = ev->x;
++--		wc.y = ev->y;
++--		wc.width = ev->width;
++--		wc.height = ev->height;
++--		wc.border_width = ev->border_width;
++--		wc.sibling = ev->above;
++--		wc.stack_mode = ev->detail;
++--		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
++--	}
++--	XSync(dpy, False);
++-+    Client *c;
++-+    Monitor *m;
++-+    XConfigureRequestEvent *ev = &e->xconfigurerequest;
++-+    XWindowChanges wc;
++-+
++-+    if ((c = wintoclient(ev->window))) {
++-+        if (ev->value_mask & CWBorderWidth)
++-+            c->bw = ev->border_width;
++-+        else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
++-+            m = c->mon;
++-+            if (ev->value_mask & CWX) {
++-+                c->oldx = c->x;
++-+                c->x = m->mx + ev->x;
++-+            }
++-+            if (ev->value_mask & CWY) {
++-+                c->oldy = c->y;
++-+                c->y = m->my + ev->y;
++-+            }
++-+            if (ev->value_mask & CWWidth) {
++-+                c->oldw = c->w;
++-+                c->w = ev->width;
++-+            }
++-+            if (ev->value_mask & CWHeight) {
++-+                c->oldh = c->h;
++-+                c->h = ev->height;
++-+            }
++-+            if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
++-+                c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
++-+            if ((c->y + c->h) > m->my + m->mh && c->isfloating)
++-+                c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
++-+            if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
++-+                configure(c);
++-+            if (ISVISIBLE(c))
++-+                XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++-+        } else
++-+            configure(c);
++-+    } else {
++-+        wc.x = ev->x;
++-+        wc.y = ev->y;
++-+        wc.width = ev->width;
++-+        wc.height = ev->height;
++-+        wc.border_width = ev->border_width;
++-+        wc.sibling = ev->above;
++-+        wc.stack_mode = ev->detail;
++-+        XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
++-+    }
++-+    XSync(dpy, False);
++-+}
++-+
++-+void
++-+copyvalidchars(char *text, char *rawtext)
++-+{
++-+    int i = -1, j = 0;
++-+
++-+    while(rawtext[++i]) {
++-+        if ((unsigned char)rawtext[i] >= ' ') {
++-+            text[j++] = rawtext[i];
++-+        }
++-+    }
++-+    text[j] = '\0';
++- }
++- 
++- Monitor *
++- createmon(void)
++- {
++--	Monitor *m;
++-+    Monitor *m;
++- 
++--	m = ecalloc(1, sizeof(Monitor));
++--	m->tagset[0] = m->tagset[1] = 1;
++--	m->mfact = mfact;
++--	m->nmaster = nmaster;
++--	m->showbar = showbar;
++--	m->topbar = topbar;
++--	m->lt[0] = &layouts[0];
++--	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++--	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++--	return m;
++-+    m = ecalloc(1, sizeof(Monitor));
++-+    m->tagset[0] = m->tagset[1] = 1;
++-+    m->mfact = mfact;
++-+    m->nmaster = nmaster;
++-+    m->showbar = showbar;
++-+    m->topbar = topbar;
++-+    m->gappih = gappih;
++-+    m->gappiv = gappiv;
++-+    m->gappoh = gappoh;
++-+    m->gappov = gappov;
++-+    m->lt[0] = &layouts[0];
++-+    m->lt[1] = &layouts[1 % LENGTH(layouts)];
++-+    strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++-+    return m;
++- }
++- 
++- void
++- destroynotify(XEvent *e)
++- {
++--	Client *c;
++--	XDestroyWindowEvent *ev = &e->xdestroywindow;
++-+    Client *c;
++-+    XDestroyWindowEvent *ev = &e->xdestroywindow;
++-+
++-+    if ((c = wintoclient(ev->window)))
++-+        unmanage(c, 1);
++- 
++--	if ((c = wintoclient(ev->window)))
++--		unmanage(c, 1);
++-+    else if ((c = swallowingclient(ev->window)))
++-+        unmanage(c->swallowing, 1);
++- }
++- 
++- void
++- detach(Client *c)
++- {
++--	Client **tc;
++-+    Client **tc;
++- 
++--	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
++--	*tc = c->next;
++-+    for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
++-+    *tc = c->next;
++- }
++- 
++- void
++- detachstack(Client *c)
++- {
++--	Client **tc, *t;
++-+    Client **tc, *t;
++- 
++--	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
++--	*tc = c->snext;
++-+    for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
++-+    *tc = c->snext;
++- 
++--	if (c == c->mon->sel) {
++--		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
++--		c->mon->sel = t;
++--	}
++-+    if (c == c->mon->sel) {
++-+        for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
++-+        c->mon->sel = t;
++-+    }
++- }
++- 
++- Monitor *
++- dirtomon(int dir)
++- {
++--	Monitor *m = NULL;
++-+    Monitor *m = NULL;
++- 
++--	if (dir > 0) {
++--		if (!(m = selmon->next))
++--			m = mons;
++--	} else if (selmon == mons)
++--		for (m = mons; m->next; m = m->next);
++--	else
++--		for (m = mons; m->next != selmon; m = m->next);
++--	return m;
++-+    if (dir > 0) {
++-+        if (!(m = selmon->next))
++-+            m = mons;
++-+    } else if (selmon == mons)
++-+        for (m = mons; m->next; m = m->next);
++-+    else
++-+        for (m = mons; m->next != selmon; m = m->next);
++-+    return m;
++- }
++- 
++--void
++--drawbar(Monitor *m)
++--{
++--	int x, w, tw = 0;
++--	int boxs = drw->fonts->h / 9;
++--	int boxw = drw->fonts->h / 6 + 2;
++--	unsigned int i, occ = 0, urg = 0;
++--	Client *c;
++--
++--	if (!m->showbar)
++--		return;
++--
++--	/* draw status first so it can be overdrawn by tags later */
++--	if (m == selmon) { /* status is only drawn on selected monitor */
++--		drw_setscheme(drw, scheme[SchemeNorm]);
++--		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
++--		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++--	}
++--
++--	for (c = m->clients; c; c = c->next) {
++--		occ |= c->tags;
++--		if (c->isurgent)
++--			urg |= c->tags;
++--	}
++--	x = 0;
++--	for (i = 0; i < LENGTH(tags); i++) {
++--		w = TEXTW(tags[i]);
++--		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++--		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++--		if (occ & 1 << i)
++--			drw_rect(drw, x + boxs, boxs, boxw, boxw,
++--				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
++--				urg & 1 << i);
++--		x += w;
++--	}
++--	w = TEXTW(m->ltsymbol);
++--	drw_setscheme(drw, scheme[SchemeNorm]);
++--	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++--
++--	if ((w = m->ww - tw - x) > bh) {
++--		if (m->sel) {
++--			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
++--			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++--			if (m->sel->isfloating)
++--				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
++--		} else {
++--			drw_setscheme(drw, scheme[SchemeNorm]);
++--			drw_rect(drw, x, 0, w, bh, 1, 1);
++--		}
++--	}
++--	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++-+int
++-+drawstatusbar(Monitor *m, int bh, char* stext)
++-+{
++-+    int ret, i, w, x, len;
++-+    short isCode = 0;
++-+    char *text;
++-+    char *p;
++-+    FILE *ptr;
++-+    char ch;
++-+    int hotbool = 0;
++-+
++-+    len = strlen(stext) + 1 ;
++-+    if (!(text = (char*) malloc(sizeof(char)*len)))
++-+        die("malloc");
++-+    p = text;
++-+    memcpy(text, stext, len);
++-+
++-+    /* compute width of the status text */
++-+    w = 0;
++-+    i = -1;
++-+    while (text[++i]) {
++-+        if (text[i] == '^') {
++-+            if (!isCode) {
++-+                isCode = 1;
++-+                text[i] = '\0';
++-+                w += TEXTW(text) - lrpad;
++-+                text[i] = '^';
++-+                if (text[++i] == 'f')
++-+                    w += atoi(text + ++i);
++-+            } else {
++-+                isCode = 0;
++-+                text = text + i + 1;
++-+                i = -1;
++-+            }
++-+        }
++-+    }
++-+    if (!isCode)
++-+        w += TEXTW(text) - lrpad;
++-+    else
++-+        isCode = 0;
++-+    text = p;
++-+
++-+    w += 2; /* 1px padding on both sides */
++-+    ret = x = m->ww - w;
++-+
++-+    drw_setscheme(drw, scheme[LENGTH(colors)]);
++-+    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++-+    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++-+    drw_rect(drw, x, 0, w, bh, 1, 1);
++-+    x++;
++-+
++-+    /* process status text */
++-+    i = -1;
++-+    drw_clr_create(drw, &drw->scheme[ColFg], col1);
++-+
++-+    while (text[++i]) {
++-+        if (text[i] == '^' && !isCode) {
++-+            isCode = 1;
++-+
++-+            text[i] = '\0';
++-+            w = TEXTW(text) - lrpad;
++-+            drw_text(drw, x, 0, w, bh, 0, text, 0);
++-+            x += w;
++-+
++-+            while (text[++i] != '^') {
++-+                if (text[i] == '2') {
++-+                    // Check if weather is hot or not
++-+                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
++-+                    if (ptr == NULL) printf("Fail to read wr...");
++-+                    do{
++-+                        ch = fgetc(ptr);
++-+                        // Check if contains + and 2 (= hot)
++-+                        if (hotbool){
++-+                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
++-+                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
++-+                                break;
++-+                            }else{
++-+                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
++-+                                break;
++-+                            }
++-+                        }
++-+
++-+                        if (ch == '+'){
++-+                            hotbool = 1;
++-+                        }else if (ch == '-') {
++-+                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
++-+                            break;
++-+                        }
++-+                        else{
++-+                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
++-+                            break;
++-+                        }
++-+                    } while (ch != EOF);
++-+                    fclose(ptr);
++-+                } else if (text[i] == '3') {
++-+                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
++-+                } else if (text[i] == '4') {
++-+                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
++-+                } else if (text[i] == '5') {
++-+                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
++-+                } else if (text[i] == '6') {
++-+                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
++-+                }
++-+            }
++-+
++-+            text = text + i + 1;
++-+            i=-1;
++-+            isCode = 0;
++-+        }
++-+    }
++-+
++-+    if (!isCode) {
++-+        w = TEXTW(text) - lrpad;
++-+        drw_text(drw, x, 0, w, bh, 0, text, 0);
++-+    }
++-+
++-+    drw_setscheme(drw, scheme[SchemeNorm]);
++-+    free(p);
++-+
++-+    return ret;
++- }
++- 
++- void
++--drawbars(void)
++-+drawbar(Monitor *m)
++- {
++--	Monitor *m;
++--
++--	for (m = mons; m; m = m->next)
++--		drawbar(m);
++-+    if (!m->showbar) return;
++-+    int x, w, tw = 0;
++-+    int boxs = drw->fonts->h / 9;
++-+    int boxw = drw->fonts->h / 6 + 2;
++-+    unsigned int i, occ = 0, urg = 0;
++-+    Client *c;
++-+
++-+    /* draw status first so it can be overdrawn by tags later */
++-+    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
++-+    if (m == selmon || 1) { 
++-+        tw = m->ww - drawstatusbar(m, bh, stext);
++-+    }
++-+
++-+    for (c = m->clients; c; c = c->next) {
++-+        occ |= c->tags == 255 ? 0 : c->tags;
++-+        if (c->isurgent)
++-+            urg |= c->tags;
++-+    }
++-+    x = 0;
++-+    for (i = 0; i < LENGTH(tags); i++) {
++-+        /* do not draw vacant tags */
++-+        if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++-+            continue;
++-+
++-+        w = TEXTW(tags[i]);
++-+        drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++-+        drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++-+        x += w;
++-+    }
++-+    w = TEXTW(m->ltsymbol);
++-+    drw_setscheme(drw, scheme[SchemeNorm]);
++-+    x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++-+
++-+    if ((w = m->ww - tw - x) > bh) {
++-+        drw_setscheme(drw, scheme[SchemeNorm]);
++-+        drw_rect(drw, x, 0, w, bh, 1, 1);
++-+    }
++-+    drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++- }
++- 
++- void
++--enternotify(XEvent *e)
++-+drawbars(void)
++- {
++--	Client *c;
++--	Monitor *m;
++--	XCrossingEvent *ev = &e->xcrossing;
++-+    Monitor *m;
++- 
++--	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++--		return;
++--	c = wintoclient(ev->window);
++--	m = c ? c->mon : wintomon(ev->window);
++--	if (m != selmon) {
++--		unfocus(selmon->sel, 1);
++--		selmon = m;
++--	} else if (!c || c == selmon->sel)
++--		return;
++--	focus(c);
++-+    for (m = mons; m; m = m->next)
++-+        drawbar(m);
++- }
++- 
++- void
++- expose(XEvent *e)
++- {
++--	Monitor *m;
++--	XExposeEvent *ev = &e->xexpose;
++-+    Monitor *m;
++-+    XExposeEvent *ev = &e->xexpose;
++- 
++--	if (ev->count == 0 && (m = wintomon(ev->window)))
++--		drawbar(m);
++-+    if (ev->count == 0 && (m = wintomon(ev->window)))
++-+        drawbar(m);
++- }
++- 
++- void
++- focus(Client *c)
++- {
++--	if (!c || !ISVISIBLE(c))
++--		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
++--	if (selmon->sel && selmon->sel != c)
++--		unfocus(selmon->sel, 0);
++--	if (c) {
++--		if (c->mon != selmon)
++--			selmon = c->mon;
++--		if (c->isurgent)
++--			seturgent(c, 0);
++--		detachstack(c);
++--		attachstack(c);
++--		grabbuttons(c, 1);
++--		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
++--		setfocus(c);
++--	} else {
++--		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++--		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++--	}
++--	selmon->sel = c;
++--	drawbars();
++-+    if (!c || !ISVISIBLE(c))
++-+        for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
++-+    if (selmon->sel && selmon->sel != c)
++-+        unfocus(selmon->sel, 0);
++-+    if (c) {
++-+        if (c->mon != selmon)
++-+            selmon = c->mon;
++-+        if (c->isurgent)
++-+            seturgent(c, 0);
++-+        detachstack(c);
++-+        attachstack(c);
++-+        grabbuttons(c, 1);
++-+        XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
++-+        setfocus(c);
++-+    } else {
++-+        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++-+        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+    }
++-+    selmon->sel = c;
++-+    drawbars();
++- }
++- 
++- /* there are some broken focus acquiring clients needing extra handling */
++- void
++- focusin(XEvent *e)
++- {
++--	XFocusChangeEvent *ev = &e->xfocus;
++-+    XFocusChangeEvent *ev = &e->xfocus;
++- 
++--	if (selmon->sel && ev->window != selmon->sel->win)
++--		setfocus(selmon->sel);
++-+    if (selmon->sel && ev->window != selmon->sel->win)
++-+        setfocus(selmon->sel);
++- }
++- 
++- void
++- focusmon(const Arg *arg)
++- {
++--	Monitor *m;
++-+    Monitor *m;
++- 
++--	if (!mons->next)
++--		return;
++--	if ((m = dirtomon(arg->i)) == selmon)
++--		return;
++--	unfocus(selmon->sel, 0);
++--	selmon = m;
++--	focus(NULL);
++-+    if (!mons->next)
++-+        return;
++-+    if ((m = dirtomon(arg->i)) == selmon)
++-+        return;
++-+    unfocus(selmon->sel, 0);
++-+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++-+    selmon = m;
++-+    focus(NULL);
++- }
++- 
++- void
++- focusstack(const Arg *arg)
++- {
++--	Client *c = NULL, *i;
++--
++--	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++--		return;
++--	if (arg->i > 0) {
++--		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
++--		if (!c)
++--			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
++--	} else {
++--		for (i = selmon->clients; i != selmon->sel; i = i->next)
++--			if (ISVISIBLE(i))
++--				c = i;
++--		if (!c)
++--			for (; i; i = i->next)
++--				if (ISVISIBLE(i))
++--					c = i;
++--	}
++--	if (c) {
++--		focus(c);
++--		restack(selmon);
++--	}
++-+    int i = stackpos(arg);
++-+    Client *c, *p;
++-+
++-+    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
++-+        return;
++-+
++-+    for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++-+            i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++-+    focus(c ? c : p);
++-+    restack(selmon);
++- }
++- 
++- Atom
++- getatomprop(Client *c, Atom prop)
++- {
++--	int di;
++--	unsigned long dl;
++--	unsigned char *p = NULL;
++--	Atom da, atom = None;
++-+    int di;
++-+    unsigned long dl;
++-+    unsigned char *p = NULL;
++-+    Atom da, atom = None;
++- 
++--	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
++--		&da, &di, &dl, &dl, &p) == Success && p) {
++--		atom = *(Atom *)p;
++--		XFree(p);
++--	}
++--	return atom;
++-+    if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
++-+                &da, &di, &dl, &dl, &p) == Success && p) {
++-+        atom = *(Atom *)p;
++-+        XFree(p);
++-+    }
++-+    return atom;
++- }
++- 
++-+#ifndef __OpenBSD__
++-+int getdwmblockspid()
++-+{
++-+    char buf[16];
++-+    FILE *fp = popen("pidof -s dwmblocks", "r");
++-+    fgets(buf, sizeof(buf), fp);
++-+    pid_t pid = strtoul(buf, NULL, 10);
++-+    pclose(fp);
++-+    dwmblockspid = pid;
++-+    return pid != 0 ? 0 : -1;
++-+}
++-+#endif
++-+
++- int
++- getrootptr(int *x, int *y)
++- {
++--	int di;
++--	unsigned int dui;
++--	Window dummy;
++-+    int di;
++-+    unsigned int dui;
++-+    Window dummy;
++- 
++--	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
++-+    return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
++- }
++- 
++- long
++- getstate(Window w)
++- {
++--	int format;
++--	long result = -1;
++--	unsigned char *p = NULL;
++--	unsigned long n, extra;
++--	Atom real;
++-+    int format;
++-+    long result = -1;
++-+    unsigned char *p = NULL;
++-+    unsigned long n, extra;
++-+    Atom real;
++- 
++--	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
++--		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
++--		return -1;
++--	if (n != 0)
++--		result = *p;
++--	XFree(p);
++--	return result;
++-+    if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
++-+                &real, &format, &n, &extra, (unsigned char **)&p) != Success)
++-+        return -1;
++-+    if (n != 0)
++-+        result = *p;
++-+    XFree(p);
++-+    return result;
++- }
++- 
++- int
++- gettextprop(Window w, Atom atom, char *text, unsigned int size)
++- {
++--	char **list = NULL;
++--	int n;
++--	XTextProperty name;
++--
++--	if (!text || size == 0)
++--		return 0;
++--	text[0] = '\0';
++--	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++--		return 0;
++--	if (name.encoding == XA_STRING) {
++--		strncpy(text, (char *)name.value, size - 1);
++--	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++--		strncpy(text, *list, size - 1);
++--		XFreeStringList(list);
++--	}
++--	text[size - 1] = '\0';
++--	XFree(name.value);
++--	return 1;
++-+    char **list = NULL;
++-+    int n;
++-+    XTextProperty name;
++-+
++-+    if (!text || size == 0)
++-+        return 0;
++-+    text[0] = '\0';
++-+    if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++-+        return 0;
++-+    if (name.encoding == XA_STRING)
++-+        strncpy(text, (char *)name.value, size - 1);
++-+    else {
++-+        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++-+            strncpy(text, *list, size - 1);
++-+            XFreeStringList(list);
++-+        }
++-+    }
++-+    text[size - 1] = '\0';
++-+    XFree(name.value);
++-+    return 1;
++- }
++- 
++- void
++- grabbuttons(Client *c, int focused)
++- {
++--	updatenumlockmask();
++--	{
++--		unsigned int i, j;
++--		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++--		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++--		if (!focused)
++--			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
++--				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
++--		for (i = 0; i < LENGTH(buttons); i++)
++--			if (buttons[i].click == ClkClientWin)
++--				for (j = 0; j < LENGTH(modifiers); j++)
++--					XGrabButton(dpy, buttons[i].button,
++--						buttons[i].mask | modifiers[j],
++--						c->win, False, BUTTONMASK,
++--						GrabModeAsync, GrabModeSync, None, None);
++--	}
++-+    updatenumlockmask();
++-+    {
++-+        unsigned int i, j;
++-+        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++-+        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++-+        if (!focused)
++-+            XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
++-+                    BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
++-+        for (i = 0; i < LENGTH(buttons); i++)
++-+            if (buttons[i].click == ClkClientWin)
++-+                for (j = 0; j < LENGTH(modifiers); j++)
++-+                    XGrabButton(dpy, buttons[i].button,
++-+                            buttons[i].mask | modifiers[j],
++-+                            c->win, False, BUTTONMASK,
++-+                            GrabModeAsync, GrabModeSync, None, None);
++-+    }
++- }
++- 
++- void
++- grabkeys(void)
++- {
++--	updatenumlockmask();
++--	{
++--		unsigned int i, j, k;
++--		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++--		int start, end, skip;
++--		KeySym *syms;
++--
++--		XUngrabKey(dpy, AnyKey, AnyModifier, root);
++--		XDisplayKeycodes(dpy, &start, &end);
++--		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
++--		if (!syms)
++--			return;
++--		for (k = start; k <= end; k++)
++--			for (i = 0; i < LENGTH(keys); i++)
++--				/* skip modifier codes, we do that ourselves */
++--				if (keys[i].keysym == syms[(k - start) * skip])
++--					for (j = 0; j < LENGTH(modifiers); j++)
++--						XGrabKey(dpy, k,
++--							 keys[i].mod | modifiers[j],
++--							 root, True,
++--							 GrabModeAsync, GrabModeAsync);
++--		XFree(syms);
++--	}
++-+    updatenumlockmask();
++-+    {
++-+        unsigned int i, j, k;
++-+        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++-+        int start, end, skip;
++-+        KeySym *syms;
++-+
++-+        XUngrabKey(dpy, AnyKey, AnyModifier, root);
++-+        XDisplayKeycodes(dpy, &start, &end);
++-+        syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
++-+        if (!syms)
++-+            return;
++-+        for (k = start; k <= end; k++)
++-+            for (i = 0; i < LENGTH(keys); i++)
++-+                /* skip modifier codes, we do that ourselves */
++-+                if (keys[i].keysym == syms[(k - start) * skip])
++-+                    for (j = 0; j < LENGTH(modifiers); j++)
++-+                        XGrabKey(dpy, k,
++-+                                keys[i].mod | modifiers[j],
++-+                                root, True,
++-+                                GrabModeAsync, GrabModeAsync);
++-+        XFree(syms);
++-+    }
++- }
++- 
++- void
++- incnmaster(const Arg *arg)
++- {
++--	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++--	arrange(selmon);
++-+    selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++-+    arrange(selmon);
++- }
++- 
++- #ifdef XINERAMA
++--static int
++--isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++-+static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++- {
++--	while (n--)
++--		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++--		&& unique[n].width == info->width && unique[n].height == info->height)
++--			return 0;
++--	return 1;
++-+    while (n--)
++-+        if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++-+                && unique[n].width == info->width && unique[n].height == info->height)
++-+            return 0;
++-+    return 1;
++- }
++- #endif /* XINERAMA */
++- 
++- void
++- keypress(XEvent *e)
++- {
++--	unsigned int i;
++--	KeySym keysym;
++--	XKeyEvent *ev;
++-+    unsigned int i;
++-+    KeySym keysym;
++-+    XKeyEvent *ev;
++- 
++--	ev = &e->xkey;
++--	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
++--	for (i = 0; i < LENGTH(keys); i++)
++--		if (keysym == keys[i].keysym
++--		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
++--		&& keys[i].func)
++--			keys[i].func(&(keys[i].arg));
++-+    ev = &e->xkey;
++-+    keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
++-+    for (i = 0; i < LENGTH(keys); i++)
++-+        if (keysym == keys[i].keysym
++-+                && CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
++-+                && keys[i].func)
++-+            keys[i].func(&(keys[i].arg));
++- }
++- 
++- void
++- killclient(const Arg *arg)
++- {
++--	if (!selmon->sel)
++--		return;
++--	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
++--		XGrabServer(dpy);
++--		XSetErrorHandler(xerrordummy);
++--		XSetCloseDownMode(dpy, DestroyAll);
++--		XKillClient(dpy, selmon->sel->win);
++--		XSync(dpy, False);
++--		XSetErrorHandler(xerror);
++--		XUngrabServer(dpy);
++--	}
++-+    if (!selmon->sel)
++-+        return;
++-+    if (!sendevent(selmon->sel, wmatom[WMDelete])) {
++-+        XGrabServer(dpy);
++-+        XSetErrorHandler(xerrordummy);
++-+        XSetCloseDownMode(dpy, DestroyAll);
++-+        XKillClient(dpy, selmon->sel->win);
++-+        XSync(dpy, False);
++-+        XSetErrorHandler(xerror);
++-+        XUngrabServer(dpy);
++-+    }
++- }
++- 
++- void
++- manage(Window w, XWindowAttributes *wa)
++- {
++--	Client *c, *t = NULL;
++--	Window trans = None;
++--	XWindowChanges wc;
++--
++--	c = ecalloc(1, sizeof(Client));
++--	c->win = w;
++--	/* geometry */
++--	c->x = c->oldx = wa->x;
++--	c->y = c->oldy = wa->y;
++--	c->w = c->oldw = wa->width;
++--	c->h = c->oldh = wa->height;
++--	c->oldbw = wa->border_width;
++--
++--	updatetitle(c);
++--	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++--		c->mon = t->mon;
++--		c->tags = t->tags;
++--	} else {
++--		c->mon = selmon;
++--		applyrules(c);
++--	}
++--
++--	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++--		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
++--	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
++--		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
++--	c->x = MAX(c->x, c->mon->wx);
++--	c->y = MAX(c->y, c->mon->wy);
++--	c->bw = borderpx;
++--
++--	wc.border_width = c->bw;
++--	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++--	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++--	configure(c); /* propagates border_width, if size doesn't change */
++--	updatewindowtype(c);
++--	updatesizehints(c);
++--	updatewmhints(c);
++--	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++--	grabbuttons(c, 0);
++--	if (!c->isfloating)
++--		c->isfloating = c->oldstate = trans != None || c->isfixed;
++--	if (c->isfloating)
++--		XRaiseWindow(dpy, c->win);
++--	attach(c);
++--	attachstack(c);
++--	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++--		(unsigned char *) &(c->win), 1);
++--	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
++--	setclientstate(c, NormalState);
++--	if (c->mon == selmon)
++--		unfocus(selmon->sel, 0);
++--	c->mon->sel = c;
++--	arrange(c->mon);
++--	XMapWindow(dpy, c->win);
++--	focus(NULL);
++-+    Client *c, *t = NULL, *term = NULL;
++-+    Window trans = None;
++-+    XWindowChanges wc;
++-+
++-+    c = ecalloc(1, sizeof(Client));
++-+    c->win = w;
++-+    c->pid = winpid(w);
++-+    /* geometry */
++-+    c->x = c->oldx = wa->x;
++-+    c->y = c->oldy = wa->y;
++-+    c->w = c->oldw = wa->width;
++-+    c->h = c->oldh = wa->height;
++-+    c->oldbw = wa->border_width;
++-+
++-+    updatetitle(c);
++-+    if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++-+        c->mon = t->mon;
++-+        c->tags = t->tags;
++-+    } else {
++-+        c->mon = selmon;
++-+        applyrules(c);
++-+        term = termforwin(c);
++-+    }
++-+
++-+    if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++-+        c->x = c->mon->wx + c->mon->ww - WIDTH(c);
++-+    if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
++-+        c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
++-+    c->x = MAX(c->x, c->mon->wx);
++-+    c->y = MAX(c->y, c->mon->wy);
++-+    c->bw = borderpx;
++-+    /* if (c->isfloating) c->bw = 0; */
++-+
++-+    wc.border_width = c->bw;
++-+    XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++-+    XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++-+    configure(c); /* propagates border_width, if size doesn't change */
++-+    updatewindowtype(c);
++-+    updatewmhints(c);
++-+    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
++-+    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
++-+    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
++-+    c->sfx = c->x;
++-+    c->sfy = c->y;
++-+    c->sfw = c->w;
++-+    c->sfh = c->h;
++-+
++-+    XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++-+    grabbuttons(c, 0);
++-+    if (!c->isfloating)
++-+        c->isfloating = c->oldstate = t || c->isfixed;
++-+    if (c->isfloating) {
++-+        XRaiseWindow(dpy, c->win);
++-+        if (strcmp(c->name, "YAD") == 0) {
++-+            c->x = 1488;
++-+            c->y = 42;
++-+            c->w = 405;
++-+            c->h = 280;
++-+        }
++-+    }
++-+    attach(c);
++-+    attachstack(c);
++-+    XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++-+            (unsigned char *) &(c->win), 1);
++-+    XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
++-+    setclientstate(c, NormalState);
++-+    if (c->mon == selmon)
++-+        unfocus(selmon->sel, 0);
++-+    c->mon->sel = c;
++-+    XMapWindow(dpy, c->win);
++-+    if (term)
++-+        swallow(term, c);
++-+    arrange(c->mon);
++-+    focus(NULL);
++- }
++- 
++- void
++- mappingnotify(XEvent *e)
++- {
++--	XMappingEvent *ev = &e->xmapping;
++-+    XMappingEvent *ev = &e->xmapping;
++- 
++--	XRefreshKeyboardMapping(ev);
++--	if (ev->request == MappingKeyboard)
++--		grabkeys();
++-+    XRefreshKeyboardMapping(ev);
++-+    if (ev->request == MappingKeyboard)
++-+        grabkeys();
++- }
++- 
++- void
++- maprequest(XEvent *e)
++- {
++--	static XWindowAttributes wa;
++--	XMapRequestEvent *ev = &e->xmaprequest;
++-+    static XWindowAttributes wa;
++-+    XMapRequestEvent *ev = &e->xmaprequest;
++- 
++--	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
++--		return;
++--	if (!wintoclient(ev->window))
++--		manage(ev->window, &wa);
++-+    if (!XGetWindowAttributes(dpy, ev->window, &wa))
++-+        return;
++-+    if (wa.override_redirect)
++-+        return;
++-+    if (!wintoclient(ev->window))
++-+        manage(ev->window, &wa);
++- }
++- 
++- void
++- monocle(Monitor *m)
++- {
++--	unsigned int n = 0;
++--	Client *c;
++-+    unsigned int n;
++-+    int oh, ov, ih, iv;
++-+    Client *c;
++-+
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++- 
++--	for (c = m->clients; c; c = c->next)
++--		if (ISVISIBLE(c))
++--			n++;
++--	if (n > 0) /* override layout symbol */
++--		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++--	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++--		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++-+    if (n > 0) /* override layout symbol */
++-+        snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++-+    for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++-+        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
++- }
++- 
++- void
++- motionnotify(XEvent *e)
++- {
++--	static Monitor *mon = NULL;
++--	Monitor *m;
++--	XMotionEvent *ev = &e->xmotion;
++-+    static Monitor *mon = NULL;
++-+    Monitor *m;
++-+    XMotionEvent *ev = &e->xmotion;
++- 
++--	if (ev->window != root)
++--		return;
++--	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++--		unfocus(selmon->sel, 1);
++--		selmon = m;
++--		focus(NULL);
++--	}
++--	mon = m;
++-+    if (ev->window != root)
++-+        return;
++-+    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-+        unfocus(selmon->sel, 1);
++-+        selmon = m;
++-+        focus(NULL);
++-+    }
++-+    mon = m;
++- }
++- 
++- void
++- movemouse(const Arg *arg)
++- {
++--	int x, y, ocx, ocy, nx, ny;
++--	Client *c;
++--	Monitor *m;
++--	XEvent ev;
++--	Time lasttime = 0;
++--
++--	if (!(c = selmon->sel))
++--		return;
++--	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++--		return;
++--	restack(selmon);
++--	ocx = c->x;
++--	ocy = c->y;
++--	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++--		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
++--		return;
++--	if (!getrootptr(&x, &y))
++--		return;
++--	do {
++--		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++--		switch(ev.type) {
++--		case ConfigureRequest:
++--		case Expose:
++--		case MapRequest:
++--			handler[ev.type](&ev);
++--			break;
++--		case MotionNotify:
++--			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++--				continue;
++--			lasttime = ev.xmotion.time;
++--
++--			nx = ocx + (ev.xmotion.x - x);
++--			ny = ocy + (ev.xmotion.y - y);
++--			if (abs(selmon->wx - nx) < snap)
++--				nx = selmon->wx;
++--			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
++--				nx = selmon->wx + selmon->ww - WIDTH(c);
++--			if (abs(selmon->wy - ny) < snap)
++--				ny = selmon->wy;
++--			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
++--				ny = selmon->wy + selmon->wh - HEIGHT(c);
++--			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++--			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
++--				togglefloating(NULL);
++--			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++--				resize(c, nx, ny, c->w, c->h, 1);
++--			break;
++--		}
++--	} while (ev.type != ButtonRelease);
++--	XUngrabPointer(dpy, CurrentTime);
++--	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++--		sendmon(c, m);
++--		selmon = m;
++--		focus(NULL);
++--	}
++-+    int x, y, ocx, ocy, nx, ny;
++-+    Client *c;
++-+    Monitor *m;
++-+    XEvent ev;
++-+    Time lasttime = 0;
++-+
++-+    if (!(c = selmon->sel))
++-+        return;
++-+    if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++-+        return;
++-+    restack(selmon);
++-+    ocx = c->x;
++-+    ocy = c->y;
++-+    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++-+                None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
++-+        return;
++-+    if (!getrootptr(&x, &y))
++-+        return;
++-+    do {
++-+        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++-+        switch(ev.type) {
++-+            case ConfigureRequest:
++-+            case Expose:
++-+            case MapRequest:
++-+                handler[ev.type](&ev);
++-+                break;
++-+            case MotionNotify:
++-+                // Increase display rate when dragging  and resizing floats
++-+                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
++-+                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
++-+                    continue;
++-+                lasttime = ev.xmotion.time;
++-+
++-+                nx = ocx + (ev.xmotion.x - x);
++-+                ny = ocy + (ev.xmotion.y - y);
++-+                if (abs(selmon->wx - nx) < snap)
++-+                    nx = selmon->wx;
++-+                else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
++-+                    nx = selmon->wx + selmon->ww - WIDTH(c);
++-+                if (abs(selmon->wy - ny) < snap)
++-+                    ny = selmon->wy;
++-+                else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
++-+                    ny = selmon->wy + selmon->wh - HEIGHT(c);
++-+                if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++-+                        && (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
++-+                    togglefloating(NULL);
++-+                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++-+                    resize(c, nx, ny, c->w, c->h, 1);
++-+                break;
++-+        }
++-+    } while (ev.type != ButtonRelease);
++-+    XUngrabPointer(dpy, CurrentTime);
++-+    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++-+        sendmon(c, m);
++-+        selmon = m;
++-+        focus(NULL);
++-+    }
++- }
++- 
++- Client *
++- nexttiled(Client *c)
++- {
++--	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
++--	return c;
++-+    for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
++-+    return c;
++- }
++- 
++- void
++- pop(Client *c)
++- {
++--	detach(c);
++--	attach(c);
++--	focus(c);
++--	arrange(c->mon);
++-+    detach(c);
++-+    attach(c);
++-+    focus(c);
++-+    arrange(c->mon);
++-+}
++-+
++-+void
++-+pushstack(const Arg *arg)
++-+{
++-+    int i = stackpos(arg);
++-+    Client *sel = selmon->sel, *c, *p;
++-+
++-+    if(i < 0 || !sel)
++-+        return;
++-+    else if(i == 0) {
++-+        detach(sel);
++-+        attach(sel);
++-+    }
++-+    else {
++-+        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++-+            if(!(i -= (ISVISIBLE(c) && c != sel)))
++-+                break;
++-+        c = c ? c : p;
++-+        detach(sel);
++-+        sel->next = c->next;
++-+        c->next = sel;
++-+    }
++-+    arrange(selmon);
++- }
++- 
++- void
++- propertynotify(XEvent *e)
++- {
++--	Client *c;
++--	Window trans;
++--	XPropertyEvent *ev = &e->xproperty;
++--
++--	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
++--		updatestatus();
++--	else if (ev->state == PropertyDelete)
++--		return; /* ignore */
++--	else if ((c = wintoclient(ev->window))) {
++--		switch(ev->atom) {
++--		default: break;
++--		case XA_WM_TRANSIENT_FOR:
++--			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
++--				(c->isfloating = (wintoclient(trans)) != NULL))
++--				arrange(c->mon);
++--			break;
++--		case XA_WM_NORMAL_HINTS:
++--			c->hintsvalid = 0;
++--			break;
++--		case XA_WM_HINTS:
++--			updatewmhints(c);
++--			drawbars();
++--			break;
++--		}
++--		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++--			updatetitle(c);
++--			if (c == c->mon->sel)
++--				drawbar(c->mon);
++--		}
++--		if (ev->atom == netatom[NetWMWindowType])
++--			updatewindowtype(c);
++--	}
++-+    Client *c;
++-+    Window trans;
++-+    XPropertyEvent *ev = &e->xproperty;
++-+
++-+    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
++-+        updatestatus();
++-+    } else if (ev->state == PropertyDelete) {
++-+        return; /* ignore */
++-+    } else if ((c = wintoclient(ev->window))) {
++-+        switch(ev->atom) {
++-+            default: break;
++-+            case XA_WM_TRANSIENT_FOR:
++-+                     if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
++-+                             (c->isfloating = (wintoclient(trans)) != NULL))
++-+                         arrange(c->mon);
++-+                     break;
++-+            case XA_WM_NORMAL_HINTS:
++-+                     c->hintsvalid = 0;
++-+                     break;
++-+            case XA_WM_HINTS:
++-+                     updatewmhints(c);
++-+                     drawbars();
++-+                     break;
++-+        }
++-+        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
++-+            updatetitle(c);
++-+            if (c == c->mon->sel)
++-+                drawbar(c->mon);
++-+        }
++-+
++-+        if (ev->atom == netatom[NetWMWindowType])
++-+            updatewindowtype(c);
++-+    }
++- }
++- 
++- void
++- quit(const Arg *arg)
++- {
++--	running = 0;
++-+    if(arg->i) restart = 1;
++-+    running = 0;
++- }
++- 
++- Monitor *
++- recttomon(int x, int y, int w, int h)
++- {
++--	Monitor *m, *r = selmon;
++--	int a, area = 0;
++-+    Monitor *m, *r = selmon;
++-+    int a, area = 0;
++- 
++--	for (m = mons; m; m = m->next)
++--		if ((a = INTERSECT(x, y, w, h, m)) > area) {
++--			area = a;
++--			r = m;
++--		}
++--	return r;
++-+    for (m = mons; m; m = m->next)
++-+        if ((a = INTERSECT(x, y, w, h, m)) > area) {
++-+            area = a;
++-+            r = m;
++-+        }
++-+    return r;
++- }
++- 
++- void
++- resize(Client *c, int x, int y, int w, int h, int interact)
++- {
++--	if (applysizehints(c, &x, &y, &w, &h, interact))
++--		resizeclient(c, x, y, w, h);
++-+    if (applysizehints(c, &x, &y, &w, &h, interact))
++-+        resizeclient(c, x, y, w, h);
++- }
++- 
++- void
++- resizeclient(Client *c, int x, int y, int w, int h)
++- {
++--	XWindowChanges wc;
++-+    XWindowChanges wc;
++-+
++-+    c->oldx = c->x; c->x = wc.x = x;
++-+    c->oldy = c->y; c->y = wc.y = y;
++-+    c->oldw = c->w; c->w = wc.width = w;
++-+    c->oldh = c->h; c->h = wc.height = h;
++-+    wc.border_width = c->bw;
++-+    // Don't show border if floating or if only 1 client
++-+    if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++-+                || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++-+            && !c->isfullscreen) {
++-+        /* && !c->isfullscreen && !c->isfloating) { */
++-+        c->w = wc.width += c->bw * 2;
++-+        c->h = wc.height += c->bw * 2;
++-+        wc.border_width = 0;
++-+    }
++- 
++--	c->oldx = c->x; c->x = wc.x = x;
++--	c->oldy = c->y; c->y = wc.y = y;
++--	c->oldw = c->w; c->w = wc.width = w;
++--	c->oldh = c->h; c->h = wc.height = h;
++--	wc.border_width = c->bw;
++--	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++--	configure(c);
++--	XSync(dpy, False);
++-+    XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++-+    configure(c);
++-+    XSync(dpy, False);
++- }
++- 
++- void
++- resizemouse(const Arg *arg)
++- {
++--	int ocx, ocy, nw, nh;
++--	Client *c;
++--	Monitor *m;
++--	XEvent ev;
++--	Time lasttime = 0;
++--
++--	if (!(c = selmon->sel))
++--		return;
++--	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++--		return;
++--	restack(selmon);
++--	ocx = c->x;
++--	ocy = c->y;
++--	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++--		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
++--		return;
++--	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++--	do {
++--		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++--		switch(ev.type) {
++--		case ConfigureRequest:
++--		case Expose:
++--		case MapRequest:
++--			handler[ev.type](&ev);
++--			break;
++--		case MotionNotify:
++--			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++--				continue;
++--			lasttime = ev.xmotion.time;
++--
++--			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
++--			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
++--			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
++--			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
++--			{
++--				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++--				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
++--					togglefloating(NULL);
++--			}
++--			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++--				resize(c, c->x, c->y, nw, nh, 1);
++--			break;
++--		}
++--	} while (ev.type != ButtonRelease);
++--	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++--	XUngrabPointer(dpy, CurrentTime);
++--	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++--	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++--		sendmon(c, m);
++--		selmon = m;
++--		focus(NULL);
++--	}
++-+    int ocx, ocy, nw, nh;
++-+    Client *c;
++-+    Monitor *m;
++-+    XEvent ev;
++-+    Time lasttime = 0;
++-+
++-+    if (!(c = selmon->sel))
++-+        return;
++-+    if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++-+        return;
++-+    restack(selmon);
++-+    ocx = c->x;
++-+    ocy = c->y;
++-+    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++-+                None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
++-+        return;
++-+    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++-+    do {
++-+        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++-+        switch(ev.type) {
++-+            case ConfigureRequest:
++-+            case Expose:
++-+            case MapRequest:
++-+                handler[ev.type](&ev);
++-+                break;
++-+            case MotionNotify:
++-+                if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++-+                    continue;
++-+                lasttime = ev.xmotion.time;
++-+
++-+                nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
++-+                nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
++-+                if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
++-+                        && c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
++-+                {
++-+                    if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++-+                            && (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
++-+                        togglefloating(NULL);
++-+                }
++-+                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++-+                    resize(c, c->x, c->y, nw, nh, 1);
++-+                break;
++-+        }
++-+    } while (ev.type != ButtonRelease);
++-+    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++-+    XUngrabPointer(dpy, CurrentTime);
++-+    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++-+    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++-+        sendmon(c, m);
++-+        selmon = m;
++-+        focus(NULL);
++-+    }
++- }
++- 
++- void
++- restack(Monitor *m)
++- {
++--	Client *c;
++--	XEvent ev;
++--	XWindowChanges wc;
++--
++--	drawbar(m);
++--	if (!m->sel)
++--		return;
++--	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
++--		XRaiseWindow(dpy, m->sel->win);
++--	if (m->lt[m->sellt]->arrange) {
++--		wc.stack_mode = Below;
++--		wc.sibling = m->barwin;
++--		for (c = m->stack; c; c = c->snext)
++--			if (!c->isfloating && ISVISIBLE(c)) {
++--				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
++--				wc.sibling = c->win;
++--			}
++--	}
++--	XSync(dpy, False);
++--	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++-+    Client *c;
++-+    XEvent ev;
++-+    XWindowChanges wc;
++-+
++-+    drawbar(m);
++-+    if (!m->sel)
++-+        return;
++-+    if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
++-+        XRaiseWindow(dpy, m->sel->win);
++-+    if (m->lt[m->sellt]->arrange) {
++-+        wc.stack_mode = Below;
++-+        wc.sibling = m->barwin;
++-+        for (c = m->stack; c; c = c->snext)
++-+            if (!c->isfloating && ISVISIBLE(c)) {
++-+                XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
++-+                wc.sibling = c->win;
++-+            }
++-+    }
++-+    XSync(dpy, False);
++-+    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++- }
++- 
++- void
++- run(void)
++- {
++--	XEvent ev;
++--	/* main event loop */
++--	XSync(dpy, False);
++--	while (running && !XNextEvent(dpy, &ev))
++--		if (handler[ev.type])
++--			handler[ev.type](&ev); /* call handler */
++-+    XEvent ev;
++-+    /* main event loop */
++-+    XSync(dpy, False);
++-+    while (running && !XNextEvent(dpy, &ev))
++-+        if (handler[ev.type])
++-+            handler[ev.type](&ev); /* call handler */
++-+}
++-+
++-+void
++-+runAutostart(void)
++-+{
++-+    system("killall -q dwmblocks; dwmblocks &");
++- }
++- 
++- void
++- scan(void)
++- {
++--	unsigned int i, num;
++--	Window d1, d2, *wins = NULL;
++--	XWindowAttributes wa;
++--
++--	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
++--		for (i = 0; i < num; i++) {
++--			if (!XGetWindowAttributes(dpy, wins[i], &wa)
++--			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
++--				continue;
++--			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
++--				manage(wins[i], &wa);
++--		}
++--		for (i = 0; i < num; i++) { /* now the transients */
++--			if (!XGetWindowAttributes(dpy, wins[i], &wa))
++--				continue;
++--			if (XGetTransientForHint(dpy, wins[i], &d1)
++--			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
++--				manage(wins[i], &wa);
++--		}
++--		if (wins)
++--			XFree(wins);
++--	}
++-+    unsigned int i, num;
++-+    Window d1, d2, *wins = NULL;
++-+    XWindowAttributes wa;
++-+
++-+    if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
++-+        for (i = 0; i < num; i++) {
++-+            if (!XGetWindowAttributes(dpy, wins[i], &wa)
++-+                    || wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
++-+                continue;
++-+            if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
++-+                manage(wins[i], &wa);
++-+        }
++-+        for (i = 0; i < num; i++) { /* now the transients */
++-+            if (!XGetWindowAttributes(dpy, wins[i], &wa))
++-+                continue;
++-+            if (XGetTransientForHint(dpy, wins[i], &d1)
++-+                    && (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
++-+                manage(wins[i], &wa);
++-+        }
++-+        if (wins)
++-+            XFree(wins);
++-+    }
++- }
++- 
++- void
++- sendmon(Client *c, Monitor *m)
++- {
++--	if (c->mon == m)
++--		return;
++--	unfocus(c, 1);
++--	detach(c);
++--	detachstack(c);
++--	c->mon = m;
++--	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++--	attach(c);
++--	attachstack(c);
++--	focus(NULL);
++--	arrange(NULL);
++-+    if (c->mon == m)
++-+        return;
++-+    unfocus(c, 1);
++-+    detach(c);
++-+    detachstack(c);
++-+    c->mon = m;
++-+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++-+    attach(c);
++-+    attachstack(c);
++-+    focus(NULL);
++-+    arrange(NULL);
++-+}
++-+
++-+void
++-+sendmonview(Client *c, Monitor *m)
++-+{
++-+    if (c->mon == m)
++-+        return;
++-+    unfocus(c, 1);
++-+    detach(c);
++-+    detachstack(c);
++-+    arrange(c->mon);
++-+    c->mon = m;
++-+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++-+    attach(c);
++-+    attachstack(c);
++-+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++-+    arrange(m);
++-+    focus(c);
++-+    restack(m);
++- }
++- 
++- void
++- setclientstate(Client *c, long state)
++- {
++--	long data[] = { state, None };
++-+    long data[] = { state, None };
++- 
++--	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
++--		PropModeReplace, (unsigned char *)data, 2);
++-+    XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
++-+            PropModeReplace, (unsigned char *)data, 2);
++- }
++- 
++- int
++- sendevent(Client *c, Atom proto)
++- {
++--	int n;
++--	Atom *protocols;
++--	int exists = 0;
++--	XEvent ev;
++--
++--	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
++--		while (!exists && n--)
++--			exists = protocols[n] == proto;
++--		XFree(protocols);
++--	}
++--	if (exists) {
++--		ev.type = ClientMessage;
++--		ev.xclient.window = c->win;
++--		ev.xclient.message_type = wmatom[WMProtocols];
++--		ev.xclient.format = 32;
++--		ev.xclient.data.l[0] = proto;
++--		ev.xclient.data.l[1] = CurrentTime;
++--		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
++--	}
++--	return exists;
++-+    int n;
++-+    Atom *protocols;
++-+    int exists = 0;
++-+    XEvent ev;
++-+
++-+    if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
++-+        while (!exists && n--)
++-+            exists = protocols[n] == proto;
++-+        XFree(protocols);
++-+    }
++-+    if (exists) {
++-+        ev.type = ClientMessage;
++-+        ev.xclient.window = c->win;
++-+        ev.xclient.message_type = wmatom[WMProtocols];
++-+        ev.xclient.format = 32;
++-+        ev.xclient.data.l[0] = proto;
++-+        ev.xclient.data.l[1] = CurrentTime;
++-+        XSendEvent(dpy, c->win, False, NoEventMask, &ev);
++-+    }
++-+    return exists;
++- }
++- 
++- void
++- setfocus(Client *c)
++- {
++--	if (!c->neverfocus) {
++--		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
++--		XChangeProperty(dpy, root, netatom[NetActiveWindow],
++--			XA_WINDOW, 32, PropModeReplace,
++--			(unsigned char *) &(c->win), 1);
++--	}
++--	sendevent(c, wmatom[WMTakeFocus]);
++-+    if (!c->neverfocus) {
++-+        XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
++-+        XChangeProperty(dpy, root, netatom[NetActiveWindow],
++-+                XA_WINDOW, 32, PropModeReplace,
++-+                (unsigned char *) &(c->win), 1);
++-+    }
++-+    sendevent(c, wmatom[WMTakeFocus]);
++- }
++- 
++- void
++- setfullscreen(Client *c, int fullscreen)
++- {
++--	if (fullscreen && !c->isfullscreen) {
++--		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++--			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++--		c->isfullscreen = 1;
++--		c->oldstate = c->isfloating;
++--		c->oldbw = c->bw;
++--		c->bw = 0;
++--		c->isfloating = 1;
++--		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++--		XRaiseWindow(dpy, c->win);
++--	} else if (!fullscreen && c->isfullscreen){
++--		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++--			PropModeReplace, (unsigned char*)0, 0);
++--		c->isfullscreen = 0;
++--		c->isfloating = c->oldstate;
++--		c->bw = c->oldbw;
++--		c->x = c->oldx;
++--		c->y = c->oldy;
++--		c->w = c->oldw;
++--		c->h = c->oldh;
++--		resizeclient(c, c->x, c->y, c->w, c->h);
++--		arrange(c->mon);
++--	}
++-+    if (fullscreen && !c->isfullscreen) {
++-+        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++-+                PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++-+        c->isfullscreen = 1;
++-+        c->oldstate = c->isfloating;
++-+        c->oldbw = c->bw;
++-+        c->bw = 0;
++-+        c->isfloating = 1;
++-+        resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++-+        XRaiseWindow(dpy, c->win);
++-+    } else if (!fullscreen && c->isfullscreen){
++-+        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++-+                PropModeReplace, (unsigned char*)0, 0);
++-+        c->isfullscreen = 0;
++-+        c->isfloating = c->oldstate;
++-+        c->bw = c->oldbw;
++-+        c->x = c->oldx;
++-+        c->y = c->oldy;
++-+        c->w = c->oldw;
++-+        c->h = c->oldh;
++-+        resizeclient(c, c->x, c->y, c->w, c->h);
++-+        arrange(c->mon);
++-+    }
++-+}
++-+
++-+int
++-+stackpos(const Arg *arg)
++-+{
++-+    int n, i;
++-+    Client *c, *l;
++-+
++-+    if(!selmon->clients)
++-+        return -1;
++-+
++-+    if(arg->i == PREVSEL) {
++-+        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++-+        if(!l)
++-+            return -1;
++-+        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+        return i;
++-+    }
++-+    else if(ISINC(arg->i)) {
++-+        if(!selmon->sel)
++-+            return -1;
++-+        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+        return MOD(i + GETINC(arg->i), n);
++-+    }
++-+    else if(arg->i < 0) {
++-+        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+        return MAX(i + arg->i, 0);
++-+    }
++-+    else
++-+        return arg->i;
++- }
++- 
++- void
++- setlayout(const Arg *arg)
++- {
++--	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
++--		selmon->sellt ^= 1;
++--	if (arg && arg->v)
++--		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++--	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
++--	if (selmon->sel)
++--		arrange(selmon);
++--	else
++--		drawbar(selmon);
++-+    if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
++-+        selmon->sellt ^= 1;
++-+    if (arg && arg->v)
++-+        selmon->lt[selmon->sellt] = (Layout *)arg->v;
++-+    strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
++-+    if (selmon->sel)
++-+        arrange(selmon);
++-+    else
++-+        drawbar(selmon);
++- }
++- 
++- /* arg > 1.0 will set mfact absolutely */
++- void
++- setmfact(const Arg *arg)
++- {
++--	float f;
++-+    float f;
++- 
++--	if (!arg || !selmon->lt[selmon->sellt]->arrange)
++--		return;
++--	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
++--	if (f < 0.05 || f > 0.95)
++--		return;
++--	selmon->mfact = f;
++--	arrange(selmon);
++-+    if (!arg || !selmon->lt[selmon->sellt]->arrange)
++-+        return;
++-+    f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
++-+    if (f < 0.05 || f > 0.95)
++-+        return;
++-+    selmon->mfact = f;
++-+    arrange(selmon);
++- }
++- 
++- void
++- setup(void)
++- {
++--	int i;
++--	XSetWindowAttributes wa;
++--	Atom utf8string;
++--	struct sigaction sa;
++--
++--	/* do not transform children into zombies when they terminate */
++--	sigemptyset(&sa.sa_mask);
++--	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
++--	sa.sa_handler = SIG_IGN;
++--	sigaction(SIGCHLD, &sa, NULL);
++--
++--	/* clean up any zombies (inherited from .xinitrc etc) immediately */
++--	while (waitpid(-1, NULL, WNOHANG) > 0);
++--
++--	/* init screen */
++--	screen = DefaultScreen(dpy);
++--	sw = DisplayWidth(dpy, screen);
++--	sh = DisplayHeight(dpy, screen);
++--	root = RootWindow(dpy, screen);
++--	drw = drw_create(dpy, screen, root, sw, sh);
++--	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++--		die("no fonts could be loaded.");
++--	lrpad = drw->fonts->h;
++--	bh = drw->fonts->h + 2;
++--	updategeom();
++--	/* init atoms */
++--	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
++--	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
++--	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
++--	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
++--	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
++--	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
++--	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
++--	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
++--	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++--	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++--	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++--	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++--	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++--	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++--	/* init cursors */
++--	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
++--	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++--	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++--	/* init appearance */
++--	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++--	for (i = 0; i < LENGTH(colors); i++)
++--		scheme[i] = drw_scm_create(drw, colors[i], 3);
++--	/* init bars */
++--	updatebars();
++--	updatestatus();
++--	/* supporting window for NetWMCheck */
++--	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
++--	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
++--		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++--	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
++--		PropModeReplace, (unsigned char *) "dwm", 3);
++--	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
++--		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++--	/* EWMH support per view */
++--	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
++--		PropModeReplace, (unsigned char *) netatom, NetLast);
++--	XDeleteProperty(dpy, root, netatom[NetClientList]);
++--	/* select events */
++--	wa.cursor = cursor[CurNormal]->cursor;
++--	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
++--		|ButtonPressMask|PointerMotionMask|EnterWindowMask
++--		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
++--	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
++--	XSelectInput(dpy, root, wa.event_mask);
++--	grabkeys();
++--	focus(NULL);
++-+    int i;
++-+    XSetWindowAttributes wa;
++-+    Atom utf8string;
++-+    struct sigaction sa;
++-+
++-+    /* do not transform children into zombies when they terminate */
++-+    sigemptyset(&sa.sa_mask);
++-+    sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
++-+    sa.sa_handler = SIG_IGN;
++-+    sigaction(SIGCHLD, &sa, NULL);
++-+
++-+    /* clean up any zombies (inherited from .xinitrc etc) immediately */
++-+    while (waitpid(-1, NULL, WNOHANG) > 0);
++-+
++-+    signal(SIGHUP, sighup);
++-+    signal(SIGTERM, sigterm);
++-+
++-+    /* init screen */
++-+    screen = DefaultScreen(dpy);
++-+    sw = DisplayWidth(dpy, screen);
++-+    sh = DisplayHeight(dpy, screen);
++-+    root = RootWindow(dpy, screen);
++-+    drw = drw_create(dpy, screen, root, sw, sh);
++-+    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++-+        die("no fonts could be loaded.");
++-+    lrpad = drw->fonts->h;
++-+    bh = drw->fonts->h + 2;
++-+    updategeom();
++-+    /* init atoms */
++-+    utf8string = XInternAtom(dpy, "UTF8_STRING", False);
++-+    wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
++-+    wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
++-+    wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
++-+    wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
++-+    netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
++-+    netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
++-+    netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
++-+    netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++-+    netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++-+    netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++-+    netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++-+    netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++-+    netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++-+    /* init cursors */
++-+    cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
++-+    cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++-+    cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++-+    /* init appearance */
++-+    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
++-+    scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++-+    scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++-+
++-+    for (i = 0; i < LENGTH(colors); i++)
++-+        scheme[i] = drw_scm_create(drw, colors[i], 3);
++-+    /* init bars */
++-+    updatebars();
++-+    updatestatus();
++-+    /* supporting window for NetWMCheck */
++-+    wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
++-+    XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
++-+            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++-+    XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
++-+            PropModeReplace, (unsigned char *) "dwm", 3);
++-+    XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
++-+            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++-+    /* EWMH support per view */
++-+    XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
++-+            PropModeReplace, (unsigned char *) netatom, NetLast);
++-+    XDeleteProperty(dpy, root, netatom[NetClientList]);
++-+    /* select events */
++-+    wa.cursor = cursor[CurNormal]->cursor;
++-+    wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
++-+        |ButtonPressMask|PointerMotionMask|EnterWindowMask
++-+        |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
++-+    XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
++-+    XSelectInput(dpy, root, wa.event_mask);
++-+    grabkeys();
++-+    focus(NULL);
++- }
++- 
++- void
++- seturgent(Client *c, int urg)
++- {
++--	XWMHints *wmh;
++-+    XWMHints *wmh;
++- 
++--	c->isurgent = urg;
++--	if (!(wmh = XGetWMHints(dpy, c->win)))
++--		return;
++--	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
++--	XSetWMHints(dpy, c->win, wmh);
++--	XFree(wmh);
++-+    c->isurgent = urg;
++-+    if (!(wmh = XGetWMHints(dpy, c->win)))
++-+        return;
++-+    wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
++-+    XSetWMHints(dpy, c->win, wmh);
++-+    XFree(wmh);
++- }
++- 
++- void
++- showhide(Client *c)
++- {
++--	if (!c)
++--		return;
++--	if (ISVISIBLE(c)) {
++--		/* show clients top down */
++--		XMoveWindow(dpy, c->win, c->x, c->y);
++--		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++--			resize(c, c->x, c->y, c->w, c->h, 0);
++--		showhide(c->snext);
++--	} else {
++--		/* hide clients bottom up */
++--		showhide(c->snext);
++--		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++--	}
++-+    if (!c)
++-+        return;
++-+    if (ISVISIBLE(c)) {
++-+        if ((c->tags & SPTAGMASK) && c->isfloating) {
++-+            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
++-+            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
++-+        }
++-+        /* show clients top down */
++-+        XMoveWindow(dpy, c->win, c->x, c->y);
++-+        if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++-+            resize(c, c->x, c->y, c->w, c->h, 0);
++-+        showhide(c->snext);
++-+    } else {
++-+        /* hide clients bottom up */
++-+        showhide(c->snext);
++-+        XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++-+    }
++- }
++- 
++- void
++--spawn(const Arg *arg)
++-+sighup(int unused)
++- {
++--	struct sigaction sa;
++-+    Arg a = {.i = 1};
++-+    quit(&a);
++-+}
++- 
++--	if (arg->v == dmenucmd)
++--		dmenumon[0] = '0' + selmon->num;
++--	if (fork() == 0) {
++--		if (dpy)
++--			close(ConnectionNumber(dpy));
++--		setsid();
++-+void
++-+sigterm(int unused)
++-+{
++-+    Arg a = {.i = 0};
++-+    quit(&a);
++-+}
++- 
++--		sigemptyset(&sa.sa_mask);
++--		sa.sa_flags = 0;
++--		sa.sa_handler = SIG_DFL;
++--		sigaction(SIGCHLD, &sa, NULL);
++-+#ifndef __OpenBSD__
++-+void sigdwmblocks(const Arg *arg)
++-+{
++-+    union sigval sv;
++-+    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
++-+    if (!dwmblockspid)
++-+        if (getdwmblockspid() == -1)
++-+            return;
++- 
++--		execvp(((char **)arg->v)[0], (char **)arg->v);
++--		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
++--	}
++-+    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
++-+        if (errno == ESRCH) {
++-+            if (!getdwmblockspid())
++-+                sigqueue(dwmblockspid, SIGUSR1, sv);
++-+        }
++-+    }
++- }
++-+#endif
++- 
++- void
++--tag(const Arg *arg)
++-+spawn(const Arg *arg)
++- {
++--	if (selmon->sel && arg->ui & TAGMASK) {
++--		selmon->sel->tags = arg->ui & TAGMASK;
++--		focus(NULL);
++--		arrange(selmon);
++--	}
++-+    struct sigaction sa;
++-+    if (fork() == 0) {
++-+        if (dpy)
++-+            close(ConnectionNumber(dpy));
++-+        setsid();
++-+
++-+        sigemptyset(&sa.sa_mask);
++-+        sa.sa_flags = 0;
++-+        sa.sa_handler = SIG_DFL;
++-+        sigaction(SIGCHLD, &sa, NULL);
++-+
++-+        execvp(((char **)arg->v)[0], (char **)arg->v);
++-+        die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
++-+    }
++- }
++- 
++- void
++--tagmon(const Arg *arg)
++-+tag(const Arg *arg)
++- {
++--	if (!selmon->sel || !mons->next)
++--		return;
++--	sendmon(selmon->sel, dirtomon(arg->i));
++-+    if (selmon->sel && arg->ui & TAGMASK) {
++-+        selmon->sel->tags = arg->ui & TAGMASK;
++-+        focus(NULL);
++-+        arrange(selmon);
++-+    }
++- }
++- 
++- void
++--tile(Monitor *m)
++-+tagview(const Arg *arg)
++- {
++--	unsigned int i, n, h, mw, my, ty;
++--	Client *c;
++-+    if (selmon->sel && arg->ui & TAGMASK) {
++-+        selmon->sel->tags = arg->ui & TAGMASK;
++-+        focus(NULL);
++-+        arrange(selmon);
++-+        view(arg);
++-+    }
++-+}
++- 
++--	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++--	if (n == 0)
++--		return;
++-+void
++-+tagmon(const Arg *arg)
++-+{
++-+    if (!selmon->sel || !mons->next)
++-+        return;
++-+    sendmon(selmon->sel, dirtomon(arg->i));
++-+}
++- 
++--	if (n > m->nmaster)
++--		mw = m->nmaster ? m->ww * m->mfact : 0;
++--	else
++--		mw = m->ww;
++--	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++--		if (i < m->nmaster) {
++--			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
++--			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
++--			if (my + HEIGHT(c) < m->wh)
++--				my += HEIGHT(c);
++--		} else {
++--			h = (m->wh - ty) / (n - i);
++--			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
++--			if (ty + HEIGHT(c) < m->wh)
++--				ty += HEIGHT(c);
++--		}
++-+void
++-+tagmonview(const Arg *arg)
++-+{
++-+    if (!selmon->sel || !mons->next)
++-+        return;
++-+    sendmonview(selmon->sel, dirtomon(arg->i));
++- }
++- 
++- void
++- togglebar(const Arg *arg)
++- {
++--	selmon->showbar = !selmon->showbar;
++--	updatebarpos(selmon);
++--	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++--	arrange(selmon);
++-+    selmon->showbar = !selmon->showbar;
++-+    updatebarpos(selmon);
++-+    XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++-+    arrange(selmon);
++- }
++- 
++- void
++- togglefloating(const Arg *arg)
++- {
++--	if (!selmon->sel)
++--		return;
++--	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++--		return;
++--	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++--	if (selmon->sel->isfloating)
++--		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
++--			selmon->sel->w, selmon->sel->h, 0);
++--	arrange(selmon);
++-+    if (!selmon->sel)
++-+        return;
++-+    if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++-+        return;
++-+    selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++-+    if (selmon->sel->isfloating) {
++-+        /* selmon->sel->bw = 0; */
++-+        /* configure(selmon->sel); */
++-+        /* restore last known float dimensions */
++-+        resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++-+                selmon->sel->sfw, selmon->sel->sfh, False);
++-+    } else {
++-+        /* save last known float dimensions */
++-+        selmon->sel->sfx = selmon->sel->x;
++-+        selmon->sel->sfy = selmon->sel->y;
++-+        selmon->sel->sfw = selmon->sel->w;
++-+        selmon->sel->sfh = selmon->sel->h;
++-+    }
++-+    arrange(selmon);
++-+}
++-+
++-+void
++-+togglefullscr(const Arg *arg)
++-+{
++-+    if(selmon->sel)
++-+        setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++-+}
++-+
++-+void
++-+togglesticky(const Arg *arg)
++-+{
++-+    if (!selmon->sel)
++-+        return;
++-+    selmon->sel->issticky = !selmon->sel->issticky;
++-+    arrange(selmon);
++-+}
++-+
++-+void
++-+togglescratch(const Arg *arg)
++-+{
++-+    Client *c;
++-+    unsigned int found = 0;
++-+    unsigned int scratchtag = SPTAG(arg->ui);
++-+    Arg sparg = {.v = scratchpads[arg->ui].cmd};
++-+
++-+    for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++-+    if (found) {
++-+        unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++-+        if (newtagset) {
++-+            selmon->tagset[selmon->seltags] = newtagset;
++-+            focus(NULL);
++-+            arrange(selmon);
++-+        }
++-+        if (ISVISIBLE(c)) {
++-+            focus(c);
++-+            restack(selmon);
++-+        }
++-+    } else {
++-+        selmon->tagset[selmon->seltags] |= scratchtag;
++-+        spawn(&sparg);
++-+    }
++- }
++- 
++- void
++- toggletag(const Arg *arg)
++- {
++--	unsigned int newtags;
++-+    unsigned int newtags;
++- 
++--	if (!selmon->sel)
++--		return;
++--	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
++--	if (newtags) {
++--		selmon->sel->tags = newtags;
++--		focus(NULL);
++--		arrange(selmon);
++--	}
++-+    if (!selmon->sel)
++-+        return;
++-+    newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
++-+    if (newtags) {
++-+        selmon->sel->tags = newtags;
++-+        focus(NULL);
++-+        arrange(selmon);
++-+    }
++- }
++- 
++- void
++- toggleview(const Arg *arg)
++- {
++--	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++-+    unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++- 
++--	if (newtagset) {
++--		selmon->tagset[selmon->seltags] = newtagset;
++--		focus(NULL);
++--		arrange(selmon);
++--	}
++-+    if (newtagset) {
++-+        selmon->tagset[selmon->seltags] = newtagset;
++-+        focus(NULL);
++-+        arrange(selmon);
++-+    }
++- }
++- 
++- void
++- unfocus(Client *c, int setfocus)
++- {
++--	if (!c)
++--		return;
++--	grabbuttons(c, 0);
++--	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++--	if (setfocus) {
++--		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++--		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++--	}
++-+    if (!c)
++-+        return;
++-+    grabbuttons(c, 0);
++-+    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++-+    if (setfocus) {
++-+        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++-+        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+    }
++- }
++- 
++- void
++- unmanage(Client *c, int destroyed)
++- {
++--	Monitor *m = c->mon;
++--	XWindowChanges wc;
++--
++--	detach(c);
++--	detachstack(c);
++--	if (!destroyed) {
++--		wc.border_width = c->oldbw;
++--		XGrabServer(dpy); /* avoid race conditions */
++--		XSetErrorHandler(xerrordummy);
++--		XSelectInput(dpy, c->win, NoEventMask);
++--		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
++--		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++--		setclientstate(c, WithdrawnState);
++--		XSync(dpy, False);
++--		XSetErrorHandler(xerror);
++--		XUngrabServer(dpy);
++--	}
++--	free(c);
++--	focus(NULL);
++--	updateclientlist();
++--	arrange(m);
++-+    Monitor *m = c->mon;
++-+    XWindowChanges wc;
++-+
++-+    if (c->swallowing) {
++-+        unswallow(c);
++-+        return;
++-+    }
++-+
++-+    Client *s = swallowingclient(c->win);
++-+    if (s) {
++-+        free(s->swallowing);
++-+        s->swallowing = NULL;
++-+        arrange(m);
++-+        focus(NULL);
++-+        return;
++-+    }
++-+
++-+    detach(c);
++-+    detachstack(c);
++-+    if (!destroyed) {
++-+        wc.border_width = c->oldbw;
++-+        XGrabServer(dpy); /* avoid race conditions */
++-+        XSetErrorHandler(xerrordummy);
++-+        XSelectInput(dpy, c->win, NoEventMask);
++-+        XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
++-+        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++-+        setclientstate(c, WithdrawnState);
++-+        XSync(dpy, False);
++-+        XSetErrorHandler(xerror);
++-+        XUngrabServer(dpy);
++-+    }
++-+    free(c);
++-+
++-+    if (!s) {
++-+        arrange(m);
++-+        focus(NULL);
++-+        updateclientlist();
++-+    }
++- }
++- 
++- void
++- unmapnotify(XEvent *e)
++- {
++--	Client *c;
++--	XUnmapEvent *ev = &e->xunmap;
++-+    Client *c;
++-+    XUnmapEvent *ev = &e->xunmap;
++- 
++--	if ((c = wintoclient(ev->window))) {
++--		if (ev->send_event)
++--			setclientstate(c, WithdrawnState);
++--		else
++--			unmanage(c, 0);
++--	}
++-+    if ((c = wintoclient(ev->window))) {
++-+        if (ev->send_event)
++-+            setclientstate(c, WithdrawnState);
++-+        else
++-+            unmanage(c, 0);
++-+    }
++- }
++- 
++- void
++- updatebars(void)
++- {
++--	Monitor *m;
++--	XSetWindowAttributes wa = {
++--		.override_redirect = True,
++--		.background_pixmap = ParentRelative,
++--		.event_mask = ButtonPressMask|ExposureMask
++--	};
++--	XClassHint ch = {"dwm", "dwm"};
++--	for (m = mons; m; m = m->next) {
++--		if (m->barwin)
++--			continue;
++--		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++--				CopyFromParent, DefaultVisual(dpy, screen),
++--				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++--		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++--		XMapRaised(dpy, m->barwin);
++--		XSetClassHint(dpy, m->barwin, &ch);
++--	}
++-+    Monitor *m;
++-+    XSetWindowAttributes wa = {
++-+        .override_redirect = True,
++-+        .background_pixmap = ParentRelative,
++-+        .event_mask = ButtonPressMask|ExposureMask
++-+    };
++-+    XClassHint ch = {"dwm", "dwm"};
++-+    for (m = mons; m; m = m->next) {
++-+        if (m->barwin)
++-+            continue;
++-+        m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++-+                CopyFromParent, DefaultVisual(dpy, screen),
++-+                CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++-+        XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++-+        XMapRaised(dpy, m->barwin);
++-+        XSetClassHint(dpy, m->barwin, &ch);
++-+    }
++- }
++- 
++- void
++- updatebarpos(Monitor *m)
++- {
++--	m->wy = m->my;
++--	m->wh = m->mh;
++--	if (m->showbar) {
++--		m->wh -= bh;
++--		m->by = m->topbar ? m->wy : m->wy + m->wh;
++--		m->wy = m->topbar ? m->wy + bh : m->wy;
++--	} else
++--		m->by = -bh;
++-+    m->wy = m->my;
++-+    m->wh = m->mh;
++-+    if (m->showbar) {
++-+        m->wh -= bh;
++-+        m->by = m->topbar ? m->wy : m->wy + m->wh;
++-+        m->wy = m->topbar ? m->wy + bh : m->wy;
++-+    } else
++-+        m->by = -bh;
++- }
++- 
++- void
++- updateclientlist(void)
++- {
++--	Client *c;
++--	Monitor *m;
++-+    Client *c;
++-+    Monitor *m;
++- 
++--	XDeleteProperty(dpy, root, netatom[NetClientList]);
++--	for (m = mons; m; m = m->next)
++--		for (c = m->clients; c; c = c->next)
++--			XChangeProperty(dpy, root, netatom[NetClientList],
++--				XA_WINDOW, 32, PropModeAppend,
++--				(unsigned char *) &(c->win), 1);
++-+    XDeleteProperty(dpy, root, netatom[NetClientList]);
++-+    for (m = mons; m; m = m->next)
++-+        for (c = m->clients; c; c = c->next)
++-+            XChangeProperty(dpy, root, netatom[NetClientList],
++-+                    XA_WINDOW, 32, PropModeAppend,
++-+                    (unsigned char *) &(c->win), 1);
++- }
++- 
++- int
++- updategeom(void)
++- {
++--	int dirty = 0;
++-+    int dirty = 0;
++- 
++- #ifdef XINERAMA
++--	if (XineramaIsActive(dpy)) {
++--		int i, j, n, nn;
++--		Client *c;
++--		Monitor *m;
++--		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
++--		XineramaScreenInfo *unique = NULL;
++--
++--		for (n = 0, m = mons; m; m = m->next, n++);
++--		/* only consider unique geometries as separate screens */
++--		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
++--		for (i = 0, j = 0; i < nn; i++)
++--			if (isuniquegeom(unique, j, &info[i]))
++--				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++--		XFree(info);
++--		nn = j;
++--
++--		/* new monitors if nn > n */
++--		for (i = n; i < nn; i++) {
++--			for (m = mons; m && m->next; m = m->next);
++--			if (m)
++--				m->next = createmon();
++--			else
++--				mons = createmon();
++--		}
++--		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
++--			if (i >= n
++--			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
++--			|| unique[i].width != m->mw || unique[i].height != m->mh)
++--			{
++--				dirty = 1;
++--				m->num = i;
++--				m->mx = m->wx = unique[i].x_org;
++--				m->my = m->wy = unique[i].y_org;
++--				m->mw = m->ww = unique[i].width;
++--				m->mh = m->wh = unique[i].height;
++--				updatebarpos(m);
++--			}
++--		/* removed monitors if n > nn */
++--		for (i = nn; i < n; i++) {
++--			for (m = mons; m && m->next; m = m->next);
++--			while ((c = m->clients)) {
++--				dirty = 1;
++--				m->clients = c->next;
++--				detachstack(c);
++--				c->mon = mons;
++--				attach(c);
++--				attachstack(c);
++--			}
++--			if (m == selmon)
++--				selmon = mons;
++--			cleanupmon(m);
++--		}
++--		free(unique);
++--	} else
++-+    if (XineramaIsActive(dpy)) {
++-+        int i, j, n, nn;
++-+        Client *c;
++-+        Monitor *m;
++-+        XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
++-+        XineramaScreenInfo *unique = NULL;
++-+
++-+        for (n = 0, m = mons; m; m = m->next, n++);
++-+        /* only consider unique geometries as separate screens */
++-+        unique = ecalloc(nn, sizeof(XineramaScreenInfo));
++-+        for (i = 0, j = 0; i < nn; i++)
++-+            if (isuniquegeom(unique, j, &info[i]))
++-+                memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++-+        XFree(info);
++-+        nn = j;
++-+        if (n <= nn) { /* new monitors available */
++-+            for (i = 0; i < (nn - n); i++) {
++-+                for (m = mons; m && m->next; m = m->next);
++-+                if (m)
++-+                    m->next = createmon();
++-+                else
++-+                    mons = createmon();
++-+            }
++-+            for (i = 0, m = mons; i < nn && m; m = m->next, i++)
++-+                if (i >= n
++-+                        || unique[i].x_org != m->mx || unique[i].y_org != m->my
++-+                        || unique[i].width != m->mw || unique[i].height != m->mh)
++-+                {
++-+                    dirty = 1;
++-+                    m->num = i;
++-+                    m->mx = m->wx = unique[i].x_org;
++-+                    m->my = m->wy = unique[i].y_org;
++-+                    m->mw = m->ww = unique[i].width;
++-+                    m->mh = m->wh = unique[i].height;
++-+                    updatebarpos(m);
++-+                }
++-+        } else { /* less monitors available nn < n */
++-+            for (i = nn; i < n; i++) {
++-+                for (m = mons; m && m->next; m = m->next);
++-+                while ((c = m->clients)) {
++-+                    dirty = 1;
++-+                    m->clients = c->next;
++-+                    detachstack(c);
++-+                    c->mon = mons;
++-+                    attach(c);
++-+                    attachstack(c);
++-+                }
++-+                if (m == selmon)
++-+                    selmon = mons;
++-+                cleanupmon(m);
++-+            }
++-+        }
++-+        free(unique);
++-+    } else
++- #endif /* XINERAMA */
++--	{ /* default monitor setup */
++--		if (!mons)
++--			mons = createmon();
++--		if (mons->mw != sw || mons->mh != sh) {
++--			dirty = 1;
++--			mons->mw = mons->ww = sw;
++--			mons->mh = mons->wh = sh;
++--			updatebarpos(mons);
++--		}
++--	}
++--	if (dirty) {
++--		selmon = mons;
++--		selmon = wintomon(root);
++--	}
++--	return dirty;
++-+    { /* default monitor setup */
++-+        if (!mons)
++-+            mons = createmon();
++-+        if (mons->mw != sw || mons->mh != sh) {
++-+            dirty = 1;
++-+            mons->mw = mons->ww = sw;
++-+            mons->mh = mons->wh = sh;
++-+            updatebarpos(mons);
++-+        }
++-+    }
++-+    if (dirty) {
++-+        selmon = mons;
++-+        selmon = wintomon(root);
++-+    }
++-+    return dirty;
++- }
++- 
++- void
++- updatenumlockmask(void)
++- {
++--	unsigned int i, j;
++--	XModifierKeymap *modmap;
++-+    unsigned int i, j;
++-+    XModifierKeymap *modmap;
++- 
++--	numlockmask = 0;
++--	modmap = XGetModifierMapping(dpy);
++--	for (i = 0; i < 8; i++)
++--		for (j = 0; j < modmap->max_keypermod; j++)
++--			if (modmap->modifiermap[i * modmap->max_keypermod + j]
++--				== XKeysymToKeycode(dpy, XK_Num_Lock))
++--				numlockmask = (1 << i);
++--	XFreeModifiermap(modmap);
++-+    numlockmask = 0;
++-+    modmap = XGetModifierMapping(dpy);
++-+    for (i = 0; i < 8; i++)
++-+        for (j = 0; j < modmap->max_keypermod; j++)
++-+            if (modmap->modifiermap[i * modmap->max_keypermod + j]
++-+                    == XKeysymToKeycode(dpy, XK_Num_Lock))
++-+                numlockmask = (1 << i);
++-+    XFreeModifiermap(modmap);
++- }
++- 
++- void
++- updatesizehints(Client *c)
++- {
++--	long msize;
++--	XSizeHints size;
++--
++--	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
++--		/* size is uninitialized, ensure that size.flags aren't used */
++--		size.flags = PSize;
++--	if (size.flags & PBaseSize) {
++--		c->basew = size.base_width;
++--		c->baseh = size.base_height;
++--	} else if (size.flags & PMinSize) {
++--		c->basew = size.min_width;
++--		c->baseh = size.min_height;
++--	} else
++--		c->basew = c->baseh = 0;
++--	if (size.flags & PResizeInc) {
++--		c->incw = size.width_inc;
++--		c->inch = size.height_inc;
++--	} else
++--		c->incw = c->inch = 0;
++--	if (size.flags & PMaxSize) {
++--		c->maxw = size.max_width;
++--		c->maxh = size.max_height;
++--	} else
++--		c->maxw = c->maxh = 0;
++--	if (size.flags & PMinSize) {
++--		c->minw = size.min_width;
++--		c->minh = size.min_height;
++--	} else if (size.flags & PBaseSize) {
++--		c->minw = size.base_width;
++--		c->minh = size.base_height;
++--	} else
++--		c->minw = c->minh = 0;
++--	if (size.flags & PAspect) {
++--		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
++--		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
++--	} else
++--		c->maxa = c->mina = 0.0;
++--	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
++--	c->hintsvalid = 1;
++-+    long msize;
++-+    XSizeHints size;
++-+
++-+    if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
++-+        /* size is uninitialized, ensure that size.flags aren't used */
++-+        size.flags = PSize;
++-+    if (size.flags & PBaseSize) {
++-+        c->basew = size.base_width;
++-+        c->baseh = size.base_height;
++-+    } else if (size.flags & PMinSize) {
++-+        c->basew = size.min_width;
++-+        c->baseh = size.min_height;
++-+    } else
++-+        c->basew = c->baseh = 0;
++-+    if (size.flags & PResizeInc) {
++-+        c->incw = size.width_inc;
++-+        c->inch = size.height_inc;
++-+    } else
++-+        c->incw = c->inch = 0;
++-+    if (size.flags & PMaxSize) {
++-+        c->maxw = size.max_width;
++-+        c->maxh = size.max_height;
++-+    } else
++-+        c->maxw = c->maxh = 0;
++-+    if (size.flags & PMinSize) {
++-+        c->minw = size.min_width;
++-+        c->minh = size.min_height;
++-+    } else if (size.flags & PBaseSize) {
++-+        c->minw = size.base_width;
++-+        c->minh = size.base_height;
++-+    } else
++-+        c->minw = c->minh = 0;
++-+    if (size.flags & PAspect) {
++-+        c->mina = (float)size.min_aspect.y / size.min_aspect.x;
++-+        c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
++-+    } else
++-+        c->maxa = c->mina = 0.0;
++-+    c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
++-+    c->hintsvalid = 1;
++- }
++- 
++- void
++- updatestatus(void)
++- {
++--	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
++--		strcpy(stext, "dwm-"VERSION);
++--	drawbar(selmon);
++-+    Monitor* m;
++-+    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
++-+        strcpy(stext, "dwm-"VERSION);
++-+    else
++-+        copyvalidchars(stext, rawstext);
++-+    /* drawbar(selmon); */
++-+    for(m = mons; m; m = m->next)
++-+        drawbar(m);
++- }
++- 
++- void
++- updatetitle(Client *c)
++- {
++--	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
++--		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
++--	if (c->name[0] == '\0') /* hack to mark broken clients */
++--		strcpy(c->name, broken);
++-+    if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
++-+        gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
++-+    if (c->name[0] == '\0') /* hack to mark broken clients */
++-+        strcpy(c->name, broken);
++- }
++- 
++- void
++- updatewindowtype(Client *c)
++- {
++--	Atom state = getatomprop(c, netatom[NetWMState]);
++--	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
++-+    Atom state = getatomprop(c, netatom[NetWMState]);
++-+    Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
++- 
++--	if (state == netatom[NetWMFullscreen])
++--		setfullscreen(c, 1);
++--	if (wtype == netatom[NetWMWindowTypeDialog])
++--		c->isfloating = 1;
++-+    if (state == netatom[NetWMFullscreen])
++-+        setfullscreen(c, 1);
++-+    if (wtype == netatom[NetWMWindowTypeDialog])
++-+        c->isfloating = 1;
++- }
++- 
++- void
++- updatewmhints(Client *c)
++- {
++--	XWMHints *wmh;
++-+    XWMHints *wmh;
++- 
++--	if ((wmh = XGetWMHints(dpy, c->win))) {
++--		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
++--			wmh->flags &= ~XUrgencyHint;
++--			XSetWMHints(dpy, c->win, wmh);
++--		} else
++--			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++--		if (wmh->flags & InputHint)
++--			c->neverfocus = !wmh->input;
++--		else
++--			c->neverfocus = 0;
++--		XFree(wmh);
++--	}
++-+    if ((wmh = XGetWMHints(dpy, c->win))) {
++-+        if (c == selmon->sel && wmh->flags & XUrgencyHint) {
++-+            wmh->flags &= ~XUrgencyHint;
++-+            XSetWMHints(dpy, c->win, wmh);
++-+        } else
++-+            c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++-+        if (wmh->flags & InputHint)
++-+            c->neverfocus = !wmh->input;
++-+        else
++-+            c->neverfocus = 0;
++-+        XFree(wmh);
++-+    }
++- }
++- 
++- void
++- view(const Arg *arg)
++- {
++--	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++--		return;
++--	selmon->seltags ^= 1; /* toggle sel tagset */
++--	if (arg->ui & TAGMASK)
++--		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++--	focus(NULL);
++--	arrange(selmon);
++-+    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
++-+        view(&((Arg) { .ui = 0 }));
++-+        return;
++-+    }
++-+
++-+    selmon->seltags ^= 1; /* toggle sel tagset */
++-+    if (arg->ui & TAGMASK)
++-+        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++-+    focus(NULL);
++-+    arrange(selmon);
++-+}
++-+
++-+pid_t
++-+winpid(Window w)
++-+{
++-+    pid_t result = 0;
++-+
++-+    xcb_res_client_id_spec_t spec = {0};
++-+    spec.client = w;
++-+    spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++-+
++-+    xcb_generic_error_t *e = NULL;
++-+    xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++-+    xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++-+
++-+    if (!r)
++-+        return (pid_t)0;
++-+
++-+    xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++-+    for (; i.rem; xcb_res_client_id_value_next(&i)) {
++-+        spec = i.data->spec;
++-+        if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++-+            uint32_t *t = xcb_res_client_id_value_value(i.data);
++-+            result = *t;
++-+            break;
++-+        }
++-+    }
++-+
++-+    free(r);
++-+
++-+    if (result == (pid_t)-1)
++-+        result = 0;
++-+    return result;
++-+}
++-+
++-+pid_t
++-+getparentprocess(pid_t p)
++-+{
++-+    unsigned int v = 0;
++-+
++-+#if defined(__linux__)
++-+    FILE *f;
++-+    char buf[256];
++-+    snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++-+
++-+    if (!(f = fopen(buf, "r")))
++-+        return (pid_t)0;
++-+
++-+    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
++-+        v = (pid_t)0;
++-+    fclose(f);
++-+#elif defined(__FreeBSD__)
++-+    struct kinfo_proc *proc = kinfo_getproc(p);
++-+    if (!proc)
++-+        return (pid_t)0;
++-+
++-+    v = proc->ki_ppid;
++-+    free(proc);
++-+#endif
++-+    return (pid_t)v;
++-+}
++-+
++-+int
++-+isdescprocess(pid_t p, pid_t c)
++-+{
++-+    while (p != c && c != 0)
++-+        c = getparentprocess(c);
++-+
++-+    return (int)c;
++-+}
++-+
++-+Client *
++-+termforwin(const Client *w)
++-+{
++-+    Client *c;
++-+    Monitor *m;
++-+
++-+    if (!w->pid || w->isterminal)
++-+        return NULL;
++-+
++-+    for (m = mons; m; m = m->next) {
++-+        for (c = m->clients; c; c = c->next) {
++-+            if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++-+                return c;
++-+        }
++-+    }
++-+
++-+    return NULL;
++-+}
++-+
++-+Client *
++-+swallowingclient(Window w)
++-+{
++-+    Client *c;
++-+    Monitor *m;
++-+
++-+    for (m = mons; m; m = m->next) {
++-+        for (c = m->clients; c; c = c->next) {
++-+            if (c->swallowing && c->swallowing->win == w)
++-+                return c;
++-+        }
++-+    }
++-+
++-+    return NULL;
++- }
++- 
++- Client *
++- wintoclient(Window w)
++- {
++--	Client *c;
++--	Monitor *m;
++-+    Client *c;
++-+    Monitor *m;
++- 
++--	for (m = mons; m; m = m->next)
++--		for (c = m->clients; c; c = c->next)
++--			if (c->win == w)
++--				return c;
++--	return NULL;
++-+    for (m = mons; m; m = m->next)
++-+        for (c = m->clients; c; c = c->next)
++-+            if (c->win == w)
++-+                return c;
++-+    return NULL;
++- }
++- 
++- Monitor *
++- wintomon(Window w)
++- {
++--	int x, y;
++--	Client *c;
++--	Monitor *m;
++-+    int x, y;
++-+    Client *c;
++-+    Monitor *m;
++- 
++--	if (w == root && getrootptr(&x, &y))
++--		return recttomon(x, y, 1, 1);
++--	for (m = mons; m; m = m->next)
++--		if (w == m->barwin)
++--			return m;
++--	if ((c = wintoclient(w)))
++--		return c->mon;
++--	return selmon;
++-+    if (w == root && getrootptr(&x, &y))
++-+        return recttomon(x, y, 1, 1);
++-+    for (m = mons; m; m = m->next)
++-+        if (w == m->barwin)
++-+            return m;
++-+    if ((c = wintoclient(w)))
++-+        return c->mon;
++-+    return selmon;
++- }
++- 
++- /* There's no way to check accesses to destroyed windows, thus those cases are
++-@@ -2097,25 +2691,25 @@ wintomon(Window w)
++- int
++- xerror(Display *dpy, XErrorEvent *ee)
++- {
++--	if (ee->error_code == BadWindow
++--	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
++--	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
++--	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
++--	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
++--	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
++--	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
++--	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
++--	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
++--		return 0;
++--	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
++--		ee->request_code, ee->error_code);
++--	return xerrorxlib(dpy, ee); /* may call exit */
++-+    if (ee->error_code == BadWindow
++-+            || (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
++-+            || (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
++-+            || (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
++-+            || (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
++-+            || (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
++-+            || (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
++-+            || (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
++-+            || (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
++-+        return 0;
++-+    fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
++-+            ee->request_code, ee->error_code);
++-+    return xerrorxlib(dpy, ee); /* may call exit */
++- }
++- 
++- int
++- xerrordummy(Display *dpy, XErrorEvent *ee)
++- {
++--	return 0;
++-+    return 0;
++- }
++- 
++- /* Startup Error handler to check if another window manager
++-@@ -2123,42 +2717,107 @@ xerrordummy(Display *dpy, XErrorEvent *ee)
++- int
++- xerrorstart(Display *dpy, XErrorEvent *ee)
++- {
++--	die("dwm: another window manager is already running");
++--	return -1;
++-+    die("dwm: another window manager is already running");
++-+    return -1;
++- }
++- 
++- void
++- zoom(const Arg *arg)
++- {
++--	Client *c = selmon->sel;
++-+    Client *c = selmon->sel;
++-+
++-+    if (!selmon->lt[selmon->sellt]->arrange
++-+            || (selmon->sel && selmon->sel->isfloating))
++-+        return;
++-+    if (c == nexttiled(selmon->clients))
++-+        if (!c || !(c = nexttiled(c->next)))
++-+            return;
++-+    pop(c);
++-+}
++-+
++-+void
++-+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++-+{
++-+    char *sdst = NULL;
++-+    int *idst = NULL;
++-+    float *fdst = NULL;
++-+
++-+    sdst = dst;
++-+    idst = dst;
++-+    fdst = dst;
++-+
++-+    char fullname[256];
++-+    char *type;
++-+    XrmValue ret;
++-+
++-+    snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++-+    fullname[sizeof(fullname) - 1] = '\0';
++-+
++-+    XrmGetResource(db, fullname, "*", &type, &ret);
++-+    if (!(ret.addr == NULL || strncmp("String", type, 64)))
++-+    {
++-+        switch (rtype) {
++-+            case STRING:
++-+                strcpy(sdst, ret.addr);
++-+                break;
++-+            case INTEGER:
++-+                *idst = strtoul(ret.addr, NULL, 10);
++-+                break;
++-+            case FLOAT:
++-+                *fdst = strtof(ret.addr, NULL);
++-+                break;
++-+        }
++-+    }
++-+}
++-+
++-+void
++-+load_xresources(void)
++-+{
++-+    Display *display;
++-+    char *resm;
++-+    XrmDatabase db;
++-+    ResourcePref *p;
++-+
++-+    display = XOpenDisplay(NULL);
++-+    resm = XResourceManagerString(display);
++-+    if (!resm)
++-+        return;
++- 
++--	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
++--		return;
++--	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
++--		return;
++--	pop(c);
++-+    db = XrmGetStringDatabase(resm);
++-+    for (p = resources; p < resources + LENGTH(resources); p++)
++-+        resource_load(db, p->name, p->type, p->dst);
++-+    XCloseDisplay(display);
++- }
++- 
++- int
++- main(int argc, char *argv[])
++- {
++--	if (argc == 2 && !strcmp("-v", argv[1]))
++--		die("dwm-"VERSION);
++--	else if (argc != 1)
++--		die("usage: dwm [-v]");
++--	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
++--		fputs("warning: no locale support\n", stderr);
++--	if (!(dpy = XOpenDisplay(NULL)))
++--		die("dwm: cannot open display");
++--	checkotherwm();
++--	setup();
++-+    if (argc == 2 && !strcmp("-v", argv[1]))
++-+        die("dwm-"VERSION);
++-+    else if (argc != 1)
++-+        die("usage: dwm [-v]");
++-+    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
++-+        fputs("warning: no locale support\n", stderr);
++-+    if (!(dpy = XOpenDisplay(NULL)))
++-+        die("dwm: cannot open display");
++-+    if (!(xcon = XGetXCBConnection(dpy)))
++-+        die("dwm: cannot get xcb connection\n");
++-+    checkotherwm();
++-+    XrmInitialize();
++-+    load_xresources();
++-+    setup();
++- #ifdef __OpenBSD__
++--	if (pledge("stdio rpath proc exec", NULL) == -1)
++--		die("pledge");
++-+    if (pledge("stdio rpath proc exec", NULL) == -1)
++-+        die("pledge");
++- #endif /* __OpenBSD__ */
++--	scan();
++--	run();
++--	cleanup();
++--	XCloseDisplay(dpy);
++--	return EXIT_SUCCESS;
++-+    scan();
++-+    runAutostart();
++-+    /* runautostart(); */
++-+    enablegaps = 1;
++-+    arrange(selmon);
++-+    run();
++-+    if(restart) execvp(argv[0], argv);
++-+    cleanup();
++-+    XCloseDisplay(dpy);
++-+    return EXIT_SUCCESS;
++- }
++-diff --git a/dwm.png b/dwm.png
++-deleted file mode 100644
++-index b1f9ba7..0000000
++-Binary files a/dwm.png and /dev/null differ
++-diff --git a/dwm_org.c b/dwm_org.c
++-new file mode 100644
++-index 0000000..0785fe3
++---- /dev/null
++-+++ b/dwm_org.c
++-@@ -0,0 +1,2893 @@
++-+/* See LICENSE file for copyright and license details.
++-+ *
++-+ * dynamic window manager is designed like any other X client as well. It is
++-+ * driven through handling X events. In contrast to other X clients, a window
++-+ * manager selects for SubstructureRedirectMask on the root window, to receive
++-+ * events about window (dis-)appearance. Only one X connection at a time is
++-+ * allowed to select for this event mask.
++-+ *
++-+ * The event handlers of dwm are organized in an array which is accessed
++-+ * whenever a new event has been fetched. This allows event dispatching
++-+ * in O(1) time.
++-+ *
++-+ * Each child of the root window is called a client, except windows which have
++-+ * set the override_redirect flag. Clients are organized in a linked client
++-+ * list on each monitor, the focus history is remembered through a stack list
++-+ * on each monitor. Each client contains a bit array to indicate the tags of a
++-+ * client.
++-+ *
++-+ * Keys and tagging rules are organized as arrays and defined in config.h.
++-+ *
++-+ * To understand everything else, start reading main().
++-+ */
++-+#include <errno.h>
++-+#include <locale.h>
++-+#include <signal.h>
++-+#include <stdarg.h>
++-+#include <stdio.h>
++-+#include <stdlib.h>
++-+#include <string.h>
++-+#include <unistd.h>
++-+#include <assert.h>
++-+#include <sys/types.h>
++-+#include <sys/stat.h>
++-+#include <sys/wait.h>
++-+#include <X11/cursorfont.h>
++-+#include <X11/keysym.h>
++-+#include <X11/Xatom.h>
++-+#include <X11/Xlib.h>
++-+#include <X11/Xproto.h>
++-+#include <X11/Xutil.h>
++-+#include <X11/Xresource.h>
++-+#ifdef XINERAMA
++-+#include <X11/extensions/Xinerama.h>
++-+#endif /* XINERAMA */
++-+#include <X11/Xft/Xft.h>
++-+#include <X11/Xlib-xcb.h>
++-+#include <xcb/res.h>
++-+
++-+#include "drw.h"
++-+#include "util.h"
++-+
++-+/* macros */
++-+#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++-+#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++-+#define GETINC(X)               ((X) - 2000)
++-+#define INC(X)                  ((X) + 2000)
++-+#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++-+                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++-+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
++-+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++-+#define PREVSEL                 3000
++-+#define LENGTH(X)               (sizeof X / sizeof X[0])
++-+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++-+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++-+#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++-+#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++-+#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
++-+#define TAGMASK			((1 << NUMTAGS) - 1)
++-+#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
++-+#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++-+#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++-+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++-+
++-+/* enums */
++-+enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++-+enum { SchemeNorm, SchemeSel, SchemeWarn, SchemeUrgent }; /* color schemes */
++-+enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++-+       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++-+       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++-+enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++-+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++-+       ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
++-+
++-+typedef union {
++-+	int i;
++-+	unsigned int ui;
++-+	float f;
++-+	const void *v;
++-+} Arg;
++-+
++-+typedef struct {
++-+	unsigned int click;
++-+	unsigned int mask;
++-+	unsigned int button;
++-+	void (*func)(const Arg *arg);
++-+	const Arg arg;
++-+} Button;
++-+
++-+typedef struct Monitor Monitor;
++-+typedef struct Client Client;
++-+struct Client {
++-+	char name[256];
++-+	float mina, maxa;
++-+	int x, y, w, h;
++-+	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++-+	int oldx, oldy, oldw, oldh;
++-+	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
++-+	int bw, oldbw;
++-+	unsigned int tags;
++-+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
++-+	pid_t pid;
++-+	Client *next;
++-+	Client *snext;
++-+	Client *swallowing;
++-+	Monitor *mon;
++-+	Window win;
++-+};
++-+
++-+typedef struct {
++-+	unsigned int mod;
++-+	KeySym keysym;
++-+	void (*func)(const Arg *);
++-+	const Arg arg;
++-+} Key;
++-+
++-+typedef struct {
++-+	const char *symbol;
++-+	void (*arrange)(Monitor *);
++-+} Layout;
++-+
++-+struct Monitor {
++-+	char ltsymbol[16];
++-+	float mfact;
++-+	int nmaster;
++-+	int num;
++-+	int by;               /* bar geometry */
++-+	int mx, my, mw, mh;   /* screen size */
++-+	int wx, wy, ww, wh;   /* window area  */
++-+	int gappih;           /* horizontal gap between windows */
++-+	int gappiv;           /* vertical gap between windows */
++-+	int gappoh;           /* horizontal outer gaps */
++-+	int gappov;           /* vertical outer gaps */
++-+	int gappx;			/* gaps between windows */
++-+	unsigned int seltags;
++-+	unsigned int sellt;
++-+	unsigned int tagset[2];
++-+	int showbar;
++-+	int topbar;
++-+	Client *clients;
++-+	Client *sel;
++-+	Client *stack;
++-+	Monitor *next;
++-+	Window barwin;
++-+	const Layout *lt[2];
++-+};
++-+
++-+typedef struct {
++-+	const char *class;
++-+	const char *instance;
++-+	const char *title;
++-+	unsigned int tags;
++-+	int isfloating;
++-+	int isterminal;
++-+	int noswallow;
++-+	int monitor;
++-+} Rule;
++-+
++-+/* Xresources preferences */
++-+enum resource_type {
++-+	STRING = 0,
++-+	INTEGER = 1,
++-+	FLOAT = 2
++-+};
++-+
++-+typedef struct {
++-+	char *name;
++-+	enum resource_type type;
++-+	void *dst;
++-+} ResourcePref;
++-+
++-+/* function declarations */
++-+static int colorincr;
++-+static void applyrules(Client *c);
++-+static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++-+static void arrange(Monitor *m);
++-+static void arrangemon(Monitor *m);
++-+static void attach(Client *c);
++-+static void attachstack(Client *c);
++-+static void buttonpress(XEvent *e);
++-+static void checkotherwm(void);
++-+static void cleanup(void);
++-+static void cleanupmon(Monitor *mon);
++-+static void clientmessage(XEvent *e);
++-+static void configure(Client *c);
++-+static void configurenotify(XEvent *e);
++-+static void configurerequest(XEvent *e);
++-+static void copyvalidchars(char *text, char *rawtext);
++-+static Monitor *createmon(void);
++-+static void destroynotify(XEvent *e);
++-+static void detach(Client *c);
++-+static void detachstack(Client *c);
++-+static Monitor *dirtomon(int dir);
++-+static void drawbar(Monitor *m);
++-+static void drawbars(void);
++-+static int drawstatusbar(Monitor *m, int bh, char* text);
++-+static void enternotify(XEvent *e);
++-+static void expose(XEvent *e);
++-+static void focus(Client *c);
++-+static void focusin(XEvent *e);
++-+static void focusmon(const Arg *arg);
++-+static void focusstack(const Arg *arg);
++-+static Atom getatomprop(Client *c, Atom prop);
++-+static int getrootptr(int *x, int *y);
++-+static long getstate(Window w);
++-+static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++-+static void grabbuttons(Client *c, int focused);
++-+static void grabkeys(void);
++-+static void incnmaster(const Arg *arg);
++-+static void keypress(XEvent *e);
++-+static void killclient(const Arg *arg);
++-+static void manage(Window w, XWindowAttributes *wa);
++-+static void mappingnotify(XEvent *e);
++-+static void maprequest(XEvent *e);
++-+static void monocle(Monitor *m);
++-+static void motionnotify(XEvent *e);
++-+static void movemouse(const Arg *arg);
++-+static Client *nexttiled(Client *c);
++-+static void pop(Client *);
++-+static void propertynotify(XEvent *e);
++-+static void pushstack(const Arg *arg);
++-+static void quit(const Arg *arg);
++-+static Monitor *recttomon(int x, int y, int w, int h);
++-+static void resize(Client *c, int x, int y, int w, int h, int interact);
++-+static void resizeclient(Client *c, int x, int y, int w, int h);
++-+static void resizemouse(const Arg *arg);
++-+static void restack(Monitor *m);
++-+static void run(void);
++-+static void runAutostart(void);
++-+static void scan(void);
++-+static int sendevent(Client *c, Atom proto);
++-+static void sendmon(Client *c, Monitor *m);
++-+static void setclientstate(Client *c, long state);
++-+static void setfocus(Client *c);
++-+static void setfullscreen(Client *c, int fullscreen);
++-+static void setlayout(const Arg *arg);
++-+static void setmfact(const Arg *arg);
++-+static void setup(void);
++-+static void seturgent(Client *c, int urg);
++-+static void showhide(Client *c);
++-+static void sigchld(int unused);
++-+#ifndef __OpenBSD__
++-+static int getdwmblockspid();
++-+static void sigdwmblocks(const Arg *arg);
++-+#endif
++-+static void sighup(int unused);
++-+static void sigterm(int unused);
++-+static void spawn(const Arg *arg);
++-+static int stackpos(const Arg *arg);
++-+static void tag(const Arg *arg);
++-+static void noviewontag(const Arg *arg);
++-+static void tagmon(const Arg *arg);
++-+static void togglebar(const Arg *arg);
++-+static void togglefloating(const Arg *arg);
++-+static void togglescratch(const Arg *arg);
++-+static void togglesticky(const Arg *arg);
++-+static void togglefullscr(const Arg *arg);
++-+static void toggletag(const Arg *arg);
++-+static void toggleview(const Arg *arg);
++-+static void unfocus(Client *c, int setfocus);
++-+static void unmanage(Client *c, int destroyed);
++-+static void unmapnotify(XEvent *e);
++-+static void updatebarpos(Monitor *m);
++-+static void updatebars(void);
++-+static void updateclientlist(void);
++-+static int updategeom(void);
++-+static void updatenumlockmask(void);
++-+static void updatesizehints(Client *c);
++-+static void updatestatus(void);
++-+static void updatetitle(Client *c);
++-+static void updatewindowtype(Client *c);
++-+static void updatewmhints(Client *c);
++-+static void view(const Arg *arg);
++-+static Client *wintoclient(Window w);
++-+static Monitor *wintomon(Window w);
++-+static int xerror(Display *dpy, XErrorEvent *ee);
++-+static int xerrordummy(Display *dpy, XErrorEvent *ee);
++-+static int xerrorstart(Display *dpy, XErrorEvent *ee);
++-+static void zoom(const Arg *arg);
++-+static void load_xresources(void);
++-+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
++-+
++-+static pid_t getparentprocess(pid_t p);
++-+static int isdescprocess(pid_t p, pid_t c);
++-+static Client *swallowingclient(Window w);
++-+static Client *termforwin(const Client *c);
++-+static pid_t winpid(Window w);
++-+
++-+/* variables */
++-+static const char broken[] = "broken";
++-+static const char dwmdir[] = "dwm";
++-+static const char localshare[] = ".local/share";
++-+/* static char stext[256]; */
++-+static char stext[1024];
++-+static char rawstext[256];
++-+static int dwmblockssig;
++-+pid_t dwmblockspid = 0;
++-+static int screen;
++-+static int sw, sh;           /* X display screen geometry width, height */
++-+static int bh, blw = 0;      /* bar geometry */
++-+static int lrpad;            /* sum of left and right padding for text */
++-+static int (*xerrorxlib)(Display *, XErrorEvent *);
++-+static unsigned int numlockmask = 0;
++-+static void (*handler[LASTEvent]) (XEvent *) = {
++-+	[ButtonPress] = buttonpress,
++-+	[ClientMessage] = clientmessage,
++-+	[ConfigureRequest] = configurerequest,
++-+	[ConfigureNotify] = configurenotify,
++-+	[DestroyNotify] = destroynotify,
++-+	[EnterNotify] = enternotify,
++-+	[Expose] = expose,
++-+	[FocusIn] = focusin,
++-+	[KeyPress] = keypress,
++-+	[MappingNotify] = mappingnotify,
++-+	[MapRequest] = maprequest,
++-+	[MotionNotify] = motionnotify,
++-+	[PropertyNotify] = propertynotify,
++-+	[UnmapNotify] = unmapnotify
++-+};
++-+static Atom wmatom[WMLast], netatom[NetLast];
++-+static int restart = 0;
++-+static int running = 1;
++-+static Cur *cursor[CurLast];
++-+static Clr **scheme;
++-+static Display *dpy;
++-+static Drw *drw;
++-+static Monitor *mons, *selmon;
++-+static Window root, wmcheckwin;
++-+
++-+static xcb_connection_t *xcon;
++-+
++-+/* configuration, allows nested code to access above variables */
++-+#include "config.h"
++-+
++-+/* compile-time check if all tags fit into an unsigned int bit array. */
++-+struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
++-+
++-+/* function implementations */
++-+void
++-+applyrules(Client *c)
++-+{
++-+	const char *class, *instance;
++-+	unsigned int i;
++-+	const Rule *r;
++-+	Monitor *m;
++-+	XClassHint ch = { NULL, NULL };
++-+
++-+	/* rule matching */
++-+	c->isfloating = 0;
++-+	c->tags = 0;
++-+	XGetClassHint(dpy, c->win, &ch);
++-+	class    = ch.res_class ? ch.res_class : broken;
++-+	instance = ch.res_name  ? ch.res_name  : broken;
++-+
++-+	for (i = 0; i < LENGTH(rules); i++) {
++-+		r = &rules[i];
++-+		if ((!r->title || strstr(c->name, r->title))
++-+		&& (!r->class || strstr(class, r->class))
++-+		&& (!r->instance || strstr(instance, r->instance)))
++-+		{
++-+			c->isterminal = r->isterminal;
++-+			c->isfloating = r->isfloating;
++-+			c->noswallow  = r->noswallow;
++-+			c->tags |= r->tags;
++-+			if ((r->tags & SPTAGMASK) && r->isfloating) {
++-+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++-+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++-+			}
++-+
++-+			for (m = mons; m && m->num != r->monitor; m = m->next);
++-+			if (m)
++-+				c->mon = m;
++-+		}
++-+	}
++-+	if (ch.res_class)
++-+		XFree(ch.res_class);
++-+	if (ch.res_name)
++-+		XFree(ch.res_name);
++-+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++-+}
++-+
++-+int
++-+applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
++-+{
++-+	int baseismin;
++-+	Monitor *m = c->mon;
++-+
++-+	/* set minimum possible */
++-+	*w = MAX(1, *w);
++-+	*h = MAX(1, *h);
++-+	if (interact) {
++-+		if (*x > sw)
++-+			*x = sw - WIDTH(c);
++-+		if (*y > sh)
++-+			*y = sh - HEIGHT(c);
++-+		if (*x + *w + 2 * c->bw < 0)
++-+			*x = 0;
++-+		if (*y + *h + 2 * c->bw < 0)
++-+			*y = 0;
++-+	} else {
++-+		if (*x >= m->wx + m->ww)
++-+			*x = m->wx + m->ww - WIDTH(c);
++-+		if (*y >= m->wy + m->wh)
++-+			*y = m->wy + m->wh - HEIGHT(c);
++-+		if (*x + *w + 2 * c->bw <= m->wx)
++-+			*x = m->wx;
++-+		if (*y + *h + 2 * c->bw <= m->wy)
++-+			*y = m->wy;
++-+	}
++-+	if (*h < bh)
++-+		*h = bh;
++-+	if (*w < bh)
++-+		*w = bh;
++-+	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
++-+		/* see last two sentences in ICCCM 4.1.2.3 */
++-+		baseismin = c->basew == c->minw && c->baseh == c->minh;
++-+		if (!baseismin) { /* temporarily remove base dimensions */
++-+			*w -= c->basew;
++-+			*h -= c->baseh;
++-+		}
++-+		/* adjust for aspect limits */
++-+		if (c->mina > 0 && c->maxa > 0) {
++-+			if (c->maxa < (float)*w / *h)
++-+				*w = *h * c->maxa + 0.5;
++-+			else if (c->mina < (float)*h / *w)
++-+				*h = *w * c->mina + 0.5;
++-+		}
++-+		if (baseismin) { /* increment calculation requires this */
++-+			*w -= c->basew;
++-+			*h -= c->baseh;
++-+		}
++-+		/* adjust for increment value */
++-+		if (c->incw)
++-+			*w -= *w % c->incw;
++-+		if (c->inch)
++-+			*h -= *h % c->inch;
++-+		/* restore base dimensions */
++-+		*w = MAX(*w + c->basew, c->minw);
++-+		*h = MAX(*h + c->baseh, c->minh);
++-+		if (c->maxw)
++-+			*w = MIN(*w, c->maxw);
++-+		if (c->maxh)
++-+			*h = MIN(*h, c->maxh);
++-+	}
++-+	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
++-+}
++-+
++-+void
++-+arrange(Monitor *m)
++-+{
++-+	if (m)
++-+		showhide(m->stack);
++-+	else for (m = mons; m; m = m->next)
++-+		showhide(m->stack);
++-+	if (m) {
++-+		arrangemon(m);
++-+		restack(m);
++-+	} else for (m = mons; m; m = m->next)
++-+		arrangemon(m);
++-+}
++-+
++-+void
++-+arrangemon(Monitor *m)
++-+{
++-+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
++-+	if (m->lt[m->sellt]->arrange)
++-+		m->lt[m->sellt]->arrange(m);
++-+}
++-+
++-+void
++-+attach(Client *c)
++-+{
++-+	c->next = c->mon->clients;
++-+	c->mon->clients = c;
++-+}
++-+
++-+void
++-+attachstack(Client *c)
++-+{
++-+	c->snext = c->mon->stack;
++-+	c->mon->stack = c;
++-+}
++-+
++-+void
++-+swallow(Client *p, Client *c)
++-+{
++-+	if (c->noswallow || c->isterminal)
++-+		return;
++-+	if (!swallowfloating && c->isfloating)
++-+		return;
++-+
++-+	detach(c);
++-+	detachstack(c);
++-+
++-+	setclientstate(c, WithdrawnState);
++-+	XUnmapWindow(dpy, p->win);
++-+
++-+	p->swallowing = c;
++-+	c->mon = p->mon;
++-+
++-+	Window w = p->win;
++-+	p->win = c->win;
++-+	c->win = w;
++-+	updatetitle(p);
++-+
++-+	XWindowChanges wc;
++-+	wc.border_width = p->bw;
++-+	XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
++-+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++-+	XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
++-+
++-+	arrange(p->mon);
++-+	configure(p);
++-+	updateclientlist();
++-+}
++-+
++-+void
++-+unswallow(Client *c)
++-+{
++-+	c->win = c->swallowing->win;
++-+
++-+	free(c->swallowing);
++-+	c->swallowing = NULL;
++-+
++-+	/* unfullscreen the client */
++-+	setfullscreen(c, 0);
++-+	updatetitle(c);
++-+	arrange(c->mon);
++-+	XMapWindow(dpy, c->win);
++-+
++-+	XWindowChanges wc;
++-+	wc.border_width = c->bw;
++-+	XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
++-+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++-+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++-+
++-+	setclientstate(c, NormalState);
++-+	focus(NULL);
++-+	arrange(c->mon);
++-+}
++-+
++-+void
++-+buttonpress(XEvent *e)
++-+{
++-+	unsigned int i, x, click, occ = 0;
++-+	Arg arg = {0};
++-+	Client *c;
++-+	Monitor *m;
++-+	XButtonPressedEvent *ev = &e->xbutton;
++-+
++-+	click = ClkRootWin;
++-+	/* focus monitor if necessary */
++-+	if ((m = wintomon(ev->window)) && m != selmon) {
++-+		unfocus(selmon->sel, 1);
++-+		selmon = m;
++-+		focus(NULL);
++-+	}
++-+	if (ev->window == selmon->barwin) {
++-+		i = x = 0;
++-+		for (c = m->clients; c; c = c->next)
++-+			occ |= c->tags == 255 ? 0 : c->tags;
++-+		do {
++-+			/* do not reserve space for vacant tags */
++-+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++-+				continue;
++-+			x += TEXTW(tags[i]);
++-+		} while (ev->x >= x && ++i < LENGTH(tags));
++-+		if (i < LENGTH(tags)) {
++-+			click = ClkTagBar;
++-+			arg.ui = 1 << i;
++-+		} else if (ev->x < x + blw)
++-+			click = ClkLtSymbol;
++-+		else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
++-+			click = ClkStatusText; 
++-+
++-+			char *text = rawstext;
++-+			int i = -1;
++-+			char ch;
++-+			dwmblockssig = 0;
++-+			while (text[++i]) {
++-+				if ((unsigned char)text[i] < ' ') {
++-+					ch = text[i];
++-+					text[i] = '\0';
++-+					x += TEXTW(text) - lrpad;
++-+					text[i] = ch;
++-+					text += i+1;
++-+					i = -1;
++-+					if (x >= ev->x) break;
++-+					dwmblockssig = ch;
++-+				}
++-+			}
++-+		} else
++-+			click = ClkWinTitle;
++-+			/* click = ClkStatusText; */
++-+	} else if ((c = wintoclient(ev->window))) {
++-+		focus(c);
++-+		restack(selmon);
++-+		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++-+		click = ClkClientWin;
++-+	}
++-+	for (i = 0; i < LENGTH(buttons); i++)
++-+		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
++-+		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
++-+			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
++-+}
++-+
++-+void
++-+checkotherwm(void)
++-+{
++-+	xerrorxlib = XSetErrorHandler(xerrorstart);
++-+	/* this causes an error if some other window manager is running */
++-+	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
++-+	XSync(dpy, False);
++-+	XSetErrorHandler(xerror);
++-+	XSync(dpy, False);
++-+}
++-+
++-+void
++-+cleanup(void)
++-+{
++-+	Arg a = {.ui = ~0};
++-+	Layout foo = { "", NULL };
++-+	Monitor *m;
++-+	size_t i;
++-+
++-+	view(&a);
++-+	selmon->lt[selmon->sellt] = &foo;
++-+	for (m = mons; m; m = m->next)
++-+		while (m->stack)
++-+			unmanage(m->stack, 0);
++-+	XUngrabKey(dpy, AnyKey, AnyModifier, root);
++-+	while (mons)
++-+		cleanupmon(mons);
++-+	for (i = 0; i < CurLast; i++)
++-+		drw_cur_free(drw, cursor[i]);
++-+	/* for (i = 0; i < LENGTH(colors); i++) */
++-+	for (i = 0; i < LENGTH(colors) + 1; i++)
++-+		free(scheme[i]);
++-+	XDestroyWindow(dpy, wmcheckwin);
++-+	drw_free(drw);
++-+	XSync(dpy, False);
++-+	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
++-+	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+}
++-+
++-+void
++-+cleanupmon(Monitor *mon)
++-+{
++-+	Monitor *m;
++-+
++-+	if (mon == mons)
++-+		mons = mons->next;
++-+	else {
++-+		for (m = mons; m && m->next != mon; m = m->next);
++-+		m->next = mon->next;
++-+	}
++-+	XUnmapWindow(dpy, mon->barwin);
++-+	XDestroyWindow(dpy, mon->barwin);
++-+	free(mon);
++-+}
++-+
++-+void
++-+clientmessage(XEvent *e)
++-+{
++-+	XClientMessageEvent *cme = &e->xclient;
++-+	Client *c = wintoclient(cme->window);
++-+
++-+	if (!c)
++-+		return;
++-+	if (cme->message_type == netatom[NetWMState]) {
++-+		if (cme->data.l[1] == netatom[NetWMFullscreen]
++-+		|| cme->data.l[2] == netatom[NetWMFullscreen])
++-+			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++-+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++-+	} else if (cme->message_type == netatom[NetActiveWindow]) {
++-+		if (c != selmon->sel && !c->isurgent)
++-+			seturgent(c, 1);
++-+	}
++-+}
++-+
++-+void
++-+configure(Client *c)
++-+{
++-+	XConfigureEvent ce;
++-+
++-+	ce.type = ConfigureNotify;
++-+	ce.display = dpy;
++-+	ce.event = c->win;
++-+	ce.window = c->win;
++-+	ce.x = c->x;
++-+	ce.y = c->y;
++-+	ce.width = c->w;
++-+	ce.height = c->h;
++-+	ce.border_width = c->bw;
++-+	ce.above = None;
++-+	ce.override_redirect = False;
++-+	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
++-+}
++-+
++-+void
++-+configurenotify(XEvent *e)
++-+{
++-+	Monitor *m;
++-+	Client *c;
++-+	XConfigureEvent *ev = &e->xconfigure;
++-+	int dirty;
++-+
++-+	/* TODO: updategeom handling sucks, needs to be simplified */
++-+	if (ev->window == root) {
++-+		dirty = (sw != ev->width || sh != ev->height);
++-+		sw = ev->width;
++-+		sh = ev->height;
++-+		if (updategeom() || dirty) {
++-+			drw_resize(drw, sw, bh);
++-+			updatebars();
++-+			for (m = mons; m; m = m->next) {
++-+				for (c = m->clients; c; c = c->next)
++-+					if (c->isfullscreen)
++-+						resizeclient(c, m->mx, m->my, m->mw, m->mh);
++-+				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++-+			}
++-+			focus(NULL);
++-+			arrange(NULL);
++-+		}
++-+	}
++-+}
++-+
++-+void
++-+configurerequest(XEvent *e)
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+	XConfigureRequestEvent *ev = &e->xconfigurerequest;
++-+	XWindowChanges wc;
++-+
++-+	if ((c = wintoclient(ev->window))) {
++-+		if (ev->value_mask & CWBorderWidth)
++-+			c->bw = ev->border_width;
++-+		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
++-+			m = c->mon;
++-+			if (ev->value_mask & CWX) {
++-+				c->oldx = c->x;
++-+				c->x = m->mx + ev->x;
++-+			}
++-+			if (ev->value_mask & CWY) {
++-+				c->oldy = c->y;
++-+				c->y = m->my + ev->y;
++-+			}
++-+			if (ev->value_mask & CWWidth) {
++-+				c->oldw = c->w;
++-+				c->w = ev->width;
++-+			}
++-+			if (ev->value_mask & CWHeight) {
++-+				c->oldh = c->h;
++-+				c->h = ev->height;
++-+			}
++-+			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
++-+				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
++-+			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
++-+				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
++-+			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
++-+				configure(c);
++-+			if (ISVISIBLE(c))
++-+				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++-+		} else
++-+			configure(c);
++-+	} else {
++-+		wc.x = ev->x;
++-+		wc.y = ev->y;
++-+		wc.width = ev->width;
++-+		wc.height = ev->height;
++-+		wc.border_width = ev->border_width;
++-+		wc.sibling = ev->above;
++-+		wc.stack_mode = ev->detail;
++-+		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
++-+	}
++-+	XSync(dpy, False);
++-+}
++-+
++-+void
++-+copyvalidchars(char *text, char *rawtext)
++-+{
++-+	int i = -1, j = 0;
++-+
++-+	while(rawtext[++i]) {
++-+		if ((unsigned char)rawtext[i] >= ' ') {
++-+			text[j++] = rawtext[i];
++-+		}
++-+	}
++-+	text[j] = '\0';
++-+}
++-+
++-+Monitor *
++-+createmon(void)
++-+{
++-+	Monitor *m;
++-+
++-+	m = ecalloc(1, sizeof(Monitor));
++-+	m->tagset[0] = m->tagset[1] = 1;
++-+	m->mfact = mfact;
++-+	m->nmaster = nmaster;
++-+	m->showbar = showbar;
++-+	m->topbar = topbar;
++-+	m->gappih = gappih;
++-+	m->gappiv = gappiv;
++-+	m->gappoh = gappoh;
++-+	m->gappov = gappov;
++-+	m->lt[0] = &layouts[0];
++-+	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++-+	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++-+	return m;
++-+}
++-+
++-+void
++-+destroynotify(XEvent *e)
++-+{
++-+	Client *c;
++-+	XDestroyWindowEvent *ev = &e->xdestroywindow;
++-+
++-+	if ((c = wintoclient(ev->window)))
++-+		unmanage(c, 1);
++-+
++-+	else if ((c = swallowingclient(ev->window)))
++-+		unmanage(c->swallowing, 1);
++-+}
++-+
++-+void
++-+detach(Client *c)
++-+{
++-+	Client **tc;
++-+
++-+	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
++-+	*tc = c->next;
++-+}
++-+
++-+void
++-+detachstack(Client *c)
++-+{
++-+	Client **tc, *t;
++-+
++-+	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
++-+	*tc = c->snext;
++-+
++-+	if (c == c->mon->sel) {
++-+		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
++-+		c->mon->sel = t;
++-+	}
++-+}
++-+
++-+Monitor *
++-+dirtomon(int dir)
++-+{
++-+	Monitor *m = NULL;
++-+
++-+	if (dir > 0) {
++-+		if (!(m = selmon->next))
++-+			m = mons;
++-+	} else if (selmon == mons)
++-+		for (m = mons; m->next; m = m->next);
++-+	else
++-+		for (m = mons; m->next != selmon; m = m->next);
++-+	return m;
++-+}
++-+
++-+
++-+char**
++-+str_split(char* a_str, const char a_delim)
++-+{
++-+    char** result    = 0;
++-+    size_t count     = 0;
++-+    char* tmp        = a_str;
++-+    char* last_comma = 0;
++-+    char delim[2];
++-+    delim[0] = a_delim;
++-+    delim[1] = 0;
++-+
++-+    /* Count how many elements will be extracted. */
++-+    while (*tmp)
++-+    {
++-+        if (a_delim == *tmp)
++-+        {
++-+            count++;
++-+            last_comma = tmp;
++-+        }
++-+        tmp++;
++-+    }
++-+
++-+    /* Add space for trailing token. */
++-+    count += last_comma < (a_str + strlen(a_str) - 1);
++-+
++-+    /* Add space for terminating null string so caller
++-+       knows where the list of returned strings ends. */
++-+    count++;
++-+
++-+    result = malloc(sizeof(char*) * count);
++-+
++-+    if (result)
++-+    {
++-+        size_t idx  = 0;
++-+        char* token = strtok(a_str, delim);
++-+
++-+        while (token)
++-+        {
++-+            assert(idx < count);
++-+            *(result + idx++) = strdup(token);
++-+            token = strtok(0, delim);
++-+        }
++-+        assert(idx == count - 1);
++-+        *(result + idx) = 0;
++-+    }
++-+
++-+    return result;
++-+}
++-+
++-+
++-+int
++-+drawstatusbar(Monitor *m, int bh, char* stext) {
++-+	int ret, i, w, x, len;
++-+	short isCode = 0;
++-+	char *text;
++-+	char *p;
++-+	colorincr = 0;
++-+
++-+	len = strlen(stext) + 1 ;
++-+	if (!(text = (char*) malloc(sizeof(char)*len)))
++-+		die("malloc");
++-+	p = text;
++-+	memcpy(text, stext, len);
++-+
++-+	/* compute width of the status text */
++-+	w = 0;
++-+	i = -1;
++-+	while (text[++i]) {
++-+		if (text[i] == '^') {
++-+			if (!isCode) {
++-+				isCode = 1;
++-+				text[i] = '\0';
++-+				w += TEXTW(text) - lrpad;
++-+				text[i] = '^';
++-+				if (text[++i] == 'f')
++-+					w += atoi(text + ++i);
++-+			} else {
++-+				isCode = 0;
++-+				text = text + i + 1;
++-+				i = -1;
++-+			}
++-+		}
++-+	}
++-+	if (!isCode)
++-+		w += TEXTW(text) - lrpad;
++-+	else
++-+		isCode = 0;
++-+	text = p;
++-+
++-+	w += 2; /* 1px padding on both sides */
++-+	ret = x = m->ww - w;
++-+
++-+	drw_setscheme(drw, scheme[LENGTH(colors)]);
++-+	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++-+	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++-+	drw_rect(drw, x, 0, w, bh, 1, 1);
++-+	x++;
++-+
++-+	/* process status text */
++-+	i = -1;
++-+
++-+	while (text[++i]) {
++-+		if (text[i] == '^' && !isCode) {
++-+			isCode = 1;
++-+
++-+			text[i] = '\0';
++-+			w = TEXTW(text) - lrpad;
++-+			drw_text(drw, x, 0, w, bh, 0, text, 0);
++-+			x += w;
++-+
++-+			while (text[++i] != '^') {
++-+				if (text[i] == '1') {
++-+					char col1[] = "#98971a";
++-+					drw_clr_create(drw, &drw->scheme[ColFg], col1);
++-+				} else if (text[i] == '2') {
++-+					// Check if weather is hot or not
++-+					FILE *ptr;
++-+					char ch;
++-+					ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
++-+					int hotbool = 0;
++-+					if (ptr == NULL) printf("Fail to read wr...");
++-+					do{
++-+						ch = fgetc(ptr);
++-+						// Check if contains + and 2 (= hot)
++-+						if (hotbool){
++-+							if (ch == '2' || ch == '3'){
++-+								char col2[] = "#fb4934";
++-+								drw_clr_create(drw, &drw->scheme[ColFg], col2);
++-+								break;
++-+							}else{
++-+								char col2[] = "#ebdbb2";
++-+								drw_clr_create(drw, &drw->scheme[ColFg], col2);
++-+								break;
++-+							}
++-+						}
++-+
++-+						if (ch == '+'){
++-+							hotbool = 1;
++-+						}else if (ch == '-') {
++-+							char col2[] = "#458588";
++-+							drw_clr_create(drw, &drw->scheme[ColFg], col2);
++-+							break;
++-+						}
++-+						else{
++-+							char col2[] = "#ebdbb2";
++-+							drw_clr_create(drw, &drw->scheme[ColFg], col2);
++-+							break;
++-+						}
++-+					} while (ch != EOF);
++-+					fclose(ptr);
++-+				} else if (text[i] == '3') {
++-+					char col3[] = "#fabd2f";
++-+					drw_clr_create(drw, &drw->scheme[ColFg], col3);
++-+				} else if (text[i] == '4') {
++-+					char col4[] = "#83a598";
++-+					drw_clr_create(drw, &drw->scheme[ColFg], col4);
++-+				} else if (text[i] == '5') {
++-+					char col5[] = "#d3869b";
++-+					drw_clr_create(drw, &drw->scheme[ColFg], col5);
++-+				} else if (text[i] == '6') {
++-+					char col6[] = "#8ec07c";
++-+					drw_clr_create(drw, &drw->scheme[ColFg], col6);
++-+				}
++-+			}
++-+
++-+			text = text + i + 1;
++-+			i=-1;
++-+			isCode = 0;
++-+		}
++-+	}
++-+
++-+	if (!isCode) {
++-+		w = TEXTW(text) - lrpad;
++-+		drw_text(drw, x, 0, w, bh, 0, text, 0);
++-+	}
++-+
++-+	drw_setscheme(drw, scheme[SchemeNorm]);
++-+	free(p);
++-+
++-+	return ret;
++-+}
++-+
++-+void
++-+drawbar(Monitor *m)
++-+{
++-+	int x, w, tw = 0;
++-+	int boxs = drw->fonts->h / 9;
++-+	int boxw = drw->fonts->h / 6 + 2;
++-+	unsigned int i, occ = 0, urg = 0;
++-+	char *ts = stext;
++-+	char *tp = stext;
++-+	int tx = 0;
++-+	char ctmp;
++-+	Client *c;
++-+
++-+	/* draw status first so it can be overdrawn by tags later */
++-+	if (m == selmon) { /* status is only drawn on selected monitor */
++-+		tw = m->ww - drawstatusbar(m, bh, stext);
++-+		/* FILE *fp; */
++-+		/* fp = fopen("/home/jonas/test.txt", "w"); */
++-+		/* /1* fprintf(fp, stext); *1/ */
++-+		/* fprintf(fp, stext); */
++-+		/* fclose(fp); */
++-+	}
++-+
++-+	for (c = m->clients; c; c = c->next) {
++-+		occ |= c->tags == 255 ? 0 : c->tags;
++-+		if (c->isurgent)
++-+			urg |= c->tags;
++-+	}
++-+	x = 0;
++-+	for (i = 0; i < LENGTH(tags); i++) {
++-+		/* do not draw vacant tags */
++-+		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++-+		continue;
++-+
++-+		w = TEXTW(tags[i]);
++-+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++-+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++-+		x += w;
++-+	}
++-+	w = blw = TEXTW(m->ltsymbol);
++-+	drw_setscheme(drw, scheme[SchemeNorm]);
++-+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++-+
++-+	if ((w = m->ww - tw - x) > bh) {
++-+		drw_setscheme(drw, scheme[SchemeNorm]);
++-+		drw_rect(drw, x, 0, w, bh, 1, 1);
++-+	}
++-+	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++-+}
++-+
++-+void
++-+drawbars(void)
++-+{
++-+	Monitor *m;
++-+
++-+	for (m = mons; m; m = m->next)
++-+		drawbar(m);
++-+}
++-+
++-+void
++-+enternotify(XEvent *e)
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+	XCrossingEvent *ev = &e->xcrossing;
++-+
++-+	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++-+		return;
++-+	c = wintoclient(ev->window);
++-+	m = c ? c->mon : wintomon(ev->window);
++-+	if (m != selmon) {
++-+		unfocus(selmon->sel, 1);
++-+		selmon = m;
++-+	} else if (!c || c == selmon->sel)
++-+		return;
++-+	focus(c);
++-+}
++-+
++-+void
++-+expose(XEvent *e)
++-+{
++-+	Monitor *m;
++-+	XExposeEvent *ev = &e->xexpose;
++-+
++-+	if (ev->count == 0 && (m = wintomon(ev->window)))
++-+		drawbar(m);
++-+}
++-+
++-+void
++-+focus(Client *c)
++-+{
++-+
++-+	if (!c || !ISVISIBLE(c))
++-+		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
++-+	if (selmon->sel && selmon->sel != c)
++-+		unfocus(selmon->sel, 0);
++-+	if (c) {
++-+		if (c->mon != selmon)
++-+			selmon = c->mon;
++-+		if (c->isurgent)
++-+			seturgent(c, 0);
++-+		detachstack(c);
++-+		attachstack(c);
++-+		grabbuttons(c, 1);
++-+		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
++-+		setfocus(c);
++-+	} else {
++-+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++-+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+	}
++-+	selmon->sel = c;
++-+	drawbars();
++-+}
++-+
++-+/* there are some broken focus acquiring clients needing extra handling */
++-+void
++-+focusin(XEvent *e)
++-+{
++-+	XFocusChangeEvent *ev = &e->xfocus;
++-+
++-+	if (selmon->sel && ev->window != selmon->sel->win)
++-+		setfocus(selmon->sel);
++-+}
++-+
++-+void
++-+focusmon(const Arg *arg)
++-+{
++-+	Monitor *m;
++-+
++-+	if (!mons->next)
++-+		return;
++-+	if ((m = dirtomon(arg->i)) == selmon)
++-+		return;
++-+	unfocus(selmon->sel, 0);
++-+	selmon = m;
++-+	focus(NULL);
++-+}
++-+
++-+void
++-+focusstack(const Arg *arg)
++-+{
++-+	int i = stackpos(arg);
++-+	Client *c, *p;
++-+
++-+	if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
++-+		return;
++-+
++-+	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++-+	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++-+	focus(c ? c : p);
++-+	restack(selmon);
++-+}
++-+
++-+Atom
++-+getatomprop(Client *c, Atom prop)
++-+{
++-+	int di;
++-+	unsigned long dl;
++-+	unsigned char *p = NULL;
++-+	Atom da, atom = None;
++-+
++-+	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
++-+		&da, &di, &dl, &dl, &p) == Success && p) {
++-+		atom = *(Atom *)p;
++-+		XFree(p);
++-+	}
++-+	return atom;
++-+}
++-+
++-+#ifndef __OpenBSD__
++-+int
++-+getdwmblockspid()
++-+{
++-+	char buf[16];
++-+	FILE *fp = popen("pidof -s dwmblocks", "r");
++-+	fgets(buf, sizeof(buf), fp);
++-+	pid_t pid = strtoul(buf, NULL, 10);
++-+	pclose(fp);
++-+	dwmblockspid = pid;
++-+	return pid != 0 ? 0 : -1;
++-+}
++-+#endif
++-+
++-+int
++-+getrootptr(int *x, int *y)
++-+{
++-+	int di;
++-+	unsigned int dui;
++-+	Window dummy;
++-+
++-+	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
++-+}
++-+
++-+long
++-+getstate(Window w)
++-+{
++-+	int format;
++-+	long result = -1;
++-+	unsigned char *p = NULL;
++-+	unsigned long n, extra;
++-+	Atom real;
++-+
++-+	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
++-+		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
++-+		return -1;
++-+	if (n != 0)
++-+		result = *p;
++-+	XFree(p);
++-+	return result;
++-+}
++-+
++-+int
++-+gettextprop(Window w, Atom atom, char *text, unsigned int size)
++-+{
++-+	char **list = NULL;
++-+	int n;
++-+	XTextProperty name;
++-+
++-+	if (!text || size == 0)
++-+		return 0;
++-+	text[0] = '\0';
++-+	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++-+		return 0;
++-+	if (name.encoding == XA_STRING)
++-+		strncpy(text, (char *)name.value, size - 1);
++-+	else {
++-+		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++-+			strncpy(text, *list, size - 1);
++-+			XFreeStringList(list);
++-+		}
++-+	}
++-+	text[size - 1] = '\0';
++-+	XFree(name.value);
++-+	return 1;
++-+}
++-+
++-+void
++-+grabbuttons(Client *c, int focused)
++-+{
++-+	updatenumlockmask();
++-+	{
++-+		unsigned int i, j;
++-+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++-+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++-+		if (!focused)
++-+			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
++-+				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
++-+		for (i = 0; i < LENGTH(buttons); i++)
++-+			if (buttons[i].click == ClkClientWin)
++-+				for (j = 0; j < LENGTH(modifiers); j++)
++-+					XGrabButton(dpy, buttons[i].button,
++-+						buttons[i].mask | modifiers[j],
++-+						c->win, False, BUTTONMASK,
++-+						GrabModeAsync, GrabModeSync, None, None);
++-+	}
++-+}
++-+
++-+void
++-+grabkeys(void)
++-+{
++-+	updatenumlockmask();
++-+	{
++-+		unsigned int i, j;
++-+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++-+		KeyCode code;
++-+
++-+		XUngrabKey(dpy, AnyKey, AnyModifier, root);
++-+		for (i = 0; i < LENGTH(keys); i++)
++-+			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
++-+				for (j = 0; j < LENGTH(modifiers); j++)
++-+					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
++-+						True, GrabModeAsync, GrabModeAsync);
++-+	}
++-+}
++-+
++-+void
++-+incnmaster(const Arg *arg)
++-+{
++-+	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++-+	arrange(selmon);
++-+}
++-+
++-+#ifdef XINERAMA
++-+static int
++-+isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++-+{
++-+	while (n--)
++-+		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++-+		&& unique[n].width == info->width && unique[n].height == info->height)
++-+			return 0;
++-+	return 1;
++-+}
++-+#endif /* XINERAMA */
++-+
++-+void
++-+keypress(XEvent *e)
++-+{
++-+	unsigned int i;
++-+	KeySym keysym;
++-+	XKeyEvent *ev;
++-+
++-+	ev = &e->xkey;
++-+	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
++-+	for (i = 0; i < LENGTH(keys); i++)
++-+		if (keysym == keys[i].keysym
++-+		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
++-+		&& keys[i].func)
++-+			keys[i].func(&(keys[i].arg));
++-+}
++-+
++-+void
++-+killclient(const Arg *arg)
++-+{
++-+	if (!selmon->sel)
++-+		return;
++-+	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
++-+		XGrabServer(dpy);
++-+		XSetErrorHandler(xerrordummy);
++-+		XSetCloseDownMode(dpy, DestroyAll);
++-+		XKillClient(dpy, selmon->sel->win);
++-+		XSync(dpy, False);
++-+		XSetErrorHandler(xerror);
++-+		XUngrabServer(dpy);
++-+	}
++-+}
++-+
++-+void
++-+manage(Window w, XWindowAttributes *wa)
++-+{
++-+	Client *c, *t = NULL, *term = NULL;
++-+	Window trans = None;
++-+	XWindowChanges wc;
++-+
++-+	c = ecalloc(1, sizeof(Client));
++-+	c->win = w;
++-+	c->pid = winpid(w);
++-+	/* geometry */
++-+	c->x = c->oldx = wa->x;
++-+	c->y = c->oldy = wa->y;
++-+	c->w = c->oldw = wa->width;
++-+	c->h = c->oldh = wa->height;
++-+	c->oldbw = wa->border_width;
++-+
++-+	updatetitle(c);
++-+	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++-+		c->mon = t->mon;
++-+		c->tags = t->tags;
++-+	} else {
++-+		c->mon = selmon;
++-+		applyrules(c);
++-+		term = termforwin(c);
++-+	}
++-+
++-+	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
++-+		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
++-+	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
++-+		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
++-+	c->x = MAX(c->x, c->mon->mx);
++-+	/* only fix client y-offset, if the client center might cover the bar */
++-+	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
++-+		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
++-+	c->bw = borderpx;
++-+
++-+	wc.border_width = c->bw;
++-+	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++-+	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++-+	configure(c); /* propagates border_width, if size doesn't change */
++-+	updatewindowtype(c);
++-+	updatesizehints(c);
++-+	updatewmhints(c);
++-+	c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
++-+	c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
++-+	// These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
++-+	c->sfx = c->x;
++-+	c->sfy = c->y;
++-+	c->sfw = c->w;
++-+	c->sfh = c->h;
++-+
++-+	/* c->sfx = 1200; */
++-+	/* c->sfy = 730; */
++-+	/* c->sfw = 700; */
++-+	/* c->sfh = 350; */
++-+	//
++-+	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++-+	grabbuttons(c, 0);
++-+	if (!c->isfloating)
++-+		c->isfloating = c->oldstate = trans != None || c->isfixed;
++-+	if (c->isfloating){
++-+		XRaiseWindow(dpy, c->win);
++-+		// TODO (my own implementation of moving floats from rules)
++-+		c->x = 1280;
++-+		c->y = 33;
++-+		c->w = 500;
++-+		c->h = 350;
++-+		c->bw = 0;
++-+	}
++-+	attach(c);
++-+	attachstack(c);
++-+	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++-+		(unsigned char *) &(c->win), 1);
++-+	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
++-+	setclientstate(c, NormalState);
++-+	if (c->mon == selmon)
++-+		unfocus(selmon->sel, 0);
++-+	c->mon->sel = c;
++-+	arrange(c->mon);
++-+	XMapWindow(dpy, c->win);
++-+	if (term)
++-+		swallow(term, c);
++-+	focus(NULL);
++-+}
++-+
++-+void
++-+mappingnotify(XEvent *e)
++-+{
++-+	XMappingEvent *ev = &e->xmapping;
++-+
++-+	XRefreshKeyboardMapping(ev);
++-+	if (ev->request == MappingKeyboard)
++-+		grabkeys();
++-+}
++-+
++-+void
++-+maprequest(XEvent *e)
++-+{
++-+	static XWindowAttributes wa;
++-+	XMapRequestEvent *ev = &e->xmaprequest;
++-+
++-+	if (!XGetWindowAttributes(dpy, ev->window, &wa))
++-+		return;
++-+	if (wa.override_redirect)
++-+		return;
++-+	if (!wintoclient(ev->window))
++-+		manage(ev->window, &wa);
++-+}
++-+
++-+void
++-+monocle(Monitor *m)
++-+{
++-+	unsigned int n;
++-+	int oh, ov, ih, iv;
++-+	Client *c;
++-+
++-+	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+	if (n > 0) /* override layout symbol */
++-+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++-+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++-+		resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
++-+}
++-+
++-+void
++-+motionnotify(XEvent *e)
++-+{
++-+	static Monitor *mon = NULL;
++-+	Monitor *m;
++-+	XMotionEvent *ev = &e->xmotion;
++-+
++-+	if (ev->window != root)
++-+		return;
++-+	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-+		unfocus(selmon->sel, 1);
++-+		selmon = m;
++-+		focus(NULL);
++-+	}
++-+	mon = m;
++-+}
++-+
++-+void
++-+movemouse(const Arg *arg)
++-+{
++-+	int x, y, ocx, ocy, nx, ny;
++-+	Client *c;
++-+	Monitor *m;
++-+	XEvent ev;
++-+	Time lasttime = 0;
++-+
++-+	if (!(c = selmon->sel))
++-+		return;
++-+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++-+		return;
++-+	restack(selmon);
++-+	ocx = c->x;
++-+	ocy = c->y;
++-+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++-+		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
++-+		return;
++-+	if (!getrootptr(&x, &y))
++-+		return;
++-+	do {
++-+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++-+		switch(ev.type) {
++-+		case ConfigureRequest:
++-+		case Expose:
++-+		case MapRequest:
++-+			handler[ev.type](&ev);
++-+			break;
++-+		case MotionNotify:
++-+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++-+				continue;
++-+			lasttime = ev.xmotion.time;
++-+
++-+			nx = ocx + (ev.xmotion.x - x);
++-+			ny = ocy + (ev.xmotion.y - y);
++-+			if (abs(selmon->wx - nx) < snap)
++-+				nx = selmon->wx;
++-+			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
++-+				nx = selmon->wx + selmon->ww - WIDTH(c);
++-+			if (abs(selmon->wy - ny) < snap)
++-+				ny = selmon->wy;
++-+			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
++-+				ny = selmon->wy + selmon->wh - HEIGHT(c);
++-+			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++-+			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
++-+				togglefloating(NULL);
++-+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++-+				resize(c, nx, ny, c->w, c->h, 1);
++-+			break;
++-+		}
++-+	} while (ev.type != ButtonRelease);
++-+	XUngrabPointer(dpy, CurrentTime);
++-+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++-+		sendmon(c, m);
++-+		selmon = m;
++-+		focus(NULL);
++-+	}
++-+}
++-+
++-+Client *
++-+nexttiled(Client *c)
++-+{
++-+	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
++-+	return c;
++-+}
++-+
++-+void
++-+pop(Client *c)
++-+{
++-+	detach(c);
++-+	attach(c);
++-+	focus(c);
++-+	arrange(c->mon);
++-+}
++-+
++-+void
++-+pushstack(const Arg *arg) {
++-+	int i = stackpos(arg);
++-+	Client *sel = selmon->sel, *c, *p;
++-+
++-+	if(i < 0 || !sel)
++-+		return;
++-+	else if(i == 0) {
++-+		detach(sel);
++-+		attach(sel);
++-+	}
++-+	else {
++-+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++-+			if(!(i -= (ISVISIBLE(c) && c != sel)))
++-+				break;
++-+		c = c ? c : p;
++-+		detach(sel);
++-+		sel->next = c->next;
++-+		c->next = sel;
++-+	}
++-+	arrange(selmon);
++-+}
++-+
++-+void
++-+propertynotify(XEvent *e)
++-+{
++-+	Client *c;
++-+	Window trans;
++-+	XPropertyEvent *ev = &e->xproperty;
++-+
++-+	if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
++-+		updatestatus();
++-+	} else if (ev->state == PropertyDelete) {
++-+		return; /* ignore */
++-+	} else if ((c = wintoclient(ev->window))) {
++-+		switch(ev->atom) {
++-+		default: break;
++-+		case XA_WM_TRANSIENT_FOR:
++-+			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
++-+				(c->isfloating = (wintoclient(trans)) != NULL))
++-+				arrange(c->mon);
++-+			break;
++-+		case XA_WM_NORMAL_HINTS:
++-+			updatesizehints(c);
++-+			break;
++-+		case XA_WM_HINTS:
++-+			updatewmhints(c);
++-+			drawbars();
++-+			break;
++-+		}
++-+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++-+			updatetitle(c);
++-+		if (ev->atom == netatom[NetWMWindowType])
++-+			updatewindowtype(c);
++-+	}
++-+}
++-+
++-+void
++-+quit(const Arg *arg)
++-+{
++-+	if(arg->i) restart = 1;
++-+	running = 0;
++-+}
++-+
++-+Monitor *
++-+recttomon(int x, int y, int w, int h)
++-+{
++-+	Monitor *m, *r = selmon;
++-+	int a, area = 0;
++-+
++-+	for (m = mons; m; m = m->next)
++-+		if ((a = INTERSECT(x, y, w, h, m)) > area) {
++-+			area = a;
++-+			r = m;
++-+		}
++-+	return r;
++-+}
++-+
++-+void
++-+resize(Client *c, int x, int y, int w, int h, int interact)
++-+{
++-+	if (applysizehints(c, &x, &y, &w, &h, interact))
++-+		resizeclient(c, x, y, w, h);
++-+}
++-+
++-+void
++-+resizeclient(Client *c, int x, int y, int w, int h)
++-+{
++-+	XWindowChanges wc;
++-+
++-+	c->oldx = c->x; c->x = wc.x = x;
++-+	c->oldy = c->y; c->y = wc.y = y;
++-+	c->oldw = c->w; c->w = wc.width = w;
++-+	c->oldh = c->h; c->h = wc.height = h;
++-+	wc.border_width = c->bw;
++-+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++-+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++-+	    && !c->isfullscreen && !c->isfloating) {
++-+		c->w = wc.width += c->bw * 2;
++-+		c->h = wc.height += c->bw * 2;
++-+		wc.border_width = 0;
++-+	} else if (c->isfloating){
++-+		wc.border_width = 0;
++-+	}
++-+	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++-+	configure(c);
++-+	XSync(dpy, False);
++-+}
++-+
++-+void
++-+resizemouse(const Arg *arg)
++-+{
++-+	int ocx, ocy, nw, nh;
++-+	Client *c;
++-+	Monitor *m;
++-+	XEvent ev;
++-+	Time lasttime = 0;
++-+
++-+	if (!(c = selmon->sel))
++-+		return;
++-+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++-+		return;
++-+	restack(selmon);
++-+	ocx = c->x;
++-+	ocy = c->y;
++-+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++-+		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
++-+		return;
++-+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++-+	do {
++-+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++-+		switch(ev.type) {
++-+		case ConfigureRequest:
++-+		case Expose:
++-+		case MapRequest:
++-+			handler[ev.type](&ev);
++-+			break;
++-+		case MotionNotify:
++-+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++-+				continue;
++-+			lasttime = ev.xmotion.time;
++-+
++-+			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
++-+			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
++-+			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
++-+			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
++-+			{
++-+				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++-+				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
++-+					togglefloating(NULL);
++-+			}
++-+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++-+				resize(c, c->x, c->y, nw, nh, 1);
++-+			break;
++-+		}
++-+	} while (ev.type != ButtonRelease);
++-+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++-+	XUngrabPointer(dpy, CurrentTime);
++-+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++-+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++-+		sendmon(c, m);
++-+		selmon = m;
++-+		focus(NULL);
++-+	}
++-+}
++-+
++-+void
++-+restack(Monitor *m)
++-+{
++-+	Client *c;
++-+	XEvent ev;
++-+	XWindowChanges wc;
++-+
++-+	drawbar(m);
++-+	if (!m->sel)
++-+		return;
++-+	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
++-+		XRaiseWindow(dpy, m->sel->win);
++-+	if (m->lt[m->sellt]->arrange) {
++-+		wc.stack_mode = Below;
++-+		wc.sibling = m->barwin;
++-+		for (c = m->stack; c; c = c->snext)
++-+			if (!c->isfloating && ISVISIBLE(c)) {
++-+				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
++-+				wc.sibling = c->win;
++-+			}
++-+	}
++-+	XSync(dpy, False);
++-+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++-+}
++-+
++-+void
++-+run(void)
++-+{
++-+	XEvent ev;
++-+	/* main event loop */
++-+	XSync(dpy, False);
++-+	while (running && !XNextEvent(dpy, &ev))
++-+		if (handler[ev.type])
++-+			handler[ev.type](&ev); /* call handler */
++-+}
++-+
++-+void
++-+runAutostart(void) {
++-+	system("killall -q dwmblocks; dwmblocks &");
++-+}
++-+
++-+void
++-+scan(void)
++-+{
++-+	unsigned int i, num;
++-+	Window d1, d2, *wins = NULL;
++-+	XWindowAttributes wa;
++-+
++-+	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
++-+		for (i = 0; i < num; i++) {
++-+			if (!XGetWindowAttributes(dpy, wins[i], &wa)
++-+			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
++-+				continue;
++-+			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
++-+				manage(wins[i], &wa);
++-+		}
++-+		for (i = 0; i < num; i++) { /* now the transients */
++-+			if (!XGetWindowAttributes(dpy, wins[i], &wa))
++-+				continue;
++-+			if (XGetTransientForHint(dpy, wins[i], &d1)
++-+			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
++-+				manage(wins[i], &wa);
++-+		}
++-+		if (wins)
++-+			XFree(wins);
++-+	}
++-+}
++-+
++-+void
++-+sendmon(Client *c, Monitor *m)
++-+{
++-+	if (c->mon == m)
++-+		return;
++-+	unfocus(c, 1);
++-+	detach(c);
++-+	detachstack(c);
++-+	c->mon = m;
++-+	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++-+	attach(c);
++-+	attachstack(c);
++-+	focus(NULL);
++-+	arrange(NULL);
++-+}
++-+
++-+void
++-+setclientstate(Client *c, long state)
++-+{
++-+	long data[] = { state, None };
++-+
++-+	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
++-+		PropModeReplace, (unsigned char *)data, 2);
++-+}
++-+
++-+int
++-+sendevent(Client *c, Atom proto)
++-+{
++-+	int n;
++-+	Atom *protocols;
++-+	int exists = 0;
++-+	XEvent ev;
++-+
++-+	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
++-+		while (!exists && n--)
++-+			exists = protocols[n] == proto;
++-+		XFree(protocols);
++-+	}
++-+	if (exists) {
++-+		ev.type = ClientMessage;
++-+		ev.xclient.window = c->win;
++-+		ev.xclient.message_type = wmatom[WMProtocols];
++-+		ev.xclient.format = 32;
++-+		ev.xclient.data.l[0] = proto;
++-+		ev.xclient.data.l[1] = CurrentTime;
++-+		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
++-+	}
++-+	return exists;
++-+}
++-+
++-+void
++-+setfocus(Client *c)
++-+{
++-+	if (!c->neverfocus) {
++-+		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
++-+		XChangeProperty(dpy, root, netatom[NetActiveWindow],
++-+			XA_WINDOW, 32, PropModeReplace,
++-+			(unsigned char *) &(c->win), 1);
++-+	}
++-+	sendevent(c, wmatom[WMTakeFocus]);
++-+}
++-+
++-+void
++-+setfullscreen(Client *c, int fullscreen)
++-+{
++-+	if (fullscreen && !c->isfullscreen) {
++-+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++-+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++-+		c->isfullscreen = 1;
++-+		c->oldstate = c->isfloating;
++-+		c->oldbw = c->bw;
++-+		c->bw = 0;
++-+		c->isfloating = 1;
++-+		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++-+		XRaiseWindow(dpy, c->win);
++-+	} else if (!fullscreen && c->isfullscreen){
++-+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++-+			PropModeReplace, (unsigned char*)0, 0);
++-+		c->isfullscreen = 0;
++-+		c->isfloating = c->oldstate;
++-+		c->bw = c->oldbw;
++-+		c->x = c->oldx;
++-+		c->y = c->oldy;
++-+		c->w = c->oldw;
++-+		c->h = c->oldh;
++-+		resizeclient(c, c->x, c->y, c->w, c->h);
++-+		arrange(c->mon);
++-+	}
++-+}
++-+
++-+int
++-+stackpos(const Arg *arg) {
++-+	int n, i;
++-+	Client *c, *l;
++-+
++-+	if(!selmon->clients)
++-+		return -1;
++-+
++-+	if(arg->i == PREVSEL) {
++-+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++-+		if(!l)
++-+			return -1;
++-+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+		return i;
++-+	}
++-+	else if(ISINC(arg->i)) {
++-+		if(!selmon->sel)
++-+			return -1;
++-+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+		return MOD(i + GETINC(arg->i), n);
++-+	}
++-+	else if(arg->i < 0) {
++-+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-+		return MAX(i + arg->i, 0);
++-+	}
++-+	else
++-+		return arg->i;
++-+}
++-+
++-+void
++-+setlayout(const Arg *arg)
++-+{
++-+	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
++-+		selmon->sellt ^= 1;
++-+	if (arg && arg->v)
++-+		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++-+	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
++-+	if (selmon->sel)
++-+		arrange(selmon);
++-+	else
++-+		drawbar(selmon);
++-+}
++-+
++-+/* arg > 1.0 will set mfact absolutely */
++-+void
++-+setmfact(const Arg *arg)
++-+{
++-+	float f;
++-+
++-+	if (!arg || !selmon->lt[selmon->sellt]->arrange)
++-+		return;
++-+	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
++-+	if (f < 0.05 || f > 0.95)
++-+		return;
++-+	selmon->mfact = f;
++-+	arrange(selmon);
++-+}
++-+
++-+void
++-+setup(void)
++-+{
++-+	int i;
++-+	XSetWindowAttributes wa;
++-+	Atom utf8string;
++-+
++-+	/* clean up any zombies immediately */
++-+	sigchld(0);
++-+
++-+	signal(SIGHUP, sighup);
++-+	signal(SIGTERM, sigterm);
++-+
++-+	/* init screen */
++-+	screen = DefaultScreen(dpy);
++-+	sw = DisplayWidth(dpy, screen);
++-+	sh = DisplayHeight(dpy, screen);
++-+	root = RootWindow(dpy, screen);
++-+	drw = drw_create(dpy, screen, root, sw, sh);
++-+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++-+		die("no fonts could be loaded.");
++-+	lrpad = drw->fonts->h;
++-+	bh = drw->fonts->h + 2;
++-+	updategeom();
++-+	/* init atoms */
++-+	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
++-+	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
++-+	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
++-+	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
++-+	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
++-+	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
++-+	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
++-+	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
++-+	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++-+	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++-+	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++-+	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++-+	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++-+	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++-+	/* init cursors */
++-+	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
++-+	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++-+	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++-+	/* init appearance */
++-+	/* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
++-+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++-+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++-+	for (i = 0; i < LENGTH(colors); i++)
++-+		scheme[i] = drw_scm_create(drw, colors[i], 3);
++-+	/* init bars */
++-+	updatebars();
++-+	updatestatus();
++-+	/* supporting window for NetWMCheck */
++-+	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
++-+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
++-+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++-+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
++-+		PropModeReplace, (unsigned char *) "dwm", 3);
++-+	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
++-+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++-+	/* EWMH support per view */
++-+	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
++-+		PropModeReplace, (unsigned char *) netatom, NetLast);
++-+	XDeleteProperty(dpy, root, netatom[NetClientList]);
++-+	/* select events */
++-+	wa.cursor = cursor[CurNormal]->cursor;
++-+	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
++-+		|ButtonPressMask|PointerMotionMask|EnterWindowMask
++-+		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
++-+	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
++-+	XSelectInput(dpy, root, wa.event_mask);
++-+	grabkeys();
++-+	focus(NULL);
++-+}
++-+
++-+
++-+void
++-+seturgent(Client *c, int urg)
++-+{
++-+	XWMHints *wmh;
++-+
++-+	c->isurgent = urg;
++-+	if (!(wmh = XGetWMHints(dpy, c->win)))
++-+		return;
++-+	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
++-+	XSetWMHints(dpy, c->win, wmh);
++-+	XFree(wmh);
++-+}
++-+
++-+void
++-+showhide(Client *c)
++-+{
++-+	if (!c)
++-+		return;
++-+	if (ISVISIBLE(c)) {
++-+		if ((c->tags & SPTAGMASK) && c->isfloating) {
++-+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++-+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++-+		}
++-+		/* show clients top down */
++-+		XMoveWindow(dpy, c->win, c->x, c->y);
++-+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++-+			resize(c, c->x, c->y, c->w, c->h, 0);
++-+		showhide(c->snext);
++-+	} else {
++-+		/* hide clients bottom up */
++-+		showhide(c->snext);
++-+		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++-+	}
++-+}
++-+
++-+void
++-+sigchld(int unused)
++-+{
++-+	if (signal(SIGCHLD, sigchld) == SIG_ERR)
++-+		die("can't install SIGCHLD handler:");
++-+	while (0 < waitpid(-1, NULL, WNOHANG));
++-+}
++-+
++-+void
++-+sighup(int unused)
++-+{
++-+	Arg a = {.i = 1};
++-+	quit(&a);
++-+}
++-+
++-+void
++-+sigterm(int unused)
++-+{
++-+	Arg a = {.i = 0};
++-+	quit(&a);
++-+}
++-+
++-+#ifndef __OpenBSD__
++-+void
++-+sigdwmblocks(const Arg *arg)
++-+{
++-+	union sigval sv;
++-+	sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
++-+	if (!dwmblockspid)
++-+		if (getdwmblockspid() == -1)
++-+			return;
++-+
++-+	if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
++-+		if (errno == ESRCH) {
++-+			if (!getdwmblockspid())
++-+				sigqueue(dwmblockspid, SIGUSR1, sv);
++-+		}
++-+	}
++-+}
++-+#endif
++-+
++-+void
++-+spawn(const Arg *arg)
++-+{
++-+	if (fork() == 0) {
++-+		if (dpy)
++-+			close(ConnectionNumber(dpy));
++-+		setsid();
++-+		execvp(((char **)arg->v)[0], (char **)arg->v);
++-+		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
++-+		perror(" failed");
++-+		exit(EXIT_SUCCESS);
++-+	}
++-+}
++-+
++-+void
++-+tag(const Arg *arg)
++-+{
++-+	if (selmon->sel && arg->ui & TAGMASK) {
++-+		selmon->sel->tags = arg->ui & TAGMASK;
++-+		focus(NULL);
++-+		arrange(selmon);
++-+		view(arg);
++-+	}
++-+}
++-+
++-+void
++-+noviewontag(const Arg *arg)
++-+{
++-+	if (selmon->sel && arg->ui & TAGMASK) {
++-+		selmon->sel->tags = arg->ui & TAGMASK;
++-+		focus(NULL);
++-+		arrange(selmon);
++-+	}
++-+}
++-+
++-+void
++-+tagmon(const Arg *arg)
++-+{
++-+	if (!selmon->sel || !mons->next)
++-+		return;
++-+	sendmon(selmon->sel, dirtomon(arg->i));
++-+}
++-+
++-+void
++-+togglebar(const Arg *arg)
++-+{
++-+	selmon->showbar = !selmon->showbar;
++-+	updatebarpos(selmon);
++-+	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++-+	arrange(selmon);
++-+}
++-+
++-+void
++-+togglefloating(const Arg *arg)
++-+{
++-+	if (!selmon->sel)
++-+		return;
++-+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++-+		return;
++-+	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++-+	if (selmon->sel->isfloating)
++-+		/* resize(selmon->sel, selmon->sel->x, selmon->sel->y, */
++-+		/* 	selmon->sel->w, selmon->sel->h, 0); */
++-+		/* restore last known float dimensions */
++-+		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++-+		       selmon->sel->sfw, selmon->sel->sfh, False);
++-+	else {
++-+		/* save last known float dimensions */
++-+		selmon->sel->sfx = selmon->sel->x;
++-+		selmon->sel->sfy = selmon->sel->y;
++-+		selmon->sel->sfw = selmon->sel->w;
++-+		selmon->sel->sfh = selmon->sel->h;
++-+	}
++-+	arrange(selmon);
++-+}
++-+
++-+// Without save floats patch:
++-+/* void */
++-+/* togglefloating(const Arg *arg) */
++-+/* { */
++-+/* 	if (!selmon->sel) */
++-+/* 		return; */
++-+/* 	if (selmon->sel->isfullscreen) /1* no support for fullscreen windows *1/ */
++-+/* 		return; */
++-+/* 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed; */
++-+/* 	if (selmon->sel->isfloating) */
++-+/* 		resize(selmon->sel, selmon->sel->x, selmon->sel->y, */
++-+/* 			selmon->sel->w, selmon->sel->h, 0); */
++-+/* 	arrange(selmon); */
++-+/* } */
++-+
++-+
++-+void
++-+togglefullscr(const Arg *arg)
++-+{
++-+  if(selmon->sel)
++-+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++-+}
++-+
++-+void
++-+togglesticky(const Arg *arg)
++-+{
++-+	if (!selmon->sel)
++-+		return;
++-+	selmon->sel->issticky = !selmon->sel->issticky;
++-+	arrange(selmon);
++-+}
++-+
++-+void
++-+togglescratch(const Arg *arg)
++-+{
++-+	Client *c;
++-+	unsigned int found = 0;
++-+	unsigned int scratchtag = SPTAG(arg->ui);
++-+	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++-+
++-+	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++-+	if (found) {
++-+		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++-+		if (newtagset) {
++-+			selmon->tagset[selmon->seltags] = newtagset;
++-+			focus(NULL);
++-+			arrange(selmon);
++-+		}
++-+		if (ISVISIBLE(c)) {
++-+			focus(c);
++-+			restack(selmon);
++-+		}
++-+	} else {
++-+		selmon->tagset[selmon->seltags] |= scratchtag;
++-+		spawn(&sparg);
++-+	}
++-+}
++-+
++-+void
++-+toggletag(const Arg *arg)
++-+{
++-+	unsigned int newtags;
++-+
++-+	if (!selmon->sel)
++-+		return;
++-+	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
++-+	if (newtags) {
++-+		selmon->sel->tags = newtags;
++-+		focus(NULL);
++-+		arrange(selmon);
++-+	}
++-+}
++-+
++-+void
++-+toggleview(const Arg *arg)
++-+{
++-+	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++-+
++-+	if (newtagset) {
++-+		selmon->tagset[selmon->seltags] = newtagset;
++-+		focus(NULL);
++-+		arrange(selmon);
++-+	}
++-+}
++-+
++-+void
++-+unfocus(Client *c, int setfocus)
++-+{
++-+	if (!c)
++-+		return;
++-+	grabbuttons(c, 0);
++-+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++-+	if (setfocus) {
++-+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++-+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++-+	}
++-+}
++-+
++-+void
++-+unmanage(Client *c, int destroyed)
++-+{
++-+	Monitor *m = c->mon;
++-+	XWindowChanges wc;
++-+
++-+	if (c->swallowing) {
++-+		unswallow(c);
++-+		return;
++-+	}
++-+
++-+	Client *s = swallowingclient(c->win);
++-+	if (s) {
++-+		free(s->swallowing);
++-+		s->swallowing = NULL;
++-+		arrange(m);
++-+        focus(NULL);
++-+		return;
++-+	}
++-+
++-+	detach(c);
++-+	detachstack(c);
++-+	if (!destroyed) {
++-+		wc.border_width = c->oldbw;
++-+		XGrabServer(dpy); /* avoid race conditions */
++-+		XSetErrorHandler(xerrordummy);
++-+		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
++-+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++-+		setclientstate(c, WithdrawnState);
++-+		XSync(dpy, False);
++-+		XSetErrorHandler(xerror);
++-+		XUngrabServer(dpy);
++-+	}
++-+	free(c);
++-+
++-+	if (!s) {
++-+		arrange(m);
++-+		focus(NULL);
++-+		updateclientlist();
++-+	}
++-+}
++-+
++-+void
++-+unmapnotify(XEvent *e)
++-+{
++-+	Client *c;
++-+	XUnmapEvent *ev = &e->xunmap;
++-+
++-+	if ((c = wintoclient(ev->window))) {
++-+		if (ev->send_event)
++-+			setclientstate(c, WithdrawnState);
++-+		else
++-+			unmanage(c, 0);
++-+	}
++-+}
++-+
++-+void
++-+updatebars(void)
++-+{
++-+	Monitor *m;
++-+	XSetWindowAttributes wa = {
++-+		.override_redirect = True,
++-+		.background_pixmap = ParentRelative,
++-+		.event_mask = ButtonPressMask|ExposureMask
++-+	};
++-+	XClassHint ch = {"dwm", "dwm"};
++-+	for (m = mons; m; m = m->next) {
++-+		if (m->barwin)
++-+			continue;
++-+		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++-+				CopyFromParent, DefaultVisual(dpy, screen),
++-+				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++-+		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++-+		XMapRaised(dpy, m->barwin);
++-+		XSetClassHint(dpy, m->barwin, &ch);
++-+	}
++-+}
++-+
++-+void
++-+updatebarpos(Monitor *m)
++-+{
++-+	m->wy = m->my;
++-+	m->wh = m->mh;
++-+	if (m->showbar) {
++-+		m->wh -= bh;
++-+		m->by = m->topbar ? m->wy : m->wy + m->wh;
++-+		m->wy = m->topbar ? m->wy + bh : m->wy;
++-+	} else
++-+		m->by = -bh;
++-+}
++-+
++-+void
++-+updateclientlist()
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+
++-+	XDeleteProperty(dpy, root, netatom[NetClientList]);
++-+	for (m = mons; m; m = m->next)
++-+		for (c = m->clients; c; c = c->next)
++-+			XChangeProperty(dpy, root, netatom[NetClientList],
++-+				XA_WINDOW, 32, PropModeAppend,
++-+				(unsigned char *) &(c->win), 1);
++-+}
++-+
++-+int
++-+updategeom(void)
++-+{
++-+	int dirty = 0;
++-+
++-+#ifdef XINERAMA
++-+	if (XineramaIsActive(dpy)) {
++-+		int i, j, n, nn;
++-+		Client *c;
++-+		Monitor *m;
++-+		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
++-+		XineramaScreenInfo *unique = NULL;
++-+
++-+		for (n = 0, m = mons; m; m = m->next, n++);
++-+		/* only consider unique geometries as separate screens */
++-+		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
++-+		for (i = 0, j = 0; i < nn; i++)
++-+			if (isuniquegeom(unique, j, &info[i]))
++-+				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++-+		XFree(info);
++-+		nn = j;
++-+		if (n <= nn) { /* new monitors available */
++-+			for (i = 0; i < (nn - n); i++) {
++-+				for (m = mons; m && m->next; m = m->next);
++-+				if (m)
++-+					m->next = createmon();
++-+				else
++-+					mons = createmon();
++-+			}
++-+			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
++-+				if (i >= n
++-+				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
++-+				|| unique[i].width != m->mw || unique[i].height != m->mh)
++-+				{
++-+					dirty = 1;
++-+					m->num = i;
++-+					m->mx = m->wx = unique[i].x_org;
++-+					m->my = m->wy = unique[i].y_org;
++-+					m->mw = m->ww = unique[i].width;
++-+					m->mh = m->wh = unique[i].height;
++-+					updatebarpos(m);
++-+				}
++-+		} else { /* less monitors available nn < n */
++-+			for (i = nn; i < n; i++) {
++-+				for (m = mons; m && m->next; m = m->next);
++-+				while ((c = m->clients)) {
++-+					dirty = 1;
++-+					m->clients = c->next;
++-+					detachstack(c);
++-+					c->mon = mons;
++-+					attach(c);
++-+					attachstack(c);
++-+				}
++-+				if (m == selmon)
++-+					selmon = mons;
++-+				cleanupmon(m);
++-+			}
++-+		}
++-+		free(unique);
++-+	} else
++-+#endif /* XINERAMA */
++-+	{ /* default monitor setup */
++-+		if (!mons)
++-+			mons = createmon();
++-+		if (mons->mw != sw || mons->mh != sh) {
++-+			dirty = 1;
++-+			mons->mw = mons->ww = sw;
++-+			mons->mh = mons->wh = sh;
++-+			updatebarpos(mons);
++-+		}
++-+	}
++-+	if (dirty) {
++-+		selmon = mons;
++-+		selmon = wintomon(root);
++-+	}
++-+	return dirty;
++-+}
++-+
++-+void
++-+updatenumlockmask(void)
++-+{
++-+	unsigned int i, j;
++-+	XModifierKeymap *modmap;
++-+
++-+	numlockmask = 0;
++-+	modmap = XGetModifierMapping(dpy);
++-+	for (i = 0; i < 8; i++)
++-+		for (j = 0; j < modmap->max_keypermod; j++)
++-+			if (modmap->modifiermap[i * modmap->max_keypermod + j]
++-+				== XKeysymToKeycode(dpy, XK_Num_Lock))
++-+				numlockmask = (1 << i);
++-+	XFreeModifiermap(modmap);
++-+}
++-+
++-+void
++-+updatesizehints(Client *c)
++-+{
++-+	long msize;
++-+	XSizeHints size;
++-+
++-+	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
++-+		/* size is uninitialized, ensure that size.flags aren't used */
++-+		size.flags = PSize;
++-+	if (size.flags & PBaseSize) {
++-+		c->basew = size.base_width;
++-+		c->baseh = size.base_height;
++-+	} else if (size.flags & PMinSize) {
++-+		c->basew = size.min_width;
++-+		c->baseh = size.min_height;
++-+	} else
++-+		c->basew = c->baseh = 0;
++-+	if (size.flags & PResizeInc) {
++-+		c->incw = size.width_inc;
++-+		c->inch = size.height_inc;
++-+	} else
++-+		c->incw = c->inch = 0;
++-+	if (size.flags & PMaxSize) {
++-+		c->maxw = size.max_width;
++-+		c->maxh = size.max_height;
++-+	} else
++-+		c->maxw = c->maxh = 0;
++-+	if (size.flags & PMinSize) {
++-+		c->minw = size.min_width;
++-+		c->minh = size.min_height;
++-+	} else if (size.flags & PBaseSize) {
++-+		c->minw = size.base_width;
++-+		c->minh = size.base_height;
++-+	} else
++-+		c->minw = c->minh = 0;
++-+	if (size.flags & PAspect) {
++-+		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
++-+		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
++-+	} else
++-+		c->maxa = c->mina = 0.0;
++-+	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
++-+}
++-+
++-+void
++-+updatestatus(void)
++-+{
++-+	if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
++-+		strcpy(stext, "dwm-"VERSION);
++-+	else
++-+		copyvalidchars(stext, rawstext);
++-+	drawbar(selmon);
++-+}
++-+
++-+void
++-+updatetitle(Client *c)
++-+{
++-+	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
++-+		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
++-+	if (c->name[0] == '\0') /* hack to mark broken clients */
++-+		strcpy(c->name, broken);
++-+}
++-+
++-+void
++-+updatewindowtype(Client *c)
++-+{
++-+	Atom state = getatomprop(c, netatom[NetWMState]);
++-+	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
++-+
++-+	if (state == netatom[NetWMFullscreen])
++-+		setfullscreen(c, 1);
++-+	if (wtype == netatom[NetWMWindowTypeDialog])
++-+		c->isfloating = 1;
++-+}
++-+
++-+void
++-+updatewmhints(Client *c)
++-+{
++-+	XWMHints *wmh;
++-+
++-+	if ((wmh = XGetWMHints(dpy, c->win))) {
++-+		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
++-+			wmh->flags &= ~XUrgencyHint;
++-+			XSetWMHints(dpy, c->win, wmh);
++-+		} else
++-+			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++-+		if (wmh->flags & InputHint)
++-+			c->neverfocus = !wmh->input;
++-+		else
++-+			c->neverfocus = 0;
++-+		XFree(wmh);
++-+	}
++-+}
++-+
++-+void
++-+view(const Arg *arg)
++-+{
++-+	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++-+		return;
++-+
++-+	/* if ((arg->ui & TAGMASK) == ( 1 << 8)){ */
++-+	if ((arg->ui & TAGMASK) == (000000001)){
++-+		enablegaps = 0;
++-+		/* arrange(NULL); */
++-+	}else{
++-+		enablegaps = 1;
++-+		/* arrange(NULL); */
++-+	}
++-+
++-+	selmon->seltags ^= 1; /* toggle sel tagset */
++-+	if (arg->ui & TAGMASK)
++-+		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++-+	focus(NULL);
++-+	arrange(selmon);
++-+}
++-+
++-+pid_t
++-+winpid(Window w)
++-+{
++-+	pid_t result = 0;
++-+
++-+	xcb_res_client_id_spec_t spec = {0};
++-+	spec.client = w;
++-+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++-+
++-+	xcb_generic_error_t *e = NULL;
++-+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++-+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++-+
++-+	if (!r)
++-+		return (pid_t)0;
++-+
++-+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++-+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++-+		spec = i.data->spec;
++-+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++-+			uint32_t *t = xcb_res_client_id_value_value(i.data);
++-+			result = *t;
++-+			break;
++-+		}
++-+	}
++-+
++-+	free(r);
++-+
++-+	if (result == (pid_t)-1)
++-+		result = 0;
++-+	return result;
++-+}
++-+
++-+pid_t
++-+getparentprocess(pid_t p)
++-+{
++-+	unsigned int v = 0;
++-+
++-+#if defined(__linux__)
++-+	FILE *f;
++-+	char buf[256];
++-+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++-+
++-+	if (!(f = fopen(buf, "r")))
++-+		return (pid_t)0;
++-+
++-+	if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
++-+		v = (pid_t)0;
++-+	fclose(f);
++-+#elif defined(__FreeBSD__)
++-+	struct kinfo_proc *proc = kinfo_getproc(p);
++-+	if (!proc)
++-+		return (pid_t)0;
++-+
++-+	v = proc->ki_ppid;
++-+	free(proc);
++-+#endif
++-+	return (pid_t)v;
++-+}
++-+
++-+int
++-+isdescprocess(pid_t p, pid_t c)
++-+{
++-+	while (p != c && c != 0)
++-+		c = getparentprocess(c);
++-+
++-+	return (int)c;
++-+}
++-+
++-+Client *
++-+termforwin(const Client *w)
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+
++-+	if (!w->pid || w->isterminal)
++-+		return NULL;
++-+
++-+	for (m = mons; m; m = m->next) {
++-+		for (c = m->clients; c; c = c->next) {
++-+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++-+				return c;
++-+		}
++-+	}
++-+
++-+	return NULL;
++-+}
++-+
++-+Client *
++-+swallowingclient(Window w)
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+
++-+	for (m = mons; m; m = m->next) {
++-+		for (c = m->clients; c; c = c->next) {
++-+			if (c->swallowing && c->swallowing->win == w)
++-+				return c;
++-+		}
++-+	}
++-+
++-+	return NULL;
++-+}
++-+
++-+Client *
++-+wintoclient(Window w)
++-+{
++-+	Client *c;
++-+	Monitor *m;
++-+
++-+	for (m = mons; m; m = m->next)
++-+		for (c = m->clients; c; c = c->next)
++-+			if (c->win == w)
++-+				return c;
++-+	return NULL;
++-+}
++-+
++-+Monitor *
++-+wintomon(Window w)
++-+{
++-+	int x, y;
++-+	Client *c;
++-+	Monitor *m;
++-+
++-+	if (w == root && getrootptr(&x, &y))
++-+		return recttomon(x, y, 1, 1);
++-+	for (m = mons; m; m = m->next)
++-+		if (w == m->barwin)
++-+			return m;
++-+	if ((c = wintoclient(w)))
++-+		return c->mon;
++-+	return selmon;
++-+}
++-+
++-+/* There's no way to check accesses to destroyed windows, thus those cases are
++-+ * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
++-+ * default error handler, which may call exit. */
++-+int
++-+xerror(Display *dpy, XErrorEvent *ee)
++-+{
++-+	if (ee->error_code == BadWindow
++-+	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
++-+	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
++-+	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
++-+	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
++-+	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
++-+	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
++-+	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
++-+	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
++-+		return 0;
++-+	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
++-+		ee->request_code, ee->error_code);
++-+	return xerrorxlib(dpy, ee); /* may call exit */
++-+}
++-+
++-+int
++-+xerrordummy(Display *dpy, XErrorEvent *ee)
++-+{
++-+	return 0;
++-+}
++-+
++-+/* Startup Error handler to check if another window manager
++-+ * is already running. */
++-+int
++-+xerrorstart(Display *dpy, XErrorEvent *ee)
++-+{
++-+	die("dwm: another window manager is already running");
++-+	return -1;
++-+}
++-+
++-+void
++-+zoom(const Arg *arg)
++-+{
++-+	Client *c = selmon->sel;
++-+
++-+	if (!selmon->lt[selmon->sellt]->arrange
++-+	|| (selmon->sel && selmon->sel->isfloating))
++-+		return;
++-+	if (c == nexttiled(selmon->clients))
++-+		if (!c || !(c = nexttiled(c->next)))
++-+			return;
++-+	pop(c);
++-+}
++-+
++-+void
++-+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++-+{
++-+	char *sdst = NULL;
++-+	int *idst = NULL;
++-+	float *fdst = NULL;
++-+
++-+	sdst = dst;
++-+	idst = dst;
++-+	fdst = dst;
++-+
++-+	char fullname[256];
++-+	char *type;
++-+	XrmValue ret;
++-+
++-+	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++-+	fullname[sizeof(fullname) - 1] = '\0';
++-+
++-+	XrmGetResource(db, fullname, "*", &type, &ret);
++-+	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++-+	{
++-+		switch (rtype) {
++-+		case STRING:
++-+			strcpy(sdst, ret.addr);
++-+			break;
++-+		case INTEGER:
++-+			*idst = strtoul(ret.addr, NULL, 10);
++-+			break;
++-+		case FLOAT:
++-+			*fdst = strtof(ret.addr, NULL);
++-+			break;
++-+		}
++-+	}
++-+}
++-+
++-+void
++-+load_xresources(void)
++-+{
++-+	Display *display;
++-+	char *resm;
++-+	XrmDatabase db;
++-+	ResourcePref *p;
++-+
++-+	display = XOpenDisplay(NULL);
++-+	resm = XResourceManagerString(display);
++-+	if (!resm)
++-+		return;
++-+
++-+	db = XrmGetStringDatabase(resm);
++-+	for (p = resources; p < resources + LENGTH(resources); p++)
++-+		resource_load(db, p->name, p->type, p->dst);
++-+	XCloseDisplay(display);
++-+}
++-+
++-+int
++-+main(int argc, char *argv[])
++-+{
++-+	if (argc == 2 && !strcmp("-v", argv[1]))
++-+		die("dwm-"VERSION);
++-+	else if (argc != 1)
++-+		die("usage: dwm [-v]");
++-+	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
++-+		fputs("warning: no locale support\n", stderr);
++-+	if (!(dpy = XOpenDisplay(NULL)))
++-+		die("dwm: cannot open display");
++-+	if (!(xcon = XGetXCBConnection(dpy)))
++-+		die("dwm: cannot get xcb connection\n");
++-+	checkotherwm();
++-+	XrmInitialize();
++-+	load_xresources();
++-+	setup();
++-+#ifdef __OpenBSD__
++-+	if (pledge("stdio rpath proc exec", NULL) == -1)
++-+		die("pledge");
++-+#endif /* __OpenBSD__ */
++-+	scan();
++-+	runAutostart();
++-+	/* runautostart(); */
++-+	enablegaps = 0;
++-+	arrange(NULL);
++-+	run();
++-+	if(restart) execvp(argv[0], argv);
++-+	cleanup();
++-+	XCloseDisplay(dpy);
++-+	return EXIT_SUCCESS;
++-+}
++-diff --git a/shiftview.c b/shiftview.c
++-new file mode 100644
++-index 0000000..7905a6d
++---- /dev/null
++-+++ b/shiftview.c
++-@@ -0,0 +1,64 @@
++-+/** Function to shift the current view to the left/right
++-+ *
++-+ * @param: "arg->i" stores the number of tags to shift right (positive value)
++-+ *          or left (negative value)
++-+ */
++-+void
++-+shiftview(const Arg *arg)
++-+{
++-+    Arg shifted;
++-+    Client *c;
++-+    unsigned int tagmask = 0;
++-+
++-+    for (c = selmon->clients; c; c = c->next)
++-+        if (!(c->tags & SPTAGMASK))
++-+            tagmask = tagmask | c->tags;
++-+
++-+    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++-+    if (arg->i > 0) /* left circular shift */
++-+        do {
++-+            shifted.ui = (shifted.ui << arg->i)
++-+                | (shifted.ui >> (LENGTH(tags) - arg->i));
++-+            shifted.ui &= ~SPTAGMASK;
++-+        } while (tagmask && !(shifted.ui & tagmask));
++-+    else /* right circular shift */
++-+        do {
++-+            shifted.ui = (shifted.ui >> (- arg->i)
++-+                    | shifted.ui << (LENGTH(tags) + arg->i));
++-+            shifted.ui &= ~SPTAGMASK;
++-+        } while (tagmask && !(shifted.ui & tagmask));
++-+
++-+    view(&shifted);
++-+}
++-+
++-+void
++-+shifttag(const Arg *arg)
++-+{
++-+    Arg a;
++-+    Client *c;
++-+    unsigned visible = 0;
++-+    int i = arg->i;
++-+    int count = 0;
++-+    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
++-+
++-+    do {
++-+        if(i > 0) // left circular shift
++-+            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
++-+
++-+        else // right circular shift
++-+            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
++-+
++-+        // Check if tag is visible
++-+        for (c = selmon->clients; c && !visible; c = c->next)
++-+            if (nextseltags & c->tags) {
++-+                visible = 1;
++-+                break;
++-+            }
++-+        i += arg->i;
++-+    } while (!visible && ++count < 10);
++-+
++-+    if (count < 10) {
++-+        a.i = nextseltags;
++-+        tag(&a);
++-+    }
++-+}
++-diff --git a/test.c b/test.c
++-new file mode 100644
++-index 0000000..50e4cba
++---- /dev/null
++-+++ b/test.c
++-@@ -0,0 +1,37 @@
++-+#include <stdio.h>
++-+#include <string.h>
++-+
++-+int
++-+main()
++-+{
++-+    char s[1000];
++-+    int i, alphabets=0, digits=0, specialchars=0;
++-+    /* printf("Enter string"); */
++-+    /* gets(s); */
++-+
++-+    FILE *ptr;
++-+    char ch;
++-+    ptr = fopen("/home/jonas/test.txt", "r");
++-+    if (ptr == NULL) printf("Fail...");
++-+    do{
++-+        ch = fgetc(ptr);
++-+        /* printf("%c", ch); */
++-+        /* printf("%c %d \n", ch, ch); */
++-+        printf("%d\n", ch);
++-+        /* printf("%d", ch); */
++-+    } while (ch != EOF);
++-+    fclose(ptr);
++-+
++-+    /* for(int i = 0;s[i]; i++){ */
++-+    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
++-+    /*         alphabets++; */
++-+    /*     else if (s[i]>48 && s[i] <=57) digits++; */
++-+    /*     else specialchars++; */
++-+
++-+    /* } */
++-+    /* printf("Alphas = %d}n", alphabets); */
++-+    /* printf("Digits = %d\n", digits); */
++-+    /* printf("Spec chars = %d", specialchars); */
++-+
++-+    return 0;
++-+}
++-diff --git a/transient.c b/transient.c
++-index 040adb5..802b66a 100644
++---- a/transient.c
++-+++ b/transient.c
++-@@ -6,37 +6,37 @@
++- #include <X11/Xutil.h>
++- 
++- int main(void) {
++--	Display *d;
++--	Window r, f, t = None;
++--	XSizeHints h;
++--	XEvent e;
++-+    Display *d;
++-+    Window r, f, t = None;
++-+    XSizeHints h;
++-+    XEvent e;
++- 
++--	d = XOpenDisplay(NULL);
++--	if (!d)
++--		exit(1);
++--	r = DefaultRootWindow(d);
++-+    d = XOpenDisplay(NULL);
++-+    if (!d)
++-+        exit(1);
++-+    r = DefaultRootWindow(d);
++- 
++--	f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
++--	h.min_width = h.max_width = h.min_height = h.max_height = 400;
++--	h.flags = PMinSize | PMaxSize;
++--	XSetWMNormalHints(d, f, &h);
++--	XStoreName(d, f, "floating");
++--	XMapWindow(d, f);
++-+    f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
++-+    h.min_width = h.max_width = h.min_height = h.max_height = 400;
++-+    h.flags = PMinSize | PMaxSize;
++-+    XSetWMNormalHints(d, f, &h);
++-+    XStoreName(d, f, "floating");
++-+    XMapWindow(d, f);
++- 
++--	XSelectInput(d, f, ExposureMask);
++--	while (1) {
++--		XNextEvent(d, &e);
++-+    XSelectInput(d, f, ExposureMask);
++-+    while (1) {
++-+        XNextEvent(d, &e);
++- 
++--		if (t == None) {
++--			sleep(5);
++--			t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
++--			XSetTransientForHint(d, t, f);
++--			XStoreName(d, t, "transient");
++--			XMapWindow(d, t);
++--			XSelectInput(d, t, ExposureMask);
++--		}
++--	}
++-+        if (t == None) {
++-+            sleep(5);
++-+            t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
++-+            XSetTransientForHint(d, t, f);
++-+            XStoreName(d, t, "transient");
++-+            XMapWindow(d, t);
++-+            XSelectInput(d, t, ExposureMask);
++-+        }
++-+    }
++- 
++--	XCloseDisplay(d);
++--	exit(0);
++-+    XCloseDisplay(d);
++-+    exit(0);
++- }
++-diff --git a/util.c b/util.c
++-index 8e26a51..c8b1dcd 100644
++---- a/util.c
++-+++ b/util.c
++-@@ -7,31 +7,29 @@
++- 
++- #include "util.h"
++- 
++--void
++--die(const char *fmt, ...)
++-+void *
++-+ecalloc(size_t nmemb, size_t size)
++- {
++--	va_list ap;
++-+    void *p;
++-+
++-+    if (!(p = calloc(nmemb, size)))
++-+        die("calloc:");
++-+    return p;
++-+}
++-+
++-+void die(const char *fmt, ...) {
++-+    va_list ap;
++- 	int saved_errno;
++- 
++- 	saved_errno = errno;
++- 
++--	va_start(ap, fmt);
++--	vfprintf(stderr, fmt, ap);
++--	va_end(ap);
++-+    va_start(ap, fmt);
++-+    vfprintf(stderr, fmt, ap);
++-+    va_end(ap);
++- 
++- 	if (fmt[0] && fmt[strlen(fmt)-1] == ':')
++- 		fprintf(stderr, " %s", strerror(saved_errno));
++- 	fputc('\n', stderr);
++- 
++--	exit(1);
++--}
++--
++--void *
++--ecalloc(size_t nmemb, size_t size)
++--{
++--	void *p;
++--
++--	if (!(p = calloc(nmemb, size)))
++--		die("calloc:");
++--	return p;
++-+    exit(1);
++- }
++-diff --git a/vanitygaps.c b/vanitygaps.c
++-new file mode 100644
++-index 0000000..7b64fd2
++---- /dev/null
++-+++ b/vanitygaps.c
++-@@ -0,0 +1,555 @@
++-+/* Key binding functions */
++-+static void defaultgaps(const Arg *arg);
++-+static void incrgaps(const Arg *arg);
++-+/* static void incrigaps(const Arg *arg); */
++-+/* static void incrogaps(const Arg *arg); */
++-+/* static void incrohgaps(const Arg *arg); */
++-+/* static void incrovgaps(const Arg *arg); */
++-+/* static void incrihgaps(const Arg *arg); */
++-+/* static void incrivgaps(const Arg *arg); */
++-+static void togglegaps(const Arg *arg);
++-+static void togglebgaps(const Arg *arg);
++-+
++-+/* Layouts */
++-+static void bstack(Monitor *m);
++-+static void centeredmaster(Monitor *m);
++-+static void centeredfloatingmaster(Monitor *m);
++-+static void deck(Monitor *m);
++-+static void dwindle(Monitor *m);
++-+static void fibonacci(Monitor *m, int s);
++-+static void spiral(Monitor *m);
++-+static void tile(Monitor *m);
++-+
++-+/* Internals */
++-+static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++-+static void setgaps(int oh, int ov, int ih, int iv);
++-+
++-+/* Settings */
++-+static int enablegaps = 1;
++-+
++-+static void
++-+setgaps(int oh, int ov, int ih, int iv)
++-+{
++-+    if (oh < 0) oh = 0;
++-+    if (ov < 0) ov = 0;
++-+    if (ih < 0) ih = 0;
++-+    if (iv < 0) iv = 0;
++-+
++-+    selmon->gappoh = oh;
++-+    selmon->gappov = ov;
++-+    selmon->gappih = ih;
++-+    selmon->gappiv = iv;
++-+    arrange(selmon);
++-+}
++-+
++-+static void
++-+togglegaps(const Arg *arg)
++-+{
++-+    enablegaps = !enablegaps;
++-+    /* arrange(NULL); */
++-+    arrange(selmon);
++-+}
++-+
++-+static void
++-+togglebgaps(const Arg *arg)
++-+{
++-+    browsergaps = !browsergaps;
++-+    arrange(NULL);
++-+}
++-+
++-+static void
++-+defaultgaps(const Arg *arg)
++-+{
++-+    setgaps(gappoh, gappov, gappih, gappiv);
++-+}
++-+
++-+static void
++-+incrgaps(const Arg *arg)
++-+{
++-+    setgaps(
++-+            selmon->gappoh + arg->i,
++-+            selmon->gappov + arg->i,
++-+            selmon->gappih + arg->i,
++-+            selmon->gappiv + arg->i
++-+           );
++-+}
++-+
++-+/* static void */
++-+/* incrigaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh, */
++-+/* 		selmon->gappov, */
++-+/* 		selmon->gappih + arg->i, */
++-+/* 		selmon->gappiv + arg->i */
++-+/* 	); */
++-+/* } */
++-+
++-+/* static void */
++-+/* incrogaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh + arg->i, */
++-+/* 		selmon->gappov + arg->i, */
++-+/* 		selmon->gappih, */
++-+/* 		selmon->gappiv */
++-+/* 	); */
++-+/* } */
++-+
++-+/* static void */
++-+/* incrohgaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh + arg->i, */
++-+/* 		selmon->gappov, */
++-+/* 		selmon->gappih, */
++-+/* 		selmon->gappiv */
++-+/* 	); */
++-+/* } */
++-+
++-+/* static void */
++-+/* incrovgaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh, */
++-+/* 		selmon->gappov + arg->i, */
++-+/* 		selmon->gappih, */
++-+/* 		selmon->gappiv */
++-+/* 	); */
++-+/* } */
++-+
++-+/* static void */
++-+/* incrihgaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh, */
++-+/* 		selmon->gappov, */
++-+/* 		selmon->gappih + arg->i, */
++-+/* 		selmon->gappiv */
++-+/* 	); */
++-+/* } */
++-+
++-+/* static void */
++-+/* incrivgaps(const Arg *arg) */
++-+/* { */
++-+/* 	setgaps( */
++-+/* 		selmon->gappoh, */
++-+/* 		selmon->gappov, */
++-+/* 		selmon->gappih, */
++-+/* 		selmon->gappiv + arg->i */
++-+/* 	); */
++-+/* } */
++-+
++-+static void
++-+getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++-+{
++-+    unsigned int n, oe, ie;
++-+    oe = ie = enablegaps;
++-+    Client *c;
++-+
++-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-+    /* if (smartgaps && n == 1) { */
++-+    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
++-+        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
++-+    }
++-+
++-+    if (TAGMASK == (1 << 8)){
++-+        setgaps(gappoh, gappov, gappih, gappiv);
++-+    }
++-+
++-+    *oh = m->gappoh*oe; // outer horizontal gap
++-+    *ov = m->gappov*oe; // outer vertical gap
++-+    *ih = m->gappih*ie; // inner horizontal gap
++-+    *iv = m->gappiv*ie; // inner vertical gap
++-+    *nc = n;            // number of clients
++-+}
++-+
++-+void
++-+getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++-+{
++-+    unsigned int n;
++-+    float mfacts, sfacts;
++-+    int mtotal = 0, stotal = 0;
++-+    Client *c;
++-+
++-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-+    mfacts = MIN(n, m->nmaster);
++-+    sfacts = n - m->nmaster;
++-+
++-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++-+        if (n < m->nmaster)
++-+            mtotal += msize / mfacts;
++-+        else
++-+            stotal += ssize / sfacts;
++-+
++-+    *mf = mfacts; // total factor of master area
++-+    *sf = sfacts; // total factor of stack area
++-+    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
++-+    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
++-+}
++-+
++-+/***
++-+ * Layouts
++-+ */
++-+
++-+/*
++-+ * Bottomstack layout + gaps
++-+ * https://dwm.suckless.org/patches/bottomstack/
++-+ */
++-+
++-+static void
++-+bstack(Monitor *m)
++-+{
++-+    unsigned int i, n;
++-+    int mx = 0, my = 0, mh = 0, mw = 0;
++-+    int sx = 0, sy = 0, sh = 0, sw = 0;
++-+    float mfacts, sfacts;
++-+    int mrest, srest;
++-+    Client *c;
++-+
++-+    int oh, ov, ih, iv;
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    sx = mx = m->wx + ov;
++-+    sy = my = m->wy + oh;
++-+    sh = mh = m->wh - 2*oh;
++-+    mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++-+    sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++-+
++-+    if (m->nmaster && n > m->nmaster) {
++-+        sh = (mh - ih) * (1 - m->mfact);
++-+        mh = (mh - ih) * m->mfact;
++-+        sx = mx;
++-+        sy = my + mh + ih;
++-+    }
++-+
++-+    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++-+        if (i < m->nmaster) {
++-+            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++-+            mx += WIDTH(c) + iv;
++-+        } else {
++-+            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++-+            sx += WIDTH(c) + iv;
++-+        }
++-+    }
++-+}
++-+
++-+/*
++-+ * Centred master layout + gaps
++-+ * https://dwm.suckless.org/patches/centeredmaster/
++-+ */
++-+
++-+void
++-+centeredmaster(Monitor *m)
++-+{
++-+    unsigned int i, n;
++-+    int mx = 0, my = 0, mh = 0, mw = 0;
++-+    int lx = 0, ly = 0, lw = 0, lh = 0;
++-+    int rx = 0, ry = 0, rw = 0, rh = 0;
++-+    float mfacts = 0, lfacts = 0, rfacts = 0;
++-+    int mtotal = 0, ltotal = 0, rtotal = 0;
++-+    int mrest = 0, lrest = 0, rrest = 0;
++-+    Client *c;
++-+
++-+    int oh, ov, ih, iv;
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    /* initialize areas */
++-+    mx = m->wx + ov;
++-+    my = m->wy + oh;
++-+    mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++-+    mw = m->ww - 2*ov;
++-+    lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++-+    rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++-+
++-+    if (m->nmaster && n > m->nmaster) {
++-+        /* go mfact box in the center if more than nmaster clients */
++-+        if (n - m->nmaster > 1) {
++-+            /* ||<-S->|<---M--->|<-S->|| */
++-+            mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++-+            lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++-+            mx += lw + iv;
++-+        } else {
++-+            /* ||<---M--->|<-S->|| */
++-+            mw = (mw - iv) * m->mfact;
++-+            lw = m->ww - mw - iv - 2*ov;
++-+        }
++-+        rw = lw;
++-+        lx = m->wx + ov;
++-+        ly = m->wy + oh;
++-+        rx = mx + mw + iv;
++-+        ry = m->wy + oh;
++-+    }
++-+
++-+    /* calculate facts */
++-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++-+        if (!m->nmaster || n < m->nmaster)
++-+            mfacts += 1;
++-+        else if ((n - m->nmaster) % 2)
++-+            lfacts += 1; // total factor of left hand stack area
++-+        else
++-+            rfacts += 1; // total factor of right hand stack area
++-+    }
++-+
++-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++-+        if (!m->nmaster || n < m->nmaster)
++-+            mtotal += mh / mfacts;
++-+        else if ((n - m->nmaster) % 2)
++-+            ltotal += lh / lfacts;
++-+        else
++-+            rtotal += rh / rfacts;
++-+
++-+    mrest = mh - mtotal;
++-+    lrest = lh - ltotal;
++-+    rrest = rh - rtotal;
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++-+        if (!m->nmaster || i < m->nmaster) {
++-+            /* nmaster clients are stacked vertically, in the center of the screen */
++-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++-+            my += HEIGHT(c) + ih;
++-+        } else {
++-+            /* stack clients are stacked vertically */
++-+            if ((i - m->nmaster) % 2 ) {
++-+                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++-+                ly += HEIGHT(c) + ih;
++-+            } else {
++-+                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++-+                ry += HEIGHT(c) + ih;
++-+            }
++-+        }
++-+    }
++-+}
++-+
++-+void
++-+centeredfloatingmaster(Monitor *m)
++-+{
++-+    unsigned int i, n;
++-+    float mfacts, sfacts;
++-+    int mrest, srest;
++-+    int mx = 0, my = 0, mh = 0, mw = 0;
++-+    int sx = 0, sy = 0, sh = 0, sw = 0;
++-+    Client *c;
++-+
++-+    float mivf = 1.0; // master inner vertical gap factor
++-+    int oh, ov, ih, iv;
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    sx = mx = m->wx + ov;
++-+    sy = my = m->wy + oh;
++-+    sh = mh = m->wh - 2*oh;
++-+    mw = m->ww - 2*ov - iv*(n - 1);
++-+    sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++-+
++-+    if (m->nmaster && n > m->nmaster) {
++-+        mivf = 0.8;
++-+        /* go mfact box in the center if more than nmaster clients */
++-+        if (m->ww > m->wh) {
++-+            mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++-+            mh = m->wh * 0.9 - 2*oh;
++-+        } else {
++-+            mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++-+            mh = m->wh * m->mfact;
++-+        }
++-+        mx = m->wx + (m->ww - mw) / 2;
++-+        my = m->wy + (m->wh - mh) / 2;
++-+
++-+        sx = m->wx + ov;
++-+        sy = m->wy + oh;
++-+        sh = m->wh - 2*oh;
++-+    }
++-+
++-+    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-+        if (i < m->nmaster) {
++-+            /* nmaster clients are stacked horizontally, in the center of the screen */
++-+            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++-+            mx += WIDTH(c) + iv*mivf;
++-+        } else {
++-+            /* stack clients are stacked horizontally */
++-+            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++-+            sx += WIDTH(c) + iv;
++-+        }
++-+}
++-+
++-+/*
++-+ * Deck layout + gaps
++-+ * https://dwm.suckless.org/patches/deck/
++-+ */
++-+
++-+static void
++-+deck(Monitor *m)
++-+{
++-+    unsigned int i, n;
++-+    int mx = 0, my = 0, mh = 0, mw = 0;
++-+    int sx = 0, sy = 0, sh = 0, sw = 0;
++-+    float mfacts, sfacts;
++-+    int mrest, srest;
++-+    Client *c;
++-+
++-+    int oh, ov, ih, iv;
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    sx = mx = m->wx + ov;
++-+    sy = my = m->wy + oh;
++-+    sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++-+    sw = mw = m->ww - 2*ov;
++-+
++-+    if (m->nmaster && n > m->nmaster) {
++-+        sw = (mw - iv) * (1 - m->mfact);
++-+        mw = (mw - iv) * m->mfact;
++-+        sx = mx + mw + iv;
++-+        sh = m->wh - 2*oh;
++-+    }
++-+
++-+    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++-+
++-+    if (n - m->nmaster > 0) /* override layout symbol */
++-+        snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-+        if (i < m->nmaster) {
++-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++-+            my += HEIGHT(c) + ih;
++-+        } else {
++-+            resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++-+        }
++-+}
++-+
++-+/*
++-+ * Fibonacci layout + gaps
++-+ * https://dwm.suckless.org/patches/fibonacci/
++-+ */
++-+
++-+static void
++-+fibonacci(Monitor *m, int s)
++-+{
++-+    unsigned int i, n;
++-+    int nx, ny, nw, nh;
++-+    int oh, ov, ih, iv;
++-+    Client *c;
++-+
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    nx = m->wx + ov;
++-+    ny = oh;
++-+    nw = m->ww - 2*ov;
++-+    nh = m->wh - 2*oh;
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++-+        if ((i % 2 && nh / 2 > 2*c->bw)
++-+                || (!(i % 2) && nw / 2 > 2*c->bw)) {
++-+            if (i < n - 1) {
++-+                if (i % 2)
++-+                    nh = (nh - ih) / 2;
++-+                else
++-+                    nw = (nw - iv) / 2;
++-+
++-+                if ((i % 4) == 2 && !s)
++-+                    nx += nw + iv;
++-+                else if ((i % 4) == 3 && !s)
++-+                    ny += nh + ih;
++-+            }
++-+            if ((i % 4) == 0) {
++-+                if (s)
++-+                    ny += nh + ih;
++-+                else
++-+                    ny -= nh + ih;
++-+            }
++-+            else if ((i % 4) == 1)
++-+                nx += nw + iv;
++-+            else if ((i % 4) == 2)
++-+                ny += nh + ih;
++-+            else if ((i % 4) == 3) {
++-+                if (s)
++-+                    nx += nw + iv;
++-+                else
++-+                    nx -= nw + iv;
++-+            }
++-+            if (i == 0)	{
++-+                if (n != 1)
++-+                    nw = (m->ww - 2*ov - iv) * m->mfact;
++-+                ny = m->wy + oh;
++-+            }
++-+            else if (i == 1)
++-+                nw = m->ww - nw - iv - 2*ov;
++-+            i++;
++-+        }
++-+
++-+        resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++-+    }
++-+}
++-+
++-+static void
++-+dwindle(Monitor *m)
++-+{
++-+    fibonacci(m, 1);
++-+}
++-+
++-+static void
++-+spiral(Monitor *m)
++-+{
++-+    fibonacci(m, 0);
++-+}
++-+
++-+/*
++-+ * Default tile layout + gaps
++-+ */
++-+
++-+static void
++-+tile(Monitor *m)
++-+{
++-+    unsigned int i, n;
++-+    int mx = 0, my = 0, mh = 0, mw = 0;
++-+    int sx = 0, sy = 0, sh = 0, sw = 0;
++-+    float mfacts, sfacts;
++-+    int mrest, srest;
++-+    Client *c;
++-+
++-+    int oh, ov, ih, iv;
++-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-+
++-+    if (n == 0)
++-+        return;
++-+
++-+    sx = mx = m->wx + ov;
++-+    sy = my = m->wy + oh;
++-+    mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++-+    sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++-+    sw = mw = m->ww - 2*ov;
++-+
++-+    if (m->nmaster && n > m->nmaster) {
++-+        sw = (mw - iv) * (1 - m->mfact);
++-+        mw = (mw - iv) * m->mfact;
++-+        sx = mx + mw + iv;
++-+    }
++-+
++-+    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++-+
++-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-+        if (i < m->nmaster) {
++-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++-+            my += HEIGHT(c) + ih;
++-+        } else {
++-+            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++-+            sy += HEIGHT(c) + ih;
++-+        }
++-+}
++diff --git a/config.h b/config.h
++index 342750a..ec7de9e 100644
++--- a/config.h
+++++ b/config.h
++@@ -28,13 +28,15 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
++ static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
++ static int showbar              = 1;        /* 0 means no bar */
++ static int topbar               = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
++ /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
++ /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
++ static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
++-static char normbgcolor[]       = "#222222";
++-static char normbordercolor[]   = "#444444";
++-static char normfgcolor[]       = "#bbbbbb";
++-static char selfgcolor[]        = "#eeeeee";
+++//static char normbgcolor[]       = "#222222";
+++static char normbgcolor[]       = "#282828";
+++static char normbordercolor[]   = "#ebdbb2";
+++static char normfgcolor[]       = "#ebdbb2";
+++static char selfgcolor[]        = "#ebdbb2";
++ static char selbordercolor[]    = "#770000";
++ static char selbgcolor[]        = "#005577";
++ static const char col1[]        = "#98971a";
++@@ -127,8 +129,13 @@ static const Layout layouts[] = {
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++ 
+++#define STATUSBAR "dwmblocks"
+++
++ /* commands */
+++static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++ static const char *termcmd[]  = { TERMINAL, NULL };
+++//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
++ 
++ /*
++  * Xresources preferences to load at startup
++@@ -157,7 +164,6 @@ ResourcePref resources[] = {
++ };
++ 
++ #include <X11/XF86keysym.h>
++-#include "shiftview.c"
++ 
++ static const Key keys[] = {
++     /*  modifier                    key                 function            argument */
++@@ -328,17 +334,19 @@ static const Key keys[] = {
++         /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
++ };
++ 
+++#define STATUSBAR "dwmblocks"
+++
++ /* button definitions */
++ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
++ static const Button buttons[] = {
++     /* click                event mask      button          function        argument */
++ #ifndef __OpenBSD__
++-    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
++-    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
++-    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
++-    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
++-    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
++-    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
+++    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+++    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+++    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+++    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+++    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+++    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
++ #endif
++     { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
++     { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++diff --git a/config.mk b/config.mk
++index 1fc4bf1..a933c0b 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -19,10 +19,12 @@ FREETYPELIBS = -lfontconfig -lXft
++ FREETYPEINC = /usr/include/freetype2
++ # OpenBSD (uncomment)
++ #FREETYPEINC = ${X11INC}/freetype2
+++#MANPREFIX = ${PREFIX}/man
+++#KVMLIB = -lkvm
++ 
++ # includes and libs
++ INCS = -I${X11INC} -I${FREETYPEINC}
++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
+++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
++ 
++ # flags
++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++diff --git a/drw.c b/drw.c
++index d43d8c2..6be5dee 100644
++--- a/drw.c
+++++ b/drw.c
++@@ -13,7 +13,6 @@
++ static int
++ utf8decode(const char *s_in, long *u, int *err)
++ {
++-
++ 	static const unsigned char lens[] = {
++ 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
++ 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
++@@ -27,7 +26,6 @@ utf8decode(const char *s_in, long *u, int *err)
++ 
++ 	const unsigned char *s = (const unsigned char *)s_in;
++ 	int len = lens[*s >> 3];
++-
++ 	*u = UTF_INVALID;
++ 	*err = 1;
++ 	if (len == 0)
++@@ -83,6 +81,7 @@ drw_free(Drw *drw)
++ {
++ 	XFreePixmap(drw->dpy, drw->drawable);
++ 	XFreeGC(drw->dpy, drw->gc);
+++	drw_fontset_free(drw->fonts);
++ 	free(drw);
++ }
++ 
++@@ -177,8 +176,6 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++ 	                       DefaultColormap(drw->dpy, drw->screen),
++ 	                       clrname, dest))
++ 		die("error, cannot allocate color '%s'", clrname);
++-
++-    dest->pixel |= 0xff << 24;
++ }
++ 
++ /* Wrapper to create color schemes. The caller has to call free(3) on the
++@@ -266,7 +263,6 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++ 	if (!invalid_width && render)
++ 		invalid_width = drw_fontset_getwidth(drw, invalid);
++ 	while (1) {
++-        utf8strlen = 0;
++ 		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
++ 		utf8str = text;
++ 		nextfont = NULL;
++@@ -357,7 +353,6 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++ 			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
++ 			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
++ 			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
++-            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
++ 
++ 			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
++ 			FcDefaultSubstitute(fcpattern);
++diff --git a/dwm.1 b/dwm.1
++index 7feba78..d04bec6 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -1,16 +1,21 @@
++ .TH DWM 1 dwm\-VERSION
++ .SH NAME
++-dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
+++dwm \- dynamic window manager
++ .SH SYNOPSIS
++ .B dwm
++ .RB [ \-v ]
++ .SH DESCRIPTION
++-dwm is a dynamic window manager for X.
+++dwm is a dynamic window manager for X. It manages windows in tiled, monocle
+++and floating layouts. Either layout can be applied dynamically, optimising the
+++environment for the application in use and the task performed.
++ .P
++-dwm "orders" windows based on recency and primacy, while dwm layouts may
++-change, the most recent "master" window is shown in the most prominent
++-position. There are bindings for cycling through and promoting windows to the
++-master position.
+++In tiled layouts windows are managed in a master and stacking area. The master
+++area on the left contains one window by default, and the stacking area on the
+++right contains all other windows. The number of master area windows can be
+++adjusted from zero to an arbitrary number. In monocle layout all windows are
+++maximised to the screen size. In floating layout windows can be resized and
+++moved freely. Dialog windows are always managed floating, regardless of the
+++layout applied.
++ .P
++ Windows are grouped by tags. Each window can be tagged with one or multiple
++ tags. Selecting certain tags displays all windows with these tags.
++@@ -26,18 +31,17 @@ indicated with an empty square in the top left corner.
++ .P
++ dwm draws a small border around windows to indicate the focus state.
++ .P
++-.I
++-libxft-bgra
++-should be installed for this build of dwm. Arch users may install it via the
++-AUR. Color characters and emoji are enabled, but these will cause crashes
++-without the fix
++-.I
++-libxft-bgra
++-offers.
+++On start, dwm can start additional programs that may be specified in two special
+++shell scripts (see the FILES section below), autostart_blocking.sh and
+++autostart.sh.  The former is executed first and dwm will wait for its
+++termination before starting.  The latter is executed in the background before
+++dwm enters its handler loop.
+++.P
+++Either of these files may be omitted.
++ .SH OPTIONS
++ .TP
++ .B \-v
++-prints version information to standard output, then exits.
+++prints version information to stderr, then exits.
++ .SH USAGE
++ .SS Status bar
++ .TP
++@@ -46,142 +50,118 @@ is read and displayed in the status text area. It can be set with the
++ .BR xsetroot (1)
++ command.
++ .TP
++-.B Left click
+++.B Button1
++ click on a tag label to display all windows with that tag, click on the layout
++ label toggles between tiled and floating layout.
++ .TP
++-.B Right click
+++.B Button3
++ click on a tag label adds/removes all windows with that tag to/from the view.
++ .TP
++-.B Super\-Left click
+++.B Mod1\-Button1
++ click on a tag label applies that tag to the focused window.
++ .TP
++-.B Super\-Right click
+++.B Mod1\-Button3
++ click on a tag label adds/removes that tag to/from the focused window.
++ .SS Keyboard commands
++ .TP
++-.B Super\-Return
++-Start terminal,
+++.B Mod1\-Shift\-Return
+++Start
++ .BR st(1).
++ .TP
++-.B Super\-d
+++.B Mod1\-p
++ Spawn
++ .BR dmenu(1)
++ for launching other programs.
++ .TP
++-.B Super\-b
++-Toggles bar on and off.
+++.B Mod1\-,
+++Focus previous screen, if any.
++ .TP
++-.B Super\-q
++-Close focused window.
+++.B Mod1\-.
+++Focus next screen, if any.
++ .TP
++-.B Super\-t/T
++-Sets tiled/bstack layouts.
+++.B Mod1\-Shift\-,
+++Send focused window to previous screen, if any.
++ .TP
++-.B Super\-f
++-Toggle fullscreen window.
+++.B Mod1\-Shift\-.
+++Send focused window to next screen, if any.
++ .TP
++-.B Super\-F
++-Toggle floating layout.
+++.B Mod1\-b
+++Toggles bar on and off.
+++.TP
+++.B Mod1\-t
+++Sets tiled layout.
++ .TP
++-.B Super\-y/Y
++-Sets Fibonacci spiral/dwinde layouts.
+++.B Mod1\-f
+++Sets floating layout.
++ .TP
++-.B Super\-u/U
++-Sets centered master layout.
+++.B Mod1\-m
+++Sets monocle layout.
++ .TP
++-.B Super\-i/I
++-Sets centered master or floating master layouts.
+++.B Mod1\-space
+++Toggles between current and previous layout.
++ .TP
++-.B Super\-space
++-Zooms/cycles focused window to/from master area.
+++.B Mod1\-j
+++Focus next window.
++ .TP
++-.B Super\-j/k
++-Focus next/previous window.
+++.B Mod1\-k
+++Focus previous window.
++ .TP
++-.B Super\-Shift\-j/k
++-Move selected window down/up in stack.
+++.B Mod1\-i
+++Increase number of windows in master area.
++ .TP
++-.B Super\-o/O
++-Increase/decrease number of windows in master area.
+++.B Mod1\-d
+++Decrease number of windows in master area.
++ .TP
++-.B Super\-l
+++.B Mod1\-l
++ Increase master area size.
++ .TP
++-.B Super\-h
+++.B Mod1\-h
++ Decrease master area size.
++ .TP
++-.B Super\-Shift\-space
++-Toggle focused window between tiled and floating state.
++-.TP
++-.B Super\-Tab
++-Toggles to the previously selected tags.
++-.TP
++-.B Super\-g
++-Moves to the previous tag.
++-.TP
++-.B Super\-Shift\-g
++-Moves selected window to the previous tag.
++-.TP
++-.B Super\-;
++-Moves to the next tag.
+++.B Mod1\-Return
+++Zooms/cycles focused window to/from master area (tiled layouts only).
++ .TP
++-.B Super\-Shift\-;
++-Moves selected window to the next tag.
++-.TP
++-.B Super\-PageUp
++-Moves to the previous tag.
++-.TP
++-.B Super\-Shift\-PageUp
++-Moves selected window to the previous tag.
++-.TP
++-.B Super\-Pagedown
++-Moves to the next tag.
++-.TP
++-.B Super\-Shift\-PageDown
++-Moves selected window to the next tag.
+++.B Mod1\-Shift\-c
+++Close focused window.
++ .TP
++-.B Super\-a
++-Toggle gaps.
+++.B Mod1\-Shift\-f
+++Toggle fullscreen for focused window.
++ .TP
++-.B Super\-z
++-Increase gaps between windows.
+++.B Mod1\-Shift\-space
+++Toggle focused window between tiled and floating state.
++ .TP
++-.B Super\-x
++-Decrease gaps between windows.
+++.B Mod1\-Tab
+++Toggles to the previously selected tags.
++ .TP
++-.B Super\-Shift\-[1..n]
+++.B Mod1\-Shift\-[1..n]
++ Apply nth tag to focused window.
++ .TP
++-.B Super\-Shift\-0
+++.B Mod1\-Shift\-0
++ Apply all tags to focused window.
++ .TP
++-.B Super\-Control\-Shift\-[1..n]
+++.B Mod1\-Control\-Shift\-[1..n]
++ Add/remove nth tag to/from focused window.
++ .TP
++-.B Super\-[1..n]
+++.B Mod1\-[1..n]
++ View all windows with nth tag.
++ .TP
++-.B Super\-0
+++.B Mod1\-0
++ View all windows with any tag.
++ .TP
++-.B Super\-Control\-[1..n]
+++.B Mod1\-Control\-[1..n]
++ Add/remove all windows with nth tag to/from the view.
++ .TP
++-.B Super\-Shift\-q
+++.B Mod1\-Shift\-q
++ Quit dwm.
++-.TP
++-.B Mod1\-Control\-Shift\-q
++-Menu to refresh/quit/reboot/shutdown.
++ .SS Mouse commands
++ .TP
++-.B Super\-Left click
+++.B Mod1\-Button1
++ Move focused window while dragging. Tiled windows will be toggled to the floating state.
++ .TP
++-.B Super\-Middle click
+++.B Mod1\-Button2
++ Toggles focused window between floating and tiled state.
++ .TP
++-.B Super\-Right click
+++.B Mod1\-Button3
++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++ .SH FILES
++ The files containing programs to be started along with dwm are searched for in
++@@ -201,13 +181,6 @@ This file is started before any autostart.sh; dwm waits for its termination.
++ .SH CUSTOMIZATION
++ dwm is customized by creating a custom config.h and (re)compiling the source
++ code. This keeps it fast, secure and simple.
++-.SH SIGNALS
++-.TP
++-.B SIGHUP - 1
++-Restart the dwm process.
++-.TP
++-.B SIGTERM - 15
++-Cleanly terminate the dwm process.
++ .SH SEE ALSO
++ .BR dmenu (1),
++ .BR st (1)
++diff --git a/dwm.c b/dwm.c
++index 9086e16..6232799 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -29,6 +29,7 @@
++ #include <string.h>
++ #include <unistd.h>
++ #include <sys/types.h>
+++#include <sys/stat.h>
++ #include <sys/wait.h>
++ #include <X11/cursorfont.h>
++ #include <X11/keysym.h>
++@@ -43,6 +44,10 @@
++ #include <X11/Xft/Xft.h>
++ #include <X11/Xlib-xcb.h>
++ #include <xcb/res.h>
+++#ifdef __OpenBSD__
+++#include <sys/sysctl.h>
+++#include <kvm.h>
+++#endif /* __OpenBSD */
++ 
++ #include "drw.h"
++ #include "util.h"
++@@ -57,8 +62,8 @@
++ #define ISINC(X)                ((X) > 1000 && (X) < 3000)
++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++ #define PREVSEL                 3000
++-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+++#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++ #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++@@ -72,11 +77,11 @@
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++ enum { SchemeNorm, SchemeSel }; /* color schemes */
++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++-    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++-    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
+++       ClkRootWin, ClkLast }; /* clicks */
++ 
++ typedef union {
++ 	int i;
++@@ -98,13 +103,14 @@ typedef struct Client Client;
++ struct Client {
++ 	char name[256];
++ 	float mina, maxa;
+++	float cfact;
++ 	int x, y, w, h;
++ 	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
+++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
++     pid_t pid;
++ 	Client *next;
++ 	Client *snext;
++@@ -189,7 +195,6 @@ static void clientmessage(XEvent *e);
++ static void configure(Client *c);
++ static void configurenotify(XEvent *e);
++ static void configurerequest(XEvent *e);
++-static void copyvalidchars(char *text, char *rawtext);
++ static Monitor *createmon(void);
++ static void destroynotify(XEvent *e);
++ static void detach(Client *c);
++@@ -206,6 +211,7 @@ static void focusstack(const Arg *arg);
++ static Atom getatomprop(Client *c, Atom prop);
++ static int getrootptr(int *x, int *y);
++ static long getstate(Window w);
+++static pid_t getstatusbarpid();
++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++ static void grabbuttons(Client *c, int focused);
++ static void grabkeys(void);
++@@ -216,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
++ static void mappingnotify(XEvent *e);
++ static void maprequest(XEvent *e);
++ static void monocle(Monitor *m);
++-static void motionnotify(XEvent *e);
++ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *c);
++@@ -229,7 +234,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
++ static void resizemouse(const Arg *arg);
++ static void restack(Monitor *m);
++ static void run(void);
++-static void runAutostart(void);
+++static void runautostart(void);
++ static void scan(void);
++ static int sendevent(Client *c, Atom proto);
++ static void sendmon(Client *c, Monitor *m);
++@@ -237,17 +242,16 @@ static void sendmonview(Client *c, Monitor *m);
++ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
+++static void setsticky(Client *c, int sticky);
++ static void setlayout(const Arg *arg);
+++static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
+++static void shiftview(const Arg *arg);
+++static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
++-#ifndef __OpenBSD__
++-static int getdwmblockspid();
++-static void sigdwmblocks(const Arg *arg);
++-#endif
++-static void sighup(int unused);
++-static void sigterm(int unused);
+++static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
++ static int stackpos(const Arg *arg);
++ static void tag(const Arg *arg);
++@@ -291,12 +295,15 @@ static Client *termforwin(const Client *c);
++ static pid_t winpid(Window w);
++ 
++ /* variables */
+++static const char autostartblocksh[] = "autostart_blocking.sh";
+++static const char autostartsh[] = "autostart.sh";
++ static const char broken[] = "broken";
++-static char stext[256];
++-/* static char stext[1024]; */
++-static char rawstext[256];
++-static int dwmblockssig;
++-pid_t dwmblockspid = 0;
+++static const char dwmdir[] = "dwm";
+++static const char localshare[] = ".local/share";
+++static char stext[1024];
+++static int statussig;
+++static int statusw;
+++static pid_t statuspid = -1;
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh;               /* bar height */
++@@ -314,12 +321,10 @@ static void (*handler[LASTEvent]) (XEvent *) = {
++ 	[KeyPress] = keypress,
++ 	[MappingNotify] = mappingnotify,
++ 	[MapRequest] = maprequest,
++-    [MotionNotify] = motionnotify,
++ 	[PropertyNotify] = propertynotify,
++ 	[UnmapNotify] = unmapnotify
++ };
++ static Atom wmatom[WMLast], netatom[NetLast];
++-static int restart = 0;
++ static int running = 1;
++ static Cur *cursor[CurLast];
++ static Clr **scheme;
++@@ -360,12 +365,12 @@ applyrules(Client *c)
++ 		&& (!r->instance || strstr(instance, r->instance)))
++ 		{
++ 			c->isterminal = r->isterminal;
++-            c->isfloating = r->isfloating;
++ 			c->noswallow  = r->noswallow;
+++			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
++ 			if ((r->tags & SPTAGMASK) && r->isfloating) {
++-                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
++-                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++ 			}
++ 
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++@@ -487,9 +492,10 @@ attachstack(Client *c)
++ void
++ swallow(Client *p, Client *c)
++ {
+++
++ 	if (c->noswallow || c->isterminal)
++ 		return;
++-    if (!swallowfloating && c->isfloating)
+++	if (c->noswallow && !swallowfloating && c->isfloating)
++ 		return;
++ 
++ 	detach(c);
++@@ -505,13 +511,7 @@ swallow(Client *p, Client *c)
++ 	p->win = c->win;
++ 	c->win = w;
++ 	updatetitle(p);
++-
++-    XWindowChanges wc;
++-    wc.border_width = p->bw;
++-    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
++ 	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++-    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
++-
++ 	arrange(p->mon);
++ 	configure(p);
++ 	updateclientlist();
++@@ -530,13 +530,7 @@ unswallow(Client *c)
++ 	updatetitle(c);
++ 	arrange(c->mon);
++ 	XMapWindow(dpy, c->win);
++-
++-    XWindowChanges wc;
++-    wc.border_width = c->bw;
++-    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
++ 	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++-
++ 	setclientstate(c, NormalState);
++ 	focus(NULL);
++ 	arrange(c->mon);
++@@ -545,7 +539,7 @@ unswallow(Client *c)
++ void
++ buttonpress(XEvent *e)
++ {
++-    unsigned int i, x, click, occ = 0;
+++	unsigned int i, x, click;
++ 	Arg arg = {0};
++ 	Client *c;
++ 	Monitor *m;
++@@ -553,17 +547,19 @@ buttonpress(XEvent *e)
++ 
++ 	click = ClkRootWin;
++ 	/* focus monitor if necessary */
++-    if ((m = wintomon(ev->window)) && m != selmon) {
+++	if ((m = wintomon(ev->window)) && m != selmon
+++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++ 		unfocus(selmon->sel, 1);
++ 		selmon = m;
++ 		focus(NULL);
++ 	}
++ 	if (ev->window == selmon->barwin) {
++ 		i = x = 0;
+++		unsigned int occ = 0;
++ 		for(c = m->clients; c; c=c->next)
++-            occ |= c->tags == 255 ? 0 : c->tags;
+++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++ 		do {
++-            /* do not reserve space for vacant tags */
+++			/* Do not reserve space for vacant tags */
++ 			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++ 				continue;
++ 			x += TEXTW(tags[i]);
++@@ -573,30 +569,36 @@ buttonpress(XEvent *e)
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++ 			click = ClkLtSymbol;
++-        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
+++        } else if (ev->x > selmon->ww - statusw) {
+++            x = selmon->ww - statusw;
++             click = ClkStatusText;
++ 
++-            char *text = rawstext;
++-            int i = -1;
++-            char ch;
++-            dwmblockssig = 0;
++-            while (text[++i]) {
++-                if ((unsigned char)text[i] < ' ') {
++-                    ch = text[i];
++-                    text[i] = '\0';
+++			char *text, *s, ch;
+++			statussig = 0;
+++			for (text = s = stext; *s && x <= ev->x; s++) {
+++				if ((unsigned char)(*s) < ' ') {
+++					ch = *s;
+++					*s = '\0';
++ 					x += TEXTW(text) - lrpad;
++-                    text[i] = ch;
++-                    text += i+1;
++-                    i = -1;
++-                    if (x >= ev->x) break;
++-                    dwmblockssig = ch;
+++					*s = ch;
+++					text = s + 1;
+++					if (x >= ev->x)
+++						break;
+++					statussig = ch;
+++				} else if (*s == '^') {
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = '^';
+++					if (*(++s) == 'f')
+++						x += atoi(++s);
+++					while (*(s++) != '^');
+++					text = s;
+++					s--;
++ 				}
++ 			}
++-        } else
++-            click = ClkWinTitle;
++ 	} else if ((c = wintoclient(ev->window))) {
+++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++ 			focus(c);
++-        restack(selmon);
++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++ 		click = ClkClientWin;
++ 	}
++@@ -635,7 +637,6 @@ cleanup(void)
++ 		cleanupmon(mons);
++ 	for (i = 0; i < CurLast; i++)
++ 		drw_cur_free(drw, cursor[i]);
++-    /* for (i = 0; i < LENGTH(colors); i++) */
++ 	for (i = 0; i < LENGTH(colors) + 1; i++)
++ 		free(scheme[i]);
++ 	free(scheme);
++@@ -675,6 +676,10 @@ clientmessage(XEvent *e)
++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+++
+++        if (cme->data.l[1] == netatom[NetWMSticky]
+++                || cme->data.l[2] == netatom[NetWMSticky])
+++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
++ 		if (c != selmon->sel && !c->isurgent)
++ 			seturgent(c, 1);
++@@ -780,19 +785,6 @@ configurerequest(XEvent *e)
++ 	XSync(dpy, False);
++ }
++ 
++-void
++-copyvalidchars(char *text, char *rawtext)
++-{
++-    int i = -1, j = 0;
++-
++-    while(rawtext[++i]) {
++-        if ((unsigned char)rawtext[i] >= ' ') {
++-            text[j++] = rawtext[i];
++-        }
++-    }
++-    text[j] = '\0';
++-}
++-
++ Monitor *
++ createmon(void)
++ {
++@@ -936,7 +928,7 @@ drawstatusbar(Monitor *m, int bh, char* stext)
++                     if (ptr == NULL) printf("Fail to read wr...");
++                     do{
++                         ch = fgetc(ptr);
++-                        // Check if contains + and 2 (= hot)
+++                        // Check if temp is above +20 (= hot)
++                         if (hotbool){
++                             if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
++                                 drw_clr_create(drw, &drw->scheme[ColFg], col21);
++@@ -990,30 +982,31 @@ drawstatusbar(Monitor *m, int bh, char* stext)
++ void
++ drawbar(Monitor *m)
++ {
++-    if (!m->showbar) return;
++ 	int x, w, tw = 0;
++ 	int boxs = drw->fonts->h / 9;
++ 	int boxw = drw->fonts->h / 6 + 2;
++ 	unsigned int i, occ = 0, urg = 0;
++ 	Client *c;
++ 
+++	if (!m->showbar)
+++		return;
+++
++ 	/* draw status first so it can be overdrawn by tags later */
++-    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
+++	//if (m == selmon) { /* status is only drawn on selected monitor */
++     if (m == selmon || 1) { 
++-        tw = m->ww - drawstatusbar(m, bh, stext);
+++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++-        occ |= c->tags == 255 ? 0 : c->tags;
+++		occ |= c->tags == TAGMASK ? 0 : c->tags;
++ 		if (c->isurgent)
++ 			urg |= c->tags;
++ 	}
++ 	x = 0;
++ 	for (i = 0; i < LENGTH(tags); i++) {
++-        /* do not draw vacant tags */
+++		/* Do not draw vacant tags */
++ 		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++ 			continue;
++-
++ 		w = TEXTW(tags[i]);
++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++@@ -1094,7 +1087,6 @@ focusmon(const Arg *arg)
++ 	if ((m = dirtomon(arg->i)) == selmon)
++ 		return;
++ 	unfocus(selmon->sel, 0);
++-    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++ 	selmon = m;
++ 	focus(NULL);
++ }
++@@ -1105,7 +1097,7 @@ focusstack(const Arg *arg)
++ 	int i = stackpos(arg);
++ 	Client *c, *p;
++ 
++-    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
+++	if(i < 0)
++ 		return;
++ 
++ 	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++@@ -1130,18 +1122,29 @@ getatomprop(Client *c, Atom prop)
++ 	return atom;
++ }
++ 
++-#ifndef __OpenBSD__
++-int getdwmblockspid()
+++pid_t
+++getstatusbarpid()
++ {
++-    char buf[16];
++-    FILE *fp = popen("pidof -s dwmblocks", "r");
+++	char buf[32], *str = buf, *c;
+++	FILE *fp;
+++
+++	if (statuspid > 0) {
+++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+++		if ((fp = fopen(buf, "r"))) {
+++			fgets(buf, sizeof(buf), fp);
+++			while ((c = strchr(str, '/')))
+++				str = c + 1;
+++			fclose(fp);
+++			if (!strcmp(str, STATUSBAR))
+++				return statuspid;
+++		}
+++	}
+++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+++		return -1;
++ 	fgets(buf, sizeof(buf), fp);
++-    pid_t pid = strtoul(buf, NULL, 10);
++ 	pclose(fp);
++-    dwmblockspid = pid;
++-    return pid != 0 ? 0 : -1;
+++	return strtoul(buf, NULL, 10);
++ }
++-#endif
++ 
++ int
++ getrootptr(int *x, int *y)
++@@ -1183,14 +1186,12 @@ gettextprop(Window w, Atom atom, char *text, unsigned int size)
++ 	text[0] = '\0';
++ 	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++ 		return 0;
++-    if (name.encoding == XA_STRING)
+++	if (name.encoding == XA_STRING) {
++ 		strncpy(text, (char *)name.value, size - 1);
++-    else {
++-        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+++	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++ 		strncpy(text, *list, size - 1);
++ 		XFreeStringList(list);
++ 	}
++-    }
++ 	text[size - 1] = '\0';
++ 	XFree(name.value);
++ 	return 1;
++@@ -1253,7 +1254,8 @@ incnmaster(const Arg *arg)
++ }
++ 
++ #ifdef XINERAMA
++-static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+++static int
+++isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++ {
++ 	while (n--)
++ 		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++@@ -1311,6 +1313,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->w = c->oldw = wa->width;
++ 	c->h = c->oldh = wa->height;
++ 	c->oldbw = wa->border_width;
+++	c->cfact = 1.0;
++ 
++ 	updatetitle(c);
++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++@@ -1329,35 +1332,24 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->x = MAX(c->x, c->mon->wx);
++ 	c->y = MAX(c->y, c->mon->wy);
++ 	c->bw = borderpx;
++-    /* if (c->isfloating) c->bw = 0; */
++ 
++ 	wc.border_width = c->bw;
++ 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++ 	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++ 	configure(c); /* propagates border_width, if size doesn't change */
++ 	updatewindowtype(c);
+++	updatesizehints(c);
++ 	updatewmhints(c);
++-    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
++-    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
++-    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
++ 	c->sfx = c->x;
++ 	c->sfy = c->y;
++ 	c->sfw = c->w;
++ 	c->sfh = c->h;
++-
++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++ 	grabbuttons(c, 0);
++ 	if (!c->isfloating)
++-        c->isfloating = c->oldstate = t || c->isfixed;
++-    if (c->isfloating) {
+++		c->isfloating = c->oldstate = trans != None || c->isfixed;
+++	if (c->isfloating)
++ 		XRaiseWindow(dpy, c->win);
++-        if (strcmp(c->name, "YAD") == 0) {
++-            c->x = 1488;
++-            c->y = 42;
++-            c->w = 405;
++-            c->h = 280;
++-        }
++-    }
++ 	attach(c);
++ 	attachstack(c);
++ 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++@@ -1367,10 +1359,10 @@ manage(Window w, XWindowAttributes *wa)
++ 	if (c->mon == selmon)
++ 		unfocus(selmon->sel, 0);
++ 	c->mon->sel = c;
+++	arrange(c->mon);
++ 	XMapWindow(dpy, c->win);
++ 	if (term)
++ 		swallow(term, c);
++-    arrange(c->mon);
++ 	focus(NULL);
++ }
++ 
++@@ -1390,9 +1382,7 @@ maprequest(XEvent *e)
++ 	static XWindowAttributes wa;
++ 	XMapRequestEvent *ev = &e->xmaprequest;
++ 
++-    if (!XGetWindowAttributes(dpy, ev->window, &wa))
++-        return;
++-    if (wa.override_redirect)
+++	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
++ 		return;
++ 	if (!wintoclient(ev->window))
++ 		manage(ev->window, &wa);
++@@ -1401,33 +1391,16 @@ maprequest(XEvent *e)
++ void
++ monocle(Monitor *m)
++ {
++-    unsigned int n;
++-    int oh, ov, ih, iv;
+++	unsigned int n = 0;
++ 	Client *c;
++ 
++-    getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
+++	for (c = m->clients; c; c = c->next)
+++		if (ISVISIBLE(c))
+++			n++;
++ 	if (n > 0) /* override layout symbol */
++ 		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++ 	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++-        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
++-}
++-
++-void
++-motionnotify(XEvent *e)
++-{
++-    static Monitor *mon = NULL;
++-    Monitor *m;
++-    XMotionEvent *ev = &e->xmotion;
++-
++-    if (ev->window != root)
++-        return;
++-    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-        unfocus(selmon->sel, 1);
++-        selmon = m;
++-        focus(NULL);
++-    }
++-    mon = m;
+++		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++ }
++ 
++ void
++@@ -1460,9 +1433,7 @@ movemouse(const Arg *arg)
++ 			handler[ev.type](&ev);
++ 			break;
++ 		case MotionNotify:
++-                // Increase display rate when dragging  and resizing floats
++-                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
++-                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
+++			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++ 				continue;
++ 			lasttime = ev.xmotion.time;
++ 
++@@ -1508,30 +1479,6 @@ pop(Client *c)
++ 	arrange(c->mon);
++ }
++ 
++-void
++-pushstack(const Arg *arg)
++-{
++-    int i = stackpos(arg);
++-    Client *sel = selmon->sel, *c, *p;
++-
++-    if(i < 0 || !sel)
++-        return;
++-    else if(i == 0) {
++-        detach(sel);
++-        attach(sel);
++-    }
++-    else {
++-        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++-            if(!(i -= (ISVISIBLE(c) && c != sel)))
++-                break;
++-        c = c ? c : p;
++-        detach(sel);
++-        sel->next = c->next;
++-        c->next = sel;
++-    }
++-    arrange(selmon);
++-}
++-
++ void
++ propertynotify(XEvent *e)
++ {
++@@ -1539,11 +1486,11 @@ propertynotify(XEvent *e)
++ 	Window trans;
++ 	XPropertyEvent *ev = &e->xproperty;
++ 
++-    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
+++	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
++ 		updatestatus();
++-    } else if (ev->state == PropertyDelete) {
+++	else if (ev->state == PropertyDelete)
++ 		return; /* ignore */
++-    } else if ((c = wintoclient(ev->window))) {
+++	else if ((c = wintoclient(ev->window))) {
++ 		switch(ev->atom) {
++ 		default: break;
++ 		case XA_WM_TRANSIENT_FOR:
++@@ -1559,21 +1506,39 @@ propertynotify(XEvent *e)
++ 			drawbars();
++ 			break;
++ 		}
++-        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
+++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++ 			updatetitle(c);
++-            if (c == c->mon->sel)
++-                drawbar(c->mon);
++-        }
++-
++ 		if (ev->atom == netatom[NetWMWindowType])
++ 			updatewindowtype(c);
++ 	}
++ }
++ 
+++void
+++pushstack(const Arg *arg) {
+++	int i = stackpos(arg);
+++	Client *sel = selmon->sel, *c, *p;
+++
+++	if(i < 0)
+++		return;
+++	else if(i == 0) {
+++		detach(sel);
+++		attach(sel);
+++	}
+++	else {
+++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+++			if(!(i -= (ISVISIBLE(c) && c != sel)))
+++				break;
+++		c = c ? c : p;
+++		detach(sel);
+++		sel->next = c->next;
+++		c->next = sel;
+++	}
+++	arrange(selmon);
+++}
+++
++ void
++ quit(const Arg *arg)
++ {
++-    if(arg->i) restart = 1;
++ 	running = 0;
++ }
++ 
++@@ -1608,16 +1573,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
++ 	c->oldw = c->w; c->w = wc.width = w;
++ 	c->oldh = c->h; c->h = wc.height = h;
++ 	wc.border_width = c->bw;
++-    // Don't show border if floating or if only 1 client
++ 	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++ 	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++-            && !c->isfullscreen) {
++-        /* && !c->isfullscreen && !c->isfloating) { */
+++	    && !c->isfullscreen && !c->isfloating) {
++ 		c->w = wc.width += c->bw * 2;
++ 		c->h = wc.height += c->bw * 2;
++ 		wc.border_width = 0;
++ 	}
++-
++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++ 	configure(c);
++ 	XSync(dpy, False);
++@@ -1716,8 +1678,85 @@ run(void)
++ 			handler[ev.type](&ev); /* call handler */
++ }
++ 
++-void
++-runAutostart(void)
+++//void
+++//runautostart(void)
+++//{
+++//	char *pathpfx;
+++//	char *path;
+++//	char *xdgdatahome;
+++//	char *home;
+++//	struct stat sb;
+++//
+++//	if ((home = getenv("HOME")) == NULL)
+++//		/* this is almost impossible */
+++//		return;
+++//
+++//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+++//	 * otherwise use ~/.local/share/dwm as autostart script directory
+++//	 */
+++//	xdgdatahome = getenv("XDG_DATA_HOME");
+++//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+++//		/* space for path segments, separators and nul */
+++//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+++//
+++//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	} else {
+++//		/* space for path segments, separators and nul */
+++//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+++//		                     + strlen(dwmdir) + 3);
+++//
+++//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	}
+++//
+++//	/* check if the autostart script directory exists */
+++//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+++//		/* the XDG conformant path does not exist or is no directory
+++//		 * so we try ~/.dwm instead
+++//		 */
+++//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+++//		if(pathpfx_new == NULL) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//		pathpfx = pathpfx_new;
+++//
+++//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	}
+++//
+++//	/* try the blocking script first */
+++//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+++//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+++//		free(path);
+++//		free(pathpfx);
+++//	}
+++//
+++//	if (access(path, X_OK) == 0)
+++//		system(path);
+++//
+++//	/* now the non-blocking script */
+++//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+++//		free(path);
+++//		free(pathpfx);
+++//	}
+++//
+++//	if (access(path, X_OK) == 0)
+++//		system(strcat(path, " &"));
+++//
+++//	free(pathpfx);
+++//	free(path);
+++//}
+++
+++void
+++runautostart(void)
++ {
++     system("killall -q dwmblocks; dwmblocks &");
++ }
++@@ -1858,37 +1897,23 @@ setfullscreen(Client *c, int fullscreen)
++ 	}
++ }
++ 
++-int
++-stackpos(const Arg *arg)
+++void
+++	 setsticky(Client *c, int sticky)
++ 	 {
++-    int n, i;
++-    Client *c, *l;
++ 
++-    if(!selmon->clients)
++-        return -1;
++-
++-    if(arg->i == PREVSEL) {
++-        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++-        if(!l)
++-            return -1;
++-        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-        return i;
++-    }
++-    else if(ISINC(arg->i)) {
++-        if(!selmon->sel)
++-            return -1;
++-        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-        return MOD(i + GETINC(arg->i), n);
++-    }
++-    else if(arg->i < 0) {
++-        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++-        return MAX(i + arg->i, 0);
+++		 if(sticky && !c->issticky) {
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+++			 c->issticky = 1;
+++		 } else if(!sticky && c->issticky){
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *)0, 0);
+++			 c->issticky = 0;
+++			 arrange(c->mon);
++ 		 }
++-    else
++-        return arg->i;
++ 	 }
++ 
+++
++ void
++ setlayout(const Arg *arg)
++ {
++@@ -1903,6 +1928,58 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++shiftview(const Arg *arg) {
+++	Arg shifted;
+++
+++	if(arg->i > 0) /* left circular shift */
+++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++
+++	else /* right circular shift */
+++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++
+++	view(&shifted);
+++}
+++
+++void
+++shifttag(const Arg *arg) {
+++	Arg shifted;
+++	Client *c;
+++
+++	if (!selmon->sel)
+++		return;
+++	c = selmon->sel;
+++
+++	if (arg->i > 0) /* left circular shift */
+++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++			^ (c->tags >> (LENGTH(tags) - arg->i));
+++	else /* right circular shift */
+++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++			^ (c->tags << (LENGTH(tags) + arg->i));
+++
+++	toggletag(&shifted);
+++}
+++
+++void
+++setcfact(const Arg *arg) {
+++	float f;
+++	Client *c;
+++
+++	c = selmon->sel;
+++
+++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+++		return;
+++	f = arg->f + c->cfact;
+++	if(arg->f == 0.0)
+++		f = 1.0;
+++	else if(f < 0.25 || f > 4.0)
+++		return;
+++	c->cfact = f;
+++	arrange(selmon);
+++}
+++
++ /* arg > 1.0 will set mfact absolutely */
++ void
++ setmfact(const Arg *arg)
++@@ -1935,9 +2012,6 @@ setup(void)
++ 	/* clean up any zombies (inherited from .xinitrc etc) immediately */
++ 	while (waitpid(-1, NULL, WNOHANG) > 0);
++ 
++-    signal(SIGHUP, sighup);
++-    signal(SIGTERM, sigterm);
++-
++ 	/* init screen */
++ 	screen = DefaultScreen(dpy);
++ 	sw = DisplayWidth(dpy, screen);
++@@ -1961,6 +2035,7 @@ setup(void)
++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++@@ -1969,10 +2044,8 @@ setup(void)
++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++ 	/* init appearance */
++-    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
++ 	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++ 	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++-
++ 	for (i = 0; i < LENGTH(colors); i++)
++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
++ 	/* init bars */
++@@ -2021,8 +2094,8 @@ showhide(Client *c)
++ 		return;
++ 	if (ISVISIBLE(c)) {
++ 		if ((c->tags & SPTAGMASK) && c->isfloating) {
++-            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
++-            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++ 		}
++ 		/* show clients top down */
++ 		XMoveWindow(dpy, c->win, c->x, c->y);
++@@ -2037,41 +2110,26 @@ showhide(Client *c)
++ }
++ 
++ void
++-sighup(int unused)
++-{
++-    Arg a = {.i = 1};
++-    quit(&a);
++-}
++-
++-void
++-sigterm(int unused)
++-{
++-    Arg a = {.i = 0};
++-    quit(&a);
++-}
++-
++-#ifndef __OpenBSD__
++-void sigdwmblocks(const Arg *arg)
+++sigstatusbar(const Arg *arg)
++ {
++ 	union sigval sv;
++-    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
++-    if (!dwmblockspid)
++-        if (getdwmblockspid() == -1)
+++
+++	if (!statussig)
+++		return;
+++	sv.sival_int = arg->i;
+++	if ((statuspid = getstatusbarpid()) <= 0)
++ 		return;
++ 
++-    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
++-        if (errno == ESRCH) {
++-            if (!getdwmblockspid())
++-                sigqueue(dwmblockspid, SIGUSR1, sv);
+++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++ }
++-    }
++-}
++-#endif
++ 
++ void
++ spawn(const Arg *arg)
++ {
++ 	struct sigaction sa;
+++
+++	if (arg->v == dmenucmd)
+++		dmenumon[0] = '0' + selmon->num;
++ 	if (fork() == 0) {
++ 		if (dpy)
++ 			close(ConnectionNumber(dpy));
++@@ -2087,6 +2145,36 @@ spawn(const Arg *arg)
++ 	}
++ }
++ 
+++int
+++stackpos(const Arg *arg) {
+++	int n, i;
+++	Client *c, *l;
+++
+++	if(!selmon->clients)
+++		return -1;
+++
+++	if(arg->i == PREVSEL) {
+++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+++		if(!l)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return i;
+++	}
+++	else if(ISINC(arg->i)) {
+++		if(!selmon->sel)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MOD(i + GETINC(arg->i), n);
+++	}
+++	else if(arg->i < 0) {
+++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MAX(i + arg->i, 0);
+++	}
+++	else
+++		return arg->i;
+++}
+++
++ void
++ tag(const Arg *arg)
++ {
++@@ -2141,13 +2229,11 @@ togglefloating(const Arg *arg)
++ 	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++ 		return;
++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++-    if (selmon->sel->isfloating) {
++-        /* selmon->sel->bw = 0; */
++-        /* configure(selmon->sel); */
+++	if (selmon->sel->isfloating)
++ 		/* restore last known float dimensions */
++ 		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++ 		       selmon->sel->sfw, selmon->sel->sfh, False);
++-    } else {
+++	else {
++ 		/* save last known float dimensions */
++ 		selmon->sel->sfx = selmon->sel->x;
++ 		selmon->sel->sfy = selmon->sel->y;
++@@ -2169,7 +2255,7 @@ togglesticky(const Arg *arg)
++ {
++ 	if (!selmon->sel)
++ 		return;
++-    selmon->sel->issticky = !selmon->sel->issticky;
+++	setsticky(selmon->sel, !selmon->sel->issticky);
++ 	arrange(selmon);
++ }
++ 
++@@ -2366,8 +2452,9 @@ updategeom(void)
++ 				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++ 		XFree(info);
++ 		nn = j;
++-        if (n <= nn) { /* new monitors available */
++-            for (i = 0; i < (nn - n); i++) {
+++
+++		/* new monitors if nn > n */
+++		for (i = n; i < nn; i++) {
++ 			for (m = mons; m && m->next; m = m->next);
++ 			if (m)
++ 				m->next = createmon();
++@@ -2387,7 +2474,7 @@ updategeom(void)
++ 				m->mh = m->wh = unique[i].height;
++ 				updatebarpos(m);
++ 			}
++-        } else { /* less monitors available nn < n */
+++		/* removed monitors if n > nn */
++ 		for (i = nn; i < n; i++) {
++ 			for (m = mons; m && m->next; m = m->next);
++ 			while ((c = m->clients)) {
++@@ -2402,7 +2489,6 @@ updategeom(void)
++ 				selmon = mons;
++ 			cleanupmon(m);
++ 		}
++-        }
++ 		free(unique);
++ 	} else
++ #endif /* XINERAMA */
++@@ -2486,14 +2572,9 @@ updatesizehints(Client *c)
++ void
++ updatestatus(void)
++ {
++-    Monitor* m;
++-    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
+++	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
++ 		strcpy(stext, "dwm-"VERSION);
++-    else
++-        copyvalidchars(stext, rawstext);
++-    /* drawbar(selmon); */
++-    for(m = mons; m; m = m->next)
++-        drawbar(m);
+++	drawbar(selmon);
++ }
++ 
++ void
++@@ -2513,6 +2594,9 @@ updatewindowtype(Client *c)
++ 
++ 	if (state == netatom[NetWMFullscreen])
++ 		setfullscreen(c, 1);
+++	if (state == netatom[NetWMSticky]) {
+++		setsticky(c, 1);
+++	}
++ 	if (wtype == netatom[NetWMWindowTypeDialog])
++ 		c->isfloating = 1;
++ }
++@@ -2554,8 +2638,10 @@ view(const Arg *arg)
++ pid_t
++ winpid(Window w)
++ {
+++
++ 	pid_t result = 0;
++ 
+++#ifdef __linux__
++ 	xcb_res_client_id_spec_t spec = {0};
++ 	spec.client = w;
++ 	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++@@ -2581,6 +2667,24 @@ winpid(Window w)
++ 
++ 	if (result == (pid_t)-1)
++ 		result = 0;
+++
+++#endif /* __linux__ */
+++
+++#ifdef __OpenBSD__
+++        Atom type;
+++        int format;
+++        unsigned long len, bytes;
+++        unsigned char *prop;
+++        pid_t ret;
+++
+++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+++               return 0;
+++
+++        ret = *(pid_t*)prop;
+++        XFree(prop);
+++        result = ret;
+++
+++#endif /* __OpenBSD__ */
++ 	return result;
++ }
++ 
++@@ -2589,25 +2693,31 @@ getparentprocess(pid_t p)
++ {
++ 	unsigned int v = 0;
++ 
++-#if defined(__linux__)
+++#ifdef __linux__
++ 	FILE *f;
++ 	char buf[256];
++ 	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++ 
++ 	if (!(f = fopen(buf, "r")))
++-        return (pid_t)0;
+++		return 0;
++ 
++-    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
++-        v = (pid_t)0;
+++	fscanf(f, "%*u %*s %*c %u", &v);
++ 	fclose(f);
++-#elif defined(__FreeBSD__)
++-    struct kinfo_proc *proc = kinfo_getproc(p);
++-    if (!proc)
++-        return (pid_t)0;
+++#endif /* __linux__*/
+++
+++#ifdef __OpenBSD__
+++	int n;
+++	kvm_t *kd;
+++	struct kinfo_proc *kp;
+++
+++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+++	if (!kd)
+++		return 0;
+++
+++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+++	v = kp->p_ppid;
+++#endif /* __OpenBSD__ */
++ 
++-    v = proc->ki_ppid;
++-    free(proc);
++-#endif
++ 	return (pid_t)v;
++ }
++ 
++@@ -2726,11 +2836,9 @@ zoom(const Arg *arg)
++ {
++ 	Client *c = selmon->sel;
++ 
++-    if (!selmon->lt[selmon->sellt]->arrange
++-            || (selmon->sel && selmon->sel->isfloating))
+++	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
++ 		return;
++-    if (c == nexttiled(selmon->clients))
++-        if (!c || !(c = nexttiled(c->next)))
+++	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
++ 		return;
++ 	pop(c);
++ }
++@@ -2807,17 +2915,15 @@ main(int argc, char *argv[])
++ 	load_xresources();
++ 	setup();
++ #ifdef __OpenBSD__
++-    if (pledge("stdio rpath proc exec", NULL) == -1)
+++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
++-    runAutostart();
++-    /* runautostart(); */
++-    enablegaps = 1;
+++	runautostart();
++     arrange(selmon);
++ 	run();
++-    if(restart) execvp(argv[0], argv);
++ 	cleanup();
++ 	XCloseDisplay(dpy);
++ 	return EXIT_SUCCESS;
++ }
+++
++diff --git a/dwm.png b/dwm.png
++new file mode 100644
++index 0000000..b1f9ba7
++Binary files /dev/null and b/dwm.png differ
++diff --git a/shiftview.c b/shiftview.c
++deleted file mode 100644
++index 7905a6d..0000000
++--- a/shiftview.c
+++++ /dev/null
++@@ -1,64 +0,0 @@
++-/** Function to shift the current view to the left/right
++- *
++- * @param: "arg->i" stores the number of tags to shift right (positive value)
++- *          or left (negative value)
++- */
++-void
++-shiftview(const Arg *arg)
++-{
++-    Arg shifted;
++-    Client *c;
++-    unsigned int tagmask = 0;
++-
++-    for (c = selmon->clients; c; c = c->next)
++-        if (!(c->tags & SPTAGMASK))
++-            tagmask = tagmask | c->tags;
++-
++-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++-    if (arg->i > 0) /* left circular shift */
++-        do {
++-            shifted.ui = (shifted.ui << arg->i)
++-                | (shifted.ui >> (LENGTH(tags) - arg->i));
++-            shifted.ui &= ~SPTAGMASK;
++-        } while (tagmask && !(shifted.ui & tagmask));
++-    else /* right circular shift */
++-        do {
++-            shifted.ui = (shifted.ui >> (- arg->i)
++-                    | shifted.ui << (LENGTH(tags) + arg->i));
++-            shifted.ui &= ~SPTAGMASK;
++-        } while (tagmask && !(shifted.ui & tagmask));
++-
++-    view(&shifted);
++-}
++-
++-void
++-shifttag(const Arg *arg)
++-{
++-    Arg a;
++-    Client *c;
++-    unsigned visible = 0;
++-    int i = arg->i;
++-    int count = 0;
++-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
++-
++-    do {
++-        if(i > 0) // left circular shift
++-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
++-
++-        else // right circular shift
++-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
++-
++-        // Check if tag is visible
++-        for (c = selmon->clients; c && !visible; c = c->next)
++-            if (nextseltags & c->tags) {
++-                visible = 1;
++-                break;
++-            }
++-        i += arg->i;
++-    } while (!visible && ++count < 10);
++-
++-    if (count < 10) {
++-        a.i = nextseltags;
++-        tag(&a);
++-    }
++-}
++diff --git a/test.c b/test.c
++deleted file mode 100644
++index 50e4cba..0000000
++--- a/test.c
+++++ /dev/null
++@@ -1,37 +0,0 @@
++-#include <stdio.h>
++-#include <string.h>
++-
++-int
++-main()
++-{
++-    char s[1000];
++-    int i, alphabets=0, digits=0, specialchars=0;
++-    /* printf("Enter string"); */
++-    /* gets(s); */
++-
++-    FILE *ptr;
++-    char ch;
++-    ptr = fopen("/home/jonas/test.txt", "r");
++-    if (ptr == NULL) printf("Fail...");
++-    do{
++-        ch = fgetc(ptr);
++-        /* printf("%c", ch); */
++-        /* printf("%c %d \n", ch, ch); */
++-        printf("%d\n", ch);
++-        /* printf("%d", ch); */
++-    } while (ch != EOF);
++-    fclose(ptr);
++-
++-    /* for(int i = 0;s[i]; i++){ */
++-    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
++-    /*         alphabets++; */
++-    /*     else if (s[i]>48 && s[i] <=57) digits++; */
++-    /*     else specialchars++; */
++-
++-    /* } */
++-    /* printf("Alphas = %d}n", alphabets); */
++-    /* printf("Digits = %d\n", digits); */
++-    /* printf("Spec chars = %d", specialchars); */
++-
++-    return 0;
++-}
++diff --git a/util.c b/util.c
++index c8b1dcd..8e26a51 100644
++--- a/util.c
+++++ b/util.c
++@@ -7,17 +7,9 @@
++ 
++ #include "util.h"
++ 
++-void *
++-ecalloc(size_t nmemb, size_t size)
+++void
+++die(const char *fmt, ...)
++ {
++-    void *p;
++-
++-    if (!(p = calloc(nmemb, size)))
++-        die("calloc:");
++-    return p;
++-}
++-
++-void die(const char *fmt, ...) {
++ 	va_list ap;
++ 	int saved_errno;
++ 
++@@ -33,3 +25,13 @@ void die(const char *fmt, ...) {
++ 
++ 	exit(1);
++ }
+++
+++void *
+++ecalloc(size_t nmemb, size_t size)
+++{
+++	void *p;
+++
+++	if (!(p = calloc(nmemb, size)))
+++		die("calloc:");
+++	return p;
+++}
++diff --git a/vanitygaps.c b/vanitygaps.c
++index 7b64fd2..5acce38 100644
++--- a/vanitygaps.c
+++++ b/vanitygaps.c
++@@ -1,33 +1,37 @@
++ /* Key binding functions */
++ static void defaultgaps(const Arg *arg);
++ static void incrgaps(const Arg *arg);
++-/* static void incrigaps(const Arg *arg); */
++-/* static void incrogaps(const Arg *arg); */
++-/* static void incrohgaps(const Arg *arg); */
++-/* static void incrovgaps(const Arg *arg); */
++-/* static void incrihgaps(const Arg *arg); */
++-/* static void incrivgaps(const Arg *arg); */
+++static void incrigaps(const Arg *arg);
+++static void incrogaps(const Arg *arg);
+++static void incrohgaps(const Arg *arg);
+++static void incrovgaps(const Arg *arg);
+++static void incrihgaps(const Arg *arg);
+++static void incrivgaps(const Arg *arg);
++ static void togglegaps(const Arg *arg);
++ static void togglebgaps(const Arg *arg);
++-
++-/* Layouts */
+++/* Layouts (delete the ones you do not need) */
++ static void bstack(Monitor *m);
+++static void bstackhoriz(Monitor *m);
++ static void centeredmaster(Monitor *m);
++ static void centeredfloatingmaster(Monitor *m);
++ static void deck(Monitor *m);
++ static void dwindle(Monitor *m);
++ static void fibonacci(Monitor *m, int s);
+++static void grid(Monitor *m);
+++static void nrowgrid(Monitor *m);
++ static void spiral(Monitor *m);
++ static void tile(Monitor *m);
++-
++ /* Internals */
++ static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++ static void setgaps(int oh, int ov, int ih, int iv);
++ 
++ /* Settings */
+++#if !PERTAG_PATCH
++ static int enablegaps = 1;
+++#endif // PERTAG_PATCH
++ 
++-static void
+++void
++ setgaps(int oh, int ov, int ih, int iv)
++ {
++ 	if (oh < 0) oh = 0;
++@@ -42,12 +46,15 @@ setgaps(int oh, int ov, int ih, int iv)
++ 	arrange(selmon);
++ }
++ 
++-static void
+++void
++ togglegaps(const Arg *arg)
++ {
+++	#if PERTAG_PATCH
+++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
++ 	enablegaps = !enablegaps;
++-    /* arrange(NULL); */
++-    arrange(selmon);
+++	#endif // PERTAG_PATCH
+++	arrange(NULL);
++ }
++ 
++ static void
++@@ -57,13 +64,13 @@ togglebgaps(const Arg *arg)
++     arrange(NULL);
++ }
++ 
++-static void
+++void
++ defaultgaps(const Arg *arg)
++ {
++ 	setgaps(gappoh, gappov, gappih, gappiv);
++ }
++ 
++-static void
+++void
++ incrgaps(const Arg *arg)
++ {
++ 	setgaps(
++@@ -74,88 +81,94 @@ incrgaps(const Arg *arg)
++ 	);
++ }
++ 
++-/* static void */
++-/* incrigaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh, */
++-/* 		selmon->gappov, */
++-/* 		selmon->gappih + arg->i, */
++-/* 		selmon->gappiv + arg->i */
++-/* 	); */
++-/* } */
++-
++-/* static void */
++-/* incrogaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh + arg->i, */
++-/* 		selmon->gappov + arg->i, */
++-/* 		selmon->gappih, */
++-/* 		selmon->gappiv */
++-/* 	); */
++-/* } */
++-
++-/* static void */
++-/* incrohgaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh + arg->i, */
++-/* 		selmon->gappov, */
++-/* 		selmon->gappih, */
++-/* 		selmon->gappiv */
++-/* 	); */
++-/* } */
++-
++-/* static void */
++-/* incrovgaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh, */
++-/* 		selmon->gappov + arg->i, */
++-/* 		selmon->gappih, */
++-/* 		selmon->gappiv */
++-/* 	); */
++-/* } */
++-
++-/* static void */
++-/* incrihgaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh, */
++-/* 		selmon->gappov, */
++-/* 		selmon->gappih + arg->i, */
++-/* 		selmon->gappiv */
++-/* 	); */
++-/* } */
++-
++-/* static void */
++-/* incrivgaps(const Arg *arg) */
++-/* { */
++-/* 	setgaps( */
++-/* 		selmon->gappoh, */
++-/* 		selmon->gappov, */
++-/* 		selmon->gappih, */
++-/* 		selmon->gappiv + arg->i */
++-/* 	); */
++-/* } */
+++void
+++incrigaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrogaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
++ 
++-static void
+++void
+++incrohgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrovgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrihgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrivgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
++ getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++ {
++ 	unsigned int n, oe, ie;
+++	#if PERTAG_PATCH
+++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
++ 	oe = ie = enablegaps;
+++	#endif // PERTAG_PATCH
++ 	Client *c;
++ 
++ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-    /* if (smartgaps && n == 1) { */
++-    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
++-        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+++	if (smartgaps && n == 1) {
+++		oe = 0; // outer gaps disabled when only one client
++ 	}
++ 
+++    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+++        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
++         if (TAGMASK == (1 << 8)){
++             setgaps(gappoh, gappov, gappih, gappiv);
++         }
+++    }
++ 
++ 	*oh = m->gappoh*oe; // outer horizontal gap
++ 	*ov = m->gappov*oe; // outer vertical gap
++@@ -168,24 +181,26 @@ void
++ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++ {
++ 	unsigned int n;
++-    float mfacts, sfacts;
+++	float mfacts = 0, sfacts = 0;
++ 	int mtotal = 0, stotal = 0;
++ 	Client *c;
++ 
++-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-    mfacts = MIN(n, m->nmaster);
++-    sfacts = n - m->nmaster;
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
++ 
++ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++ 		if (n < m->nmaster)
++-            mtotal += msize / mfacts;
+++			mtotal += msize * (c->cfact / mfacts);
++ 		else
++-            stotal += ssize / sfacts;
+++			stotal += ssize * (c->cfact / sfacts);
++ 
++ 	*mf = mfacts; // total factor of master area
++ 	*sf = sfacts; // total factor of stack area
++-    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
++-    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
+++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++ }
++ 
++ /***
++@@ -196,20 +211,18 @@ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *s
++  * Bottomstack layout + gaps
++  * https://dwm.suckless.org/patches/bottomstack/
++  */
++-
++ static void
++ bstack(Monitor *m)
++ {
++ 	unsigned int i, n;
+++	int oh, ov, ih, iv;
++ 	int mx = 0, my = 0, mh = 0, mw = 0;
++ 	int sx = 0, sy = 0, sh = 0, sw = 0;
++ 	float mfacts, sfacts;
++ 	int mrest, srest;
++ 	Client *c;
++ 
++-    int oh, ov, ih, iv;
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++@@ -221,7 +234,7 @@ bstack(Monitor *m)
++ 
++ 	if (m->nmaster && n > m->nmaster) {
++ 		sh = (mh - ih) * (1 - m->mfact);
++-        mh = (mh - ih) * m->mfact;
+++		mh = mh - ih - sh;
++ 		sx = mx;
++ 		sy = my + mh + ih;
++ 	}
++@@ -230,24 +243,66 @@ bstack(Monitor *m)
++ 
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++ 		if (i < m->nmaster) {
++-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++ 			mx += WIDTH(c) + iv;
++ 		} else {
++-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++ 			sx += WIDTH(c) + iv;
++ 		}
++ 	}
++ }
++ 
+++static void
+++bstackhoriz(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh;
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+++	}
+++
+++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++	}
+++}
+++
++ /*
++  * Centred master layout + gaps
++  * https://dwm.suckless.org/patches/centeredmaster/
++  */
++-
++ void
++ centeredmaster(Monitor *m)
++ {
++ 	unsigned int i, n;
+++	int oh, ov, ih, iv;
++ 	int mx = 0, my = 0, mh = 0, mw = 0;
++ 	int lx = 0, ly = 0, lw = 0, lh = 0;
++ 	int rx = 0, ry = 0, rw = 0, rh = 0;
++@@ -256,9 +311,7 @@ centeredmaster(Monitor *m)
++ 	int mrest = 0, lrest = 0, rrest = 0;
++ 	Client *c;
++ 
++-    int oh, ov, ih, iv;
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++@@ -276,13 +329,14 @@ centeredmaster(Monitor *m)
++ 			/* ||<-S->|<---M--->|<-S->|| */
++ 			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++ 			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++ 			mx += lw + iv;
++ 		} else {
++ 			/* ||<---M--->|<-S->|| */
++ 			mw = (mw - iv) * m->mfact;
++-            lw = m->ww - mw - iv - 2*ov;
+++			lw = 0;
+++			rw = m->ww - mw - iv - 2*ov;
++ 		}
++-        rw = lw;
++ 		lx = m->wx + ov;
++ 		ly = m->wy + oh;
++ 		rx = mx + mw + iv;
++@@ -292,20 +346,20 @@ centeredmaster(Monitor *m)
++ 	/* calculate facts */
++ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++ 		if (!m->nmaster || n < m->nmaster)
++-            mfacts += 1;
+++			mfacts += c->cfact;
++ 		else if ((n - m->nmaster) % 2)
++-            lfacts += 1; // total factor of left hand stack area
+++			lfacts += c->cfact; // total factor of left hand stack area
++ 		else
++-            rfacts += 1; // total factor of right hand stack area
+++			rfacts += c->cfact; // total factor of right hand stack area
++ 	}
++ 
++ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++ 		if (!m->nmaster || n < m->nmaster)
++-            mtotal += mh / mfacts;
+++			mtotal += mh * (c->cfact / mfacts);
++ 		else if ((n - m->nmaster) % 2)
++-            ltotal += lh / lfacts;
+++			ltotal += lh * (c->cfact / lfacts);
++ 		else
++-            rtotal += rh / rfacts;
+++			rtotal += rh * (c->cfact / rfacts);
++ 
++ 	mrest = mh - mtotal;
++ 	lrest = lh - ltotal;
++@@ -314,15 +368,15 @@ centeredmaster(Monitor *m)
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++ 		if (!m->nmaster || i < m->nmaster) {
++ 			/* nmaster clients are stacked vertically, in the center of the screen */
++-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++ 			my += HEIGHT(c) + ih;
++ 		} else {
++ 			/* stack clients are stacked vertically */
++ 			if ((i - m->nmaster) % 2 ) {
++-                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++ 				ly += HEIGHT(c) + ih;
++ 			} else {
++-                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++ 				ry += HEIGHT(c) + ih;
++ 			}
++ 		}
++@@ -334,15 +388,13 @@ centeredfloatingmaster(Monitor *m)
++ {
++ 	unsigned int i, n;
++ 	float mfacts, sfacts;
++-    int mrest, srest;
+++	float mivf = 1.0; // master inner vertical gap factor
+++	int oh, ov, ih, iv, mrest, srest;
++ 	int mx = 0, my = 0, mh = 0, mw = 0;
++ 	int sx = 0, sy = 0, sh = 0, sw = 0;
++ 	Client *c;
++ 
++-    float mivf = 1.0; // master inner vertical gap factor
++-    int oh, ov, ih, iv;
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++@@ -357,13 +409,13 @@ centeredfloatingmaster(Monitor *m)
++ 		/* go mfact box in the center if more than nmaster clients */
++ 		if (m->ww > m->wh) {
++ 			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++-            mh = m->wh * 0.9 - 2*oh;
+++			mh = m->wh * 0.9;
++ 		} else {
++ 			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++ 			mh = m->wh * m->mfact;
++ 		}
++ 		mx = m->wx + (m->ww - mw) / 2;
++-        my = m->wy + (m->wh - mh) / 2;
+++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++ 
++ 		sx = m->wx + ov;
++ 		sy = m->wy + oh;
++@@ -375,11 +427,11 @@ centeredfloatingmaster(Monitor *m)
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++ 		if (i < m->nmaster) {
++ 			/* nmaster clients are stacked horizontally, in the center of the screen */
++-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++ 			mx += WIDTH(c) + iv*mivf;
++ 		} else {
++ 			/* stack clients are stacked horizontally */
++-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++ 			sx += WIDTH(c) + iv;
++ 		}
++ }
++@@ -388,20 +440,18 @@ centeredfloatingmaster(Monitor *m)
++  * Deck layout + gaps
++  * https://dwm.suckless.org/patches/deck/
++  */
++-
++-static void
+++void
++ deck(Monitor *m)
++ {
++ 	unsigned int i, n;
+++	int oh, ov, ih, iv;
++ 	int mx = 0, my = 0, mh = 0, mw = 0;
++ 	int sx = 0, sy = 0, sh = 0, sw = 0;
++ 	float mfacts, sfacts;
++ 	int mrest, srest;
++ 	Client *c;
++ 
++-    int oh, ov, ih, iv;
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++@@ -412,7 +462,7 @@ deck(Monitor *m)
++ 
++ 	if (m->nmaster && n > m->nmaster) {
++ 		sw = (mw - iv) * (1 - m->mfact);
++-        mw = (mw - iv) * m->mfact;
+++		mw = mw - iv - sw;
++ 		sx = mx + mw + iv;
++ 		sh = m->wh - 2*oh;
++ 	}
++@@ -424,7 +474,7 @@ deck(Monitor *m)
++ 
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++ 		if (i < m->nmaster) {
++-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++ 			my += HEIGHT(c) + ih;
++ 		} else {
++ 			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++@@ -435,58 +485,82 @@ deck(Monitor *m)
++  * Fibonacci layout + gaps
++  * https://dwm.suckless.org/patches/fibonacci/
++  */
++-
++-static void
+++void
++ fibonacci(Monitor *m, int s)
++ {
++ 	unsigned int i, n;
++ 	int nx, ny, nw, nh;
++ 	int oh, ov, ih, iv;
+++	int nv, hrest = 0, wrest = 0, r = 1;
++ 	Client *c;
++ 
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++ 	nx = m->wx + ov;
++-    ny = oh;
+++	ny = m->wy + oh;
++ 	nw = m->ww - 2*ov;
++ 	nh = m->wh - 2*oh;
++ 
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++-        if ((i % 2 && nh / 2 > 2*c->bw)
++-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
++-            if (i < n - 1) {
++-                if (i % 2)
++-                    nh = (nh - ih) / 2;
++-                else
++-                    nw = (nw - iv) / 2;
+++		if (r) {
+++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+++				r = 0;
+++			}
+++			if (r && i < n - 1) {
+++				if (i % 2) {
+++					nv = (nh - ih) / 2;
+++					hrest = nh - 2*nv - ih;
+++					nh = nv;
+++				} else {
+++					nv = (nw - iv) / 2;
+++					wrest = nw - 2*nv - iv;
+++					nw = nv;
+++				}
++ 
++ 				if ((i % 4) == 2 && !s)
++ 					nx += nw + iv;
++ 				else if ((i % 4) == 3 && !s)
++ 					ny += nh + ih;
++ 			}
+++
++ 			if ((i % 4) == 0) {
++-                if (s)
+++				if (s) {
++ 					ny += nh + ih;
++-                else
+++					nh += hrest;
+++				}
+++				else {
+++					nh -= hrest;
++ 					ny -= nh + ih;
++ 				}
++-            else if ((i % 4) == 1)
+++			}
+++			else if ((i % 4) == 1) {
++ 				nx += nw + iv;
++-            else if ((i % 4) == 2)
+++				nw += wrest;
+++			}
+++			else if ((i % 4) == 2) {
++ 				ny += nh + ih;
+++				nh += hrest;
+++				if (i < n - 1)
+++					nw += wrest;
+++			}
++ 			else if ((i % 4) == 3) {
++-                if (s)
+++				if (s) {
++ 					nx += nw + iv;
++-                else
+++					nw -= wrest;
+++				} else {
+++					nw -= wrest;
++ 					nx -= nw + iv;
+++					nh += hrest;
+++				}
++ 			}
++ 			if (i == 0)	{
++-                if (n != 1)
++-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+++				if (n != 1) {
+++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+++					wrest = 0;
+++				}
++ 				ny = m->wy + oh;
++ 			}
++ 			else if (i == 1)
++@@ -498,35 +572,243 @@ fibonacci(Monitor *m, int s)
++ 	}
++ }
++ 
++-static void
+++void
++ dwindle(Monitor *m)
++ {
++ 	fibonacci(m, 1);
++ }
++ 
++-static void
+++void
++ spiral(Monitor *m)
++ {
++ 	fibonacci(m, 0);
++ }
++ 
++ /*
++- * Default tile layout + gaps
+++ * Gappless grid layout + gaps (ironically)
+++ * https://dwm.suckless.org/patches/gaplessgrid/
+++ */
+++void
+++gaplessgrid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* grid dimensions */
+++	for (cols = 0; cols <= n/2; cols++)
+++		if (cols*cols >= n)
+++			break;
+++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+++		cols = 2;
+++	rows = n/cols;
+++	cn = rn = 0; // reset column no, row no, client count
+++
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	x = m->wx + ov;
+++	y = m->wy + oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+++		if (i/rows + 1 > cols - n%cols) {
+++			rows = n/cols + 1;
+++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++		}
+++		resize(c,
+++			x,
+++			y + rn*(ch + ih) + MIN(rn, rrest),
+++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+++			0);
+++		rn++;
+++		if (rn >= rows) {
+++			rn = 0;
+++			x += cw + ih + (cn < crest ? 1 : 0);
+++			cn++;
+++		}
+++	}
+++}
+++
+++/*
+++ * Gridmode layout + gaps
+++ * https://dwm.suckless.org/patches/gridmode/
+++ */
+++void
+++grid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* grid dimensions */
+++	for (rows = 0; rows <= n/2; rows++)
+++		if (rows*rows >= n)
+++			break;
+++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+++
+++	/* window geoms (cell height/width) */
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		cc = i / rows;
+++		cr = i % rows;
+++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+++	}
+++}
+++
+++/*
+++ * Horizontal grid layout + gaps
+++ * https://dwm.suckless.org/patches/horizgrid/
+++ */
+++void
+++horizgrid(Monitor *m) {
+++	Client *c;
+++	unsigned int n, i;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	int ntop, nbottom = 1;
+++	float mfacts = 0, sfacts = 0;
+++	int mrest, srest, mtotal = 0, stotal = 0;
+++
+++	/* Count windows */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	if (n <= 2)
+++		ntop = n;
+++	else {
+++		ntop = n / 2;
+++		nbottom = n - ntop;
+++	}
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (n > ntop) {
+++		sh = (mh - ih) / 2;
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		mw = m->ww - 2*ov - iv * (ntop - 1);
+++		sw = m->ww - 2*ov - iv * (nbottom - 1);
+++	}
+++
+++	/* calculate facts */
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else
+++			stotal += sw * (c->cfact / sfacts);
+++
+++	mrest = mh - mtotal;
+++	srest = sw - stotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * nrowgrid layout + gaps
+++ * https://dwm.suckless.org/patches/nrowgrid/
++  */
+++void
+++nrowgrid(Monitor *m)
+++{
+++	unsigned int n;
+++	int ri = 0, ci = 0;  /* counters */
+++	int oh, ov, ih, iv;                         /* vanitygap settings */
+++	unsigned int cx, cy, cw, ch;                /* client geometry */
+++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+++	unsigned int cols, rows = m->nmaster + 1;
+++	Client *c;
+++
+++	/* count clients */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* nothing to do here */
+++	if (n == 0)
+++		return;
+++
+++	/* force 2 clients to always split vertically */
+++	if (FORCE_VSPLIT && n == 2)
+++		rows = 1;
+++
+++	/* never allow empty rows */
+++	if (n < rows)
+++		rows = n;
+++
+++	/* define first row */
+++	cols = n / rows;
+++	uc = cols;
+++	cy = m->wy + oh;
+++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+++	uh = ch;
++ 
+++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+++		if (ci == cols) {
+++			uw = 0;
+++			ci = 0;
+++			ri++;
+++
+++			/* next row */
+++			cols = (n - uc) / (rows - ri);
+++			uc += cols;
+++			cy = m->wy + oh + uh + ih;
+++			uh += ch + ih;
+++		}
+++
+++		cx = m->wx + ov + uw;
+++		cw = (m->ww - 2*ov - uw) / (cols - ci);
+++		uw += cw + iv;
+++
+++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+++	}
+++}
+++
+++/*
+++ * Default tile layout + gaps
+++ */
++ static void
++ tile(Monitor *m)
++ {
++ 	unsigned int i, n;
+++	int oh, ov, ih, iv;
++ 	int mx = 0, my = 0, mh = 0, mw = 0;
++ 	int sx = 0, sy = 0, sh = 0, sw = 0;
++ 	float mfacts, sfacts;
++ 	int mrest, srest;
++ 	Client *c;
++ 
++-    int oh, ov, ih, iv;
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++@@ -538,7 +820,7 @@ tile(Monitor *m)
++ 
++ 	if (m->nmaster && n > m->nmaster) {
++ 		sw = (mw - iv) * (1 - m->mfact);
++-        mw = (mw - iv) * m->mfact;
+++		mw = mw - iv - sw;
++ 		sx = mx + mw + iv;
++ 	}
++ 
++@@ -546,10 +828,10 @@ tile(Monitor *m)
++ 
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++ 		if (i < m->nmaster) {
++-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++ 			my += HEIGHT(c) + ih;
++ 		} else {
++-            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++ 			sy += HEIGHT(c) + ih;
++ 		}
++ }
+diff --git a/diff_new.diff b/diff_new.diff
+new file mode 100644
+index 0000000..8c8649f
+--- /dev/null
++++ b/diff_new.diff
+@@ -0,0 +1,664 @@
++diff --git a/README b/README
++index 482b545..95d4fd0 100644
++--- a/README
+++++ b/README
++@@ -1,13 +1,5 @@
++-See patches in dir 'patches'.
++-
++-I also continously add fixes from suckless git log:
++-https://git.suckless.org/
++-https://dwm.suckless.org/
++-
++-============================
++ dwm - dynamic window manager
++ ============================
++-
++ dwm is an extremely fast, small, and dynamic window manager for X.
++ 
++ 
++diff --git a/config.h b/config.h
++index 3d14213..ec7de9e 100644
++--- a/config.h
+++++ b/config.h
++@@ -28,6 +28,7 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
++ static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
++ static int showbar              = 1;        /* 0 means no bar */
++ static int topbar               = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
++ /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
++ /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
++ static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
++@@ -163,7 +164,6 @@ ResourcePref resources[] = {
++ };
++ 
++ #include <X11/XF86keysym.h>
++-#include "shiftview.c"
++ 
++ static const Key keys[] = {
++     /*  modifier                    key                 function            argument */
++diff --git a/dwm.c b/dwm.c
++index 1ce4a38..6232799 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -62,8 +62,8 @@
++ #define ISINC(X)                ((X) > 1000 && (X) < 3000)
++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++ #define PREVSEL                 3000
++-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+++#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++ #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++@@ -248,6 +248,8 @@ static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
+++static void shiftview(const Arg *arg);
+++static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
++ static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
++@@ -545,9 +547,8 @@ buttonpress(XEvent *e)
++ 
++ 	click = ClkRootWin;
++ 	/* focus monitor if necessary */
++-	//if ((m = wintomon(ev->window)) && m != selmon
++-	//    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++-    if ((m = wintomon(ev->window)) && m != selmon) {
+++	if ((m = wintomon(ev->window)) && m != selmon
+++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++ 		unfocus(selmon->sel, 1);
++ 		selmon = m;
++ 		focus(NULL);
++@@ -566,12 +567,12 @@ buttonpress(XEvent *e)
++ 		if (i < LENGTH(tags)) {
++ 			click = ClkTagBar;
++ 			arg.ui = 1 << i;
++-		} //else if (ev->x < x + TEXTW(selmon->ltsymbol))
++-			//click = ClkLtSymbol;
++-		//else
++-		else if (ev->x > selmon->ww - statusw) {
+++		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+++			click = ClkLtSymbol;
+++        } else if (ev->x > selmon->ww - statusw) {
++             x = selmon->ww - statusw;
++             click = ClkStatusText;
+++
++ 			char *text, *s, ch;
++ 			statussig = 0;
++ 			for (text = s = stext; *s && x <= ev->x; s++) {
++@@ -595,10 +596,8 @@ buttonpress(XEvent *e)
++ 					s--;
++ 				}
++ 			}
++-		}
++ 	} else if ((c = wintoclient(ev->window))) {
++-		//if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++-		//	focus(c);
+++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++ 			focus(c);
++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++ 		click = ClkClientWin;
++@@ -858,119 +857,6 @@ dirtomon(int dir)
++ 	return m;
++ }
++ 
++-//int
++-//drawstatusbar(Monitor *m, int bh, char* stext) {
++-//	int ret, i, j, w, x, len;
++-//	short isCode = 0;
++-//	char *text;
++-//	char *p;
++-//
++-//	len = strlen(stext) + 1 ;
++-//	if (!(text = (char*) malloc(sizeof(char)*len)))
++-//		die("malloc");
++-//	p = text;
++-//
++-//	i = -1, j = 0;
++-//	while (stext[++i])
++-//		if ((unsigned char)stext[i] >= ' ')
++-//			text[j++] = stext[i];
++-//	text[j] = '\0';
++-//
++-//	/* compute width of the status text */
++-//	w = 0;
++-//	i = -1;
++-//	while (text[++i]) {
++-//		if (text[i] == '^') {
++-//			if (!isCode) {
++-//				isCode = 1;
++-//				text[i] = '\0';
++-//				w += TEXTW(text) - lrpad;
++-//				text[i] = '^';
++-//				if (text[++i] == 'f')
++-//					w += atoi(text + ++i);
++-//			} else {
++-//				isCode = 0;
++-//				text = text + i + 1;
++-//				i = -1;
++-//			}
++-//		}
++-//	}
++-//	if (!isCode)
++-//		w += TEXTW(text) - lrpad;
++-//	else
++-//		isCode = 0;
++-//	text = p;
++-//
++-//	w += 2; /* 1px padding on both sides */
++-//	ret = x = m->ww - w;
++-//
++-//	drw_setscheme(drw, scheme[LENGTH(colors)]);
++-//	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++-//	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++-//	drw_rect(drw, x, 0, w, bh, 1, 1);
++-//	x++;
++-//
++-//	/* process status text */
++-//	i = -1;
++-//	while (text[++i]) {
++-//		if (text[i] == '^' && !isCode) {
++-//			isCode = 1;
++-//
++-//			text[i] = '\0';
++-//			w = TEXTW(text) - lrpad;
++-//			drw_text(drw, x, 0, w, bh, 0, text, 0);
++-//
++-//			x += w;
++-//
++-//			/* process code */
++-//			while (text[++i] != '^') {
++-//				if (text[i] == 'c') {
++-//					char buf[8];
++-//					memcpy(buf, (char*)text+i+1, 7);
++-//					buf[7] = '\0';
++-//					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++-//					i += 7;
++-//				} else if (text[i] == 'b') {
++-//					char buf[8];
++-//					memcpy(buf, (char*)text+i+1, 7);
++-//					buf[7] = '\0';
++-//					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++-//					i += 7;
++-//				} else if (text[i] == 'd') {
++-//					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++-//					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++-//				} else if (text[i] == 'r') {
++-//					int rx = atoi(text + ++i);
++-//					while (text[++i] != ',');
++-//					int ry = atoi(text + ++i);
++-//					while (text[++i] != ',');
++-//					int rw = atoi(text + ++i);
++-//					while (text[++i] != ',');
++-//					int rh = atoi(text + ++i);
++-//
++-//					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++-//				} else if (text[i] == 'f') {
++-//					x += atoi(text + ++i);
++-//				}
++-//			}
++-//
++-//			text = text + i + 1;
++-//			i=-1;
++-//			isCode = 0;
++-//		}
++-//	}
++-//
++-//	if (!isCode) {
++-//		w = TEXTW(text) - lrpad;
++-//		drw_text(drw, x, 0, w, bh, 0, text, 0);
++-//	}
++-//
++-//	drw_setscheme(drw, scheme[SchemeNorm]);
++-//	free(p);
++-//
++-//	return ret;
++-//}
++-
++ int
++ drawstatusbar(Monitor *m, int bh, char* stext)
++ {
++@@ -1093,130 +979,6 @@ drawstatusbar(Monitor *m, int bh, char* stext)
++     return ret;
++ }
++ 
++-//typedef struct {
++-//    char key;
++-//    const char *color;
++-//} ColorMapping;
++-//
++-//int is_hot_weather(const char *filepath) {
++-//    FILE *ptr = fopen(filepath, "r");
++-//    if (!ptr) {
++-//        printf("Failed to read weather report...\n");
++-//        return 0;
++-//    }
++-//
++-//    char ch;
++-//    int hot = 0;
++-//    while ((ch = fgetc(ptr)) != EOF) {
++-//        if (ch == '+') {
++-//            hot = 1;
++-//        } else if (hot && (ch == '2' || ch == '3') && fgetc(ptr) <= '9') {
++-//            fclose(ptr);
++-//            return 1; // Hot weather
++-//        } else if (ch == '-') {
++-//            fclose(ptr);
++-//            return -1; // Cold weather
++-//        }
++-//    }
++-//    fclose(ptr);
++-//    return 0; // Neutral or unknown weather
++-//}
++-//
++-//void set_color(char key, const char *weather_path, Drw *drw) {
++-//    static const ColorMapping color_map[] = {
++-//        {'3', col3}, {'4', col4}, {'5', col5}, {'6', col6}
++-//    };
++-//
++-//    if (key == '2') {
++-//        int weather_status = is_hot_weather(weather_path);
++-//        if (weather_status > 0) {
++-//            drw_clr_create(drw, &drw->scheme[ColFg], col21); // Hot
++-//        } else if (weather_status < 0) {
++-//            drw_clr_create(drw, &drw->scheme[ColFg], col23); // Cold
++-//        } else {
++-//            drw_clr_create(drw, &drw->scheme[ColFg], col24); // Neutral
++-//        }
++-//    } else {
++-//        for (size_t i = 0; i < sizeof(color_map) / sizeof(color_map[0]); i++) {
++-//            if (color_map[i].key == key) {
++-//                drw_clr_create(drw, &drw->scheme[ColFg], color_map[i].color);
++-//                return;
++-//            }
++-//        }
++-//    }
++-//}
++-//
++-//int drawstatusbar(Monitor *m, int bh, char *stext) {
++-//    int ret, i, w, x, len;
++-//    short isCode = 0;
++-//    char *text, *p;
++-//    
++-//    len = strlen(stext) + 1;
++-//    if (!(text = malloc(len))) die("malloc");
++-//    p = text;
++-//    memcpy(text, stext, len);
++-//
++-//    // Compute the width of the status text
++-//    w = 0;
++-//    for (i = 0; text[i]; i++) {
++-//        if (text[i] == '^') {
++-//            if (!isCode) {
++-//                isCode = 1;
++-//                text[i] = '\0';
++-//                w += TEXTW(text) - lrpad;
++-//                text[i] = '^';
++-//                if (text[++i] == 'f')
++-//                    w += atoi(text + ++i);
++-//            } else {
++-//                isCode = 0;
++-//                text += i + 1;
++-//                i = -1;
++-//            }
++-//        }
++-//    }
++-//    if (!isCode) w += TEXTW(text) - lrpad;
++-//
++-//    w += 2; // Padding
++-//    ret = x = m->ww - w;
++-//
++-//    drw_setscheme(drw, scheme[LENGTH(colors)]);
++-//    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++-//    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++-//    drw_rect(drw, x, 0, w, bh, 1, 1);
++-//    x++;
++-//
++-//    // Process status text
++-//    text = p;
++-//    for (i = 0; text[i]; i++) {
++-//        if (text[i] == '^' && !isCode) {
++-//            isCode = 1;
++-//
++-//            text[i] = '\0';
++-//            w = TEXTW(text) - lrpad;
++-//            drw_text(drw, x, 0, w, bh, 0, text, 0);
++-//            x += w;
++-//
++-//            while (text[++i] != '^') {
++-//                set_color(text[i], "/home/jonas/.local/share/weatherreport", drw);
++-//            }
++-//
++-//            text += i + 1;
++-//            i = -1;
++-//            isCode = 0;
++-//        }
++-//    }
++-//
++-//    if (!isCode) {
++-//        w = TEXTW(text) - lrpad;
++-//        drw_text(drw, x, 0, w, bh, 0, text, 0);
++-//    }
++-//
++-//    drw_setscheme(drw, scheme[SchemeNorm]);
++-//    free(p);
++-//
++-//    return ret;
++-//}
++-
++ void
++ drawbar(Monitor *m)
++ {
++@@ -2166,6 +1928,40 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++shiftview(const Arg *arg) {
+++	Arg shifted;
+++
+++	if(arg->i > 0) /* left circular shift */
+++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++
+++	else /* right circular shift */
+++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++
+++	view(&shifted);
+++}
+++
+++void
+++shifttag(const Arg *arg) {
+++	Arg shifted;
+++	Client *c;
+++
+++	if (!selmon->sel)
+++		return;
+++	c = selmon->sel;
+++
+++	if (arg->i > 0) /* left circular shift */
+++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++			^ (c->tags >> (LENGTH(tags) - arg->i));
+++	else /* right circular shift */
+++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++			^ (c->tags << (LENGTH(tags) + arg->i));
+++
+++	toggletag(&shifted);
+++}
+++
++ void
++ setcfact(const Arg *arg) {
++ 	float f;
++diff --git a/shiftview.c b/shiftview.c
++deleted file mode 100644
++index 7905a6d..0000000
++--- a/shiftview.c
+++++ /dev/null
++@@ -1,64 +0,0 @@
++-/** Function to shift the current view to the left/right
++- *
++- * @param: "arg->i" stores the number of tags to shift right (positive value)
++- *          or left (negative value)
++- */
++-void
++-shiftview(const Arg *arg)
++-{
++-    Arg shifted;
++-    Client *c;
++-    unsigned int tagmask = 0;
++-
++-    for (c = selmon->clients; c; c = c->next)
++-        if (!(c->tags & SPTAGMASK))
++-            tagmask = tagmask | c->tags;
++-
++-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++-    if (arg->i > 0) /* left circular shift */
++-        do {
++-            shifted.ui = (shifted.ui << arg->i)
++-                | (shifted.ui >> (LENGTH(tags) - arg->i));
++-            shifted.ui &= ~SPTAGMASK;
++-        } while (tagmask && !(shifted.ui & tagmask));
++-    else /* right circular shift */
++-        do {
++-            shifted.ui = (shifted.ui >> (- arg->i)
++-                    | shifted.ui << (LENGTH(tags) + arg->i));
++-            shifted.ui &= ~SPTAGMASK;
++-        } while (tagmask && !(shifted.ui & tagmask));
++-
++-    view(&shifted);
++-}
++-
++-void
++-shifttag(const Arg *arg)
++-{
++-    Arg a;
++-    Client *c;
++-    unsigned visible = 0;
++-    int i = arg->i;
++-    int count = 0;
++-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
++-
++-    do {
++-        if(i > 0) // left circular shift
++-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
++-
++-        else // right circular shift
++-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
++-
++-        // Check if tag is visible
++-        for (c = selmon->clients; c && !visible; c = c->next)
++-            if (nextseltags & c->tags) {
++-                visible = 1;
++-                break;
++-            }
++-        i += arg->i;
++-    } while (!visible && ++count < 10);
++-
++-    if (count < 10) {
++-        a.i = nextseltags;
++-        tag(&a);
++-    }
++-}
++diff --git a/vanitygaps.c b/vanitygaps.c
++index 6f2407d..5acce38 100644
++--- a/vanitygaps.c
+++++ b/vanitygaps.c
++@@ -162,6 +162,7 @@ getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++ 	if (smartgaps && n == 1) {
++ 		oe = 0; // outer gaps disabled when only one client
++ 	}
+++
++     if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
++         oe = 0; // outer gaps disabled when only one client (and it's Firefox)
++         if (TAGMASK == (1 << 8)){
++@@ -484,144 +485,82 @@ deck(Monitor *m)
++  * Fibonacci layout + gaps
++  * https://dwm.suckless.org/patches/fibonacci/
++  */
++-//void
++-//fibonacci(Monitor *m, int s)
++-//{
++-//	unsigned int i, n;
++-//	int nx, ny, nw, nh;
++-//	int oh, ov, ih, iv;
++-//	int nv, hrest = 0, wrest = 0, r = 1;
++-//	Client *c;
++-//
++-//	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-//	if (n == 0)
++-//		return;
++-//
++-//	nx = m->wx + ov;
++-//	ny = m->wy + oh;
++-//	nw = m->ww - 2*ov;
++-//	nh = m->wh - 2*oh;
++-//
++-//	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++-//		if (r) {
++-//			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++-//			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++-//				r = 0;
++-//			}
++-//			if (r && i < n - 1) {
++-//				if (i % 2) {
++-//					nv = (nh - ih) / 2;
++-//					hrest = nh - 2*nv - ih;
++-//					nh = nv;
++-//				} else {
++-//					nv = (nw - iv) / 2;
++-//					wrest = nw - 2*nv - iv;
++-//					nw = nv;
++-//				}
++-//
++-//				if ((i % 4) == 2 && !s)
++-//					nx += nw + iv;
++-//				else if ((i % 4) == 3 && !s)
++-//					ny += nh + ih;
++-//			}
++-//
++-//			if ((i % 4) == 0) {
++-//				if (s) {
++-//					ny += nh + ih;
++-//					nh += hrest;
++-//				}
++-//				else {
++-//					nh -= hrest;
++-//					ny -= nh + ih;
++-//				}
++-//			}
++-//			else if ((i % 4) == 1) {
++-//				nx += nw + iv;
++-//				nw += wrest;
++-//			}
++-//			else if ((i % 4) == 2) {
++-//				ny += nh + ih;
++-//				nh += hrest;
++-//				if (i < n - 1)
++-//					nw += wrest;
++-//			}
++-//			else if ((i % 4) == 3) {
++-//				if (s) {
++-//					nx += nw + iv;
++-//					nw -= wrest;
++-//				} else {
++-//					nw -= wrest;
++-//					nx -= nw + iv;
++-//					nh += hrest;
++-//				}
++-//			}
++-//			if (i == 0)	{
++-//				if (n != 1) {
++-//					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++-//					wrest = 0;
++-//				}
++-//				ny = m->wy + oh;
++-//			}
++-//			else if (i == 1)
++-//				nw = m->ww - nw - iv - 2*ov;
++-//			i++;
++-//		}
++-//
++-//		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++-//	}
++-//}
++-
++-static void
+++void
++ fibonacci(Monitor *m, int s)
++ {
++ 	unsigned int i, n;
++ 	int nx, ny, nw, nh;
++ 	int oh, ov, ih, iv;
+++	int nv, hrest = 0, wrest = 0, r = 1;
++ 	Client *c;
++ 
++ 	getgaps(m, &oh, &ov, &ih, &iv, &n);
++-
++ 	if (n == 0)
++ 		return;
++ 
++ 	nx = m->wx + ov;
++-    ny = oh;
+++	ny = m->wy + oh;
++ 	nw = m->ww - 2*ov;
++ 	nh = m->wh - 2*oh;
++ 
++ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++-        if ((i % 2 && nh / 2 > 2*c->bw)
++-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
++-            if (i < n - 1) {
++-                if (i % 2)
++-                    nh = (nh - ih) / 2;
++-                else
++-                    nw = (nw - iv) / 2;
+++		if (r) {
+++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+++				r = 0;
+++			}
+++			if (r && i < n - 1) {
+++				if (i % 2) {
+++					nv = (nh - ih) / 2;
+++					hrest = nh - 2*nv - ih;
+++					nh = nv;
+++				} else {
+++					nv = (nw - iv) / 2;
+++					wrest = nw - 2*nv - iv;
+++					nw = nv;
+++				}
++ 
++ 				if ((i % 4) == 2 && !s)
++ 					nx += nw + iv;
++ 				else if ((i % 4) == 3 && !s)
++ 					ny += nh + ih;
++ 			}
+++
++ 			if ((i % 4) == 0) {
++-                if (s)
+++				if (s) {
++ 					ny += nh + ih;
++-                else
+++					nh += hrest;
+++				}
+++				else {
+++					nh -= hrest;
++ 					ny -= nh + ih;
++ 				}
++-            else if ((i % 4) == 1)
+++			}
+++			else if ((i % 4) == 1) {
++ 				nx += nw + iv;
++-            else if ((i % 4) == 2)
+++				nw += wrest;
+++			}
+++			else if ((i % 4) == 2) {
++ 				ny += nh + ih;
+++				nh += hrest;
+++				if (i < n - 1)
+++					nw += wrest;
+++			}
++ 			else if ((i % 4) == 3) {
++-                if (s)
+++				if (s) {
++ 					nx += nw + iv;
++-                else
+++					nw -= wrest;
+++				} else {
+++					nw -= wrest;
++ 					nx -= nw + iv;
+++					nh += hrest;
+++				}
++ 			}
++ 			if (i == 0)	{
++-                if (n != 1)
++-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+++				if (n != 1) {
+++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+++					wrest = 0;
+++				}
++ 				ny = m->wy + oh;
++ 			}
++ 			else if (i == 1)
+diff --git a/diff_upstream.diff b/diff_upstream.diff
+new file mode 100644
+index 0000000..2123321
+--- /dev/null
++++ b/diff_upstream.diff
+@@ -0,0 +1,10051 @@
++diff --git a/.gitignore b/.gitignore
++new file mode 100644
++index 0000000..d42c9e0
++--- /dev/null
+++++ b/.gitignore
++@@ -0,0 +1,54 @@
+++# Prerequisites
+++*.d
+++
+++# Object files
+++*.o
+++*.ko
+++*.obj
+++*.elf
+++
+++# Linker output
+++*.ilk
+++*.map
+++*.exp
+++
+++# Precompiled Headers
+++*.gch
+++*.pch
+++
+++# Libraries
+++*.lib
+++*.a
+++*.la
+++*.lo
+++
+++# Shared objects (inc. Windows DLLs)
+++*.dll
+++*.so
+++*.so.*
+++*.dylib
+++
+++# Executables
+++*.exe
+++*.out
+++*.app
+++*.i*86
+++*.x86_64
+++*.hex
+++
+++# Debug files
+++*.dSYM/
+++*.su
+++*.idb
+++*.pdb
+++
+++# Kernel Module Compile Results
+++*.mod*
+++*.cmd
+++.tmp_versions/
+++modules.order
+++Module.symvers
+++Mkfile.old
+++dkms.conf
+++a.out
+++dwm
++diff --git a/config.def.h b/config.def.h
++index 9efa774..0c94360 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -1,21 +1,44 @@
++ /* See LICENSE file for copyright and license details. */
++ 
++ /* appearance */
++-static const unsigned int borderpx  = 1;        /* border pixel of windows */
++-static const unsigned int snap      = 32;       /* snap pixel */
++-static const int showbar            = 1;        /* 0 means no bar */
++-static const int topbar             = 1;        /* 0 means bottom bar */
++-static const char *fonts[]          = { "monospace:size=10" };
++-static const char dmenufont[]       = "monospace:size=10";
++-static const char col_gray1[]       = "#222222";
++-static const char col_gray2[]       = "#444444";
++-static const char col_gray3[]       = "#bbbbbb";
++-static const char col_gray4[]       = "#eeeeee";
++-static const char col_cyan[]        = "#005577";
++-static const char *colors[][3]      = {
++-	/*               fg         bg         border   */
++-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
++-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+++static unsigned int borderpx  = 1;        /* border pixel of windows */
+++static unsigned int snap      = 32;       /* snap pixel */
+++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+++static int showbar            = 1;        /* 0 means no bar */
+++static int topbar             = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
+++static char font[]            = "monospace:size=10";
+++static char dmenufont[]       = "monospace:size=10";
+++static const char *fonts[]          = { font };
+++static char normbgcolor[]           = "#222222";
+++static char normbordercolor[]       = "#444444";
+++static char normfgcolor[]           = "#bbbbbb";
+++static char selfgcolor[]            = "#eeeeee";
+++static char selbordercolor[]        = "#005577";
+++static char selbgcolor[]            = "#005577";
+++static char *colors[][3] = {
+++       /*               fg           bg           border   */
+++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+++};
+++
+++typedef struct {
+++	const char *name;
+++	const void *cmd;
+++} Sp;
+++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+++const char *spcmd3[] = {"keepassxc", NULL };
+++static Sp scratchpads[] = {
+++	/* name          cmd  */
+++	{"spterm",      spcmd1},
+++	{"spranger",    spcmd2},
+++	{"keepassxc",   spcmd3},
++ };
++ 
++ /* tagging */
++@@ -26,22 +49,39 @@ static const Rule rules[] = {
++ 	 *	WM_CLASS(STRING) = instance, class
++ 	 *	WM_NAME(STRING) = title
++ 	 */
++-	/* class      instance    title       tags mask     isfloating   monitor */
++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
++ };
++ 
++ /* layout(s) */
++-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++-static const int nmaster     = 1;    /* number of clients in master area */
++-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++static int nmaster     = 1;    /* number of clients in master area */
+++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++ 
+++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+++#include "vanitygaps.c"
+++
++ static const Layout layouts[] = {
++ 	/* symbol     arrange function */
++ 	{ "[]=",      tile },    /* first entry is default */
++-	{ "><>",      NULL },    /* no layout function means floating behavior */
++ 	{ "[M]",      monocle },
+++	{ "[@]",      spiral },
+++	{ "[\\]",     dwindle },
+++	{ "H[]",      deck },
+++	{ "TTT",      bstack },
+++	{ "===",      bstackhoriz },
+++	{ "HHH",      grid },
+++	{ "###",      nrowgrid },
+++	{ "---",      horizgrid },
+++	{ ":::",      gaplessgrid },
+++	{ "|M|",      centeredmaster },
+++	{ ">M>",      centeredfloatingmaster },
+++	{ "><>",      NULL },    /* no layout function means floating behavior */
+++	{ NULL,       NULL },
++ };
++ 
++ /* key definitions */
++@@ -51,27 +91,81 @@ static const Layout layouts[] = {
++ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+++#define STACKKEYS(MOD,ACTION) \
+++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
+++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
+++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
+++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
+++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
+++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
+++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
++ 
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++ 
+++#define STATUSBAR "dwmblocks"
+++
++ /* commands */
++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
++ static const char *termcmd[]  = { "st", NULL };
++ 
+++/*
+++ * Xresources preferences to load at startup
+++ */
+++ResourcePref resources[] = {
+++		{ "font",               STRING,  &font },
+++		{ "dmenufont",          STRING,  &dmenufont },
+++		{ "normbgcolor",        STRING,  &normbgcolor },
+++		{ "normbordercolor",    STRING,  &normbordercolor },
+++		{ "normfgcolor",        STRING,  &normfgcolor },
+++		{ "selbgcolor",         STRING,  &selbgcolor },
+++		{ "selbordercolor",     STRING,  &selbordercolor },
+++		{ "selfgcolor",         STRING,  &selfgcolor },
+++		{ "borderpx",          	INTEGER, &borderpx },
+++		{ "snap",          		INTEGER, &snap },
+++		{ "showbar",          	INTEGER, &showbar },
+++		{ "topbar",          	INTEGER, &topbar },
+++		{ "nmaster",          	INTEGER, &nmaster },
+++		{ "resizehints",       	INTEGER, &resizehints },
+++		{ "mfact",      	 	FLOAT,   &mfact },
+++};
+++
++ static const Key keys[] = {
++ 	/* modifier                     key        function        argument */
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
++ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
++-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
++-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+++	STACKKEYS(MODKEY,                          focus)
+++	STACKKEYS(MODKEY|ShiftMask,                push)
++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
+++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
+++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
++ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
++@@ -79,12 +173,16 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
++ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
++ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
++ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
++ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
++ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
++ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
++ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
++ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
++ 	TAGKEYS(                        XK_1,                      0)
++ 	TAGKEYS(                        XK_2,                      1)
++ 	TAGKEYS(                        XK_3,                      2)
++@@ -94,7 +192,8 @@ static const Key keys[] = {
++ 	TAGKEYS(                        XK_7,                      6)
++ 	TAGKEYS(                        XK_8,                      7)
++ 	TAGKEYS(                        XK_9,                      8)
++-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
++ };
++ 
++ /* button definitions */
++@@ -103,11 +202,12 @@ static const Button buttons[] = {
++ 	/* click                event mask      button          function        argument */
++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
++ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
++ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
++ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++diff --git a/config.h b/config.h
++new file mode 100644
++index 0000000..ec7de9e
++--- /dev/null
+++++ b/config.h
++@@ -0,0 +1,364 @@
+++/* See LICENSE file for copyright and license details. */
+++
+++/* Constants */
+++/* #define TERMINAL "st" */
+++/* #define TERMCLASS "St" */
+++/* #define TERMINAL "urxvt" */
+++/* #define TERMCLASS "Urxvt" */
+++/* #define TERMINAL "alacritty" */
+++/* #define TERMCLASS "alacritty" */
+++#define TERMINAL "wezterm"
+++#define TERMCLASS "wezterm"
+++#define SECTERMINAL "st"
+++
+++#define FILES "thunar"
+++//#define FILEX "ranger"
+++#define FILEX "yazi"
+++
+++/* appearance */
+++static unsigned int borderpx    = 3;        /* border pixel of windows */
+++static const unsigned int gappx = 10;       /* default gap between windows in pixels */
+++static unsigned int snap        = 32;       /* snap pixel */
+++static unsigned int gappih      = 20;       /* horiz inner gap between windows */
+++static unsigned int gappiv      = 20;       /* vert inner gap between windows */
+++static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
+++static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
+++static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
+++static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
+++static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
+++static int showbar              = 1;        /* 0 means no bar */
+++static int topbar               = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
+++/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
+++/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+++static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
+++//static char normbgcolor[]       = "#222222";
+++static char normbgcolor[]       = "#282828";
+++static char normbordercolor[]   = "#ebdbb2";
+++static char normfgcolor[]       = "#ebdbb2";
+++static char selfgcolor[]        = "#ebdbb2";
+++static char selbordercolor[]    = "#770000";
+++static char selbgcolor[]        = "#005577";
+++static const char col1[]        = "#98971a";
+++static const char col21[]       = "#fb4934";
+++static const char col22[]       = "#ebdbb2";
+++static const char col23[]       = "#458588";
+++static const char col24[]       = "#ebdbb2";
+++static const char col3[]        = "#fabd2f";
+++static const char col4[]        = "#83a598";
+++static const char col5[]        = "#d3869b";
+++static const char col6[]        = "#8ec07c";
+++static char *colors[][3]        = {
+++    /*               fg              bg              border   */
+++    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
+++    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
+++};
+++
+++typedef struct {
+++    const char *name;
+++    const void *cmd;
+++} Sp;
+++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
+++const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
+++/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
+++static Sp scratchpads[] = {
+++    /* name          cmd  */
+++    {"spterm",      spcmd1},
+++    {"spcalc",      spcmd2},
+++};
+++
+++/* tagging */
+++static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+++/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
+++
+++static const Rule rules[] = {
+++    /* xprop(1):
+++     *    WM_CLASS(STRING) = instance, class
+++     *    WM_NAME(STRING) = title
+++     */
+++    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
+++    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
+++    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
+++    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
+++    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
+++    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
+++    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
+++    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
+++    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
+++    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
+++};
+++
+++/* layout(s) */
+++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++static int nmaster     = 1;    /* number of clients in master area */
+++static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+++
+++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+++#include "vanitygaps.c"
+++static const Layout layouts[] = {
+++    /* symbol       arrange function */
+++    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
+++    { "[]=",        tile },                     /* Master on left, slaves on right */
+++    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
+++    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
+++    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
+++    { "[M]",        monocle },                  /* All windows on top of eachother */
+++    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
+++    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
+++    { "><>",        NULL },                     /* no layout function means floating behavior */
+++    { NULL,         NULL },
+++};
+++
+++/* key definitions */
+++#define MODKEY Mod4Mask
+++#define MODKEY1 Mod1Mask
+++#define TAGKEYS(KEY,TAG) \
+++{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
+++{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
+++{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
+++{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
+++/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
+++#define STACKKEYS(MOD,ACTION) \
+++{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
+++{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
+++{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
+++{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
+++/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
+++/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
+++
+++/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+++#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+++
+++#define STATUSBAR "dwmblocks"
+++
+++/* commands */
+++static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+++static const char *termcmd[]  = { TERMINAL, NULL };
+++//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
+++
+++/*
+++ * Xresources preferences to load at startup
+++ */
+++ResourcePref resources[] = {
+++    { "color0",             STRING,     &normbordercolor },
+++    { "foreground",         STRING,     &selbordercolor },
+++    /* { "color8",             STRING,     &selbordercolor }, */
+++    { "color0",             STRING,     &normbgcolor },
+++    { "foreground",         STRING,     &normfgcolor },
+++    { "color0",             STRING,     &selfgcolor },
+++    { "foreground",         STRING,     &selbgcolor },
+++    { "borderpx",           INTEGER,    &borderpx },
+++    { "snap",               INTEGER,    &snap },
+++    { "showbar",            INTEGER,    &showbar },
+++    { "topbar",             INTEGER,    &topbar },
+++    { "nmaster",            INTEGER,    &nmaster },
+++    { "resizehints",        INTEGER,    &resizehints },
+++    { "mfact",              FLOAT,      &mfact },
+++    { "gappih",             INTEGER,    &gappih },
+++    { "gappiv",             INTEGER,    &gappiv },
+++    { "gappoh",             INTEGER,    &gappoh },
+++    { "gappov",             INTEGER,    &gappov },
+++    { "swallowfloating",    INTEGER,    &swallowfloating },
+++    { "smartgaps",          INTEGER,    &smartgaps },
+++};
+++
+++#include <X11/XF86keysym.h>
+++
+++static const Key keys[] = {
+++    /*  modifier                    key                 function            argument */
+++        STACKKEYS(MODKEY,                               focus)
+++        STACKKEYS(MODKEY|ShiftMask,                     push)
+++        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
+++        TAGKEYS(                    XK_1,               0)
+++        TAGKEYS(                    XK_2,               1)
+++        TAGKEYS(                    XK_3,               2)
+++        TAGKEYS(                    XK_4,               3)
+++        TAGKEYS(                    XK_5,               4)
+++        TAGKEYS(                    XK_6,               5)
+++        TAGKEYS(                    XK_7,               6)
+++        TAGKEYS(                    XK_8,               7)
+++        TAGKEYS(                    XK_9,               8)
+++        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
+++        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
+++
+++        /* Layouts */
+++        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
+++        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
+++        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
+++        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
+++        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
+++        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
+++        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
+++        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
+++        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
+++        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
+++        { MODKEY,                   XK_f,               togglefullscr,      {0} },
+++        { MODKEY,                   XK_space,           togglefloating,     {0} },
+++        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
+++        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
+++        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
+++        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
+++        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
+++        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
+++        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
+++        { MODKEY,                   XK_x,               defaultgaps,        {0} },
+++        { MODKEY,                   XK_z,               togglegaps,         {0} },
+++        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
+++        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
+++        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+++        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+++        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+++        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
+++        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
+++        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+++        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+++        { MODKEY,                   XK_q,               killclient,         {0} },
+++        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
+++        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+++        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+++        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+++        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
+++        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
+++        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
+++        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
+++        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
+++        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
+++        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
+++        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
+++        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
+++        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
+++        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
+++        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
+++
+++        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
+++        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
+++        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
+++        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
+++        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
+++        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
+++        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
+++        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
+++        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
+++        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
+++        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
+++        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
+++        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
+++        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
+++        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
+++        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
+++        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
+++        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
+++        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
+++        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
+++        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
+++        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/files_wd.sh") },
+++        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
+++        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
+++        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
+++        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
+++        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
+++        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
+++        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
+++        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
+++        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
+++        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
+++        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
+++        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
+++        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
+++        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
+++        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
+++        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
+++        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+++        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
+++        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
+++        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
+++        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
+++
+++        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
+++        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
+++        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
+++        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
+++        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
+++        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
+++        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
+++        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
+++        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
+++        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
+++
+++        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
+++        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
+++        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
+++        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
+++        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
+++        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
+++        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
+++        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
+++        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
+++        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
+++        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+++        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+++        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+++        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
+++        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
+++        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
+++
+++        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
+++        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
+++        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
+++        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
+++        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
+++        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
+++        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
+++        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
+++        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
+++        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
+++        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
+++        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
+++        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
+++        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
+++        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
+++        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
+++        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
+++        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
+++        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
+++        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
+++        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
+++        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
+++        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
+++        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
+++        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
+++        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
+++        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
+++        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
+++        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
+++};
+++
+++#define STATUSBAR "dwmblocks"
+++
+++/* button definitions */
+++/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
+++static const Button buttons[] = {
+++    /* click                event mask      button          function        argument */
+++#ifndef __OpenBSD__
+++    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+++    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+++    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+++    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+++    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+++    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
+++#endif
+++    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
+++    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
+++    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
+++    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
+++    { ClkTagBar,            0,              Button1,        view,           {0} },
+++    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+++    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+++    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+++    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
+++    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
+++    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
+++};
++diff --git a/config.mk b/config.mk
++index 8efca9a..a933c0b 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
++ # OpenBSD (uncomment)
++ #FREETYPEINC = ${X11INC}/freetype2
++ #MANPREFIX = ${PREFIX}/man
+++#KVMLIB = -lkvm
++ 
++ # includes and libs
++ INCS = -I${X11INC} -I${FREETYPEINC}
++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
++ 
++ # flags
++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++diff --git a/drw.c b/drw.c
++index c41e6af..6be5dee 100644
++--- a/drw.c
+++++ b/drw.c
++@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++ /* Wrapper to create color schemes. The caller has to call free(3) on the
++  * returned color scheme when done using it. */
++ Clr *
++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
++ {
++ 	size_t i;
++ 	Clr *ret;
++diff --git a/drw.h b/drw.h
++index 6471431..bdbf950 100644
++--- a/drw.h
+++++ b/drw.h
++@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
++ 
++ /* Colorscheme abstraction */
++ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
++ 
++ /* Cursor abstraction */
++ Cur *drw_cur_create(Drw *drw, int shape);
++diff --git a/dwm.1 b/dwm.1
++index ddc8321..d04bec6 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
++ indicated with an empty square in the top left corner.
++ .P
++ dwm draws a small border around windows to indicate the focus state.
+++.P
+++On start, dwm can start additional programs that may be specified in two special
+++shell scripts (see the FILES section below), autostart_blocking.sh and
+++autostart.sh.  The former is executed first and dwm will wait for its
+++termination before starting.  The latter is executed in the background before
+++dwm enters its handler loop.
+++.P
+++Either of these files may be omitted.
++ .SH OPTIONS
++ .TP
++ .B \-v
++@@ -116,6 +124,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
++ .B Mod1\-Shift\-c
++ Close focused window.
++ .TP
+++.B Mod1\-Shift\-f
+++Toggle fullscreen for focused window.
+++.TP
++ .B Mod1\-Shift\-space
++ Toggle focused window between tiled and floating state.
++ .TP
++@@ -152,6 +163,21 @@ Toggles focused window between floating and tiled state.
++ .TP
++ .B Mod1\-Button3
++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+++.SH FILES
+++The files containing programs to be started along with dwm are searched for in
+++the following directories:
+++.IP "1. $XDG_DATA_HOME/dwm"
+++.IP "2. $HOME/.local/share/dwm"
+++.IP "3. $HOME/.dwm"
+++.P
+++The first existing directory is scanned for any of the autostart files below.
+++.TP 15
+++autostart.sh
+++This file is started as a shell background process before dwm enters its handler
+++loop.
+++.TP 15
+++autostart_blocking.sh
+++This file is started before any autostart.sh; dwm waits for its termination.
++ .SH CUSTOMIZATION
++ dwm is customized by creating a custom config.h and (re)compiling the source
++ code. This keeps it fast, secure and simple.
++diff --git a/dwm.c b/dwm.c
++index 1443802..6232799 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -29,6 +29,7 @@
++ #include <string.h>
++ #include <unistd.h>
++ #include <sys/types.h>
+++#include <sys/stat.h>
++ #include <sys/wait.h>
++ #include <X11/cursorfont.h>
++ #include <X11/keysym.h>
++@@ -36,10 +37,17 @@
++ #include <X11/Xlib.h>
++ #include <X11/Xproto.h>
++ #include <X11/Xutil.h>
+++#include <X11/Xresource.h>
++ #ifdef XINERAMA
++ #include <X11/extensions/Xinerama.h>
++ #endif /* XINERAMA */
++ #include <X11/Xft/Xft.h>
+++#include <X11/Xlib-xcb.h>
+++#include <xcb/res.h>
+++#ifdef __OpenBSD__
+++#include <sys/sysctl.h>
+++#include <kvm.h>
+++#endif /* __OpenBSD */
++ 
++ #include "drw.h"
++ #include "util.h"
++@@ -47,24 +55,33 @@
++ /* macros */
++ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+++#define GETINC(X)               ((X) - 2000)
+++#define INC(X)                  ((X) + 2000)
++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+++#define PREVSEL                 3000
+++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+++#define TAGMASK     			((1 << NUMTAGS) - 1)
+++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++ 
++ /* enums */
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++ enum { SchemeNorm, SchemeSel }; /* color schemes */
++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+++       ClkRootWin, ClkLast }; /* clicks */
++ 
++ typedef union {
++ 	int i;
++@@ -86,14 +103,18 @@ typedef struct Client Client;
++ struct Client {
++ 	char name[256];
++ 	float mina, maxa;
+++	float cfact;
++ 	int x, y, w, h;
+++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+++    pid_t pid;
++ 	Client *next;
++ 	Client *snext;
+++    Client *swallowing;
++ 	Monitor *mon;
++ 	Window win;
++ };
++@@ -118,6 +139,10 @@ struct Monitor {
++ 	int by;               /* bar geometry */
++ 	int mx, my, mw, mh;   /* screen size */
++ 	int wx, wy, ww, wh;   /* window area  */
+++	int gappih;           /* horizontal gap between windows */
+++	int gappiv;           /* vertical gap between windows */
+++	int gappoh;           /* horizontal outer gaps */
+++	int gappov;           /* vertical outer gaps */
++ 	unsigned int seltags;
++ 	unsigned int sellt;
++ 	unsigned int tagset[2];
++@@ -137,9 +162,24 @@ typedef struct {
++ 	const char *title;
++ 	unsigned int tags;
++ 	int isfloating;
+++	int isterminal;
+++	int noswallow;
++ 	int monitor;
++ } Rule;
++ 
+++/* Xresources preferences */
+++enum resource_type {
+++	STRING = 0,
+++	INTEGER = 1,
+++	FLOAT = 2
+++};
+++
+++typedef struct {
+++	char *name;
+++	enum resource_type type;
+++	void *dst;
+++} ResourcePref;
+++
++ /* function declarations */
++ static void applyrules(Client *c);
++ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++@@ -162,7 +202,7 @@ static void detachstack(Client *c);
++ static Monitor *dirtomon(int dir);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
++-static void enternotify(XEvent *e);
+++static int drawstatusbar(Monitor *m, int bh, char* text);
++ static void expose(XEvent *e);
++ static void focus(Client *c);
++ static void focusin(XEvent *e);
++@@ -171,6 +211,7 @@ static void focusstack(const Arg *arg);
++ static Atom getatomprop(Client *c, Atom prop);
++ static int getrootptr(int *x, int *y);
++ static long getstate(Window w);
+++static pid_t getstatusbarpid();
++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++ static void grabbuttons(Client *c, int focused);
++ static void grabkeys(void);
++@@ -181,11 +222,11 @@ static void manage(Window w, XWindowAttributes *wa);
++ static void mappingnotify(XEvent *e);
++ static void maprequest(XEvent *e);
++ static void monocle(Monitor *m);
++-static void motionnotify(XEvent *e);
++ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *c);
++ static void propertynotify(XEvent *e);
+++static void pushstack(const Arg *arg);
++ static void quit(const Arg *arg);
++ static Monitor *recttomon(int x, int y, int w, int h);
++ static void resize(Client *c, int x, int y, int w, int h, int interact);
++@@ -193,23 +234,35 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
++ static void resizemouse(const Arg *arg);
++ static void restack(Monitor *m);
++ static void run(void);
+++static void runautostart(void);
++ static void scan(void);
++ static int sendevent(Client *c, Atom proto);
++ static void sendmon(Client *c, Monitor *m);
+++static void sendmonview(Client *c, Monitor *m);
++ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
+++static void setsticky(Client *c, int sticky);
++ static void setlayout(const Arg *arg);
+++static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
+++static void shiftview(const Arg *arg);
+++static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
+++static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
+++static int stackpos(const Arg *arg);
++ static void tag(const Arg *arg);
+++static void tagview(const Arg *arg);
++ static void tagmon(const Arg *arg);
++-static void tile(Monitor *m);
+++static void tagmonview(const Arg *arg);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglescratch(const Arg *arg);
+++static void togglesticky(const Arg *arg);
+++static void togglefullscr(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++ static void unfocus(Client *c, int setfocus);
++@@ -232,10 +285,25 @@ static int xerror(Display *dpy, XErrorEvent *ee);
++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
+++static void load_xresources(void);
+++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+++
+++static pid_t getparentprocess(pid_t p);
+++static int isdescprocess(pid_t p, pid_t c);
+++static Client *swallowingclient(Window w);
+++static Client *termforwin(const Client *c);
+++static pid_t winpid(Window w);
++ 
++ /* variables */
+++static const char autostartblocksh[] = "autostart_blocking.sh";
+++static const char autostartsh[] = "autostart.sh";
++ static const char broken[] = "broken";
++-static char stext[256];
+++static const char dwmdir[] = "dwm";
+++static const char localshare[] = ".local/share";
+++static char stext[1024];
+++static int statussig;
+++static int statusw;
+++static pid_t statuspid = -1;
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh;               /* bar height */
++@@ -248,13 +316,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
++ 	[ConfigureRequest] = configurerequest,
++ 	[ConfigureNotify] = configurenotify,
++ 	[DestroyNotify] = destroynotify,
++-	[EnterNotify] = enternotify,
++ 	[Expose] = expose,
++ 	[FocusIn] = focusin,
++ 	[KeyPress] = keypress,
++ 	[MappingNotify] = mappingnotify,
++ 	[MapRequest] = maprequest,
++-	[MotionNotify] = motionnotify,
++ 	[PropertyNotify] = propertynotify,
++ 	[UnmapNotify] = unmapnotify
++ };
++@@ -267,6 +333,8 @@ static Drw *drw;
++ static Monitor *mons, *selmon;
++ static Window root, wmcheckwin;
++ 
+++static xcb_connection_t *xcon;
+++
++ /* configuration, allows nested code to access above variables */
++ #include "config.h"
++ 
++@@ -296,8 +364,15 @@ applyrules(Client *c)
++ 		&& (!r->class || strstr(class, r->class))
++ 		&& (!r->instance || strstr(instance, r->instance)))
++ 		{
+++			c->isterminal = r->isterminal;
+++			c->noswallow  = r->noswallow;
++ 			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
+++			if ((r->tags & SPTAGMASK) && r->isfloating) {
+++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++			}
+++
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++ 			if (m)
++ 				c->mon = m;
++@@ -307,7 +382,7 @@ applyrules(Client *c)
++ 		XFree(ch.res_class);
++ 	if (ch.res_name)
++ 		XFree(ch.res_name);
++-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++ }
++ 
++ int
++@@ -414,6 +489,53 @@ attachstack(Client *c)
++ 	c->mon->stack = c;
++ }
++ 
+++void
+++swallow(Client *p, Client *c)
+++{
+++
+++	if (c->noswallow || c->isterminal)
+++		return;
+++	if (c->noswallow && !swallowfloating && c->isfloating)
+++		return;
+++
+++	detach(c);
+++	detachstack(c);
+++
+++	setclientstate(c, WithdrawnState);
+++	XUnmapWindow(dpy, p->win);
+++
+++	p->swallowing = c;
+++	c->mon = p->mon;
+++
+++	Window w = p->win;
+++	p->win = c->win;
+++	c->win = w;
+++	updatetitle(p);
+++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+++	arrange(p->mon);
+++	configure(p);
+++	updateclientlist();
+++}
+++
+++void
+++unswallow(Client *c)
+++{
+++	c->win = c->swallowing->win;
+++
+++	free(c->swallowing);
+++	c->swallowing = NULL;
+++
+++	/* unfullscreen the client */
+++	setfullscreen(c, 0);
+++	updatetitle(c);
+++	arrange(c->mon);
+++	XMapWindow(dpy, c->win);
+++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+++	setclientstate(c, NormalState);
+++	focus(NULL);
+++	arrange(c->mon);
+++}
+++
++ void
++ buttonpress(XEvent *e)
++ {
++@@ -425,28 +547,58 @@ buttonpress(XEvent *e)
++ 
++ 	click = ClkRootWin;
++ 	/* focus monitor if necessary */
++-	if ((m = wintomon(ev->window)) && m != selmon) {
+++	if ((m = wintomon(ev->window)) && m != selmon
+++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++ 		unfocus(selmon->sel, 1);
++ 		selmon = m;
++ 		focus(NULL);
++ 	}
++ 	if (ev->window == selmon->barwin) {
++ 		i = x = 0;
++-		do
+++		unsigned int occ = 0;
+++		for(c = m->clients; c; c=c->next)
+++			occ |= c->tags == TAGMASK ? 0 : c->tags;
+++		do {
+++			/* Do not reserve space for vacant tags */
+++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++				continue;
++ 			x += TEXTW(tags[i]);
++-		while (ev->x >= x && ++i < LENGTH(tags));
+++		} while (ev->x >= x && ++i < LENGTH(tags));
++ 		if (i < LENGTH(tags)) {
++ 			click = ClkTagBar;
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++ 			click = ClkLtSymbol;
++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++-			click = ClkStatusText;
++-		else
++-			click = ClkWinTitle;
+++        } else if (ev->x > selmon->ww - statusw) {
+++            x = selmon->ww - statusw;
+++            click = ClkStatusText;
+++
+++			char *text, *s, ch;
+++			statussig = 0;
+++			for (text = s = stext; *s && x <= ev->x; s++) {
+++				if ((unsigned char)(*s) < ' ') {
+++					ch = *s;
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = ch;
+++					text = s + 1;
+++					if (x >= ev->x)
+++						break;
+++					statussig = ch;
+++				} else if (*s == '^') {
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = '^';
+++					if (*(++s) == 'f')
+++						x += atoi(++s);
+++					while (*(s++) != '^');
+++					text = s;
+++					s--;
+++				}
+++			}
++ 	} else if ((c = wintoclient(ev->window))) {
++-		focus(c);
++-		restack(selmon);
+++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+++			focus(c);
++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++ 		click = ClkClientWin;
++ 	}
++@@ -485,7 +637,7 @@ cleanup(void)
++ 		cleanupmon(mons);
++ 	for (i = 0; i < CurLast; i++)
++ 		drw_cur_free(drw, cursor[i]);
++-	for (i = 0; i < LENGTH(colors); i++)
+++	for (i = 0; i < LENGTH(colors) + 1; i++)
++ 		free(scheme[i]);
++ 	free(scheme);
++ 	XDestroyWindow(dpy, wmcheckwin);
++@@ -524,6 +676,10 @@ clientmessage(XEvent *e)
++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+++
+++        if (cme->data.l[1] == netatom[NetWMSticky]
+++                || cme->data.l[2] == netatom[NetWMSticky])
+++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
++ 		if (c != selmon->sel && !c->isurgent)
++ 			seturgent(c, 1);
++@@ -640,6 +796,10 @@ createmon(void)
++ 	m->nmaster = nmaster;
++ 	m->showbar = showbar;
++ 	m->topbar = topbar;
+++	m->gappih = gappih;
+++	m->gappiv = gappiv;
+++	m->gappoh = gappoh;
+++	m->gappov = gappov;
++ 	m->lt[0] = &layouts[0];
++ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++@@ -654,6 +814,9 @@ destroynotify(XEvent *e)
++ 
++ 	if ((c = wintoclient(ev->window)))
++ 		unmanage(c, 1);
+++
+++	else if ((c = swallowingclient(ev->window)))
+++		unmanage(c->swallowing, 1);
++ }
++ 
++ void
++@@ -694,6 +857,128 @@ dirtomon(int dir)
++ 	return m;
++ }
++ 
+++int
+++drawstatusbar(Monitor *m, int bh, char* stext)
+++{
+++    int ret, i, w, x, len;
+++    short isCode = 0;
+++    char *text;
+++    char *p;
+++    FILE *ptr;
+++    char ch;
+++    int hotbool = 0;
+++
+++    len = strlen(stext) + 1 ;
+++    if (!(text = (char*) malloc(sizeof(char)*len)))
+++        die("malloc");
+++    p = text;
+++    memcpy(text, stext, len);
+++
+++    /* compute width of the status text */
+++    w = 0;
+++    i = -1;
+++    while (text[++i]) {
+++        if (text[i] == '^') {
+++            if (!isCode) {
+++                isCode = 1;
+++                text[i] = '\0';
+++                w += TEXTW(text) - lrpad;
+++                text[i] = '^';
+++                if (text[++i] == 'f')
+++                    w += atoi(text + ++i);
+++            } else {
+++                isCode = 0;
+++                text = text + i + 1;
+++                i = -1;
+++            }
+++        }
+++    }
+++    if (!isCode)
+++        w += TEXTW(text) - lrpad;
+++    else
+++        isCode = 0;
+++    text = p;
+++
+++    w += 2; /* 1px padding on both sides */
+++    ret = x = m->ww - w;
+++
+++    drw_setscheme(drw, scheme[LENGTH(colors)]);
+++    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+++    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+++    drw_rect(drw, x, 0, w, bh, 1, 1);
+++    x++;
+++
+++    /* process status text */
+++    i = -1;
+++    drw_clr_create(drw, &drw->scheme[ColFg], col1);
+++
+++    while (text[++i]) {
+++        if (text[i] == '^' && !isCode) {
+++            isCode = 1;
+++
+++            text[i] = '\0';
+++            w = TEXTW(text) - lrpad;
+++            drw_text(drw, x, 0, w, bh, 0, text, 0);
+++            x += w;
+++
+++            while (text[++i] != '^') {
+++                if (text[i] == '2') {
+++                    // Check if weather is hot or not
+++                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
+++                    if (ptr == NULL) printf("Fail to read wr...");
+++                    do{
+++                        ch = fgetc(ptr);
+++                        // Check if temp is above +20 (= hot)
+++                        if (hotbool){
+++                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
+++                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
+++                                break;
+++                            }else{
+++                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
+++                                break;
+++                            }
+++                        }
+++
+++                        if (ch == '+'){
+++                            hotbool = 1;
+++                        }else if (ch == '-') {
+++                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
+++                            break;
+++                        }
+++                        else{
+++                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
+++                            break;
+++                        }
+++                    } while (ch != EOF);
+++                    fclose(ptr);
+++                } else if (text[i] == '3') {
+++                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
+++                } else if (text[i] == '4') {
+++                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
+++                } else if (text[i] == '5') {
+++                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
+++                } else if (text[i] == '6') {
+++                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
+++                }
+++            }
+++
+++            text = text + i + 1;
+++            i=-1;
+++            isCode = 0;
+++        }
+++    }
+++
+++    if (!isCode) {
+++        w = TEXTW(text) - lrpad;
+++        drw_text(drw, x, 0, w, bh, 0, text, 0);
+++    }
+++
+++    drw_setscheme(drw, scheme[SchemeNorm]);
+++    free(p);
+++
+++    return ret;
+++}
+++
++ void
++ drawbar(Monitor *m)
++ {
++@@ -707,26 +992,24 @@ drawbar(Monitor *m)
++ 		return;
++ 
++ 	/* draw status first so it can be overdrawn by tags later */
++-	if (m == selmon) { /* status is only drawn on selected monitor */
++-		drw_setscheme(drw, scheme[SchemeNorm]);
++-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
++-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+++	//if (m == selmon) { /* status is only drawn on selected monitor */
+++    if (m == selmon || 1) { 
+++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++-		occ |= c->tags;
+++		occ |= c->tags == TAGMASK ? 0 : c->tags;
++ 		if (c->isurgent)
++ 			urg |= c->tags;
++ 	}
++ 	x = 0;
++ 	for (i = 0; i < LENGTH(tags); i++) {
+++		/* Do not draw vacant tags */
+++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++			continue;
++ 		w = TEXTW(tags[i]);
++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++-		if (occ & 1 << i)
++-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
++-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
++-				urg & 1 << i);
++ 		x += w;
++ 	}
++ 	w = TEXTW(m->ltsymbol);
++@@ -734,15 +1017,8 @@ drawbar(Monitor *m)
++ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++ 
++ 	if ((w = m->ww - tw - x) > bh) {
++-		if (m->sel) {
++-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
++-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++-			if (m->sel->isfloating)
++-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
++-		} else {
++ 			drw_setscheme(drw, scheme[SchemeNorm]);
++ 			drw_rect(drw, x, 0, w, bh, 1, 1);
++-		}
++ 	}
++ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++ }
++@@ -756,25 +1032,6 @@ drawbars(void)
++ 		drawbar(m);
++ }
++ 
++-void
++-enternotify(XEvent *e)
++-{
++-	Client *c;
++-	Monitor *m;
++-	XCrossingEvent *ev = &e->xcrossing;
++-
++-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++-		return;
++-	c = wintoclient(ev->window);
++-	m = c ? c->mon : wintomon(ev->window);
++-	if (m != selmon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-	} else if (!c || c == selmon->sel)
++-		return;
++-	focus(c);
++-}
++-
++ void
++ expose(XEvent *e)
++ {
++@@ -837,27 +1094,16 @@ focusmon(const Arg *arg)
++ void
++ focusstack(const Arg *arg)
++ {
++-	Client *c = NULL, *i;
+++	int i = stackpos(arg);
+++	Client *c, *p;
++ 
++-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+++	if(i < 0)
++ 		return;
++-	if (arg->i > 0) {
++-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
++-		if (!c)
++-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
++-	} else {
++-		for (i = selmon->clients; i != selmon->sel; i = i->next)
++-			if (ISVISIBLE(i))
++-				c = i;
++-		if (!c)
++-			for (; i; i = i->next)
++-				if (ISVISIBLE(i))
++-					c = i;
++-	}
++-	if (c) {
++-		focus(c);
++-		restack(selmon);
++-	}
+++
+++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+++	focus(c ? c : p);
+++	restack(selmon);
++ }
++ 
++ Atom
++@@ -876,6 +1122,30 @@ getatomprop(Client *c, Atom prop)
++ 	return atom;
++ }
++ 
+++pid_t
+++getstatusbarpid()
+++{
+++	char buf[32], *str = buf, *c;
+++	FILE *fp;
+++
+++	if (statuspid > 0) {
+++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+++		if ((fp = fopen(buf, "r"))) {
+++			fgets(buf, sizeof(buf), fp);
+++			while ((c = strchr(str, '/')))
+++				str = c + 1;
+++			fclose(fp);
+++			if (!strcmp(str, STATUSBAR))
+++				return statuspid;
+++		}
+++	}
+++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+++		return -1;
+++	fgets(buf, sizeof(buf), fp);
+++	pclose(fp);
+++	return strtoul(buf, NULL, 10);
+++}
+++
++ int
++ getrootptr(int *x, int *y)
++ {
++@@ -1030,18 +1300,20 @@ killclient(const Arg *arg)
++ void
++ manage(Window w, XWindowAttributes *wa)
++ {
++-	Client *c, *t = NULL;
+++	Client *c, *t = NULL, *term = NULL;
++ 	Window trans = None;
++ 	XWindowChanges wc;
++ 
++ 	c = ecalloc(1, sizeof(Client));
++ 	c->win = w;
+++	c->pid = winpid(w);
++ 	/* geometry */
++ 	c->x = c->oldx = wa->x;
++ 	c->y = c->oldy = wa->y;
++ 	c->w = c->oldw = wa->width;
++ 	c->h = c->oldh = wa->height;
++ 	c->oldbw = wa->border_width;
+++	c->cfact = 1.0;
++ 
++ 	updatetitle(c);
++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++@@ -1050,6 +1322,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	} else {
++ 		c->mon = selmon;
++ 		applyrules(c);
+++		term = termforwin(c);
++ 	}
++ 
++ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++@@ -1067,6 +1340,10 @@ manage(Window w, XWindowAttributes *wa)
++ 	updatewindowtype(c);
++ 	updatesizehints(c);
++ 	updatewmhints(c);
+++	c->sfx = c->x;
+++	c->sfy = c->y;
+++	c->sfw = c->w;
+++	c->sfh = c->h;
++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++ 	grabbuttons(c, 0);
++ 	if (!c->isfloating)
++@@ -1084,6 +1361,8 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->mon->sel = c;
++ 	arrange(c->mon);
++ 	XMapWindow(dpy, c->win);
+++	if (term)
+++		swallow(term, c);
++ 	focus(NULL);
++ }
++ 
++@@ -1124,23 +1403,6 @@ monocle(Monitor *m)
++ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++ }
++ 
++-void
++-motionnotify(XEvent *e)
++-{
++-	static Monitor *mon = NULL;
++-	Monitor *m;
++-	XMotionEvent *ev = &e->xmotion;
++-
++-	if (ev->window != root)
++-		return;
++-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-		focus(NULL);
++-	}
++-	mon = m;
++-}
++-
++ void
++ movemouse(const Arg *arg)
++ {
++@@ -1244,16 +1506,36 @@ propertynotify(XEvent *e)
++ 			drawbars();
++ 			break;
++ 		}
++-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++ 			updatetitle(c);
++-			if (c == c->mon->sel)
++-				drawbar(c->mon);
++-		}
++ 		if (ev->atom == netatom[NetWMWindowType])
++ 			updatewindowtype(c);
++ 	}
++ }
++ 
+++void
+++pushstack(const Arg *arg) {
+++	int i = stackpos(arg);
+++	Client *sel = selmon->sel, *c, *p;
+++
+++	if(i < 0)
+++		return;
+++	else if(i == 0) {
+++		detach(sel);
+++		attach(sel);
+++	}
+++	else {
+++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+++			if(!(i -= (ISVISIBLE(c) && c != sel)))
+++				break;
+++		c = c ? c : p;
+++		detach(sel);
+++		sel->next = c->next;
+++		c->next = sel;
+++	}
+++	arrange(selmon);
+++}
+++
++ void
++ quit(const Arg *arg)
++ {
++@@ -1291,6 +1573,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
++ 	c->oldw = c->w; c->w = wc.width = w;
++ 	c->oldh = c->h; c->h = wc.height = h;
++ 	wc.border_width = c->bw;
+++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+++	    && !c->isfullscreen && !c->isfloating) {
+++		c->w = wc.width += c->bw * 2;
+++		c->h = wc.height += c->bw * 2;
+++		wc.border_width = 0;
+++	}
++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++ 	configure(c);
++ 	XSync(dpy, False);
++@@ -1389,6 +1678,89 @@ run(void)
++ 			handler[ev.type](&ev); /* call handler */
++ }
++ 
+++//void
+++//runautostart(void)
+++//{
+++//	char *pathpfx;
+++//	char *path;
+++//	char *xdgdatahome;
+++//	char *home;
+++//	struct stat sb;
+++//
+++//	if ((home = getenv("HOME")) == NULL)
+++//		/* this is almost impossible */
+++//		return;
+++//
+++//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+++//	 * otherwise use ~/.local/share/dwm as autostart script directory
+++//	 */
+++//	xdgdatahome = getenv("XDG_DATA_HOME");
+++//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+++//		/* space for path segments, separators and nul */
+++//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+++//
+++//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	} else {
+++//		/* space for path segments, separators and nul */
+++//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+++//		                     + strlen(dwmdir) + 3);
+++//
+++//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	}
+++//
+++//	/* check if the autostart script directory exists */
+++//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+++//		/* the XDG conformant path does not exist or is no directory
+++//		 * so we try ~/.dwm instead
+++//		 */
+++//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+++//		if(pathpfx_new == NULL) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//		pathpfx = pathpfx_new;
+++//
+++//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+++//			free(pathpfx);
+++//			return;
+++//		}
+++//	}
+++//
+++//	/* try the blocking script first */
+++//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+++//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+++//		free(path);
+++//		free(pathpfx);
+++//	}
+++//
+++//	if (access(path, X_OK) == 0)
+++//		system(path);
+++//
+++//	/* now the non-blocking script */
+++//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+++//		free(path);
+++//		free(pathpfx);
+++//	}
+++//
+++//	if (access(path, X_OK) == 0)
+++//		system(strcat(path, " &"));
+++//
+++//	free(pathpfx);
+++//	free(path);
+++//}
+++
+++void
+++runautostart(void)
+++{
+++    system("killall -q dwmblocks; dwmblocks &");
+++}
+++
++ void
++ scan(void)
++ {
++@@ -1432,6 +1804,25 @@ sendmon(Client *c, Monitor *m)
++ 	arrange(NULL);
++ }
++ 
+++void
+++sendmonview(Client *c, Monitor *m)
+++{
+++    if (c->mon == m)
+++        return;
+++    unfocus(c, 1);
+++    detach(c);
+++    detachstack(c);
+++    arrange(c->mon);
+++    c->mon = m;
+++    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+++    attach(c);
+++    attachstack(c);
+++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+++    arrange(m);
+++    focus(c);
+++    restack(m);
+++}
+++
++ void
++ setclientstate(Client *c, long state)
++ {
++@@ -1506,6 +1897,23 @@ setfullscreen(Client *c, int fullscreen)
++ 	}
++ }
++ 
+++void
+++	 setsticky(Client *c, int sticky)
+++	 {
+++
+++		 if(sticky && !c->issticky) {
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+++			 c->issticky = 1;
+++		 } else if(!sticky && c->issticky){
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *)0, 0);
+++			 c->issticky = 0;
+++			 arrange(c->mon);
+++		 }
+++	 }
+++
+++
++ void
++ setlayout(const Arg *arg)
++ {
++@@ -1520,6 +1928,58 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++shiftview(const Arg *arg) {
+++	Arg shifted;
+++
+++	if(arg->i > 0) /* left circular shift */
+++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++
+++	else /* right circular shift */
+++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++
+++	view(&shifted);
+++}
+++
+++void
+++shifttag(const Arg *arg) {
+++	Arg shifted;
+++	Client *c;
+++
+++	if (!selmon->sel)
+++		return;
+++	c = selmon->sel;
+++
+++	if (arg->i > 0) /* left circular shift */
+++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++			^ (c->tags >> (LENGTH(tags) - arg->i));
+++	else /* right circular shift */
+++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++			^ (c->tags << (LENGTH(tags) + arg->i));
+++
+++	toggletag(&shifted);
+++}
+++
+++void
+++setcfact(const Arg *arg) {
+++	float f;
+++	Client *c;
+++
+++	c = selmon->sel;
+++
+++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+++		return;
+++	f = arg->f + c->cfact;
+++	if(arg->f == 0.0)
+++		f = 1.0;
+++	else if(f < 0.25 || f > 4.0)
+++		return;
+++	c->cfact = f;
+++	arrange(selmon);
+++}
+++
++ /* arg > 1.0 will set mfact absolutely */
++ void
++ setmfact(const Arg *arg)
++@@ -1575,6 +2035,7 @@ setup(void)
++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++@@ -1583,7 +2044,8 @@ setup(void)
++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++ 	/* init appearance */
++-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++ 	for (i = 0; i < LENGTH(colors); i++)
++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
++ 	/* init bars */
++@@ -1631,6 +2093,10 @@ showhide(Client *c)
++ 	if (!c)
++ 		return;
++ 	if (ISVISIBLE(c)) {
+++		if ((c->tags & SPTAGMASK) && c->isfloating) {
+++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++		}
++ 		/* show clients top down */
++ 		XMoveWindow(dpy, c->win, c->x, c->y);
++ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++@@ -1643,6 +2109,20 @@ showhide(Client *c)
++ 	}
++ }
++ 
+++void
+++sigstatusbar(const Arg *arg)
+++{
+++	union sigval sv;
+++
+++	if (!statussig)
+++		return;
+++	sv.sival_int = arg->i;
+++	if ((statuspid = getstatusbarpid()) <= 0)
+++		return;
+++
+++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+++}
+++
++ void
++ spawn(const Arg *arg)
++ {
++@@ -1665,6 +2145,36 @@ spawn(const Arg *arg)
++ 	}
++ }
++ 
+++int
+++stackpos(const Arg *arg) {
+++	int n, i;
+++	Client *c, *l;
+++
+++	if(!selmon->clients)
+++		return -1;
+++
+++	if(arg->i == PREVSEL) {
+++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+++		if(!l)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return i;
+++	}
+++	else if(ISINC(arg->i)) {
+++		if(!selmon->sel)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MOD(i + GETINC(arg->i), n);
+++	}
+++	else if(arg->i < 0) {
+++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MAX(i + arg->i, 0);
+++	}
+++	else
+++		return arg->i;
+++}
+++
++ void
++ tag(const Arg *arg)
++ {
++@@ -1675,6 +2185,17 @@ tag(const Arg *arg)
++ 	}
++ }
++ 
+++void
+++tagview(const Arg *arg)
+++{
+++    if (selmon->sel && arg->ui & TAGMASK) {
+++        selmon->sel->tags = arg->ui & TAGMASK;
+++        focus(NULL);
+++        arrange(selmon);
+++        view(arg);
+++    }
+++}
+++
++ void
++ tagmon(const Arg *arg)
++ {
++@@ -1684,31 +2205,11 @@ tagmon(const Arg *arg)
++ }
++ 
++ void
++-tile(Monitor *m)
+++tagmonview(const Arg *arg)
++ {
++-	unsigned int i, n, h, mw, my, ty;
++-	Client *c;
++-
++-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-	if (n == 0)
++-		return;
++-
++-	if (n > m->nmaster)
++-		mw = m->nmaster ? m->ww * m->mfact : 0;
++-	else
++-		mw = m->ww;
++-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-		if (i < m->nmaster) {
++-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
++-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (my + HEIGHT(c) < m->wh)
++-				my += HEIGHT(c);
++-		} else {
++-			h = (m->wh - ty) / (n - i);
++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (ty + HEIGHT(c) < m->wh)
++-				ty += HEIGHT(c);
++-		}
+++    if (!selmon->sel || !mons->next)
+++        return;
+++    sendmonview(selmon->sel, dirtomon(arg->i));
++ }
++ 
++ void
++@@ -1729,11 +2230,61 @@ togglefloating(const Arg *arg)
++ 		return;
++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++ 	if (selmon->sel->isfloating)
++-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
++-			selmon->sel->w, selmon->sel->h, 0);
+++		/* restore last known float dimensions */
+++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+++		       selmon->sel->sfw, selmon->sel->sfh, False);
+++	else {
+++		/* save last known float dimensions */
+++		selmon->sel->sfx = selmon->sel->x;
+++		selmon->sel->sfy = selmon->sel->y;
+++		selmon->sel->sfw = selmon->sel->w;
+++		selmon->sel->sfh = selmon->sel->h;
+++	}
+++	arrange(selmon);
+++}
+++
+++void
+++togglefullscr(const Arg *arg)
+++{
+++  if(selmon->sel)
+++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+++}
+++
+++void
+++togglesticky(const Arg *arg)
+++{
+++	if (!selmon->sel)
+++		return;
+++	setsticky(selmon->sel, !selmon->sel->issticky);
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglescratch(const Arg *arg)
+++{
+++	Client *c;
+++	unsigned int found = 0;
+++	unsigned int scratchtag = SPTAG(arg->ui);
+++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+++
+++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+++	if (found) {
+++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+++		if (newtagset) {
+++			selmon->tagset[selmon->seltags] = newtagset;
+++			focus(NULL);
+++			arrange(selmon);
+++		}
+++		if (ISVISIBLE(c)) {
+++			focus(c);
+++			restack(selmon);
+++		}
+++	} else {
+++		selmon->tagset[selmon->seltags] |= scratchtag;
+++		spawn(&sparg);
+++	}
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
++@@ -1780,6 +2331,20 @@ unmanage(Client *c, int destroyed)
++ 	Monitor *m = c->mon;
++ 	XWindowChanges wc;
++ 
+++	if (c->swallowing) {
+++		unswallow(c);
+++		return;
+++	}
+++
+++	Client *s = swallowingclient(c->win);
+++	if (s) {
+++		free(s->swallowing);
+++		s->swallowing = NULL;
+++		arrange(m);
+++		focus(NULL);
+++		return;
+++	}
+++
++ 	detach(c);
++ 	detachstack(c);
++ 	if (!destroyed) {
++@@ -1795,9 +2360,12 @@ unmanage(Client *c, int destroyed)
++ 		XUngrabServer(dpy);
++ 	}
++ 	free(c);
++-	focus(NULL);
++-	updateclientlist();
++-	arrange(m);
+++
+++	if (!s) {
+++		arrange(m);
+++		focus(NULL);
+++		updateclientlist();
+++	}
++ }
++ 
++ void
++@@ -2026,6 +2594,9 @@ updatewindowtype(Client *c)
++ 
++ 	if (state == netatom[NetWMFullscreen])
++ 		setfullscreen(c, 1);
+++	if (state == netatom[NetWMSticky]) {
+++		setsticky(c, 1);
+++	}
++ 	if (wtype == netatom[NetWMWindowTypeDialog])
++ 		c->isfloating = 1;
++ }
++@@ -2052,8 +2623,11 @@ updatewmhints(Client *c)
++ void
++ view(const Arg *arg)
++ {
++-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++-		return;
+++    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
+++        view(&((Arg) { .ui = 0 }));
+++        return;
+++    }
+++
++ 	selmon->seltags ^= 1; /* toggle sel tagset */
++ 	if (arg->ui & TAGMASK)
++ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++@@ -2061,6 +2635,136 @@ view(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++pid_t
+++winpid(Window w)
+++{
+++
+++	pid_t result = 0;
+++
+++#ifdef __linux__
+++	xcb_res_client_id_spec_t spec = {0};
+++	spec.client = w;
+++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+++
+++	xcb_generic_error_t *e = NULL;
+++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+++
+++	if (!r)
+++		return (pid_t)0;
+++
+++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+++		spec = i.data->spec;
+++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+++			uint32_t *t = xcb_res_client_id_value_value(i.data);
+++			result = *t;
+++			break;
+++		}
+++	}
+++
+++	free(r);
+++
+++	if (result == (pid_t)-1)
+++		result = 0;
+++
+++#endif /* __linux__ */
+++
+++#ifdef __OpenBSD__
+++        Atom type;
+++        int format;
+++        unsigned long len, bytes;
+++        unsigned char *prop;
+++        pid_t ret;
+++
+++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+++               return 0;
+++
+++        ret = *(pid_t*)prop;
+++        XFree(prop);
+++        result = ret;
+++
+++#endif /* __OpenBSD__ */
+++	return result;
+++}
+++
+++pid_t
+++getparentprocess(pid_t p)
+++{
+++	unsigned int v = 0;
+++
+++#ifdef __linux__
+++	FILE *f;
+++	char buf[256];
+++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+++
+++	if (!(f = fopen(buf, "r")))
+++		return 0;
+++
+++	fscanf(f, "%*u %*s %*c %u", &v);
+++	fclose(f);
+++#endif /* __linux__*/
+++
+++#ifdef __OpenBSD__
+++	int n;
+++	kvm_t *kd;
+++	struct kinfo_proc *kp;
+++
+++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+++	if (!kd)
+++		return 0;
+++
+++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+++	v = kp->p_ppid;
+++#endif /* __OpenBSD__ */
+++
+++	return (pid_t)v;
+++}
+++
+++int
+++isdescprocess(pid_t p, pid_t c)
+++{
+++	while (p != c && c != 0)
+++		c = getparentprocess(c);
+++
+++	return (int)c;
+++}
+++
+++Client *
+++termforwin(const Client *w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	if (!w->pid || w->isterminal)
+++		return NULL;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
+++Client *
+++swallowingclient(Window w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->swallowing && c->swallowing->win == w)
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
++ Client *
++ wintoclient(Window w)
++ {
++@@ -2139,6 +2843,60 @@ zoom(const Arg *arg)
++ 	pop(c);
++ }
++ 
+++void
+++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+++{
+++	char *sdst = NULL;
+++	int *idst = NULL;
+++	float *fdst = NULL;
+++
+++	sdst = dst;
+++	idst = dst;
+++	fdst = dst;
+++
+++	char fullname[256];
+++	char *type;
+++	XrmValue ret;
+++
+++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+++	fullname[sizeof(fullname) - 1] = '\0';
+++
+++	XrmGetResource(db, fullname, "*", &type, &ret);
+++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+++	{
+++		switch (rtype) {
+++		case STRING:
+++			strcpy(sdst, ret.addr);
+++			break;
+++		case INTEGER:
+++			*idst = strtoul(ret.addr, NULL, 10);
+++			break;
+++		case FLOAT:
+++			*fdst = strtof(ret.addr, NULL);
+++			break;
+++		}
+++	}
+++}
+++
+++void
+++load_xresources(void)
+++{
+++	Display *display;
+++	char *resm;
+++	XrmDatabase db;
+++	ResourcePref *p;
+++
+++	display = XOpenDisplay(NULL);
+++	resm = XResourceManagerString(display);
+++	if (!resm)
+++		return;
+++
+++	db = XrmGetStringDatabase(resm);
+++	for (p = resources; p < resources + LENGTH(resources); p++)
+++		resource_load(db, p->name, p->type, p->dst);
+++	XCloseDisplay(display);
+++}
+++
++ int
++ main(int argc, char *argv[])
++ {
++@@ -2150,15 +2908,22 @@ main(int argc, char *argv[])
++ 		fputs("warning: no locale support\n", stderr);
++ 	if (!(dpy = XOpenDisplay(NULL)))
++ 		die("dwm: cannot open display");
+++	if (!(xcon = XGetXCBConnection(dpy)))
+++		die("dwm: cannot get xcb connection\n");
++ 	checkotherwm();
+++	XrmInitialize();
+++	load_xresources();
++ 	setup();
++ #ifdef __OpenBSD__
++-	if (pledge("stdio rpath proc exec", NULL) == -1)
+++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
+++	runautostart();
+++    arrange(selmon);
++ 	run();
++ 	cleanup();
++ 	XCloseDisplay(dpy);
++ 	return EXIT_SUCCESS;
++ }
+++
++diff --git a/patches/dwm-6.0-smfact.diff b/patches/dwm-6.0-smfact.diff
++new file mode 100644
++index 0000000..2032ef0
++--- /dev/null
+++++ b/patches/dwm-6.0-smfact.diff
++@@ -0,0 +1,117 @@
+++--- config.def.h	2013-04-06 21:01:27.750829760 +0200
++++++ config.def.h	2013-04-06 21:02:19.557495556 +0200
+++@@ -10,6 +10,7 @@ static const char selbgcolor[]      = "#
+++ static const char selfgcolor[]      = "#eeeeee";
+++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
++++static const unsigned int minwsz    = 20;       /* Minimal heigt of a client for smfact */
+++ static const Bool showbar           = True;     /* False means no bar */
+++ static const Bool topbar            = True;     /* False means bottom bar */
+++ 
+++@@ -24,6 +25,7 @@ static const Rule rules[] = {
+++ 
+++ /* layout(s) */
+++ static const float mfact      = 0.55; /* factor of master area size [0.05..0.95] */
++++static const float smfact     = 0.00; /* factor of tiled clients [0.00..0.95] */
+++ static const int nmaster      = 1;    /* number of clients in master area */
+++ static const Bool resizehints = True; /* True means respect size hints in tiled resizals */
+++ 
+++@@ -60,6 +62,8 @@ static Key keys[] = {
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++++	{ MODKEY|ShiftMask,             XK_h,      setsmfact,      {.f = +0.05} },
++++	{ MODKEY|ShiftMask,             XK_l,      setsmfact,      {.f = -0.05} },
+++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+++--- dwm.c	2011-12-19 16:02:46.000000000 +0100
++++++ dwm.c	2013-04-06 21:00:46.620830452 +0200
+++@@ -69,6 +69,7 @@ typedef union {
+++ 	int i;
+++ 	unsigned int ui;
+++ 	float f;
++++	float sf;
+++ 	const void *v;
+++ } Arg;
+++ 
+++@@ -127,6 +128,7 @@ typedef struct {
+++ struct Monitor {
+++ 	char ltsymbol[16];
+++ 	float mfact;
++++	float smfact;
+++ 	int nmaster;
+++ 	int num;
+++ 	int by;               /* bar geometry */
+++@@ -220,6 +222,7 @@ static void setfocus(Client *c);
+++ static void setfullscreen(Client *c, Bool fullscreen);
+++ static void setlayout(const Arg *arg);
+++ static void setmfact(const Arg *arg);
++++static void setsmfact(const Arg *arg);
+++ static void setup(void);
+++ static void showhide(Client *c);
+++ static void sigchld(int unused);
+++@@ -651,6 +654,7 @@ createmon(void) {
+++ 		die("fatal: could not malloc() %u bytes\n", sizeof(Monitor));
+++ 	m->tagset[0] = m->tagset[1] = 1;
+++ 	m->mfact = mfact;
++++	m->smfact = smfact;
+++ 	m->nmaster = nmaster;
+++ 	m->showbar = showbar;
+++ 	m->topbar = topbar;
+++@@ -1581,6 +1585,19 @@ setmfact(const Arg *arg) {
+++ }
+++ 
+++ void
++++setsmfact(const Arg *arg) {
++++	float sf;
++++
++++	if(!arg || !selmon->lt[selmon->sellt]->arrange)
++++		return;
++++	sf = arg->sf < 1.0 ? arg->sf + selmon->smfact : arg->sf - 1.0;
++++	if(sf < 0 || sf > 0.9)
++++		return;
++++	selmon->smfact = sf;
++++	arrange(selmon);
++++}
++++
++++void
+++ setup(void) {
+++ 	XSetWindowAttributes wa;
+++ 
+++@@ -1703,7 +1720,7 @@ textnw(const char *text, unsigned int le
+++ 
+++ void
+++ tile(Monitor *m) {
+++-	unsigned int i, n, h, mw, my, ty;
++++	unsigned int i, n, h, smh, mw, my, ty;
+++ 	Client *c;
+++ 
+++ 	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++@@ -1721,9 +1738,23 @@ tile(Monitor *m) {
+++ 			my += HEIGHT(c);
+++ 		}
+++ 		else {
+++-			h = (m->wh - ty) / (n - i);
+++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+++-			ty += HEIGHT(c);
++++			smh = m->mh * m->smfact;
++++			if(!(nexttiled(c->next)))
++++				h = (m->wh - ty) / (n - i);
++++			else
++++				h = (m->wh - smh - ty) / (n - i);
++++			if(h < minwsz) {
++++				c->isfloating = True;
++++				XRaiseWindow(dpy, c->win);
++++				resize(c, m->mx + (m->mw / 2 - WIDTH(c) / 2), m->my + (m->mh / 2 - HEIGHT(c) / 2), m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++++				ty -= HEIGHT(c);
++++			}
++++			else
++++				resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++++			if(!(nexttiled(c->next)))
++++				ty += HEIGHT(c) + smh;
++++			else
++++				ty += HEIGHT(c);
+++ 		}
+++ }
+++ 
++diff --git a/patches/dwm-actualfullscreen-20211013-cb3f58a.diff b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
++new file mode 100644
++index 0000000..d3be230
++--- /dev/null
+++++ b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
++@@ -0,0 +1,68 @@
+++From eea13010ffc3983392857ee1e3804e3aa1064d7a Mon Sep 17 00:00:00 2001
+++From: Soenke Lambert <s.lambert@mittwald.de>
+++Date: Wed, 13 Oct 2021 18:21:09 +0200
+++Subject: [PATCH] Fullscreen current window with [Alt]+[Shift]+[f]
+++
+++This actually fullscreens a window, instead of just hiding the statusbar
+++and applying the monocle layout.
+++---
+++ config.def.h | 1 +
+++ dwm.1        | 3 +++
+++ dwm.c        | 8 ++++++++
+++ 3 files changed, 12 insertions(+)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 1c0b587..8cd3204 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -78,6 +78,7 @@ static Key keys[] = {
+++ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+++ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+++ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+++ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+++ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+++ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+++diff --git a/dwm.1 b/dwm.1
+++index 13b3729..a368d05 100644
+++--- a/dwm.1
++++++ b/dwm.1
+++@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+++ .B Mod1\-Shift\-c
+++ Close focused window.
+++ .TP
++++.B Mod1\-Shift\-f
++++Toggle fullscreen for focused window.
++++.TP
+++ .B Mod1\-Shift\-space
+++ Toggle focused window between tiled and floating state.
+++ .TP
+++diff --git a/dwm.c b/dwm.c
+++index 4465af1..c1b899a 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -211,6 +211,7 @@ static void tagmon(const Arg *arg);
+++ static void tile(Monitor *);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglefullscr(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++ static void toggleview(const Arg *arg);
+++ static void unfocus(Client *c, int setfocus);
+++@@ -1719,6 +1720,13 @@ togglefloating(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++void
++++togglefullscr(const Arg *arg)
++++{
++++  if(selmon->sel)
++++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
+++-- 
+++2.30.2
+++
++diff --git a/patches/dwm-alpha-20230401-348f655.diff b/patches/dwm-alpha-20230401-348f655.diff
++new file mode 100644
++index 0000000..c948f04
++--- /dev/null
+++++ b/patches/dwm-alpha-20230401-348f655.diff
++@@ -0,0 +1,288 @@
+++From ad5887df95fda706291c81ee143d0786a1717b12 Mon Sep 17 00:00:00 2001
+++From: getimiskon <getimiskon@disroot.org>
+++Date: Sat, 1 Apr 2023 16:22:01 +0300
+++Subject: [PATCH] Allow dwm to have translucent bars, while keeping all the
+++ text on it opaque, just like the alpha-patch for st. Updated for 348f655.
+++
+++---
+++ config.def.h |  7 +++++++
+++ config.mk    |  2 +-
+++ drw.c        | 26 ++++++++++++-----------
+++ drw.h        |  9 +++++---
+++ dwm.c        | 59 ++++++++++++++++++++++++++++++++++++++++++++++------
+++ 5 files changed, 81 insertions(+), 22 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 9efa774..8b3789a 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -12,11 +12,18 @@ static const char col_gray2[]       = "#444444";
+++ static const char col_gray3[]       = "#bbbbbb";
+++ static const char col_gray4[]       = "#eeeeee";
+++ static const char col_cyan[]        = "#005577";
++++static const unsigned int baralpha = 0xd0;
++++static const unsigned int borderalpha = OPAQUE;
+++ static const char *colors[][3]      = {
+++ 	/*               fg         bg         border   */
+++ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+++ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+++ };
++++static const unsigned int alphas[][3]      = {
++++    /*               fg      bg        border*/
++++    [SchemeNorm] = { OPAQUE, baralpha, borderalpha },
++++	[SchemeSel]  = { OPAQUE, baralpha, borderalpha },
++++};
+++ 
+++ /* tagging */
+++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+++diff --git a/config.mk b/config.mk
+++index ba64d3d..d609c42 100644
+++--- a/config.mk
++++++ b/config.mk
+++@@ -23,7 +23,7 @@ FREETYPEINC = /usr/include/freetype2
+++ 
+++ # includes and libs
+++ INCS = -I${X11INC} -I${FREETYPEINC}
+++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lXrender
+++ 
+++ # flags
+++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+++diff --git a/drw.c b/drw.c
+++index a58a2b4..d18e8d8 100644
+++--- a/drw.c
++++++ b/drw.c
+++@@ -61,7 +61,7 @@ utf8decode(const char *c, long *u, size_t clen)
+++ }
+++ 
+++ Drw *
+++-drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
++++drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap)
+++ {
+++ 	Drw *drw = ecalloc(1, sizeof(Drw));
+++ 
+++@@ -70,8 +70,11 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
+++ 	drw->root = root;
+++ 	drw->w = w;
+++ 	drw->h = h;
+++-	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+++-	drw->gc = XCreateGC(dpy, root, 0, NULL);
++++	drw->visual = visual;
++++	drw->depth = depth;
++++	drw->cmap = cmap;
++++	drw->drawable = XCreatePixmap(dpy, root, w, h, depth);
++++	drw->gc = XCreateGC(dpy, drw->drawable, 0, NULL);
+++ 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+++ 
+++ 	return drw;
+++@@ -87,7 +90,7 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
+++ 	drw->h = h;
+++ 	if (drw->drawable)
+++ 		XFreePixmap(drw->dpy, drw->drawable);
+++-	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++++	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, drw->depth);
+++ }
+++ 
+++ void
+++@@ -181,21 +184,22 @@ drw_fontset_free(Fnt *font)
+++ }
+++ 
+++ void
+++-drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++++drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha)
+++ {
+++ 	if (!drw || !dest || !clrname)
+++ 		return;
+++ 
+++-	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+++-	                       DefaultColormap(drw->dpy, drw->screen),
++++	if (!XftColorAllocName(drw->dpy, drw->visual, drw->cmap,
+++ 	                       clrname, dest))
+++ 		die("error, cannot allocate color '%s'", clrname);
++++
++++    dest->pixel = (dest->pixel & 0x00ffffffU) | (alpha << 24);
+++ }
+++ 
+++ /* Wrapper to create color schemes. The caller has to call free(3) on the
+++  * returned color scheme when done using it. */
+++ Clr *
+++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++++drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount)
+++ {
+++ 	size_t i;
+++ 	Clr *ret;
+++@@ -205,7 +209,7 @@ drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+++ 		return NULL;
+++ 
+++ 	for (i = 0; i < clrcount; i++)
+++-		drw_clr_create(drw, &ret[i], clrnames[i]);
++++		drw_clr_create(drw, &ret[i], clrnames[i], alphas[i]);
+++ 	return ret;
+++ }
+++ 
+++@@ -263,9 +267,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+++ 	} else {
+++ 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+++ 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+++-		d = XftDrawCreate(drw->dpy, drw->drawable,
+++-		                  DefaultVisual(drw->dpy, drw->screen),
+++-		                  DefaultColormap(drw->dpy, drw->screen));
++++		d = XftDrawCreate(drw->dpy, drw->drawable, drw->visual, drw->cmap);
+++ 		x += lpad;
+++ 		w -= lpad;
+++ 	}
+++diff --git a/drw.h b/drw.h
+++index 6471431..2143533 100644
+++--- a/drw.h
++++++ b/drw.h
+++@@ -20,6 +20,9 @@ typedef struct {
+++ 	Display *dpy;
+++ 	int screen;
+++ 	Window root;
++++    Visual *visual;
++++    unsigned int depth;
++++    Colormap cmap;
+++ 	Drawable drawable;
+++ 	GC gc;
+++ 	Clr *scheme;
+++@@ -27,7 +30,7 @@ typedef struct {
+++ } Drw;
+++ 
+++ /* Drawable abstraction */
+++-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
++++Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap);
+++ void drw_resize(Drw *drw, unsigned int w, unsigned int h);
+++ void drw_free(Drw *drw);
+++ 
+++@@ -39,8 +42,8 @@ unsigned int drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int
+++ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
+++ 
+++ /* Colorscheme abstraction */
+++-void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++++void drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha);
++++Clr *drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount);
+++ 
+++ /* Cursor abstraction */
+++ Cur *drw_cur_create(Drw *drw, int shape);
+++diff --git a/dwm.c b/dwm.c
+++index c2bd871..3b34de8 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -56,6 +56,7 @@
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++++#define OPAQUE                  0xffU
+++ 
+++ /* enums */
+++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+++@@ -232,6 +233,7 @@ static Monitor *wintomon(Window w);
+++ static int xerror(Display *dpy, XErrorEvent *ee);
+++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++++static void xinitvisual();
+++ static void zoom(const Arg *arg);
+++ 
+++ /* variables */
+++@@ -268,6 +270,11 @@ static Drw *drw;
+++ static Monitor *mons, *selmon;
+++ static Window root, wmcheckwin;
+++ 
++++static int useargb = 0;
++++static Visual *visual;
++++static int depth;
++++static Colormap cmap;
++++
+++ /* configuration, allows nested code to access above variables */
+++ #include "config.h"
+++ 
+++@@ -1558,7 +1565,8 @@ setup(void)
+++ 	sw = DisplayWidth(dpy, screen);
+++ 	sh = DisplayHeight(dpy, screen);
+++ 	root = RootWindow(dpy, screen);
+++-	drw = drw_create(dpy, screen, root, sw, sh);
++++	xinitvisual();
++++	drw = drw_create(dpy, screen, root, sw, sh, visual, depth, cmap);
+++ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+++ 		die("no fonts could be loaded.");
+++ 	lrpad = drw->fonts->h;
+++@@ -1586,7 +1594,7 @@ setup(void)
+++ 	/* init appearance */
+++ 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+++ 	for (i = 0; i < LENGTH(colors); i++)
+++-		scheme[i] = drw_scm_create(drw, colors[i], 3);
++++		scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 3);
+++ 	/* init bars */
+++ 	updatebars();
+++ 	updatestatus();
+++@@ -1813,16 +1821,18 @@ updatebars(void)
+++ 	Monitor *m;
+++ 	XSetWindowAttributes wa = {
+++ 		.override_redirect = True,
+++-		.background_pixmap = ParentRelative,
++++		.background_pixel = 0,
++++		.border_pixel = 0,
++++		.colormap = cmap,
+++ 		.event_mask = ButtonPressMask|ExposureMask
+++ 	};
+++ 	XClassHint ch = {"dwm", "dwm"};
+++ 	for (m = mons; m; m = m->next) {
+++ 		if (m->barwin)
+++ 			continue;
+++-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+++-				CopyFromParent, DefaultVisual(dpy, screen),
+++-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, depth,
++++				InputOutput, visual,
++++				CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
+++ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+++ 		XMapRaised(dpy, m->barwin);
+++ 		XSetClassHint(dpy, m->barwin, &ch);
+++@@ -2120,6 +2130,43 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
+++ 	return -1;
+++ }
+++ 
++++void
++++xinitvisual()
++++{
++++    XVisualInfo *infos;
++++	XRenderPictFormat *fmt;
++++	int nitems;
++++	int i;
++++
++++	XVisualInfo tpl = {
++++        .screen = screen,
++++		.depth = 32,
++++		.class = TrueColor
++++	};
++++	long masks = VisualScreenMask | VisualDepthMask | VisualClassMask;
++++
++++	infos = XGetVisualInfo(dpy, masks, &tpl, &nitems);
++++	visual = NULL;
++++	for(i = 0; i < nitems; i ++) {
++++        fmt = XRenderFindVisualFormat(dpy, infos[i].visual);
++++		if (fmt->type == PictTypeDirect && fmt->direct.alphaMask) {
++++            visual = infos[i].visual;
++++			depth = infos[i].depth;
++++			cmap = XCreateColormap(dpy, root, visual, AllocNone);
++++			useargb = 1;
++++			break;
++++        }
++++    }
++++
++++	XFree(infos);
++++
++++	if (! visual) {
++++        visual = DefaultVisual(dpy, screen);
++++		depth = DefaultDepth(dpy, screen);
++++		cmap = DefaultColormap(dpy, screen);
++++    }
++++}
++++
+++ void
+++ zoom(const Arg *arg)
+++ {
+++-- 
+++2.40.0
+++
++diff --git a/patches/dwm-autostart-20210120-cb3f58a.diff b/patches/dwm-autostart-20210120-cb3f58a.diff
++new file mode 100644
++index 0000000..efee676
++--- /dev/null
+++++ b/patches/dwm-autostart-20210120-cb3f58a.diff
++@@ -0,0 +1,179 @@
+++From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
+++From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
+++Date: Wed, 10 Jun 2020 10:59:02 +0000
+++Subject: [PATCH] dwm-xdgautostart-6.2.diff
+++
+++===================================================================
+++---
+++ dwm.1 | 23 +++++++++++++++++
+++ dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++ 2 files changed, 105 insertions(+)
+++
+++diff --git a/dwm.1 b/dwm.1
+++index 13b3729..9533aa6 100644
+++--- a/dwm.1
++++++ b/dwm.1
+++@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+++ indicated with an empty square in the top left corner.
+++ .P
+++ dwm draws a small border around windows to indicate the focus state.
++++.P
++++On start, dwm can start additional programs that may be specified in two special
++++shell scripts (see the FILES section below), autostart_blocking.sh and
++++autostart.sh.  The former is executed first and dwm will wait for its
++++termination before starting.  The latter is executed in the background before
++++dwm enters its handler loop.
++++.P
++++Either of these files may be omitted.
+++ .SH OPTIONS
+++ .TP
+++ .B \-v
+++@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
+++ .TP
+++ .B Mod1\-Button3
+++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++++.SH FILES
++++The files containing programs to be started along with dwm are searched for in
++++the following directories:
++++.IP "1. $XDG_DATA_HOME/dwm"
++++.IP "2. $HOME/.local/share/dwm"
++++.IP "3. $HOME/.dwm"
++++.P
++++The first existing directory is scanned for any of the autostart files below.
++++.TP 15
++++autostart.sh
++++This file is started as a shell background process before dwm enters its handler
++++loop.
++++.TP 15
++++autostart_blocking.sh
++++This file is started before any autostart.sh; dwm waits for its termination.
+++ .SH CUSTOMIZATION
+++ dwm is customized by creating a custom config.h and (re)compiling the source
+++ code. This keeps it fast, secure and simple.
+++diff --git a/dwm.c b/dwm.c
+++index 4465af1..2156b49 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -29,6 +29,7 @@
+++ #include <string.h>
+++ #include <unistd.h>
+++ #include <sys/types.h>
++++#include <sys/stat.h>
+++ #include <sys/wait.h>
+++ #include <X11/cursorfont.h>
+++ #include <X11/keysym.h>
+++@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+++ static void resizemouse(const Arg *arg);
+++ static void restack(Monitor *m);
+++ static void run(void);
++++static void runautostart(void);
+++ static void scan(void);
+++ static int sendevent(Client *c, Atom proto);
+++ static void sendmon(Client *c, Monitor *m);
+++@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
+++ 
+++ /* variables */
++++static const char autostartblocksh[] = "autostart_blocking.sh";
++++static const char autostartsh[] = "autostart.sh";
+++ static const char broken[] = "broken";
++++static const char dwmdir[] = "dwm";
++++static const char localshare[] = ".local/share";
+++ static char stext[256];
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++@@ -1380,6 +1386,83 @@ run(void)
+++ 			handler[ev.type](&ev); /* call handler */
+++ }
+++ 
++++void
++++runautostart(void)
++++{
++++	char *pathpfx;
++++	char *path;
++++	char *xdgdatahome;
++++	char *home;
++++	struct stat sb;
++++
++++	if ((home = getenv("HOME")) == NULL)
++++		/* this is almost impossible */
++++		return;
++++
++++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++++	 * otherwise use ~/.local/share/dwm as autostart script directory
++++	 */
++++	xdgdatahome = getenv("XDG_DATA_HOME");
++++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++++		/* space for path segments, separators and nul */
++++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++++
++++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	} else {
++++		/* space for path segments, separators and nul */
++++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++++		                     + strlen(dwmdir) + 3);
++++
++++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	}
++++
++++	/* check if the autostart script directory exists */
++++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++++		/* the XDG conformant path does not exist or is no directory
++++		 * so we try ~/.dwm instead
++++		 */
++++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++++		if(pathpfx_new == NULL) {
++++			free(pathpfx);
++++			return;
++++		}
++++		pathpfx = pathpfx_new;
++++
++++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	}
++++
++++	/* try the blocking script first */
++++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++++		free(path);
++++		free(pathpfx);
++++	}
++++
++++	if (access(path, X_OK) == 0)
++++		system(path);
++++
++++	/* now the non-blocking script */
++++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++++		free(path);
++++		free(pathpfx);
++++	}
++++
++++	if (access(path, X_OK) == 0)
++++		system(strcat(path, " &"));
++++
++++	free(pathpfx);
++++	free(path);
++++}
++++
+++ void
+++ scan(void)
+++ {
+++@@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
+++ 		die("pledge");
+++ #endif /* __OpenBSD__ */
+++ 	scan();
++++	runautostart();
+++ 	run();
+++ 	cleanup();
+++ 	XCloseDisplay(dpy);
+++-- 
+++2.27.0
+++
++diff --git a/patches/dwm-cfacts-vanitygaps-6.4_combo.diff b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
++new file mode 100644
++index 0000000..db2cc14
++--- /dev/null
+++++ b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
++@@ -0,0 +1,1018 @@
+++diff --git a/config.def.h b/config.def.h
+++index 9efa774..357dc6f 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -3,6 +3,11 @@
+++ /* appearance */
+++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
++++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+++ static const int showbar            = 1;        /* 0 means no bar */
+++ static const int topbar             = 1;        /* 0 means bottom bar */
+++ static const char *fonts[]          = { "monospace:size=10" };
+++@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+++ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+++ 
++++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++++#include "vanitygaps.c"
++++
+++ static const Layout layouts[] = {
+++ 	/* symbol     arrange function */
+++ 	{ "[]=",      tile },    /* first entry is default */
+++-	{ "><>",      NULL },    /* no layout function means floating behavior */
+++ 	{ "[M]",      monocle },
++++	{ "[@]",      spiral },
++++	{ "[\\]",     dwindle },
++++	{ "H[]",      deck },
++++	{ "TTT",      bstack },
++++	{ "===",      bstackhoriz },
++++	{ "HHH",      grid },
++++	{ "###",      nrowgrid },
++++	{ "---",      horizgrid },
++++	{ ":::",      gaplessgrid },
++++	{ "|M|",      centeredmaster },
++++	{ ">M>",      centeredfloatingmaster },
++++	{ "><>",      NULL },    /* no layout function means floating behavior */
++++	{ NULL,       NULL },
+++ };
+++ 
+++ /* key definitions */
+++@@ -71,7 +91,26 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+++ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+++diff --git a/dwm.c b/dwm.c
+++index f1d86b2..5bbd733 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -87,6 +87,7 @@ typedef struct Client Client;
+++ struct Client {
+++ 	char name[256];
+++ 	float mina, maxa;
++++	float cfact;
+++ 	int x, y, w, h;
+++ 	int oldx, oldy, oldw, oldh;
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++@@ -119,6 +120,10 @@ struct Monitor {
+++ 	int by;               /* bar geometry */
+++ 	int mx, my, mw, mh;   /* screen size */
+++ 	int wx, wy, ww, wh;   /* window area  */
++++	int gappih;           /* horizontal gap between windows */
++++	int gappiv;           /* vertical gap between windows */
++++	int gappoh;           /* horizontal outer gaps */
++++	int gappov;           /* vertical outer gaps */
+++ 	unsigned int seltags;
+++ 	unsigned int sellt;
+++ 	unsigned int tagset[2];
+++@@ -201,6 +206,7 @@ static void setclientstate(Client *c, long state);
+++ static void setfocus(Client *c);
+++ static void setfullscreen(Client *c, int fullscreen);
+++ static void setlayout(const Arg *arg);
++++static void setcfact(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++ static void setup(void);
+++ static void seturgent(Client *c, int urg);
+++@@ -208,7 +214,6 @@ static void showhide(Client *c);
+++ static void spawn(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++-static void tile(Monitor *m);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++@@ -641,6 +646,10 @@ createmon(void)
+++ 	m->nmaster = nmaster;
+++ 	m->showbar = showbar;
+++ 	m->topbar = topbar;
++++	m->gappih = gappih;
++++	m->gappiv = gappiv;
++++	m->gappoh = gappoh;
++++	m->gappov = gappov;
+++ 	m->lt[0] = &layouts[0];
+++ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+++ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+++@@ -1043,6 +1052,7 @@ manage(Window w, XWindowAttributes *wa)
+++ 	c->w = c->oldw = wa->width;
+++ 	c->h = c->oldh = wa->height;
+++ 	c->oldbw = wa->border_width;
++++	c->cfact = 1.0;
+++ 
+++ 	updatetitle(c);
+++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+++@@ -1521,6 +1531,24 @@ setlayout(const Arg *arg)
+++ 		drawbar(selmon);
+++ }
+++ 
++++void
++++setcfact(const Arg *arg) {
++++	float f;
++++	Client *c;
++++
++++	c = selmon->sel;
++++
++++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++++		return;
++++	f = arg->f + c->cfact;
++++	if(arg->f == 0.0)
++++		f = 1.0;
++++	else if(f < 0.25 || f > 4.0)
++++		return;
++++	c->cfact = f;
++++	arrange(selmon);
++++}
++++
+++ /* arg > 1.0 will set mfact absolutely */
+++ void
+++ setmfact(const Arg *arg)
+++@@ -1684,34 +1712,6 @@ tagmon(const Arg *arg)
+++ 	sendmon(selmon->sel, dirtomon(arg->i));
+++ }
+++ 
+++-void
+++-tile(Monitor *m)
+++-{
+++-	unsigned int i, n, h, mw, my, ty;
+++-	Client *c;
+++-
+++-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++-	if (n == 0)
+++-		return;
+++-
+++-	if (n > m->nmaster)
+++-		mw = m->nmaster ? m->ww * m->mfact : 0;
+++-	else
+++-		mw = m->ww;
+++-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++-		if (i < m->nmaster) {
+++-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+++-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+++-			if (my + HEIGHT(c) < m->wh)
+++-				my += HEIGHT(c);
+++-		} else {
+++-			h = (m->wh - ty) / (n - i);
+++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+++-			if (ty + HEIGHT(c) < m->wh)
+++-				ty += HEIGHT(c);
+++-		}
+++-}
+++-
+++ void
+++ togglebar(const Arg *arg)
+++ {
+++diff --git a/vanitygaps.c b/vanitygaps.c
+++new file mode 100644
+++index 0000000..1a816b6
+++--- /dev/null
++++++ b/vanitygaps.c
+++@@ -0,0 +1,822 @@
++++/* Key binding functions */
++++static void defaultgaps(const Arg *arg);
++++static void incrgaps(const Arg *arg);
++++static void incrigaps(const Arg *arg);
++++static void incrogaps(const Arg *arg);
++++static void incrohgaps(const Arg *arg);
++++static void incrovgaps(const Arg *arg);
++++static void incrihgaps(const Arg *arg);
++++static void incrivgaps(const Arg *arg);
++++static void togglegaps(const Arg *arg);
++++/* Layouts (delete the ones you do not need) */
++++static void bstack(Monitor *m);
++++static void bstackhoriz(Monitor *m);
++++static void centeredmaster(Monitor *m);
++++static void centeredfloatingmaster(Monitor *m);
++++static void deck(Monitor *m);
++++static void dwindle(Monitor *m);
++++static void fibonacci(Monitor *m, int s);
++++static void grid(Monitor *m);
++++static void nrowgrid(Monitor *m);
++++static void spiral(Monitor *m);
++++static void tile(Monitor *m);
++++/* Internals */
++++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++++static void setgaps(int oh, int ov, int ih, int iv);
++++
++++/* Settings */
++++#if !PERTAG_PATCH
++++static int enablegaps = 1;
++++#endif // PERTAG_PATCH
++++
++++void
++++setgaps(int oh, int ov, int ih, int iv)
++++{
++++	if (oh < 0) oh = 0;
++++	if (ov < 0) ov = 0;
++++	if (ih < 0) ih = 0;
++++	if (iv < 0) iv = 0;
++++
++++	selmon->gappoh = oh;
++++	selmon->gappov = ov;
++++	selmon->gappih = ih;
++++	selmon->gappiv = iv;
++++	arrange(selmon);
++++}
++++
++++void
++++togglegaps(const Arg *arg)
++++{
++++	#if PERTAG_PATCH
++++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++++	#else
++++	enablegaps = !enablegaps;
++++	#endif // PERTAG_PATCH
++++	arrange(NULL);
++++}
++++
++++void
++++defaultgaps(const Arg *arg)
++++{
++++	setgaps(gappoh, gappov, gappih, gappiv);
++++}
++++
++++void
++++incrgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov + arg->i,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++incrigaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++incrogaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov + arg->i,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrohgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrovgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov + arg->i,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrihgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrivgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++++{
++++	unsigned int n, oe, ie;
++++	#if PERTAG_PATCH
++++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++++	#else
++++	oe = ie = enablegaps;
++++	#endif // PERTAG_PATCH
++++	Client *c;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++++	if (smartgaps && n == 1) {
++++		oe = 0; // outer gaps disabled when only one client
++++	}
++++
++++	*oh = m->gappoh*oe; // outer horizontal gap
++++	*ov = m->gappov*oe; // outer vertical gap
++++	*ih = m->gappih*ie; // inner horizontal gap
++++	*iv = m->gappiv*ie; // inner vertical gap
++++	*nc = n;            // number of clients
++++}
++++
++++void
++++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++++{
++++	unsigned int n;
++++	float mfacts = 0, sfacts = 0;
++++	int mtotal = 0, stotal = 0;
++++	Client *c;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (n < m->nmaster)
++++			mfacts += c->cfact;
++++		else
++++			sfacts += c->cfact;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (n < m->nmaster)
++++			mtotal += msize * (c->cfact / mfacts);
++++		else
++++			stotal += ssize * (c->cfact / sfacts);
++++
++++	*mf = mfacts; // total factor of master area
++++	*sf = sfacts; // total factor of stack area
++++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++++}
++++
++++/***
++++ * Layouts
++++ */
++++
++++/*
++++ * Bottomstack layout + gaps
++++ * https://dwm.suckless.org/patches/bottomstack/
++++ */
++++static void
++++bstack(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sh = (mh - ih) * (1 - m->mfact);
++++		mh = mh - ih - sh;
++++		sx = mx;
++++		sy = my + mh + ih;
++++	}
++++
++++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++	}
++++}
++++
++++static void
++++bstackhoriz(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	mh = m->wh - 2*oh;
++++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++++	sw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sh = (mh - ih) * (1 - m->mfact);
++++		mh = mh - ih - sh;
++++		sy = my + mh + ih;
++++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++++	}
++++
++++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++++			sy += HEIGHT(c) + ih;
++++		}
++++	}
++++}
++++
++++/*
++++ * Centred master layout + gaps
++++ * https://dwm.suckless.org/patches/centeredmaster/
++++ */
++++void
++++centeredmaster(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int lx = 0, ly = 0, lw = 0, lh = 0;
++++	int rx = 0, ry = 0, rw = 0, rh = 0;
++++	float mfacts = 0, lfacts = 0, rfacts = 0;
++++	int mtotal = 0, ltotal = 0, rtotal = 0;
++++	int mrest = 0, lrest = 0, rrest = 0;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	/* initialize areas */
++++	mx = m->wx + ov;
++++	my = m->wy + oh;
++++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++++	mw = m->ww - 2*ov;
++++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		/* go mfact box in the center if more than nmaster clients */
++++		if (n - m->nmaster > 1) {
++++			/* ||<-S->|<---M--->|<-S->|| */
++++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++++			mx += lw + iv;
++++		} else {
++++			/* ||<---M--->|<-S->|| */
++++			mw = (mw - iv) * m->mfact;
++++			lw = 0;
++++			rw = m->ww - mw - iv - 2*ov;
++++		}
++++		lx = m->wx + ov;
++++		ly = m->wy + oh;
++++		rx = mx + mw + iv;
++++		ry = m->wy + oh;
++++	}
++++
++++	/* calculate facts */
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++++		if (!m->nmaster || n < m->nmaster)
++++			mfacts += c->cfact;
++++		else if ((n - m->nmaster) % 2)
++++			lfacts += c->cfact; // total factor of left hand stack area
++++		else
++++			rfacts += c->cfact; // total factor of right hand stack area
++++	}
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (!m->nmaster || n < m->nmaster)
++++			mtotal += mh * (c->cfact / mfacts);
++++		else if ((n - m->nmaster) % 2)
++++			ltotal += lh * (c->cfact / lfacts);
++++		else
++++			rtotal += rh * (c->cfact / rfacts);
++++
++++	mrest = mh - mtotal;
++++	lrest = lh - ltotal;
++++	rrest = rh - rtotal;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (!m->nmaster || i < m->nmaster) {
++++			/* nmaster clients are stacked vertically, in the center of the screen */
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			/* stack clients are stacked vertically */
++++			if ((i - m->nmaster) % 2 ) {
++++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++++				ly += HEIGHT(c) + ih;
++++			} else {
++++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++++				ry += HEIGHT(c) + ih;
++++			}
++++		}
++++	}
++++}
++++
++++void
++++centeredfloatingmaster(Monitor *m)
++++{
++++	unsigned int i, n;
++++	float mfacts, sfacts;
++++	float mivf = 1.0; // master inner vertical gap factor
++++	int oh, ov, ih, iv, mrest, srest;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	mw = m->ww - 2*ov - iv*(n - 1);
++++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		mivf = 0.8;
++++		/* go mfact box in the center if more than nmaster clients */
++++		if (m->ww > m->wh) {
++++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++++			mh = m->wh * 0.9;
++++		} else {
++++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++++			mh = m->wh * m->mfact;
++++		}
++++		mx = m->wx + (m->ww - mw) / 2;
++++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++++
++++		sx = m->wx + ov;
++++		sy = m->wy + oh;
++++		sh = m->wh - 2*oh;
++++	}
++++
++++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			/* nmaster clients are stacked horizontally, in the center of the screen */
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv*mivf;
++++		} else {
++++			/* stack clients are stacked horizontally */
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++}
++++
++++/*
++++ * Deck layout + gaps
++++ * https://dwm.suckless.org/patches/deck/
++++ */
++++void
++++deck(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sw = (mw - iv) * (1 - m->mfact);
++++		mw = mw - iv - sw;
++++		sx = mx + mw + iv;
++++		sh = m->wh - 2*oh;
++++	}
++++
++++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	if (n - m->nmaster > 0) /* override layout symbol */
++++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++++		}
++++}
++++
++++/*
++++ * Fibonacci layout + gaps
++++ * https://dwm.suckless.org/patches/fibonacci/
++++ */
++++void
++++fibonacci(Monitor *m, int s)
++++{
++++	unsigned int i, n;
++++	int nx, ny, nw, nh;
++++	int oh, ov, ih, iv;
++++	int nv, hrest = 0, wrest = 0, r = 1;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	nx = m->wx + ov;
++++	ny = m->wy + oh;
++++	nw = m->ww - 2*ov;
++++	nh = m->wh - 2*oh;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++++		if (r) {
++++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++++				r = 0;
++++			}
++++			if (r && i < n - 1) {
++++				if (i % 2) {
++++					nv = (nh - ih) / 2;
++++					hrest = nh - 2*nv - ih;
++++					nh = nv;
++++				} else {
++++					nv = (nw - iv) / 2;
++++					wrest = nw - 2*nv - iv;
++++					nw = nv;
++++				}
++++
++++				if ((i % 4) == 2 && !s)
++++					nx += nw + iv;
++++				else if ((i % 4) == 3 && !s)
++++					ny += nh + ih;
++++			}
++++
++++			if ((i % 4) == 0) {
++++				if (s) {
++++					ny += nh + ih;
++++					nh += hrest;
++++				}
++++				else {
++++					nh -= hrest;
++++					ny -= nh + ih;
++++				}
++++			}
++++			else if ((i % 4) == 1) {
++++				nx += nw + iv;
++++				nw += wrest;
++++			}
++++			else if ((i % 4) == 2) {
++++				ny += nh + ih;
++++				nh += hrest;
++++				if (i < n - 1)
++++					nw += wrest;
++++			}
++++			else if ((i % 4) == 3) {
++++				if (s) {
++++					nx += nw + iv;
++++					nw -= wrest;
++++				} else {
++++					nw -= wrest;
++++					nx -= nw + iv;
++++					nh += hrest;
++++				}
++++			}
++++			if (i == 0)	{
++++				if (n != 1) {
++++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++++					wrest = 0;
++++				}
++++				ny = m->wy + oh;
++++			}
++++			else if (i == 1)
++++				nw = m->ww - nw - iv - 2*ov;
++++			i++;
++++		}
++++
++++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++++	}
++++}
++++
++++void
++++dwindle(Monitor *m)
++++{
++++	fibonacci(m, 1);
++++}
++++
++++void
++++spiral(Monitor *m)
++++{
++++	fibonacci(m, 0);
++++}
++++
++++/*
++++ * Gappless grid layout + gaps (ironically)
++++ * https://dwm.suckless.org/patches/gaplessgrid/
++++ */
++++void
++++gaplessgrid(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++++	int oh, ov, ih, iv;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	/* grid dimensions */
++++	for (cols = 0; cols <= n/2; cols++)
++++		if (cols*cols >= n)
++++			break;
++++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++++		cols = 2;
++++	rows = n/cols;
++++	cn = rn = 0; // reset column no, row no, client count
++++
++++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++++	x = m->wx + ov;
++++	y = m->wy + oh;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++++		if (i/rows + 1 > cols - n%cols) {
++++			rows = n/cols + 1;
++++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++		}
++++		resize(c,
++++			x,
++++			y + rn*(ch + ih) + MIN(rn, rrest),
++++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++++			0);
++++		rn++;
++++		if (rn >= rows) {
++++			rn = 0;
++++			x += cw + ih + (cn < crest ? 1 : 0);
++++			cn++;
++++		}
++++	}
++++}
++++
++++/*
++++ * Gridmode layout + gaps
++++ * https://dwm.suckless.org/patches/gridmode/
++++ */
++++void
++++grid(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++++	int oh, ov, ih, iv;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++
++++	/* grid dimensions */
++++	for (rows = 0; rows <= n/2; rows++)
++++		if (rows*rows >= n)
++++			break;
++++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++++
++++	/* window geoms (cell height/width) */
++++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		cc = i / rows;
++++		cr = i % rows;
++++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++++	}
++++}
++++
++++/*
++++ * Horizontal grid layout + gaps
++++ * https://dwm.suckless.org/patches/horizgrid/
++++ */
++++void
++++horizgrid(Monitor *m) {
++++	Client *c;
++++	unsigned int n, i;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	int ntop, nbottom = 1;
++++	float mfacts = 0, sfacts = 0;
++++	int mrest, srest, mtotal = 0, stotal = 0;
++++
++++	/* Count windows */
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	if (n <= 2)
++++		ntop = n;
++++	else {
++++		ntop = n / 2;
++++		nbottom = n - ntop;
++++	}
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (n > ntop) {
++++		sh = (mh - ih) / 2;
++++		mh = mh - ih - sh;
++++		sy = my + mh + ih;
++++		mw = m->ww - 2*ov - iv * (ntop - 1);
++++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++++	}
++++
++++	/* calculate facts */
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop)
++++			mfacts += c->cfact;
++++		else
++++			sfacts += c->cfact;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop)
++++			mtotal += mh * (c->cfact / mfacts);
++++		else
++++			stotal += sw * (c->cfact / sfacts);
++++
++++	mrest = mh - mtotal;
++++	srest = sw - stotal;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++}
++++
++++/*
++++ * nrowgrid layout + gaps
++++ * https://dwm.suckless.org/patches/nrowgrid/
++++ */
++++void
++++nrowgrid(Monitor *m)
++++{
++++	unsigned int n;
++++	int ri = 0, ci = 0;  /* counters */
++++	int oh, ov, ih, iv;                         /* vanitygap settings */
++++	unsigned int cx, cy, cw, ch;                /* client geometry */
++++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++++	unsigned int cols, rows = m->nmaster + 1;
++++	Client *c;
++++
++++	/* count clients */
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++
++++	/* nothing to do here */
++++	if (n == 0)
++++		return;
++++
++++	/* force 2 clients to always split vertically */
++++	if (FORCE_VSPLIT && n == 2)
++++		rows = 1;
++++
++++	/* never allow empty rows */
++++	if (n < rows)
++++		rows = n;
++++
++++	/* define first row */
++++	cols = n / rows;
++++	uc = cols;
++++	cy = m->wy + oh;
++++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++++	uh = ch;
++++
++++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++++		if (ci == cols) {
++++			uw = 0;
++++			ci = 0;
++++			ri++;
++++
++++			/* next row */
++++			cols = (n - uc) / (rows - ri);
++++			uc += cols;
++++			cy = m->wy + oh + uh + ih;
++++			uh += ch + ih;
++++		}
++++
++++		cx = m->wx + ov + uw;
++++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++++		uw += cw + iv;
++++
++++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++++	}
++++}
++++
++++/*
++++ * Default tile layout + gaps
++++ */
++++static void
++++tile(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sw = (mw - iv) * (1 - m->mfact);
++++		mw = mw - iv - sw;
++++		sx = mx + mw + iv;
++++	}
++++
++++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++++			sy += HEIGHT(c) + ih;
++++		}
++++}
+++\ No newline at end of file
++diff --git a/patches/dwm-focusonclick-20200110-61bb8b2.diff b/patches/dwm-focusonclick-20200110-61bb8b2.diff
++new file mode 100644
++index 0000000..59c7a1d
++--- /dev/null
+++++ b/patches/dwm-focusonclick-20200110-61bb8b2.diff
++@@ -0,0 +1,130 @@
+++From 7ac0b812540e21b470f2f6947c6cc1e30bf24b42 Mon Sep 17 00:00:00 2001
+++From: iofq <cjriddz@protonmail.com>
+++Date: Sun, 10 Jan 2021 22:43:16 -0600
+++Subject: [PATCH] tweak fixes floating window mouse controls
+++
+++---
+++ config.def.h |  1 +
+++ dwm.c        | 47 ++++-------------------------------------------
+++ 2 files changed, 5 insertions(+), 43 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 1c0b587..4f2c946 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -5,6 +5,7 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
+++ static const int showbar            = 1;        /* 0 means no bar */
+++ static const int topbar             = 1;        /* 0 means bottom bar */
++++static const int focusonwheel       = 0;
+++ static const char *fonts[]          = { "monospace:size=10" };
+++ static const char dmenufont[]       = "monospace:size=10";
+++ static const char col_gray1[]       = "#222222";
+++diff --git a/dwm.c b/dwm.c
+++index 664c527..de3e883 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -163,7 +163,6 @@ static void detachstack(Client *c);
+++ static Monitor *dirtomon(int dir);
+++ static void drawbar(Monitor *m);
+++ static void drawbars(void);
+++-static void enternotify(XEvent *e);
+++ static void expose(XEvent *e);
+++ static void focus(Client *c);
+++ static void focusin(XEvent *e);
+++@@ -182,7 +181,6 @@ static void manage(Window w, XWindowAttributes *wa);
+++ static void mappingnotify(XEvent *e);
+++ static void maprequest(XEvent *e);
+++ static void monocle(Monitor *m);
+++-static void motionnotify(XEvent *e);
+++ static void movemouse(const Arg *arg);
+++ static Client *nexttiled(Client *c);
+++ static void pop(Client *);
+++@@ -250,13 +248,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+++ 	[ConfigureRequest] = configurerequest,
+++ 	[ConfigureNotify] = configurenotify,
+++ 	[DestroyNotify] = destroynotify,
+++-	[EnterNotify] = enternotify,
+++ 	[Expose] = expose,
+++ 	[FocusIn] = focusin,
+++ 	[KeyPress] = keypress,
+++ 	[MappingNotify] = mappingnotify,
+++ 	[MapRequest] = maprequest,
+++-	[MotionNotify] = motionnotify,
+++ 	[PropertyNotify] = propertynotify,
+++ 	[UnmapNotify] = unmapnotify
+++ };
+++@@ -425,7 +421,8 @@ buttonpress(XEvent *e)
+++ 
+++ 	click = ClkRootWin;
+++ 	/* focus monitor if necessary */
+++-	if ((m = wintomon(ev->window)) && m != selmon) {
++++	if ((m = wintomon(ev->window)) && m != selmon
++++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+++ 		unfocus(selmon->sel, 1);
+++ 		selmon = m;
+++ 		focus(NULL);
+++@@ -445,8 +442,8 @@ buttonpress(XEvent *e)
+++ 		else
+++ 			click = ClkWinTitle;
+++ 	} else if ((c = wintoclient(ev->window))) {
+++-		focus(c);
+++-		restack(selmon);
++++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++++			focus(c);
+++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+++ 		click = ClkClientWin;
+++ 	}
+++@@ -752,25 +749,6 @@ drawbars(void)
+++ 		drawbar(m);
+++ }
+++ 
+++-void
+++-enternotify(XEvent *e)
+++-{
+++-	Client *c;
+++-	Monitor *m;
+++-	XCrossingEvent *ev = &e->xcrossing;
+++-
+++-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+++-		return;
+++-	c = wintoclient(ev->window);
+++-	m = c ? c->mon : wintomon(ev->window);
+++-	if (m != selmon) {
+++-		unfocus(selmon->sel, 1);
+++-		selmon = m;
+++-	} else if (!c || c == selmon->sel)
+++-		return;
+++-	focus(c);
+++-}
+++-
+++ void
+++ expose(XEvent *e)
+++ {
+++@@ -1116,23 +1094,6 @@ monocle(Monitor *m)
+++ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+++ }
+++ 
+++-void
+++-motionnotify(XEvent *e)
+++-{
+++-	static Monitor *mon = NULL;
+++-	Monitor *m;
+++-	XMotionEvent *ev = &e->xmotion;
+++-
+++-	if (ev->window != root)
+++-		return;
+++-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+++-		unfocus(selmon->sel, 1);
+++-		selmon = m;
+++-		focus(NULL);
+++-	}
+++-	mon = m;
+++-}
+++-
+++ void
+++ movemouse(const Arg *arg)
+++ {
+++-- 
+++2.30.0
+++
++diff --git a/patches/dwm-hide_vacant_tags-6.4.diff b/patches/dwm-hide_vacant_tags-6.4.diff
++new file mode 100644
++index 0000000..42d9c05
++--- /dev/null
+++++ b/patches/dwm-hide_vacant_tags-6.4.diff
++@@ -0,0 +1,48 @@
+++:100644 100644 f1d86b2 0000000 M	dwm.c
+++
+++diff --git a/dwm.c b/dwm.c
+++index f1d86b2..d41cc14 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -433,9 +433,15 @@ buttonpress(XEvent *e)
+++ 	}
+++ 	if (ev->window == selmon->barwin) {
+++ 		i = x = 0;
+++-		do
++++		unsigned int occ = 0;
++++		for(c = m->clients; c; c=c->next)
++++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++++		do {
++++			/* Do not reserve space for vacant tags */
++++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++++				continue;
+++ 			x += TEXTW(tags[i]);
+++-		while (ev->x >= x && ++i < LENGTH(tags));
++++		} while (ev->x >= x && ++i < LENGTH(tags));
+++ 		if (i < LENGTH(tags)) {
+++ 			click = ClkTagBar;
+++ 			arg.ui = 1 << i;
+++@@ -715,19 +721,18 @@ drawbar(Monitor *m)
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++-		occ |= c->tags;
++++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+++ 		if (c->isurgent)
+++ 			urg |= c->tags;
+++ 	}
+++ 	x = 0;
+++ 	for (i = 0; i < LENGTH(tags); i++) {
++++		/* Do not draw vacant tags */
++++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++++			continue;
+++ 		w = TEXTW(tags[i]);
+++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+++-		if (occ & 1 << i)
+++-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+++-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+++-				urg & 1 << i);
+++ 		x += w;
+++ 	}
+++ 	w = TEXTW(m->ltsymbol);
++diff --git a/patches/dwm-noborder-6.2.diff b/patches/dwm-noborder-6.2.diff
++new file mode 100644
++index 0000000..f381eb8
++--- /dev/null
+++++ b/patches/dwm-noborder-6.2.diff
++@@ -0,0 +1,30 @@
+++From 9102fdb9c670218373bbe83c891c8e8138d6a6f4 Mon Sep 17 00:00:00 2001
+++From: redacted <redacted@example.com>
+++Date: Tue, 23 Apr 2019 00:39:27 +0100
+++Subject: [PATCH] added noborder patch
+++
+++---
+++ dwm.c | 7 +++++++
+++ 1 file changed, 7 insertions(+)
+++
+++diff --git a/dwm.c b/dwm.c
+++index 4465af1..685eca1 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -1282,6 +1282,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+++ 	c->oldw = c->w; c->w = wc.width = w;
+++ 	c->oldh = c->h; c->h = wc.height = h;
+++ 	wc.border_width = c->bw;
++++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++++	    && !c->isfullscreen && !c->isfloating) {
++++		c->w = wc.width += c->bw * 2;
++++		c->h = wc.height += c->bw * 2;
++++		wc.border_width = 0;
++++	}
+++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+++ 	configure(c);
+++ 	XSync(dpy, False);
+++-- 
+++2.21.0
+++
++diff --git a/patches/dwm-notitle-20210715-138b405.diff b/patches/dwm-notitle-20210715-138b405.diff
++new file mode 100644
++index 0000000..bc8a3e5
++--- /dev/null
+++++ b/patches/dwm-notitle-20210715-138b405.diff
++@@ -0,0 +1,81 @@
+++From a3a7e94f59553689656871a65ea9ce90169a7c91 Mon Sep 17 00:00:00 2001
+++From: birdalicous <jack.bird@durham.ac.uk>
+++Date: Thu, 15 Jul 2021 12:28:29 +0100
+++Subject: [PATCH] notitle patch applied#
+++
+++---
+++ config.def.h |  1 -
+++ dwm.c        | 20 ++++----------------
+++ 2 files changed, 4 insertions(+), 17 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index a2ac963..eac20b4 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -103,7 +103,6 @@ static Button buttons[] = {
+++ 	/* click                event mask      button          function        argument */
+++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+++-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++diff --git a/dwm.c b/dwm.c
+++index 5e4d494..6cd9fb7 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -64,8 +64,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+++        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+++-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+++-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++++       ClkRootWin, ClkLast }; /* clicks */
+++ 
+++ typedef union {
+++ 	int i;
+++@@ -440,10 +440,8 @@ buttonpress(XEvent *e)
+++ 			arg.ui = 1 << i;
+++ 		} else if (ev->x < x + blw)
+++ 			click = ClkLtSymbol;
+++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+++-			click = ClkStatusText;
+++ 		else
+++-			click = ClkWinTitle;
++++			click = ClkStatusText;
+++ 	} else if ((c = wintoclient(ev->window))) {
+++ 		focus(c);
+++ 		restack(selmon);
+++@@ -730,15 +728,8 @@ drawbar(Monitor *m)
+++ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+++ 
+++ 	if ((w = m->ww - tw - x) > bh) {
+++-		if (m->sel) {
+++-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+++-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+++-			if (m->sel->isfloating)
+++-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+++-		} else {
+++ 			drw_setscheme(drw, scheme[SchemeNorm]);
+++ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+++-		}
+++ 	}
+++ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+++ }
+++@@ -1236,11 +1227,8 @@ propertynotify(XEvent *e)
+++ 			drawbars();
+++ 			break;
+++ 		}
+++-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+++ 			updatetitle(c);
+++-			if (c == c->mon->sel)
+++-				drawbar(c->mon);
+++-		}
+++ 		if (ev->atom == netatom[NetWMWindowType])
+++ 			updatewindowtype(c);
+++ 	}
+++-- 
+++2.32.0
+++
++diff --git a/patches/dwm-savefloats-20181212-b69c870.diff b/patches/dwm-savefloats-20181212-b69c870.diff
++new file mode 100644
++index 0000000..f5d8ed8
++--- /dev/null
+++++ b/patches/dwm-savefloats-20181212-b69c870.diff
++@@ -0,0 +1,42 @@
+++diff --git i/dwm.c w/dwm.c
+++index 4465af1..96b0b26 100644
+++--- i/dwm.c
++++++ w/dwm.c
+++@@ -88,6 +88,7 @@ struct Client {
+++ 	char name[256];
+++ 	float mina, maxa;
+++ 	int x, y, w, h;
++++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+++ 	int oldx, oldy, oldw, oldh;
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+++ 	int bw, oldbw;
+++@@ -1056,6 +1057,10 @@ manage(Window w, XWindowAttributes *wa)
+++ 	updatewindowtype(c);
+++ 	updatesizehints(c);
+++ 	updatewmhints(c);
++++	c->sfx = c->x;
++++	c->sfy = c->y;
++++	c->sfw = c->w;
++++	c->sfh = c->h;
+++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+++ 	grabbuttons(c, 0);
+++ 	if (!c->isfloating)
+++@@ -1714,8 +1719,16 @@ togglefloating(const Arg *arg)
+++ 		return;
+++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+++ 	if (selmon->sel->isfloating)
+++-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+++-			selmon->sel->w, selmon->sel->h, 0);
++++		/* restore last known float dimensions */
++++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++++		       selmon->sel->sfw, selmon->sel->sfh, False);
++++	else {
++++		/* save last known float dimensions */
++++		selmon->sel->sfx = selmon->sel->x;
++++		selmon->sel->sfy = selmon->sel->y;
++++		selmon->sel->sfw = selmon->sel->w;
++++		selmon->sel->sfh = selmon->sel->h;
++++	}
+++ 	arrange(selmon);
+++ }
+++ 
++diff --git a/patches/dwm-scratchpads-20200414-728d397b.diff b/patches/dwm-scratchpads-20200414-728d397b.diff
++new file mode 100644
++index 0000000..d3e90c0
++--- /dev/null
+++++ b/patches/dwm-scratchpads-20200414-728d397b.diff
++@@ -0,0 +1,199 @@
+++From 728d397b21982af88737277fd9d6939a7b558786 Mon Sep 17 00:00:00 2001
+++From: Christian Tenllado <ctenllado@gmail.com>
+++Date: Tue, 14 Apr 2020 23:31:15 +0200
+++Subject: [PATCH] Multiple scratchpads
+++
+++This patch enables multiple scratchpads, each with one asigned window.
+++This enables the same scratchpad workflow that you have in i3.
+++
+++Scratchpads are implemented as special tags, whose mask does not
+++apply to new spawned windows. To assign a window to a scratchpad you
+++have to set up a rule, as you do with regular tags.
+++
+++Windows tagged with scratchpad tags can be set floating or not in the
+++rules array. Most users would probably want them floating (i3 style),
+++but having them tiled does also perfectly work and might fit better the
+++DWM approach. In case they are set floating, the patch moves them to the
+++center of the screen whenever they are shown. The patch can easily be
+++modified to make this last feature configurable in the rules array (see
+++the center patch).
+++
+++The togglescratch function, borrowed from the previous scratchpad patch
+++and slightly modified, can be used to spawn a registered scratchpad
+++process or toggle its view. This function looks for a window tagged with
+++the selected scratchpad tag. If it is found its view is toggled. If it is
+++not found the corresponding registered command is spawned. The
+++config.def.h shows three examples of its use to spawn a terminal in the
+++first scratchpad tag, a second terminal running ranger on the second
+++scratchpad tag and the keepassxc application to manage passwords on a
+++third scratchpad tag.
+++
+++If you prefer to spawn your scratchpad applications from the startup
+++script, you might opt for binding keys to toggleview instead, as
+++scratchpads are just special tags (you may even extend the TAGKEYS macro
+++to generalize the key bindings).
+++---
+++ config.def.h | 28 ++++++++++++++++++++++++----
+++ dwm.c        | 43 +++++++++++++++++++++++++++++++++++++++++--
+++ 2 files changed, 65 insertions(+), 6 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 1c0b587..06265e1 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -18,17 +18,33 @@ static const char *colors[][3]      = {
+++ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+++ };
+++ 
++++typedef struct {
++++	const char *name;
++++	const void *cmd;
++++} Sp;
++++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++++const char *spcmd3[] = {"keepassxc", NULL };
++++static Sp scratchpads[] = {
++++	/* name          cmd  */
++++	{"spterm",      spcmd1},
++++	{"spranger",    spcmd2},
++++	{"keepassxc",   spcmd3},
++++};
++++
+++ /* tagging */
+++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+++-
+++ static const Rule rules[] = {
+++ 	/* xprop(1):
+++ 	 *	WM_CLASS(STRING) = instance, class
+++ 	 *	WM_NAME(STRING) = title
+++ 	 */
+++ 	/* class      instance    title       tags mask     isfloating   monitor */
+++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++++	{ "Gimp",	  NULL,			NULL,		0,				1,			 -1 },
++++	{ "Firefox",  NULL,			NULL,		1 << 8,			0,			 -1 },
++++	{ NULL,		  "spterm",		NULL,		SPTAG(0),		1,			 -1 },
++++	{ NULL,		  "spfm",		NULL,		SPTAG(1),		1,			 -1 },
++++	{ NULL,		  "keepassxc",	NULL,		SPTAG(2),		0,			 -1 },
+++ };
+++ 
+++ /* layout(s) */
+++@@ -59,6 +75,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
+++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++ static const char *termcmd[]  = { "st", NULL };
+++ 
++++
+++ static Key keys[] = {
+++ 	/* modifier                     key        function        argument */
+++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+++@@ -84,6 +101,9 @@ static Key keys[] = {
+++ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+++ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+++ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+++ 	TAGKEYS(                        XK_1,                      0)
+++ 	TAGKEYS(                        XK_2,                      1)
+++ 	TAGKEYS(                        XK_3,                      2)
+++@@ -106,7 +126,7 @@ static Button buttons[] = {
+++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+++ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+++ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+++ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+++diff --git a/dwm.c b/dwm.c
+++index 4465af1..646aa1a 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -54,7 +54,10 @@
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++++#define TAGMASK     			((1 << NUMTAGS) - 1)
++++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++ 
+++ /* enums */
+++@@ -211,6 +214,7 @@ static void tagmon(const Arg *arg);
+++ static void tile(Monitor *);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglescratch(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++ static void toggleview(const Arg *arg);
+++ static void unfocus(Client *c, int setfocus);
+++@@ -299,6 +303,11 @@ applyrules(Client *c)
+++ 		{
+++ 			c->isfloating = r->isfloating;
+++ 			c->tags |= r->tags;
++++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++++			}
++++
+++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+++ 			if (m)
+++ 				c->mon = m;
+++@@ -308,7 +317,7 @@ applyrules(Client *c)
+++ 		XFree(ch.res_class);
+++ 	if (ch.res_name)
+++ 		XFree(ch.res_name);
+++-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+++ }
+++ 
+++ int
+++@@ -1616,6 +1625,10 @@ showhide(Client *c)
+++ 	if (!c)
+++ 		return;
+++ 	if (ISVISIBLE(c)) {
++++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++++		}
+++ 		/* show clients top down */
+++ 		XMoveWindow(dpy, c->win, c->x, c->y);
+++ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+++@@ -1719,6 +1732,32 @@ togglefloating(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++void
++++togglescratch(const Arg *arg)
++++{
++++	Client *c;
++++	unsigned int found = 0;
++++	unsigned int scratchtag = SPTAG(arg->ui);
++++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++++
++++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++++	if (found) {
++++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++++		if (newtagset) {
++++			selmon->tagset[selmon->seltags] = newtagset;
++++			focus(NULL);
++++			arrange(selmon);
++++		}
++++		if (ISVISIBLE(c)) {
++++			focus(c);
++++			restack(selmon);
++++		}
++++	} else {
++++		selmon->tagset[selmon->seltags] |= scratchtag;
++++		spawn(&sparg);
++++	}
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
+++-- 
+++2.20.1
+++
++diff --git a/patches/dwm-stacker-6.2.diff b/patches/dwm-stacker-6.2.diff
++new file mode 100644
++index 0000000..8fe3b80
++--- /dev/null
+++++ b/patches/dwm-stacker-6.2.diff
++@@ -0,0 +1,197 @@
+++From d04f2d00688c8b0969d4f10f460c980dd91dac37 Mon Sep 17 00:00:00 2001
+++From: MLquest8 <miskuzius@gmail.com>
+++Date: Fri, 12 Jun 2020 16:04:18 +0400
+++Subject: [PATCH] stacker updated for version 6.2
+++
+++---
+++ config.def.h | 14 +++++++--
+++ dwm.c        | 88 ++++++++++++++++++++++++++++++++++++++++------------
+++ 2 files changed, 80 insertions(+), 22 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 1c0b587..d28f8fc 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -50,6 +50,14 @@ static const Layout layouts[] = {
+++ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+++ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+++ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++++#define STACKKEYS(MOD,ACTION) \
++++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+++ 
+++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+++@@ -64,8 +72,8 @@ static Key keys[] = {
+++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+++ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+++ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+++-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+++-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++++	STACKKEYS(MODKEY,                          focus)
++++	STACKKEYS(MODKEY|ShiftMask,                push)
+++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++@@ -93,7 +101,7 @@ static Key keys[] = {
+++ 	TAGKEYS(                        XK_7,                      6)
+++ 	TAGKEYS(                        XK_8,                      7)
+++ 	TAGKEYS(                        XK_9,                      8)
+++-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+++ };
+++ 
+++ /* button definitions */
+++diff --git a/dwm.c b/dwm.c
+++index 9fd0286..6c302c3 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -47,15 +47,21 @@
+++ /* macros */
+++ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++++#define GETINC(X)               ((X) - 2000)
++++#define INC(X)                  ((X) + 2000)
+++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++++#define PREVSEL                 3000
+++ #define LENGTH(X)               (sizeof X / sizeof X[0])
++++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+++ 
+++ /* enums */
+++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+++@@ -187,6 +193,7 @@ static void movemouse(const Arg *arg);
+++ static Client *nexttiled(Client *c);
+++ static void pop(Client *);
+++ static void propertynotify(XEvent *e);
++++static void pushstack(const Arg *arg);
+++ static void quit(const Arg *arg);
+++ static Monitor *recttomon(int x, int y, int w, int h);
+++ static void resize(Client *c, int x, int y, int w, int h, int interact);
+++@@ -207,6 +214,7 @@ static void seturgent(Client *c, int urg);
+++ static void showhide(Client *c);
+++ static void sigchld(int unused);
+++ static void spawn(const Arg *arg);
++++static int stackpos(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++ static void tile(Monitor *);
+++@@ -833,27 +841,16 @@ focusmon(const Arg *arg)
+++ void
+++ focusstack(const Arg *arg)
+++ {
+++-	Client *c = NULL, *i;
++++	int i = stackpos(arg);
++++	Client *c, *p;
+++ 
+++-	if (!selmon->sel)
++++	if(i < 0)
+++ 		return;
+++-	if (arg->i > 0) {
+++-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+++-		if (!c)
+++-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+++-	} else {
+++-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+++-			if (ISVISIBLE(i))
+++-				c = i;
+++-		if (!c)
+++-			for (; i; i = i->next)
+++-				if (ISVISIBLE(i))
+++-					c = i;
+++-	}
+++-	if (c) {
+++-		focus(c);
+++-		restack(selmon);
+++-	}
++++
++++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++++	focus(c ? c : p);
++++	restack(selmon);
+++ }
+++ 
+++ Atom
+++@@ -1246,6 +1243,29 @@ propertynotify(XEvent *e)
+++ 	}
+++ }
+++ 
++++void
++++pushstack(const Arg *arg) {
++++	int i = stackpos(arg);
++++	Client *sel = selmon->sel, *c, *p;
++++
++++	if(i < 0)
++++		return;
++++	else if(i == 0) {
++++		detach(sel);
++++		attach(sel);
++++	}
++++	else {
++++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++++				break;
++++		c = c ? c : p;
++++		detach(sel);
++++		sel->next = c->next;
++++		c->next = sel;
++++	}
++++	arrange(selmon);
++++}
++++
+++ void
+++ quit(const Arg *arg)
+++ {
+++@@ -1653,6 +1673,36 @@ spawn(const Arg *arg)
+++ 	}
+++ }
+++ 
++++int
++++stackpos(const Arg *arg) {
++++	int n, i;
++++	Client *c, *l;
++++
++++	if(!selmon->clients)
++++		return -1;
++++
++++	if(arg->i == PREVSEL) {
++++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++++		if(!l)
++++			return -1;
++++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return i;
++++	}
++++	else if(ISINC(arg->i)) {
++++		if(!selmon->sel)
++++			return -1;
++++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return MOD(i + GETINC(arg->i), n);
++++	}
++++	else if(arg->i < 0) {
++++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return MAX(i + arg->i, 0);
++++	}
++++	else
++++		return arg->i;
++++}
++++
+++ void
+++ tag(const Arg *arg)
+++ {
+++-- 
+++2.26.2
+++
++diff --git a/patches/dwm-status2d-6.3.diff b/patches/dwm-status2d-6.3.diff
++new file mode 100644
++index 0000000..52bf58d
++--- /dev/null
+++++ b/patches/dwm-status2d-6.3.diff
++@@ -0,0 +1,166 @@
+++diff --git a/dwm.c b/dwm.c
+++index a96f33c..24b1eeb 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -163,6 +163,7 @@ static void detachstack(Client *c);
+++ static Monitor *dirtomon(int dir);
+++ static void drawbar(Monitor *m);
+++ static void drawbars(void);
++++static int drawstatusbar(Monitor *m, int bh, char* text);
+++ static void enternotify(XEvent *e);
+++ static void expose(XEvent *e);
+++ static void focus(Client *c);
+++@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+++ 
+++ /* variables */
+++ static const char broken[] = "broken";
+++-static char stext[256];
++++static char stext[1024];
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++ static int bh, blw = 0;      /* bar geometry */
+++@@ -485,7 +486,7 @@ cleanup(void)
+++ 		cleanupmon(mons);
+++ 	for (i = 0; i < CurLast; i++)
+++ 		drw_cur_free(drw, cursor[i]);
+++-	for (i = 0; i < LENGTH(colors); i++)
++++	for (i = 0; i < LENGTH(colors) + 1; i++)
+++ 		free(scheme[i]);
+++ 	XDestroyWindow(dpy, wmcheckwin);
+++ 	drw_free(drw);
+++@@ -693,6 +694,114 @@ dirtomon(int dir)
+++ 	return m;
+++ }
+++ 
++++int
++++drawstatusbar(Monitor *m, int bh, char* stext) {
++++	int ret, i, w, x, len;
++++	short isCode = 0;
++++	char *text;
++++	char *p;
++++
++++	len = strlen(stext) + 1 ;
++++	if (!(text = (char*) malloc(sizeof(char)*len)))
++++		die("malloc");
++++	p = text;
++++	memcpy(text, stext, len);
++++
++++	/* compute width of the status text */
++++	w = 0;
++++	i = -1;
++++	while (text[++i]) {
++++		if (text[i] == '^') {
++++			if (!isCode) {
++++				isCode = 1;
++++				text[i] = '\0';
++++				w += TEXTW(text) - lrpad;
++++				text[i] = '^';
++++				if (text[++i] == 'f')
++++					w += atoi(text + ++i);
++++			} else {
++++				isCode = 0;
++++				text = text + i + 1;
++++				i = -1;
++++			}
++++		}
++++	}
++++	if (!isCode)
++++		w += TEXTW(text) - lrpad;
++++	else
++++		isCode = 0;
++++	text = p;
++++
++++	w += 2; /* 1px padding on both sides */
++++	ret = x = m->ww - w;
++++
++++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++++	drw_rect(drw, x, 0, w, bh, 1, 1);
++++	x++;
++++
++++	/* process status text */
++++	i = -1;
++++	while (text[++i]) {
++++		if (text[i] == '^' && !isCode) {
++++			isCode = 1;
++++
++++			text[i] = '\0';
++++			w = TEXTW(text) - lrpad;
++++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++++
++++			x += w;
++++
++++			/* process code */
++++			while (text[++i] != '^') {
++++				if (text[i] == 'c') {
++++					char buf[8];
++++					memcpy(buf, (char*)text+i+1, 7);
++++					buf[7] = '\0';
++++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++++					i += 7;
++++				} else if (text[i] == 'b') {
++++					char buf[8];
++++					memcpy(buf, (char*)text+i+1, 7);
++++					buf[7] = '\0';
++++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++++					i += 7;
++++				} else if (text[i] == 'd') {
++++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++++				} else if (text[i] == 'r') {
++++					int rx = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int ry = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int rw = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int rh = atoi(text + ++i);
++++
++++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++++				} else if (text[i] == 'f') {
++++					x += atoi(text + ++i);
++++				}
++++			}
++++
++++			text = text + i + 1;
++++			i=-1;
++++			isCode = 0;
++++		}
++++	}
++++
++++	if (!isCode) {
++++		w = TEXTW(text) - lrpad;
++++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++++	}
++++
++++	drw_setscheme(drw, scheme[SchemeNorm]);
++++	free(p);
++++
++++	return ret;
++++}
++++
+++ void
+++ drawbar(Monitor *m)
+++ {
+++@@ -707,9 +816,7 @@ drawbar(Monitor *m)
+++ 
+++ 	/* draw status first so it can be overdrawn by tags later */
+++ 	if (m == selmon) { /* status is only drawn on selected monitor */
+++-		drw_setscheme(drw, scheme[SchemeNorm]);
+++-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+++-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++++		tw = m->ww - drawstatusbar(m, bh, stext);
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++@@ -1571,7 +1678,8 @@ setup(void)
+++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+++ 	/* init appearance */
+++-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+++ 	for (i = 0; i < LENGTH(colors); i++)
+++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+++ 	/* init bars */
++diff --git a/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
++new file mode 100644
++index 0000000..4adb383
++--- /dev/null
+++++ b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
++@@ -0,0 +1,188 @@
+++From 05f9b3c45d4267d52724b2a76f333ba00353cab3 Mon Sep 17 00:00:00 2001
+++From: Daniel Bylinka <daniel.bylinka@gmail.com>
+++Date: Fri, 2 Apr 2021 19:04:58 +0200
+++Subject: [PATCH] [statuscmd] status2d compatibility
+++
+++---
+++ config.def.h |  6 +++-
+++ dwm.c        | 83 ++++++++++++++++++++++++++++++++++++++++++++++++----
+++ 2 files changed, 83 insertions(+), 6 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 1c0b587..154a59b 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -54,6 +54,8 @@ static const Layout layouts[] = {
+++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+++ 
++++#define STATUSBAR "dwmblocks"
++++
+++ /* commands */
+++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++@@ -103,7 +105,9 @@ static Button buttons[] = {
+++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+++ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+++-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++diff --git a/dwm.c b/dwm.c
+++index acbe6c9..ba478b9 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -173,6 +173,7 @@ static void focusstack(const Arg *arg);
+++ static Atom getatomprop(Client *c, Atom prop);
+++ static int getrootptr(int *x, int *y);
+++ static long getstate(Window w);
++++static pid_t getstatusbarpid();
+++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+++ static void grabbuttons(Client *c, int focused);
+++ static void grabkeys(void);
+++@@ -207,6 +208,7 @@ static void setup(void);
+++ static void seturgent(Client *c, int urg);
+++ static void showhide(Client *c);
+++ static void sigchld(int unused);
++++static void sigstatusbar(const Arg *arg);
+++ static void spawn(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++@@ -239,6 +241,9 @@ static void zoom(const Arg *arg);
+++ /* variables */
+++ static const char broken[] = "broken";
+++ static char stext[1024];
++++static int statussig;
++++static int statusw;
++++static pid_t statuspid = -1;
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++ static int bh, blw = 0;      /* bar geometry */
+++@@ -441,9 +446,34 @@ buttonpress(XEvent *e)
+++ 			arg.ui = 1 << i;
+++ 		} else if (ev->x < x + blw)
+++ 			click = ClkLtSymbol;
+++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++++		else if (ev->x > selmon->ww - statusw) {
++++			x = selmon->ww - statusw;
+++ 			click = ClkStatusText;
+++-		else
++++
++++			char *text, *s, ch;
++++			statussig = 0;
++++			for (text = s = stext; *s && x <= ev->x; s++) {
++++				if ((unsigned char)(*s) < ' ') {
++++					ch = *s;
++++					*s = '\0';
++++					x += TEXTW(text) - lrpad;
++++					*s = ch;
++++					text = s + 1;
++++					if (x >= ev->x)
++++						break;
++++					statussig = ch;
++++				} else if (*s == '^') {
++++					*s = '\0';
++++					x += TEXTW(text) - lrpad;
++++					*s = '^';
++++					if (*(++s) == 'f')
++++						x += atoi(++s);
++++					while (*(s++) != '^');
++++					text = s;
++++					s--;
++++				}
++++			}
++++		} else
+++ 			click = ClkWinTitle;
+++ 	} else if ((c = wintoclient(ev->window))) {
+++ 		focus(c);
+++@@ -696,7 +726,7 @@ dirtomon(int dir)
+++ 
+++ int
+++ drawstatusbar(Monitor *m, int bh, char* stext) {
+++-	int ret, i, w, x, len;
++++	int ret, i, j, w, x, len;
+++ 	short isCode = 0;
+++ 	char *text;
+++ 	char *p;
+++@@ -705,7 +735,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+++ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+++ 		die("malloc");
+++ 	p = text;
+++-	memcpy(text, stext, len);
++++
++++	i = -1, j = 0;
++++	while (stext[++i])
++++		if ((unsigned char)stext[i] >= ' ')
++++			text[j++] = stext[i];
++++	text[j] = '\0';
+++ 
+++ 	/* compute width of the status text */
+++ 	w = 0;
+++@@ -813,7 +848,7 @@ drawbar(Monitor *m)
+++ 
+++ 	/* draw status first so it can be overdrawn by tags later */
+++ 	if (m == selmon) { /* status is only drawn on selected monitor */
+++-		tw = m->ww - drawstatusbar(m, bh, stext);
++++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++@@ -979,6 +1014,30 @@ getatomprop(Client *c, Atom prop)
+++ 	return atom;
+++ }
+++ 
++++pid_t
++++getstatusbarpid()
++++{
++++	char buf[32], *str = buf, *c;
++++	FILE *fp;
++++
++++	if (statuspid > 0) {
++++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++++		if ((fp = fopen(buf, "r"))) {
++++			fgets(buf, sizeof(buf), fp);
++++			while ((c = strchr(str, '/')))
++++				str = c + 1;
++++			fclose(fp);
++++			if (!strcmp(str, STATUSBAR))
++++				return statuspid;
++++		}
++++	}
++++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++++		return -1;
++++	fgets(buf, sizeof(buf), fp);
++++	pclose(fp);
++++	return strtoul(buf, NULL, 10);
++++}
++++
+++ int
+++ getrootptr(int *x, int *y)
+++ {
+++@@ -1745,6 +1804,20 @@ sigchld(int unused)
+++ 	while (0 < waitpid(-1, NULL, WNOHANG));
+++ }
+++ 
++++void
++++sigstatusbar(const Arg *arg)
++++{
++++	union sigval sv;
++++
++++	if (!statussig)
++++		return;
++++	sv.sival_int = arg->i;
++++	if ((statuspid = getstatusbarpid()) <= 0)
++++		return;
++++
++++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++++}
++++
+++ void
+++ spawn(const Arg *arg)
+++ {
+++-- 
+++2.31.0
+++
++diff --git a/patches/dwm-sticky-20240927-60f7034.diff b/patches/dwm-sticky-20240927-60f7034.diff
++new file mode 100644
++index 0000000..055d019
++--- /dev/null
+++++ b/patches/dwm-sticky-20240927-60f7034.diff
++@@ -0,0 +1,146 @@
+++From 60f7034ca1573e10cf9e005e2ef5a44e6b76ea9b Mon Sep 17 00:00:00 2001
+++From: elbachir-one <bachiralfa@gmail.com>
+++Date: Fri, 27 Sep 2024 12:35:36 +0100
+++Subject: [PATCH] Added the missing keybinding
+++
+++---
+++ config.def.h |  1 +
+++ dwm.c        | 43 ++++++++++++++++++++++++++++++++++++++++---
+++ 2 files changed, 41 insertions(+), 3 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 9efa774..55c0a6c 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -95,6 +95,7 @@ static const Key keys[] = {
+++ 	TAGKEYS(                        XK_8,                      7)
+++ 	TAGKEYS(                        XK_9,                      8)
+++ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+++ };
+++ 
+++ /* button definitions */
+++diff --git a/dwm.c b/dwm.c
+++index 67c6b2b..e8ed755 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -49,7 +49,7 @@
+++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+++-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+++ #define LENGTH(X)               (sizeof X / sizeof X[0])
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++@@ -61,7 +61,7 @@
+++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+++ enum { SchemeNorm, SchemeSel }; /* color schemes */
+++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+++-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+++ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+++@@ -92,7 +92,7 @@ struct Client {
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++ 	int bw, oldbw;
+++ 	unsigned int tags;
+++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+++ 	Client *next;
+++ 	Client *snext;
+++ 	Monitor *mon;
+++@@ -200,6 +200,7 @@ static void sendmon(Client *c, Monitor *m);
+++ static void setclientstate(Client *c, long state);
+++ static void setfocus(Client *c);
+++ static void setfullscreen(Client *c, int fullscreen);
++++static void setsticky(Client *c, int sticky);
+++ static void setlayout(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++ static void setup(void);
+++@@ -211,6 +212,7 @@ static void tagmon(const Arg *arg);
+++ static void tile(Monitor *m);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglesticky(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++ static void toggleview(const Arg *arg);
+++ static void unfocus(Client *c, int setfocus);
+++@@ -525,6 +527,10 @@ clientmessage(XEvent *e)
+++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++++
++++        if (cme->data.l[1] == netatom[NetWMSticky]
++++                || cme->data.l[2] == netatom[NetWMSticky])
++++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+++ 		if (c != selmon->sel && !c->isurgent)
+++ 			seturgent(c, 1);
+++@@ -1507,6 +1513,23 @@ setfullscreen(Client *c, int fullscreen)
+++ 	}
+++ }
+++ 
++++void
++++	 setsticky(Client *c, int sticky)
++++	 {
++++
++++		 if(sticky && !c->issticky) {
++++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++++			 c->issticky = 1;
++++		 } else if(!sticky && c->issticky){
++++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++++					 PropModeReplace, (unsigned char *)0, 0);
++++			 c->issticky = 0;
++++			 arrange(c->mon);
++++		 }
++++	 }
++++
++++
+++ void
+++ setlayout(const Arg *arg)
+++ {
+++@@ -1576,6 +1599,7 @@ setup(void)
+++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+++@@ -1735,6 +1759,15 @@ togglefloating(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++void
++++togglesticky(const Arg *arg)
++++{
++++	if (!selmon->sel)
++++		return;
++++	setsticky(selmon->sel, !selmon->sel->issticky);
++++	arrange(selmon);
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
+++@@ -2027,6 +2060,9 @@ updatewindowtype(Client *c)
+++ 
+++ 	if (state == netatom[NetWMFullscreen])
+++ 		setfullscreen(c, 1);
++++	if (state == netatom[NetWMSticky]) {
++++		setsticky(c, 1);
++++	}
+++ 	if (wtype == netatom[NetWMWindowTypeDialog])
+++ 		c->isfloating = 1;
+++ }
+++@@ -2163,3 +2199,4 @@ main(int argc, char *argv[])
+++ 	XCloseDisplay(dpy);
+++ 	return EXIT_SUCCESS;
+++ }
++++
+++-- 
+++2.46.0
+++
++diff --git a/patches/dwm-swallow-6.3.diff b/patches/dwm-swallow-6.3.diff
++new file mode 100644
++index 0000000..47586a0
++--- /dev/null
+++++ b/patches/dwm-swallow-6.3.diff
++@@ -0,0 +1,412 @@
+++From 0cf9a007511f7dfd7dd94171b172562ebac9b6d5 Mon Sep 17 00:00:00 2001
+++From: Tom Schwindl <schwindl@posteo.de>
+++Date: Sat, 10 Sep 2022 12:51:09 +0200
+++Subject: [PATCH] 6.3 swallow patch
+++
+++---
+++ config.def.h |   9 +-
+++ config.mk    |   3 +-
+++ dwm.c        | 235 +++++++++++++++++++++++++++++++++++++++++++++++++--
+++ 3 files changed, 237 insertions(+), 10 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index 061ad662f82a..0b2b8ffd30d5 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -3,6 +3,7 @@
+++ /* appearance */
+++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
++++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+++ static const int showbar            = 1;        /* 0 means no bar */
+++ static const int topbar             = 1;        /* 0 means bottom bar */
+++ static const char *fonts[]          = { "monospace:size=10" };
+++@@ -26,9 +27,11 @@ static const Rule rules[] = {
+++ 	 *	WM_CLASS(STRING) = instance, class
+++ 	 *	WM_NAME(STRING) = title
+++ 	 */
+++-	/* class      instance    title       tags mask     isfloating   monitor */
+++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+++ };
+++ 
+++ /* layout(s) */
+++diff --git a/config.mk b/config.mk
+++index 81c493ef4aff..52d1ebf30bec 100644
+++--- a/config.mk
++++++ b/config.mk
+++@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+++ # OpenBSD (uncomment)
+++ #FREETYPEINC = ${X11INC}/freetype2
+++ #MANPREFIX = ${PREFIX}/man
++++#KVMLIB = -lkvm
+++ 
+++ # includes and libs
+++ INCS = -I${X11INC} -I${FREETYPEINC}
+++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+++ 
+++ # flags
+++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+++diff --git a/dwm.c b/dwm.c
+++index e5efb6a22806..e68294b6b679 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -40,6 +40,12 @@
+++ #include <X11/extensions/Xinerama.h>
+++ #endif /* XINERAMA */
+++ #include <X11/Xft/Xft.h>
++++#include <X11/Xlib-xcb.h>
++++#include <xcb/res.h>
++++#ifdef __OpenBSD__
++++#include <sys/sysctl.h>
++++#include <kvm.h>
++++#endif /* __OpenBSD */
+++ 
+++ #include "drw.h"
+++ #include "util.h"
+++@@ -92,9 +98,11 @@ struct Client {
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++ 	int bw, oldbw;
+++ 	unsigned int tags;
+++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++++	pid_t pid;
+++ 	Client *next;
+++ 	Client *snext;
++++	Client *swallowing;
+++ 	Monitor *mon;
+++ 	Window win;
+++ };
+++@@ -138,6 +146,8 @@ typedef struct {
+++ 	const char *title;
+++ 	unsigned int tags;
+++ 	int isfloating;
++++	int isterminal;
++++	int noswallow;
+++ 	int monitor;
+++ } Rule;
+++ 
+++@@ -235,6 +245,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
+++ 
++++static pid_t getparentprocess(pid_t p);
++++static int isdescprocess(pid_t p, pid_t c);
++++static Client *swallowingclient(Window w);
++++static Client *termforwin(const Client *c);
++++static pid_t winpid(Window w);
++++
+++ /* variables */
+++ static const char broken[] = "broken";
+++ static char stext[256];
+++@@ -269,6 +285,8 @@ static Drw *drw;
+++ static Monitor *mons, *selmon;
+++ static Window root, wmcheckwin;
+++ 
++++static xcb_connection_t *xcon;
++++
+++ /* configuration, allows nested code to access above variables */
+++ #include "config.h"
+++ 
+++@@ -298,6 +316,8 @@ applyrules(Client *c)
+++ 		&& (!r->class || strstr(class, r->class))
+++ 		&& (!r->instance || strstr(instance, r->instance)))
+++ 		{
++++			c->isterminal = r->isterminal;
++++			c->noswallow  = r->noswallow;
+++ 			c->isfloating = r->isfloating;
+++ 			c->tags |= r->tags;
+++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+++@@ -416,6 +436,53 @@ attachstack(Client *c)
+++ 	c->mon->stack = c;
+++ }
+++ 
++++void
++++swallow(Client *p, Client *c)
++++{
++++
++++	if (c->noswallow || c->isterminal)
++++		return;
++++	if (c->noswallow && !swallowfloating && c->isfloating)
++++		return;
++++
++++	detach(c);
++++	detachstack(c);
++++
++++	setclientstate(c, WithdrawnState);
++++	XUnmapWindow(dpy, p->win);
++++
++++	p->swallowing = c;
++++	c->mon = p->mon;
++++
++++	Window w = p->win;
++++	p->win = c->win;
++++	c->win = w;
++++	updatetitle(p);
++++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++++	arrange(p->mon);
++++	configure(p);
++++	updateclientlist();
++++}
++++
++++void
++++unswallow(Client *c)
++++{
++++	c->win = c->swallowing->win;
++++
++++	free(c->swallowing);
++++	c->swallowing = NULL;
++++
++++	/* unfullscreen the client */
++++	setfullscreen(c, 0);
++++	updatetitle(c);
++++	arrange(c->mon);
++++	XMapWindow(dpy, c->win);
++++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++++	setclientstate(c, NormalState);
++++	focus(NULL);
++++	arrange(c->mon);
++++}
++++
+++ void
+++ buttonpress(XEvent *e)
+++ {
+++@@ -656,6 +723,9 @@ destroynotify(XEvent *e)
+++ 
+++ 	if ((c = wintoclient(ev->window)))
+++ 		unmanage(c, 1);
++++
++++	else if ((c = swallowingclient(ev->window)))
++++		unmanage(c->swallowing, 1);
+++ }
+++ 
+++ void
+++@@ -1022,12 +1092,13 @@ killclient(const Arg *arg)
+++ void
+++ manage(Window w, XWindowAttributes *wa)
+++ {
+++-	Client *c, *t = NULL;
++++	Client *c, *t = NULL, *term = NULL;
+++ 	Window trans = None;
+++ 	XWindowChanges wc;
+++ 
+++ 	c = ecalloc(1, sizeof(Client));
+++ 	c->win = w;
++++	c->pid = winpid(w);
+++ 	/* geometry */
+++ 	c->x = c->oldx = wa->x;
+++ 	c->y = c->oldy = wa->y;
+++@@ -1042,6 +1113,7 @@ manage(Window w, XWindowAttributes *wa)
+++ 	} else {
+++ 		c->mon = selmon;
+++ 		applyrules(c);
++++		term = termforwin(c);
+++ 	}
+++ 
+++ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+++@@ -1076,6 +1148,8 @@ manage(Window w, XWindowAttributes *wa)
+++ 	c->mon->sel = c;
+++ 	arrange(c->mon);
+++ 	XMapWindow(dpy, c->win);
++++	if (term)
++++		swallow(term, c);
+++ 	focus(NULL);
+++ }
+++ 
+++@@ -1763,6 +1837,20 @@ unmanage(Client *c, int destroyed)
+++ 	Monitor *m = c->mon;
+++ 	XWindowChanges wc;
+++ 
++++	if (c->swallowing) {
++++		unswallow(c);
++++		return;
++++	}
++++
++++	Client *s = swallowingclient(c->win);
++++	if (s) {
++++		free(s->swallowing);
++++		s->swallowing = NULL;
++++		arrange(m);
++++		focus(NULL);
++++		return;
++++	}
++++
+++ 	detach(c);
+++ 	detachstack(c);
+++ 	if (!destroyed) {
+++@@ -1778,9 +1866,12 @@ unmanage(Client *c, int destroyed)
+++ 		XUngrabServer(dpy);
+++ 	}
+++ 	free(c);
+++-	focus(NULL);
+++-	updateclientlist();
+++-	arrange(m);
++++
++++	if (!s) {
++++		arrange(m);
++++		focus(NULL);
++++		updateclientlist();
++++	}
+++ }
+++ 
+++ void
+++@@ -2044,6 +2135,136 @@ view(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++pid_t
++++winpid(Window w)
++++{
++++
++++	pid_t result = 0;
++++
++++#ifdef __linux__
++++	xcb_res_client_id_spec_t spec = {0};
++++	spec.client = w;
++++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++++
++++	xcb_generic_error_t *e = NULL;
++++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++++
++++	if (!r)
++++		return (pid_t)0;
++++
++++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++++		spec = i.data->spec;
++++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++++			result = *t;
++++			break;
++++		}
++++	}
++++
++++	free(r);
++++
++++	if (result == (pid_t)-1)
++++		result = 0;
++++
++++#endif /* __linux__ */
++++
++++#ifdef __OpenBSD__
++++        Atom type;
++++        int format;
++++        unsigned long len, bytes;
++++        unsigned char *prop;
++++        pid_t ret;
++++
++++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++++               return 0;
++++
++++        ret = *(pid_t*)prop;
++++        XFree(prop);
++++        result = ret;
++++
++++#endif /* __OpenBSD__ */
++++	return result;
++++}
++++
++++pid_t
++++getparentprocess(pid_t p)
++++{
++++	unsigned int v = 0;
++++
++++#ifdef __linux__
++++	FILE *f;
++++	char buf[256];
++++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++++
++++	if (!(f = fopen(buf, "r")))
++++		return 0;
++++
++++	fscanf(f, "%*u %*s %*c %u", &v);
++++	fclose(f);
++++#endif /* __linux__*/
++++
++++#ifdef __OpenBSD__
++++	int n;
++++	kvm_t *kd;
++++	struct kinfo_proc *kp;
++++
++++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++++	if (!kd)
++++		return 0;
++++
++++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++++	v = kp->p_ppid;
++++#endif /* __OpenBSD__ */
++++
++++	return (pid_t)v;
++++}
++++
++++int
++++isdescprocess(pid_t p, pid_t c)
++++{
++++	while (p != c && c != 0)
++++		c = getparentprocess(c);
++++
++++	return (int)c;
++++}
++++
++++Client *
++++termforwin(const Client *w)
++++{
++++	Client *c;
++++	Monitor *m;
++++
++++	if (!w->pid || w->isterminal)
++++		return NULL;
++++
++++	for (m = mons; m; m = m->next) {
++++		for (c = m->clients; c; c = c->next) {
++++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++++				return c;
++++		}
++++	}
++++
++++	return NULL;
++++}
++++
++++Client *
++++swallowingclient(Window w)
++++{
++++	Client *c;
++++	Monitor *m;
++++
++++	for (m = mons; m; m = m->next) {
++++		for (c = m->clients; c; c = c->next) {
++++			if (c->swallowing && c->swallowing->win == w)
++++				return c;
++++		}
++++	}
++++
++++	return NULL;
++++}
++++
+++ Client *
+++ wintoclient(Window w)
+++ {
+++@@ -2133,10 +2354,12 @@ main(int argc, char *argv[])
+++ 		fputs("warning: no locale support\n", stderr);
+++ 	if (!(dpy = XOpenDisplay(NULL)))
+++ 		die("dwm: cannot open display");
++++	if (!(xcon = XGetXCBConnection(dpy)))
++++		die("dwm: cannot get xcb connection\n");
+++ 	checkotherwm();
+++ 	setup();
+++ #ifdef __OpenBSD__
+++-	if (pledge("stdio rpath proc exec", NULL) == -1)
++++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+++ 		die("pledge");
+++ #endif /* __OpenBSD__ */
+++ 	scan();
+++-- 
+++2.37.2
+++
++diff --git a/patches/dwm-tagshift-6.3.diff b/patches/dwm-tagshift-6.3.diff
++new file mode 100644
++index 0000000..fb4d1d7
++--- /dev/null
+++++ b/patches/dwm-tagshift-6.3.diff
++@@ -0,0 +1,69 @@
+++diff --git a/config.def.h b/config.def.h
+++index a2ac963..1bbede2 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -69,6 +69,10 @@ static Key keys[] = {
+++ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+++diff --git a/dwm.c b/dwm.c
+++index a96f33c..4bf0f70 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -204,6 +204,8 @@ static void setlayout(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++ static void setup(void);
+++ static void seturgent(Client *c, int urg);
++++static void shiftview(const Arg *arg);
++++static void shifttag(const Arg *arg);
+++ static void showhide(Client *c);
+++ static void sigchld(int unused);
+++ static void spawn(const Arg *arg);
+++@@ -1632,6 +1634,40 @@ showhide(Client *c)
+++ 	}
+++ }
+++ 
++++void
++++shiftview(const Arg *arg) {
++++	Arg shifted;
++++
++++	if(arg->i > 0) /* left circular shift */
++++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++++
++++	else /* right circular shift */
++++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++++
++++	view(&shifted);
++++}
++++
++++void
++++shifttag(const Arg *arg) {
++++	Arg shifted;
++++	Client *c;
++++
++++	if (!selmon->sel)
++++		return;
++++	c = selmon->sel;
++++
++++	if (arg->i > 0) /* left circular shift */
++++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++++			^ (c->tags >> (LENGTH(tags) - arg->i));
++++	else /* right circular shift */
++++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++++			^ (c->tags << (LENGTH(tags) + arg->i));
++++
++++	toggletag(&shifted);
++++}
++++
+++ void
+++ sigchld(int unused)
+++ {
++diff --git a/patches/dwm-xresources-20210827-138b405.diff b/patches/dwm-xresources-20210827-138b405.diff
++new file mode 100644
++index 0000000..29852a9
++--- /dev/null
+++++ b/patches/dwm-xresources-20210827-138b405.diff
++@@ -0,0 +1,240 @@
+++From f30583c6e2ab5e7de6ef4ebf156076ac0f6e69fc Mon Sep 17 00:00:00 2001
+++From: Jack Bird <jack.bird@durham.ac.uk>
+++Date: Fri, 27 Aug 2021 00:53:14 +0100
+++Subject: [PATCH] xresources updated for 138b405
+++
+++---
+++ config.def.h | 61 ++++++++++++++++++++++++++++++--------------
+++ drw.c        |  2 +-
+++ drw.h        |  2 +-
+++ dwm.c        | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++++
+++ 4 files changed, 116 insertions(+), 21 deletions(-)
+++
+++diff --git a/config.def.h b/config.def.h
+++index a2ac963..87ac198 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -1,21 +1,23 @@
+++ /* See LICENSE file for copyright and license details. */
+++ 
+++ /* appearance */
+++-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++-static const unsigned int snap      = 32;       /* snap pixel */
+++-static const int showbar            = 1;        /* 0 means no bar */
+++-static const int topbar             = 1;        /* 0 means bottom bar */
+++-static const char *fonts[]          = { "monospace:size=10" };
+++-static const char dmenufont[]       = "monospace:size=10";
+++-static const char col_gray1[]       = "#222222";
+++-static const char col_gray2[]       = "#444444";
+++-static const char col_gray3[]       = "#bbbbbb";
+++-static const char col_gray4[]       = "#eeeeee";
+++-static const char col_cyan[]        = "#005577";
+++-static const char *colors[][3]      = {
+++-	/*               fg         bg         border   */
+++-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+++-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++++static unsigned int borderpx  = 1;        /* border pixel of windows */
++++static unsigned int snap      = 32;       /* snap pixel */
++++static int showbar            = 1;        /* 0 means no bar */
++++static int topbar             = 1;        /* 0 means bottom bar */
++++static char font[]            = "monospace:size=10";
++++static char dmenufont[]       = "monospace:size=10";
++++static const char *fonts[]          = { font };
++++static char normbgcolor[]           = "#222222";
++++static char normbordercolor[]       = "#444444";
++++static char normfgcolor[]           = "#bbbbbb";
++++static char selfgcolor[]            = "#eeeeee";
++++static char selbordercolor[]        = "#005577";
++++static char selbgcolor[]            = "#005577";
++++static char *colors[][3] = {
++++       /*               fg           bg           border   */
++++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+++ };
+++ 
+++ /* tagging */
+++@@ -32,9 +34,9 @@ static const Rule rules[] = {
+++ };
+++ 
+++ /* layout(s) */
+++-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++-static const int nmaster     = 1;    /* number of clients in master area */
+++-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++++static int nmaster     = 1;    /* number of clients in master area */
++++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+++ 
+++ static const Layout layouts[] = {
+++@@ -57,9 +59,30 @@ static const Layout layouts[] = {
+++ 
+++ /* commands */
+++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+++-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+++ static const char *termcmd[]  = { "st", NULL };
+++ 
++++/*
++++ * Xresources preferences to load at startup
++++ */
++++ResourcePref resources[] = {
++++		{ "font",               STRING,  &font },
++++		{ "dmenufont",          STRING,  &dmenufont },
++++		{ "normbgcolor",        STRING,  &normbgcolor },
++++		{ "normbordercolor",    STRING,  &normbordercolor },
++++		{ "normfgcolor",        STRING,  &normfgcolor },
++++		{ "selbgcolor",         STRING,  &selbgcolor },
++++		{ "selbordercolor",     STRING,  &selbordercolor },
++++		{ "selfgcolor",         STRING,  &selfgcolor },
++++		{ "borderpx",          	INTEGER, &borderpx },
++++		{ "snap",          		INTEGER, &snap },
++++		{ "showbar",          	INTEGER, &showbar },
++++		{ "topbar",          	INTEGER, &topbar },
++++		{ "nmaster",          	INTEGER, &nmaster },
++++		{ "resizehints",       	INTEGER, &resizehints },
++++		{ "mfact",      	 	FLOAT,   &mfact },
++++};
++++
+++ static Key keys[] = {
+++ 	/* modifier                     key        function        argument */
+++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+++diff --git a/drw.c b/drw.c
+++index 4cdbcbe..8f1059e 100644
+++--- a/drw.c
++++++ b/drw.c
+++@@ -208,7 +208,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+++ /* Wrapper to create color schemes. The caller has to call free(3) on the
+++  * returned color scheme when done using it. */
+++ Clr *
+++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+++ {
+++ 	size_t i;
+++ 	Clr *ret;
+++diff --git a/drw.h b/drw.h
+++index 4bcd5ad..42b04ce 100644
+++--- a/drw.h
++++++ b/drw.h
+++@@ -39,7 +39,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+++ 
+++ /* Colorscheme abstraction */
+++ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+++ 
+++ /* Cursor abstraction */
+++ Cur *drw_cur_create(Drw *drw, int shape);
+++diff --git a/dwm.c b/dwm.c
+++index 5e4d494..2214b19 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -36,6 +36,7 @@
+++ #include <X11/Xlib.h>
+++ #include <X11/Xproto.h>
+++ #include <X11/Xutil.h>
++++#include <X11/Xresource.h>
+++ #ifdef XINERAMA
+++ #include <X11/extensions/Xinerama.h>
+++ #endif /* XINERAMA */
+++@@ -141,6 +142,19 @@ typedef struct {
+++ 	int monitor;
+++ } Rule;
+++ 
++++/* Xresources preferences */
++++enum resource_type {
++++	STRING = 0,
++++	INTEGER = 1,
++++	FLOAT = 2
++++};
++++
++++typedef struct {
++++	char *name;
++++	enum resource_type type;
++++	void *dst;
++++} ResourcePref;
++++
+++ /* function declarations */
+++ static void applyrules(Client *c);
+++ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+++@@ -234,6 +248,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
++++static void load_xresources(void);
++++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+++ 
+++ /* variables */
+++ static const char broken[] = "broken";
+++@@ -2127,6 +2143,60 @@ zoom(const Arg *arg)
+++ 	pop(c);
+++ }
+++ 
++++void
++++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++++{
++++	char *sdst = NULL;
++++	int *idst = NULL;
++++	float *fdst = NULL;
++++
++++	sdst = dst;
++++	idst = dst;
++++	fdst = dst;
++++
++++	char fullname[256];
++++	char *type;
++++	XrmValue ret;
++++
++++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++++	fullname[sizeof(fullname) - 1] = '\0';
++++
++++	XrmGetResource(db, fullname, "*", &type, &ret);
++++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++++	{
++++		switch (rtype) {
++++		case STRING:
++++			strcpy(sdst, ret.addr);
++++			break;
++++		case INTEGER:
++++			*idst = strtoul(ret.addr, NULL, 10);
++++			break;
++++		case FLOAT:
++++			*fdst = strtof(ret.addr, NULL);
++++			break;
++++		}
++++	}
++++}
++++
++++void
++++load_xresources(void)
++++{
++++	Display *display;
++++	char *resm;
++++	XrmDatabase db;
++++	ResourcePref *p;
++++
++++	display = XOpenDisplay(NULL);
++++	resm = XResourceManagerString(display);
++++	if (!resm)
++++		return;
++++
++++	db = XrmGetStringDatabase(resm);
++++	for (p = resources; p < resources + LENGTH(resources); p++)
++++		resource_load(db, p->name, p->type, p->dst);
++++	XCloseDisplay(display);
++++}
++++
+++ int
+++ main(int argc, char *argv[])
+++ {
+++@@ -2139,6 +2209,8 @@ main(int argc, char *argv[])
+++ 	if (!(dpy = XOpenDisplay(NULL)))
+++ 		die("dwm: cannot open display");
+++ 	checkotherwm();
++++	XrmInitialize();
++++	load_xresources();
+++ 	setup();
+++ #ifdef __OpenBSD__
+++ 	if (pledge("stdio rpath proc exec", NULL) == -1)
+++-- 
+++2.33.0
+++
++diff --git a/patches/get.sh b/patches/get.sh
++new file mode 100755
++index 0000000..8c998a9
++--- /dev/null
+++++ b/patches/get.sh
++@@ -0,0 +1,86 @@
+++# Example
+++# https://dwm.suckless.org/patches/alpha/
+++# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+++# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+++# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
+++# exit 0
+++
+++download_if_not_exists() {
+++  local url="$1"
+++  local filename=$(basename "$url") # Extract the file name from the URL
+++
+++  # Check if the file already exists
+++  if [[ -f "$filename" ]]; then
+++    echo "File '$filename' already exists. Skipping download."
+++  else
+++    echo "Downloading '$filename'..."
+++    curl -O "$url"
+++    if [[ $? -eq 0 ]]; then
+++      echo "Downloaded '$filename' successfully."
+++    else
+++      echo "Failed to download '$filename'."
+++    fi
+++  fi
+++}
+++
+++# https://dwm.suckless.org/patches/noborder/
+++download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborder-6.2.diff
+++#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderfloatingfix-6.2.diff
+++#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderselflickerfix-2022042627-d93ff48803f0.diff
+++
+++# https://dwm.suckless.org/patches/stackmfact/
+++download_if_not_exists https://dwm.suckless.org/patches/stackmfact/dwm-6.0-smfact.diff
+++
+++# https://dwm.suckless.org/patches/notitle/
+++download_if_not_exists https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
+++
+++# https://dwm.suckless.org/patches/sticky/
+++download_if_not_exists https://dwm.suckless.org/patches/sticky/dwm-sticky-20240927-60f7034.diff
+++
+++# https://dwm.suckless.org/patches/actualfullscreen/
+++download_if_not_exists https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
+++
+++# https://dwm.suckless.org/patches/tagshift/
+++download_if_not_exists https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
+++
+++# https://dwm.suckless.org/patches/statuscmd/
+++#download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20241009-8933ebc.diff
+++download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-status2d-20210405-60bb3df.diff
+++
+++# https://dwm.suckless.org/patches/swallow/
+++download_if_not_exists https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
+++
+++# https://dwm.suckless.org/patches/xresources/
+++download_if_not_exists https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
+++
+++# https://dwm.suckless.org/patches/hide_vacant_tags/
+++download_if_not_exists https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.4.diff
+++
+++# https://dwm.suckless.org/patches/stacker/
+++download_if_not_exists https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
+++
+++# https://dwm.suckless.org/patches/vanitygaps/
+++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-20190508-6.2.diff
+++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
+++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
+++download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
+++
+++# https://dwm.suckless.org/patches/autostart/
+++download_if_not_exists https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
+++
+++# https://dwm.suckless.org/patches/scratchpad/
+++#download_if_not_exists https://dwm.suckless.org/patches/scratchpad/dwm-scratchpad-20240321-061e9fe.diff
+++
+++#https://dwm.suckless.org/patches/scratchpads/
+++download_if_not_exists https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
+++
+++# https://dwm.suckless.org/patches/focusonclick/
+++download_if_not_exists https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
+++
+++# https://dwm.suckless.org/patches/save_floats/
+++download_if_not_exists https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
+++
+++# https://dwm.suckless.org/patches/status2d/
+++#download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-systray-6.4.diff
+++download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-6.3.diff
+++
++diff --git a/patches_git/dwm-actualfullscreen.diff b/patches_git/dwm-actualfullscreen.diff
++new file mode 100644
++index 0000000..5aa0294
++--- /dev/null
+++++ b/patches_git/dwm-actualfullscreen.diff
++@@ -0,0 +1,52 @@
+++diff --git a/config.def.h b/config.def.h
+++index 583f383..880a46a 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -118,6 +118,7 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+++ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+++ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+++ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+++ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+++ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+++diff --git a/dwm.1 b/dwm.1
+++index ddc8321..3d310ac 100644
+++--- a/dwm.1
++++++ b/dwm.1
+++@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+++ .B Mod1\-Shift\-c
+++ Close focused window.
+++ .TP
++++.B Mod1\-Shift\-f
++++Toggle fullscreen for focused window.
++++.TP
+++ .B Mod1\-Shift\-space
+++ Toggle focused window between tiled and floating state.
+++ .TP
+++diff --git a/dwm.c b/dwm.c
+++index f9989e1..9ae5616 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -216,6 +216,7 @@ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglefullscr(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++ static void toggleview(const Arg *arg);
+++ static void unfocus(Client *c, int setfocus);
+++@@ -1837,6 +1838,13 @@ togglefloating(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++void
++++togglefullscr(const Arg *arg)
++++{
++++  if(selmon->sel)
++++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
++diff --git a/patches_git/dwm-autostart.diff b/patches_git/dwm-autostart.diff
++new file mode 100644
++index 0000000..a09e438
++--- /dev/null
+++++ b/patches_git/dwm-autostart.diff
++@@ -0,0 +1,165 @@
+++diff --git a/dwm.1 b/dwm.1
+++index 3d310ac..d04bec6 100644
+++--- a/dwm.1
++++++ b/dwm.1
+++@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+++ indicated with an empty square in the top left corner.
+++ .P
+++ dwm draws a small border around windows to indicate the focus state.
++++.P
++++On start, dwm can start additional programs that may be specified in two special
++++shell scripts (see the FILES section below), autostart_blocking.sh and
++++autostart.sh.  The former is executed first and dwm will wait for its
++++termination before starting.  The latter is executed in the background before
++++dwm enters its handler loop.
++++.P
++++Either of these files may be omitted.
+++ .SH OPTIONS
+++ .TP
+++ .B \-v
+++@@ -155,6 +163,21 @@ Toggles focused window between floating and tiled state.
+++ .TP
+++ .B Mod1\-Button3
+++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++++.SH FILES
++++The files containing programs to be started along with dwm are searched for in
++++the following directories:
++++.IP "1. $XDG_DATA_HOME/dwm"
++++.IP "2. $HOME/.local/share/dwm"
++++.IP "3. $HOME/.dwm"
++++.P
++++The first existing directory is scanned for any of the autostart files below.
++++.TP 15
++++autostart.sh
++++This file is started as a shell background process before dwm enters its handler
++++loop.
++++.TP 15
++++autostart_blocking.sh
++++This file is started before any autostart.sh; dwm waits for its termination.
+++ .SH CUSTOMIZATION
+++ dwm is customized by creating a custom config.h and (re)compiling the source
+++ code. This keeps it fast, secure and simple.
+++diff --git a/dwm.c b/dwm.c
+++index 758c5ac..91fac46 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -29,6 +29,7 @@
+++ #include <string.h>
+++ #include <unistd.h>
+++ #include <sys/types.h>
++++#include <sys/stat.h>
+++ #include <sys/wait.h>
+++ #include <X11/cursorfont.h>
+++ #include <X11/keysym.h>
+++@@ -200,6 +201,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+++ static void resizemouse(const Arg *arg);
+++ static void restack(Monitor *m);
+++ static void run(void);
++++static void runautostart(void);
+++ static void scan(void);
+++ static int sendevent(Client *c, Atom proto);
+++ static void sendmon(Client *c, Monitor *m);
+++@@ -244,7 +246,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
+++ 
+++ /* variables */
++++static const char autostartblocksh[] = "autostart_blocking.sh";
++++static const char autostartsh[] = "autostart.sh";
+++ static const char broken[] = "broken";
++++static const char dwmdir[] = "dwm";
++++static const char localshare[] = ".local/share";
+++ static char stext[1024];
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++@@ -1514,6 +1520,83 @@ run(void)
+++ 			handler[ev.type](&ev); /* call handler */
+++ }
+++ 
++++void
++++runautostart(void)
++++{
++++	char *pathpfx;
++++	char *path;
++++	char *xdgdatahome;
++++	char *home;
++++	struct stat sb;
++++
++++	if ((home = getenv("HOME")) == NULL)
++++		/* this is almost impossible */
++++		return;
++++
++++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++++	 * otherwise use ~/.local/share/dwm as autostart script directory
++++	 */
++++	xdgdatahome = getenv("XDG_DATA_HOME");
++++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++++		/* space for path segments, separators and nul */
++++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++++
++++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	} else {
++++		/* space for path segments, separators and nul */
++++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++++		                     + strlen(dwmdir) + 3);
++++
++++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	}
++++
++++	/* check if the autostart script directory exists */
++++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++++		/* the XDG conformant path does not exist or is no directory
++++		 * so we try ~/.dwm instead
++++		 */
++++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++++		if(pathpfx_new == NULL) {
++++			free(pathpfx);
++++			return;
++++		}
++++		pathpfx = pathpfx_new;
++++
++++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++++			free(pathpfx);
++++			return;
++++		}
++++	}
++++
++++	/* try the blocking script first */
++++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++++		free(path);
++++		free(pathpfx);
++++	}
++++
++++	if (access(path, X_OK) == 0)
++++		system(path);
++++
++++	/* now the non-blocking script */
++++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++++		free(path);
++++		free(pathpfx);
++++	}
++++
++++	if (access(path, X_OK) == 0)
++++		system(strcat(path, " &"));
++++
++++	free(pathpfx);
++++	free(path);
++++}
++++
+++ void
+++ scan(void)
+++ {
+++@@ -2322,6 +2405,7 @@ main(int argc, char *argv[])
+++ 		die("pledge");
+++ #endif /* __OpenBSD__ */
+++ 	scan();
++++	runautostart();
+++ 	run();
+++ 	cleanup();
+++ 	XCloseDisplay(dpy);
++diff --git a/patches_git/dwm-focusonclick.diff b/patches_git/dwm-focusonclick.diff
++new file mode 100644
++index 0000000..baf3978
++--- /dev/null
+++++ b/patches_git/dwm-focusonclick.diff
++@@ -0,0 +1,117 @@
+++diff --git a/config.def.h b/config.def.h
+++index 69d4822..0c94360 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -11,6 +11,7 @@ static const unsigned int gappov    = 30;       /* vert outer gap between window
+++ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+++ static int showbar            = 1;        /* 0 means no bar */
+++ static int topbar             = 1;        /* 0 means bottom bar */
++++static const int focusonwheel       = 0;
+++ static char font[]            = "monospace:size=10";
+++ static char dmenufont[]       = "monospace:size=10";
+++ static const char *fonts[]          = { font };
+++diff --git a/dwm.c b/dwm.c
+++index c71fa3c..aec2675 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -203,7 +203,6 @@ static Monitor *dirtomon(int dir);
+++ static void drawbar(Monitor *m);
+++ static void drawbars(void);
+++ static int drawstatusbar(Monitor *m, int bh, char* text);
+++-static void enternotify(XEvent *e);
+++ static void expose(XEvent *e);
+++ static void focus(Client *c);
+++ static void focusin(XEvent *e);
+++@@ -223,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
+++ static void mappingnotify(XEvent *e);
+++ static void maprequest(XEvent *e);
+++ static void monocle(Monitor *m);
+++-static void motionnotify(XEvent *e);
+++ static void movemouse(const Arg *arg);
+++ static Client *nexttiled(Client *c);
+++ static void pop(Client *c);
+++@@ -315,13 +313,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+++ 	[ConfigureRequest] = configurerequest,
+++ 	[ConfigureNotify] = configurenotify,
+++ 	[DestroyNotify] = destroynotify,
+++-	[EnterNotify] = enternotify,
+++ 	[Expose] = expose,
+++ 	[FocusIn] = focusin,
+++ 	[KeyPress] = keypress,
+++ 	[MappingNotify] = mappingnotify,
+++ 	[MapRequest] = maprequest,
+++-	[MotionNotify] = motionnotify,
+++ 	[PropertyNotify] = propertynotify,
+++ 	[UnmapNotify] = unmapnotify
+++ };
+++@@ -548,7 +544,8 @@ buttonpress(XEvent *e)
+++ 
+++ 	click = ClkRootWin;
+++ 	/* focus monitor if necessary */
+++-	if ((m = wintomon(ev->window)) && m != selmon) {
++++	if ((m = wintomon(ev->window)) && m != selmon
++++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+++ 		unfocus(selmon->sel, 1);
+++ 		selmon = m;
+++ 		focus(NULL);
+++@@ -597,8 +594,8 @@ buttonpress(XEvent *e)
+++ 				}
+++ 			}
+++ 	} else if ((c = wintoclient(ev->window))) {
+++-		focus(c);
+++-		restack(selmon);
++++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++++			focus(c);
+++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+++ 		click = ClkClientWin;
+++ 	}
+++@@ -1022,25 +1019,6 @@ drawbars(void)
+++ 		drawbar(m);
+++ }
+++ 
+++-void
+++-enternotify(XEvent *e)
+++-{
+++-	Client *c;
+++-	Monitor *m;
+++-	XCrossingEvent *ev = &e->xcrossing;
+++-
+++-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+++-		return;
+++-	c = wintoclient(ev->window);
+++-	m = c ? c->mon : wintomon(ev->window);
+++-	if (m != selmon) {
+++-		unfocus(selmon->sel, 1);
+++-		selmon = m;
+++-	} else if (!c || c == selmon->sel)
+++-		return;
+++-	focus(c);
+++-}
+++-
+++ void
+++ expose(XEvent *e)
+++ {
+++@@ -1412,23 +1390,6 @@ monocle(Monitor *m)
+++ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+++ }
+++ 
+++-void
+++-motionnotify(XEvent *e)
+++-{
+++-	static Monitor *mon = NULL;
+++-	Monitor *m;
+++-	XMotionEvent *ev = &e->xmotion;
+++-
+++-	if (ev->window != root)
+++-		return;
+++-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+++-		unfocus(selmon->sel, 1);
+++-		selmon = m;
+++-		focus(NULL);
+++-	}
+++-	mon = m;
+++-}
+++-
+++ void
+++ movemouse(const Arg *arg)
+++ {
++diff --git a/patches_git/dwm-hide_vacant_tags.diff b/patches_git/dwm-hide_vacant_tags.diff
++new file mode 100644
++index 0000000..b9320f6
++--- /dev/null
+++++ b/patches_git/dwm-hide_vacant_tags.diff
++@@ -0,0 +1,46 @@
+++diff --git a/dwm.c b/dwm.c
+++index 0d205d0..34d25b6 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -441,9 +441,15 @@ buttonpress(XEvent *e)
+++ 	}
+++ 	if (ev->window == selmon->barwin) {
+++ 		i = x = 0;
+++-		do
++++		unsigned int occ = 0;
++++		for(c = m->clients; c; c=c->next)
++++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++++		do {
++++			/* Do not reserve space for vacant tags */
++++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++++				continue;
+++ 			x += TEXTW(tags[i]);
+++-		while (ev->x >= x && ++i < LENGTH(tags));
++++		} while (ev->x >= x && ++i < LENGTH(tags));
+++ 		if (i < LENGTH(tags)) {
+++ 			click = ClkTagBar;
+++ 			arg.ui = 1 << i;
+++@@ -831,19 +837,18 @@ drawbar(Monitor *m)
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++-		occ |= c->tags;
++++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+++ 		if (c->isurgent)
+++ 			urg |= c->tags;
+++ 	}
+++ 	x = 0;
+++ 	for (i = 0; i < LENGTH(tags); i++) {
++++		/* Do not draw vacant tags */
++++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++++			continue;
+++ 		w = TEXTW(tags[i]);
+++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+++-		if (occ & 1 << i)
+++-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+++-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+++-				urg & 1 << i);
+++ 		x += w;
+++ 	}
+++ 	w = TEXTW(m->ltsymbol);
++diff --git a/patches_git/dwm-noborder.diff b/patches_git/dwm-noborder.diff
++new file mode 100644
++index 0000000..59cf669
++--- /dev/null
+++++ b/patches_git/dwm-noborder.diff
++@@ -0,0 +1,18 @@
+++diff --git a/dwm.c b/dwm.c
+++index 1443802..857c396 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -1291,6 +1291,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+++ 	c->oldw = c->w; c->w = wc.width = w;
+++ 	c->oldh = c->h; c->h = wc.height = h;
+++ 	wc.border_width = c->bw;
++++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++++	    && !c->isfullscreen && !c->isfloating) {
++++		c->w = wc.width += c->bw * 2;
++++		c->h = wc.height += c->bw * 2;
++++		wc.border_width = 0;
++++	}
+++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+++ 	configure(c);
+++ 	XSync(dpy, False);
++diff --git a/patches_git/dwm-notitle.diff b/patches_git/dwm-notitle.diff
++new file mode 100644
++index 0000000..b23989f
++--- /dev/null
+++++ b/patches_git/dwm-notitle.diff
++@@ -0,0 +1,68 @@
+++diff --git a/config.def.h b/config.def.h
+++index 357dc6f..583f383 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -142,7 +142,6 @@ static const Button buttons[] = {
+++ 	/* click                event mask      button          function        argument */
+++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+++-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++diff --git a/dwm.c b/dwm.c
+++index 82fc028..f9989e1 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -63,8 +63,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+++        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+++-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+++-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++++       ClkRootWin, ClkLast }; /* clicks */
+++ 
+++ typedef union {
+++ 	int i;
+++@@ -446,10 +446,8 @@ buttonpress(XEvent *e)
+++ 			arg.ui = 1 << i;
+++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+++ 			click = ClkLtSymbol;
+++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+++-			click = ClkStatusText;
+++ 		else
+++-			click = ClkWinTitle;
++++			click = ClkStatusText;
+++ 	} else if ((c = wintoclient(ev->window))) {
+++ 		focus(c);
+++ 		restack(selmon);
+++@@ -850,15 +848,8 @@ drawbar(Monitor *m)
+++ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+++ 
+++ 	if ((w = m->ww - tw - x) > bh) {
+++-		if (m->sel) {
+++-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+++-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+++-			if (m->sel->isfloating)
+++-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+++-		} else {
+++ 			drw_setscheme(drw, scheme[SchemeNorm]);
+++ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+++-		}
+++ 	}
+++ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+++ }
+++@@ -1361,11 +1352,8 @@ propertynotify(XEvent *e)
+++ 			drawbars();
+++ 			break;
+++ 		}
+++-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+++ 			updatetitle(c);
+++-			if (c == c->mon->sel)
+++-				drawbar(c->mon);
+++-		}
+++ 		if (ev->atom == netatom[NetWMWindowType])
+++ 			updatewindowtype(c);
+++ 	}
++diff --git a/patches_git/dwm-savefloats.diff b/patches_git/dwm-savefloats.diff
++new file mode 100644
++index 0000000..b66f755
++--- /dev/null
+++++ b/patches_git/dwm-savefloats.diff
++@@ -0,0 +1,42 @@
+++diff --git a/dwm.c b/dwm.c
+++index 34d25b6..758c5ac 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -88,6 +88,7 @@ struct Client {
+++ 	float mina, maxa;
+++ 	float cfact;
+++ 	int x, y, w, h;
++++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+++ 	int oldx, oldy, oldw, oldh;
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++ 	int bw, oldbw;
+++@@ -1183,6 +1184,10 @@ manage(Window w, XWindowAttributes *wa)
+++ 	updatewindowtype(c);
+++ 	updatesizehints(c);
+++ 	updatewmhints(c);
++++	c->sfx = c->x;
++++	c->sfy = c->y;
++++	c->sfw = c->w;
++++	c->sfh = c->h;
+++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+++ 	grabbuttons(c, 0);
+++ 	if (!c->isfloating)
+++@@ -1874,8 +1879,16 @@ togglefloating(const Arg *arg)
+++ 		return;
+++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+++ 	if (selmon->sel->isfloating)
+++-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+++-			selmon->sel->w, selmon->sel->h, 0);
++++		/* restore last known float dimensions */
++++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++++		       selmon->sel->sfw, selmon->sel->sfh, False);
++++	else {
++++		/* save last known float dimensions */
++++		selmon->sel->sfx = selmon->sel->x;
++++		selmon->sel->sfy = selmon->sel->y;
++++		selmon->sel->sfw = selmon->sel->w;
++++		selmon->sel->sfh = selmon->sel->h;
++++	}
+++ 	arrange(selmon);
+++ }
+++ 
++diff --git a/patches_git/dwm-scratchpads.diff b/patches_git/dwm-scratchpads.diff
++new file mode 100644
++index 0000000..0bef30e
++--- /dev/null
+++++ b/patches_git/dwm-scratchpads.diff
++@@ -0,0 +1,133 @@
+++diff --git a/config.def.h b/config.def.h
+++index 1919b6c..69d4822 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -26,6 +26,20 @@ static char *colors[][3] = {
+++        [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+++ };
+++ 
++++typedef struct {
++++	const char *name;
++++	const void *cmd;
++++} Sp;
++++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++++const char *spcmd3[] = {"keepassxc", NULL };
++++static Sp scratchpads[] = {
++++	/* name          cmd  */
++++	{"spterm",      spcmd1},
++++	{"spranger",    spcmd2},
++++	{"keepassxc",   spcmd3},
++++};
++++
+++ /* tagging */
+++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+++ 
+++@@ -165,6 +179,9 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+++ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+++ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+++ 	TAGKEYS(                        XK_1,                      0)
+++ 	TAGKEYS(                        XK_2,                      1)
+++ 	TAGKEYS(                        XK_3,                      2)
+++@@ -189,7 +206,7 @@ static const Button buttons[] = {
+++ 	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+++ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+++ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+++ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+++diff --git a/dwm.c b/dwm.c
+++index 87bc8c5..c71fa3c 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -66,7 +66,10 @@
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++++#define TAGMASK     			((1 << NUMTAGS) - 1)
++++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++ #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+++ 
+++@@ -256,6 +259,7 @@ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglescratch(const Arg *arg);
+++ static void togglesticky(const Arg *arg);
+++ static void togglefullscr(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++@@ -365,6 +369,11 @@ applyrules(Client *c)
+++ 			c->noswallow  = r->noswallow;
+++ 			c->isfloating = r->isfloating;
+++ 			c->tags |= r->tags;
++++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++++			}
++++
+++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+++ 			if (m)
+++ 				c->mon = m;
+++@@ -374,7 +383,7 @@ applyrules(Client *c)
+++ 		XFree(ch.res_class);
+++ 	if (ch.res_name)
+++ 		XFree(ch.res_name);
+++-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+++ }
+++ 
+++ int
+++@@ -2085,6 +2094,10 @@ showhide(Client *c)
+++ 	if (!c)
+++ 		return;
+++ 	if (ISVISIBLE(c)) {
++++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++++		}
+++ 		/* show clients top down */
+++ 		XMoveWindow(dpy, c->win, c->x, c->y);
+++ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+++@@ -2228,6 +2241,32 @@ togglesticky(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++void
++++togglescratch(const Arg *arg)
++++{
++++	Client *c;
++++	unsigned int found = 0;
++++	unsigned int scratchtag = SPTAG(arg->ui);
++++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++++
++++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++++	if (found) {
++++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++++		if (newtagset) {
++++			selmon->tagset[selmon->seltags] = newtagset;
++++			focus(NULL);
++++			arrange(selmon);
++++		}
++++		if (ISVISIBLE(c)) {
++++			focus(c);
++++			restack(selmon);
++++		}
++++	} else {
++++		selmon->tagset[selmon->seltags] |= scratchtag;
++++		spawn(&sparg);
++++	}
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
++diff --git a/patches_git/dwm-stacker.diff b/patches_git/dwm-stacker.diff
++new file mode 100644
++index 0000000..cde0a99
++--- /dev/null
+++++ b/patches_git/dwm-stacker.diff
++@@ -0,0 +1,183 @@
+++diff --git a/config.def.h b/config.def.h
+++index 9ed2869..1919b6c 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -76,6 +76,14 @@ static const Layout layouts[] = {
+++ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+++ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+++ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++++#define STACKKEYS(MOD,ACTION) \
++++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+++ 
+++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+++@@ -113,8 +121,8 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+++ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+++ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+++-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+++-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++++	STACKKEYS(MODKEY,                          focus)
++++	STACKKEYS(MODKEY|ShiftMask,                push)
+++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+++@@ -166,7 +174,7 @@ static const Key keys[] = {
+++ 	TAGKEYS(                        XK_7,                      6)
+++ 	TAGKEYS(                        XK_8,                      7)
+++ 	TAGKEYS(                        XK_9,                      8)
+++-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+++ 	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+++ };
+++ 
+++diff --git a/dwm.c b/dwm.c
+++index cb3067d..87bc8c5 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -55,14 +55,20 @@
+++ /* macros */
+++ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++++#define GETINC(X)               ((X) - 2000)
++++#define INC(X)                  ((X) + 2000)
+++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++++#define PREVSEL                 3000
++++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+++ 
+++ /* enums */
+++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+++@@ -219,6 +225,7 @@ static void movemouse(const Arg *arg);
+++ static Client *nexttiled(Client *c);
+++ static void pop(Client *c);
+++ static void propertynotify(XEvent *e);
++++static void pushstack(const Arg *arg);
+++ static void quit(const Arg *arg);
+++ static Monitor *recttomon(int x, int y, int w, int h);
+++ static void resize(Client *c, int x, int y, int w, int h, int interact);
+++@@ -244,6 +251,7 @@ static void shifttag(const Arg *arg);
+++ static void showhide(Client *c);
+++ static void sigstatusbar(const Arg *arg);
+++ static void spawn(const Arg *arg);
++++static int stackpos(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++ static void togglebar(const Arg *arg);
+++@@ -1086,27 +1094,16 @@ focusmon(const Arg *arg)
+++ void
+++ focusstack(const Arg *arg)
+++ {
+++-	Client *c = NULL, *i;
++++	int i = stackpos(arg);
++++	Client *c, *p;
+++ 
+++-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++++	if(i < 0)
+++ 		return;
+++-	if (arg->i > 0) {
+++-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+++-		if (!c)
+++-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+++-	} else {
+++-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+++-			if (ISVISIBLE(i))
+++-				c = i;
+++-		if (!c)
+++-			for (; i; i = i->next)
+++-				if (ISVISIBLE(i))
+++-					c = i;
+++-	}
+++-	if (c) {
+++-		focus(c);
+++-		restack(selmon);
+++-	}
++++
++++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++++	focus(c ? c : p);
++++	restack(selmon);
+++ }
+++ 
+++ Atom
+++@@ -1533,6 +1530,29 @@ propertynotify(XEvent *e)
+++ 	}
+++ }
+++ 
++++void
++++pushstack(const Arg *arg) {
++++	int i = stackpos(arg);
++++	Client *sel = selmon->sel, *c, *p;
++++
++++	if(i < 0)
++++		return;
++++	else if(i == 0) {
++++		detach(sel);
++++		attach(sel);
++++	}
++++	else {
++++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++++				break;
++++		c = c ? c : p;
++++		detach(sel);
++++		sel->next = c->next;
++++		c->next = sel;
++++	}
++++	arrange(selmon);
++++}
++++
+++ void
+++ quit(const Arg *arg)
+++ {
+++@@ -2113,6 +2133,36 @@ spawn(const Arg *arg)
+++ 	}
+++ }
+++ 
++++int
++++stackpos(const Arg *arg) {
++++	int n, i;
++++	Client *c, *l;
++++
++++	if(!selmon->clients)
++++		return -1;
++++
++++	if(arg->i == PREVSEL) {
++++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++++		if(!l)
++++			return -1;
++++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return i;
++++	}
++++	else if(ISINC(arg->i)) {
++++		if(!selmon->sel)
++++			return -1;
++++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return MOD(i + GETINC(arg->i), n);
++++	}
++++	else if(arg->i < 0) {
++++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++++		return MAX(i + arg->i, 0);
++++	}
++++	else
++++		return arg->i;
++++}
++++
+++ void
+++ tag(const Arg *arg)
+++ {
++diff --git a/patches_git/dwm-status2d.diff b/patches_git/dwm-status2d.diff
++new file mode 100644
++index 0000000..c600b66
++--- /dev/null
+++++ b/patches_git/dwm-status2d.diff
++@@ -0,0 +1,166 @@
+++diff --git a/dwm.c b/dwm.c
+++index db7e0c8..82fc028 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -167,6 +167,7 @@ static void detachstack(Client *c);
+++ static Monitor *dirtomon(int dir);
+++ static void drawbar(Monitor *m);
+++ static void drawbars(void);
++++static int drawstatusbar(Monitor *m, int bh, char* text);
+++ static void enternotify(XEvent *e);
+++ static void expose(XEvent *e);
+++ static void focus(Client *c);
+++@@ -240,7 +241,7 @@ static void zoom(const Arg *arg);
+++ 
+++ /* variables */
+++ static const char broken[] = "broken";
+++-static char stext[256];
++++static char stext[1024];
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++ static int bh;               /* bar height */
+++@@ -490,7 +491,7 @@ cleanup(void)
+++ 		cleanupmon(mons);
+++ 	for (i = 0; i < CurLast; i++)
+++ 		drw_cur_free(drw, cursor[i]);
+++-	for (i = 0; i < LENGTH(colors); i++)
++++	for (i = 0; i < LENGTH(colors) + 1; i++)
+++ 		free(scheme[i]);
+++ 	free(scheme);
+++ 	XDestroyWindow(dpy, wmcheckwin);
+++@@ -703,6 +704,114 @@ dirtomon(int dir)
+++ 	return m;
+++ }
+++ 
++++int
++++drawstatusbar(Monitor *m, int bh, char* stext) {
++++	int ret, i, w, x, len;
++++	short isCode = 0;
++++	char *text;
++++	char *p;
++++
++++	len = strlen(stext) + 1 ;
++++	if (!(text = (char*) malloc(sizeof(char)*len)))
++++		die("malloc");
++++	p = text;
++++	memcpy(text, stext, len);
++++
++++	/* compute width of the status text */
++++	w = 0;
++++	i = -1;
++++	while (text[++i]) {
++++		if (text[i] == '^') {
++++			if (!isCode) {
++++				isCode = 1;
++++				text[i] = '\0';
++++				w += TEXTW(text) - lrpad;
++++				text[i] = '^';
++++				if (text[++i] == 'f')
++++					w += atoi(text + ++i);
++++			} else {
++++				isCode = 0;
++++				text = text + i + 1;
++++				i = -1;
++++			}
++++		}
++++	}
++++	if (!isCode)
++++		w += TEXTW(text) - lrpad;
++++	else
++++		isCode = 0;
++++	text = p;
++++
++++	w += 2; /* 1px padding on both sides */
++++	ret = x = m->ww - w;
++++
++++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++++	drw_rect(drw, x, 0, w, bh, 1, 1);
++++	x++;
++++
++++	/* process status text */
++++	i = -1;
++++	while (text[++i]) {
++++		if (text[i] == '^' && !isCode) {
++++			isCode = 1;
++++
++++			text[i] = '\0';
++++			w = TEXTW(text) - lrpad;
++++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++++
++++			x += w;
++++
++++			/* process code */
++++			while (text[++i] != '^') {
++++				if (text[i] == 'c') {
++++					char buf[8];
++++					memcpy(buf, (char*)text+i+1, 7);
++++					buf[7] = '\0';
++++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++++					i += 7;
++++				} else if (text[i] == 'b') {
++++					char buf[8];
++++					memcpy(buf, (char*)text+i+1, 7);
++++					buf[7] = '\0';
++++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++++					i += 7;
++++				} else if (text[i] == 'd') {
++++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++++				} else if (text[i] == 'r') {
++++					int rx = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int ry = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int rw = atoi(text + ++i);
++++					while (text[++i] != ',');
++++					int rh = atoi(text + ++i);
++++
++++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++++				} else if (text[i] == 'f') {
++++					x += atoi(text + ++i);
++++				}
++++			}
++++
++++			text = text + i + 1;
++++			i=-1;
++++			isCode = 0;
++++		}
++++	}
++++
++++	if (!isCode) {
++++		w = TEXTW(text) - lrpad;
++++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++++	}
++++
++++	drw_setscheme(drw, scheme[SchemeNorm]);
++++	free(p);
++++
++++	return ret;
++++}
++++
+++ void
+++ drawbar(Monitor *m)
+++ {
+++@@ -717,9 +826,7 @@ drawbar(Monitor *m)
+++ 
+++ 	/* draw status first so it can be overdrawn by tags later */
+++ 	if (m == selmon) { /* status is only drawn on selected monitor */
+++-		drw_setscheme(drw, scheme[SchemeNorm]);
+++-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+++-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++++		tw = m->ww - drawstatusbar(m, bh, stext);
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++@@ -1618,7 +1725,8 @@ setup(void)
+++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+++ 	/* init appearance */
+++-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+++ 	for (i = 0; i < LENGTH(colors); i++)
+++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+++ 	/* init bars */
++diff --git a/patches_git/dwm-statuscmd-status2d.diff b/patches_git/dwm-statuscmd-status2d.diff
++new file mode 100644
++index 0000000..bac794e
++--- /dev/null
+++++ b/patches_git/dwm-statuscmd-status2d.diff
++@@ -0,0 +1,174 @@
+++diff --git a/config.def.h b/config.def.h
+++index 2099993..f74867c 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -75,6 +75,8 @@ static const Layout layouts[] = {
+++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+++ 
++++#define STATUSBAR "dwmblocks"
++++
+++ /* commands */
+++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++@@ -148,7 +150,9 @@ static const Button buttons[] = {
+++ 	/* click                event mask      button          function        argument */
+++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+++-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+++ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++diff --git a/dwm.c b/dwm.c
+++index 2fddeb1..ed799c2 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -179,6 +179,7 @@ static void focusstack(const Arg *arg);
+++ static Atom getatomprop(Client *c, Atom prop);
+++ static int getrootptr(int *x, int *y);
+++ static long getstate(Window w);
++++static pid_t getstatusbarpid();
+++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+++ static void grabbuttons(Client *c, int focused);
+++ static void grabkeys(void);
+++@@ -217,6 +218,7 @@ static void seturgent(Client *c, int urg);
+++ static void shiftview(const Arg *arg);
+++ static void shifttag(const Arg *arg);
+++ static void showhide(Client *c);
++++static void sigstatusbar(const Arg *arg);
+++ static void spawn(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++@@ -254,6 +256,9 @@ static const char broken[] = "broken";
+++ static const char dwmdir[] = "dwm";
+++ static const char localshare[] = ".local/share";
+++ static char stext[1024];
++++static int statussig;
++++static int statusw;
++++static pid_t statuspid = -1;
+++ static int screen;
+++ static int sw, sh;           /* X display screen geometry width, height */
+++ static int bh;               /* bar height */
+++@@ -464,8 +469,33 @@ buttonpress(XEvent *e)
+++ 			arg.ui = 1 << i;
+++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+++ 			click = ClkLtSymbol;
+++-		else
+++-			click = ClkStatusText;
++++        } else if (ev->x > selmon->ww - statusw) {
++++            x = selmon->ww - statusw;
++++            click = ClkStatusText;
++++
++++			char *text, *s, ch;
++++			statussig = 0;
++++			for (text = s = stext; *s && x <= ev->x; s++) {
++++				if ((unsigned char)(*s) < ' ') {
++++					ch = *s;
++++					*s = '\0';
++++					x += TEXTW(text) - lrpad;
++++					*s = ch;
++++					text = s + 1;
++++					if (x >= ev->x)
++++						break;
++++					statussig = ch;
++++				} else if (*s == '^') {
++++					*s = '\0';
++++					x += TEXTW(text) - lrpad;
++++					*s = '^';
++++					if (*(++s) == 'f')
++++						x += atoi(++s);
++++					while (*(s++) != '^');
++++					text = s;
++++					s--;
++++				}
++++			}
+++ 	} else if ((c = wintoclient(ev->window))) {
+++ 		focus(c);
+++ 		restack(selmon);
+++@@ -726,7 +756,7 @@ dirtomon(int dir)
+++ 
+++ int
+++ drawstatusbar(Monitor *m, int bh, char* stext) {
+++-	int ret, i, w, x, len;
++++	int ret, i, j, w, x, len;
+++ 	short isCode = 0;
+++ 	char *text;
+++ 	char *p;
+++@@ -735,7 +765,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+++ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+++ 		die("malloc");
+++ 	p = text;
+++-	memcpy(text, stext, len);
++++
++++	i = -1, j = 0;
++++	while (stext[++i])
++++		if ((unsigned char)stext[i] >= ' ')
++++			text[j++] = stext[i];
++++	text[j] = '\0';
+++ 
+++ 	/* compute width of the status text */
+++ 	w = 0;
+++@@ -846,7 +881,7 @@ drawbar(Monitor *m)
+++ 
+++ 	/* draw status first so it can be overdrawn by tags later */
+++ 	if (m == selmon) { /* status is only drawn on selected monitor */
+++-		tw = m->ww - drawstatusbar(m, bh, stext);
++++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+++ 	}
+++ 
+++ 	for (c = m->clients; c; c = c->next) {
+++@@ -1004,6 +1039,30 @@ getatomprop(Client *c, Atom prop)
+++ 	return atom;
+++ }
+++ 
++++pid_t
++++getstatusbarpid()
++++{
++++	char buf[32], *str = buf, *c;
++++	FILE *fp;
++++
++++	if (statuspid > 0) {
++++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++++		if ((fp = fopen(buf, "r"))) {
++++			fgets(buf, sizeof(buf), fp);
++++			while ((c = strchr(str, '/')))
++++				str = c + 1;
++++			fclose(fp);
++++			if (!strcmp(str, STATUSBAR))
++++				return statuspid;
++++		}
++++	}
++++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++++		return -1;
++++	fgets(buf, sizeof(buf), fp);
++++	pclose(fp);
++++	return strtoul(buf, NULL, 10);
++++}
++++
+++ int
+++ getrootptr(int *x, int *y)
+++ {
+++@@ -1928,6 +1987,20 @@ showhide(Client *c)
+++ 	}
+++ }
+++ 
++++void
++++sigstatusbar(const Arg *arg)
++++{
++++	union sigval sv;
++++
++++	if (!statussig)
++++		return;
++++	sv.sival_int = arg->i;
++++	if ((statuspid = getstatusbarpid()) <= 0)
++++		return;
++++
++++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++++}
++++
+++ void
+++ spawn(const Arg *arg)
+++ {
++diff --git a/patches_git/dwm-sticky.diff b/patches_git/dwm-sticky.diff
++new file mode 100644
++index 0000000..0657003
++--- /dev/null
+++++ b/patches_git/dwm-sticky.diff
++@@ -0,0 +1,133 @@
+++diff --git a/config.def.h b/config.def.h
+++index f6c7894..2099993 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -139,6 +139,7 @@ static const Key keys[] = {
+++ 	TAGKEYS(                        XK_8,                      7)
+++ 	TAGKEYS(                        XK_9,                      8)
+++ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+++ };
+++ 
+++ /* button definitions */
+++diff --git a/dwm.c b/dwm.c
+++index 91fac46..2fddeb1 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -50,7 +50,7 @@
+++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+++-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+++@@ -61,7 +61,7 @@
+++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+++ enum { SchemeNorm, SchemeSel }; /* color schemes */
+++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+++-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+++ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+++@@ -94,7 +94,7 @@ struct Client {
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++ 	int bw, oldbw;
+++ 	unsigned int tags;
+++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+++ 	Client *next;
+++ 	Client *snext;
+++ 	Monitor *mon;
+++@@ -208,6 +208,7 @@ static void sendmon(Client *c, Monitor *m);
+++ static void setclientstate(Client *c, long state);
+++ static void setfocus(Client *c);
+++ static void setfullscreen(Client *c, int fullscreen);
++++static void setsticky(Client *c, int sticky);
+++ static void setlayout(const Arg *arg);
+++ static void setcfact(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++@@ -221,6 +222,7 @@ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
++++static void togglesticky(const Arg *arg);
+++ static void togglefullscr(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++ static void toggleview(const Arg *arg);
+++@@ -544,6 +546,10 @@ clientmessage(XEvent *e)
+++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++++
++++        if (cme->data.l[1] == netatom[NetWMSticky]
++++                || cme->data.l[2] == netatom[NetWMSticky])
++++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+++ 		if (c != selmon->sel && !c->isurgent)
+++ 			seturgent(c, 1);
+++@@ -1714,6 +1720,23 @@ setfullscreen(Client *c, int fullscreen)
+++ 	}
+++ }
+++ 
++++void
++++	 setsticky(Client *c, int sticky)
++++	 {
++++
++++		 if(sticky && !c->issticky) {
++++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++++			 c->issticky = 1;
++++		 } else if(!sticky && c->issticky){
++++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++++					 PropModeReplace, (unsigned char *)0, 0);
++++			 c->issticky = 0;
++++			 arrange(c->mon);
++++		 }
++++	 }
++++
++++
+++ void
+++ setlayout(const Arg *arg)
+++ {
+++@@ -1835,6 +1858,7 @@ setup(void)
+++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+++@@ -1982,6 +2006,15 @@ togglefullscr(const Arg *arg)
+++     setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+++ }
+++ 
++++void
++++togglesticky(const Arg *arg)
++++{
++++	if (!selmon->sel)
++++		return;
++++	setsticky(selmon->sel, !selmon->sel->issticky);
++++	arrange(selmon);
++++}
++++
+++ void
+++ toggletag(const Arg *arg)
+++ {
+++@@ -2274,6 +2307,9 @@ updatewindowtype(Client *c)
+++ 
+++ 	if (state == netatom[NetWMFullscreen])
+++ 		setfullscreen(c, 1);
++++	if (state == netatom[NetWMSticky]) {
++++		setsticky(c, 1);
++++	}
+++ 	if (wtype == netatom[NetWMWindowTypeDialog])
+++ 		c->isfloating = 1;
+++ }
+++@@ -2411,3 +2447,4 @@ main(int argc, char *argv[])
+++ 	XCloseDisplay(dpy);
+++ 	return EXIT_SUCCESS;
+++ }
++++
++diff --git a/patches_git/dwm-swallow.diff b/patches_git/dwm-swallow.diff
++new file mode 100644
++index 0000000..8119113
++--- /dev/null
+++++ b/patches_git/dwm-swallow.diff
++@@ -0,0 +1,398 @@
+++diff --git a/config.def.h b/config.def.h
+++index f74867c..5a9f2d4 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -3,6 +3,7 @@
+++ /* appearance */
+++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
++++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+++ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+++ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+++ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+++@@ -31,9 +32,11 @@ static const Rule rules[] = {
+++ 	 *	WM_CLASS(STRING) = instance, class
+++ 	 *	WM_NAME(STRING) = title
+++ 	 */
+++-	/* class      instance    title       tags mask     isfloating   monitor */
+++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+++ };
+++ 
+++ /* layout(s) */
+++diff --git a/config.mk b/config.mk
+++index 8efca9a..a933c0b 100644
+++--- a/config.mk
++++++ b/config.mk
+++@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+++ # OpenBSD (uncomment)
+++ #FREETYPEINC = ${X11INC}/freetype2
+++ #MANPREFIX = ${PREFIX}/man
++++#KVMLIB = -lkvm
+++ 
+++ # includes and libs
+++ INCS = -I${X11INC} -I${FREETYPEINC}
+++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+++ 
+++ # flags
+++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+++diff --git a/dwm.c b/dwm.c
+++index ed799c2..a424e60 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -41,6 +41,12 @@
+++ #include <X11/extensions/Xinerama.h>
+++ #endif /* XINERAMA */
+++ #include <X11/Xft/Xft.h>
++++#include <X11/Xlib-xcb.h>
++++#include <xcb/res.h>
++++#ifdef __OpenBSD__
++++#include <sys/sysctl.h>
++++#include <kvm.h>
++++#endif /* __OpenBSD */
+++ 
+++ #include "drw.h"
+++ #include "util.h"
+++@@ -94,9 +100,11 @@ struct Client {
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++ 	int bw, oldbw;
+++ 	unsigned int tags;
+++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
++++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
++++    pid_t pid;
+++ 	Client *next;
+++ 	Client *snext;
++++    Client *swallowing;
+++ 	Monitor *mon;
+++ 	Window win;
+++ };
+++@@ -144,6 +152,8 @@ typedef struct {
+++ 	const char *title;
+++ 	unsigned int tags;
+++ 	int isfloating;
++++	int isterminal;
++++	int noswallow;
+++ 	int monitor;
+++ } Rule;
+++ 
+++@@ -249,6 +259,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
+++ 
++++static pid_t getparentprocess(pid_t p);
++++static int isdescprocess(pid_t p, pid_t c);
++++static Client *swallowingclient(Window w);
++++static Client *termforwin(const Client *c);
++++static pid_t winpid(Window w);
++++
+++ /* variables */
+++ static const char autostartblocksh[] = "autostart_blocking.sh";
+++ static const char autostartsh[] = "autostart.sh";
+++@@ -290,6 +306,8 @@ static Drw *drw;
+++ static Monitor *mons, *selmon;
+++ static Window root, wmcheckwin;
+++ 
++++static xcb_connection_t *xcon;
++++
+++ /* configuration, allows nested code to access above variables */
+++ #include "config.h"
+++ 
+++@@ -319,6 +337,8 @@ applyrules(Client *c)
+++ 		&& (!r->class || strstr(class, r->class))
+++ 		&& (!r->instance || strstr(instance, r->instance)))
+++ 		{
++++			c->isterminal = r->isterminal;
++++			c->noswallow  = r->noswallow;
+++ 			c->isfloating = r->isfloating;
+++ 			c->tags |= r->tags;
+++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+++@@ -437,6 +457,53 @@ attachstack(Client *c)
+++ 	c->mon->stack = c;
+++ }
+++ 
++++void
++++swallow(Client *p, Client *c)
++++{
++++
++++	if (c->noswallow || c->isterminal)
++++		return;
++++	if (c->noswallow && !swallowfloating && c->isfloating)
++++		return;
++++
++++	detach(c);
++++	detachstack(c);
++++
++++	setclientstate(c, WithdrawnState);
++++	XUnmapWindow(dpy, p->win);
++++
++++	p->swallowing = c;
++++	c->mon = p->mon;
++++
++++	Window w = p->win;
++++	p->win = c->win;
++++	c->win = w;
++++	updatetitle(p);
++++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++++	arrange(p->mon);
++++	configure(p);
++++	updateclientlist();
++++}
++++
++++void
++++unswallow(Client *c)
++++{
++++	c->win = c->swallowing->win;
++++
++++	free(c->swallowing);
++++	c->swallowing = NULL;
++++
++++	/* unfullscreen the client */
++++	setfullscreen(c, 0);
++++	updatetitle(c);
++++	arrange(c->mon);
++++	XMapWindow(dpy, c->win);
++++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++++	setclientstate(c, NormalState);
++++	focus(NULL);
++++	arrange(c->mon);
++++}
++++
+++ void
+++ buttonpress(XEvent *e)
+++ {
+++@@ -714,6 +781,9 @@ destroynotify(XEvent *e)
+++ 
+++ 	if ((c = wintoclient(ev->window)))
+++ 		unmanage(c, 1);
++++
++++	else if ((c = swallowingclient(ev->window)))
++++		unmanage(c->swallowing, 1);
+++ }
+++ 
+++ void
+++@@ -1217,12 +1287,13 @@ killclient(const Arg *arg)
+++ void
+++ manage(Window w, XWindowAttributes *wa)
+++ {
+++-	Client *c, *t = NULL;
++++	Client *c, *t = NULL, *term = NULL;
+++ 	Window trans = None;
+++ 	XWindowChanges wc;
+++ 
+++ 	c = ecalloc(1, sizeof(Client));
+++ 	c->win = w;
++++	c->pid = winpid(w);
+++ 	/* geometry */
+++ 	c->x = c->oldx = wa->x;
+++ 	c->y = c->oldy = wa->y;
+++@@ -1238,6 +1309,7 @@ manage(Window w, XWindowAttributes *wa)
+++ 	} else {
+++ 		c->mon = selmon;
+++ 		applyrules(c);
++++		term = termforwin(c);
+++ 	}
+++ 
+++ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+++@@ -1276,6 +1348,8 @@ manage(Window w, XWindowAttributes *wa)
+++ 	c->mon->sel = c;
+++ 	arrange(c->mon);
+++ 	XMapWindow(dpy, c->win);
++++	if (term)
++++		swallow(term, c);
+++ 	focus(NULL);
+++ }
+++ 
+++@@ -2134,6 +2208,20 @@ unmanage(Client *c, int destroyed)
+++ 	Monitor *m = c->mon;
+++ 	XWindowChanges wc;
+++ 
++++	if (c->swallowing) {
++++		unswallow(c);
++++		return;
++++	}
++++
++++	Client *s = swallowingclient(c->win);
++++	if (s) {
++++		free(s->swallowing);
++++		s->swallowing = NULL;
++++		arrange(m);
++++		focus(NULL);
++++		return;
++++	}
++++
+++ 	detach(c);
+++ 	detachstack(c);
+++ 	if (!destroyed) {
+++@@ -2149,9 +2237,12 @@ unmanage(Client *c, int destroyed)
+++ 		XUngrabServer(dpy);
+++ 	}
+++ 	free(c);
+++-	focus(NULL);
+++-	updateclientlist();
+++-	arrange(m);
++++
++++	if (!s) {
++++		arrange(m);
++++		focus(NULL);
++++		updateclientlist();
++++	}
+++ }
+++ 
+++ void
+++@@ -2418,6 +2509,136 @@ view(const Arg *arg)
+++ 	arrange(selmon);
+++ }
+++ 
++++pid_t
++++winpid(Window w)
++++{
++++
++++	pid_t result = 0;
++++
++++#ifdef __linux__
++++	xcb_res_client_id_spec_t spec = {0};
++++	spec.client = w;
++++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++++
++++	xcb_generic_error_t *e = NULL;
++++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++++
++++	if (!r)
++++		return (pid_t)0;
++++
++++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++++		spec = i.data->spec;
++++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++++			result = *t;
++++			break;
++++		}
++++	}
++++
++++	free(r);
++++
++++	if (result == (pid_t)-1)
++++		result = 0;
++++
++++#endif /* __linux__ */
++++
++++#ifdef __OpenBSD__
++++        Atom type;
++++        int format;
++++        unsigned long len, bytes;
++++        unsigned char *prop;
++++        pid_t ret;
++++
++++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++++               return 0;
++++
++++        ret = *(pid_t*)prop;
++++        XFree(prop);
++++        result = ret;
++++
++++#endif /* __OpenBSD__ */
++++	return result;
++++}
++++
++++pid_t
++++getparentprocess(pid_t p)
++++{
++++	unsigned int v = 0;
++++
++++#ifdef __linux__
++++	FILE *f;
++++	char buf[256];
++++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++++
++++	if (!(f = fopen(buf, "r")))
++++		return 0;
++++
++++	fscanf(f, "%*u %*s %*c %u", &v);
++++	fclose(f);
++++#endif /* __linux__*/
++++
++++#ifdef __OpenBSD__
++++	int n;
++++	kvm_t *kd;
++++	struct kinfo_proc *kp;
++++
++++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++++	if (!kd)
++++		return 0;
++++
++++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++++	v = kp->p_ppid;
++++#endif /* __OpenBSD__ */
++++
++++	return (pid_t)v;
++++}
++++
++++int
++++isdescprocess(pid_t p, pid_t c)
++++{
++++	while (p != c && c != 0)
++++		c = getparentprocess(c);
++++
++++	return (int)c;
++++}
++++
++++Client *
++++termforwin(const Client *w)
++++{
++++	Client *c;
++++	Monitor *m;
++++
++++	if (!w->pid || w->isterminal)
++++		return NULL;
++++
++++	for (m = mons; m; m = m->next) {
++++		for (c = m->clients; c; c = c->next) {
++++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++++				return c;
++++		}
++++	}
++++
++++	return NULL;
++++}
++++
++++Client *
++++swallowingclient(Window w)
++++{
++++	Client *c;
++++	Monitor *m;
++++
++++	for (m = mons; m; m = m->next) {
++++		for (c = m->clients; c; c = c->next) {
++++			if (c->swallowing && c->swallowing->win == w)
++++				return c;
++++		}
++++	}
++++
++++	return NULL;
++++}
++++
+++ Client *
+++ wintoclient(Window w)
+++ {
+++@@ -2507,10 +2728,12 @@ main(int argc, char *argv[])
+++ 		fputs("warning: no locale support\n", stderr);
+++ 	if (!(dpy = XOpenDisplay(NULL)))
+++ 		die("dwm: cannot open display");
++++	if (!(xcon = XGetXCBConnection(dpy)))
++++		die("dwm: cannot get xcb connection\n");
+++ 	checkotherwm();
+++ 	setup();
+++ #ifdef __OpenBSD__
+++-	if (pledge("stdio rpath proc exec", NULL) == -1)
++++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+++ 		die("pledge");
+++ #endif /* __OpenBSD__ */
+++ 	scan();
++diff --git a/patches_git/dwm-tagshift.diff b/patches_git/dwm-tagshift.diff
++new file mode 100644
++index 0000000..b416cd8
++--- /dev/null
+++++ b/patches_git/dwm-tagshift.diff
++@@ -0,0 +1,69 @@
+++diff --git a/config.def.h b/config.def.h
+++index 880a46a..f6c7894 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -89,6 +89,10 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++ 	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+++diff --git a/dwm.c b/dwm.c
+++index 9ae5616..0d205d0 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -210,6 +210,8 @@ static void setcfact(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++ static void setup(void);
+++ static void seturgent(Client *c, int urg);
++++static void shiftview(const Arg *arg);
++++static void shifttag(const Arg *arg);
+++ static void showhide(Client *c);
+++ static void spawn(const Arg *arg);
+++ static void tag(const Arg *arg);
+++@@ -1633,6 +1635,40 @@ setlayout(const Arg *arg)
+++ 		drawbar(selmon);
+++ }
+++ 
++++void
++++shiftview(const Arg *arg) {
++++	Arg shifted;
++++
++++	if(arg->i > 0) /* left circular shift */
++++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++++
++++	else /* right circular shift */
++++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++++
++++	view(&shifted);
++++}
++++
++++void
++++shifttag(const Arg *arg) {
++++	Arg shifted;
++++	Client *c;
++++
++++	if (!selmon->sel)
++++		return;
++++	c = selmon->sel;
++++
++++	if (arg->i > 0) /* left circular shift */
++++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++++			^ (c->tags >> (LENGTH(tags) - arg->i));
++++	else /* right circular shift */
++++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++++			^ (c->tags << (LENGTH(tags) + arg->i));
++++
++++	toggletag(&shifted);
++++}
++++
+++ void
+++ setcfact(const Arg *arg) {
+++ 	float f;
++diff --git a/patches_git/dwm-vanitygaps.diff b/patches_git/dwm-vanitygaps.diff
++new file mode 100644
++index 0000000..1f1b7b5
++--- /dev/null
+++++ b/patches_git/dwm-vanitygaps.diff
++@@ -0,0 +1,1018 @@
+++diff --git a/config.def.h b/config.def.h
+++index 9efa774..357dc6f 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -3,6 +3,11 @@
+++ /* appearance */
+++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++ static const unsigned int snap      = 32;       /* snap pixel */
++++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+++ static const int showbar            = 1;        /* 0 means no bar */
+++ static const int topbar             = 1;        /* 0 means bottom bar */
+++ static const char *fonts[]          = { "monospace:size=10" };
+++@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+++ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+++ 
++++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++++#include "vanitygaps.c"
++++
+++ static const Layout layouts[] = {
+++ 	/* symbol     arrange function */
+++ 	{ "[]=",      tile },    /* first entry is default */
+++-	{ "><>",      NULL },    /* no layout function means floating behavior */
+++ 	{ "[M]",      monocle },
++++	{ "[@]",      spiral },
++++	{ "[\\]",     dwindle },
++++	{ "H[]",      deck },
++++	{ "TTT",      bstack },
++++	{ "===",      bstackhoriz },
++++	{ "HHH",      grid },
++++	{ "###",      nrowgrid },
++++	{ "---",      horizgrid },
++++	{ ":::",      gaplessgrid },
++++	{ "|M|",      centeredmaster },
++++	{ ">M>",      centeredfloatingmaster },
++++	{ "><>",      NULL },    /* no layout function means floating behavior */
++++	{ NULL,       NULL },
+++ };
+++ 
+++ /* key definitions */
+++@@ -71,7 +91,26 @@ static const Key keys[] = {
+++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+++ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+++diff --git a/dwm.c b/dwm.c
+++index 857c396..db7e0c8 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -86,6 +86,7 @@ typedef struct Client Client;
+++ struct Client {
+++ 	char name[256];
+++ 	float mina, maxa;
++++	float cfact;
+++ 	int x, y, w, h;
+++ 	int oldx, oldy, oldw, oldh;
+++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+++@@ -118,6 +119,10 @@ struct Monitor {
+++ 	int by;               /* bar geometry */
+++ 	int mx, my, mw, mh;   /* screen size */
+++ 	int wx, wy, ww, wh;   /* window area  */
++++	int gappih;           /* horizontal gap between windows */
++++	int gappiv;           /* vertical gap between windows */
++++	int gappoh;           /* horizontal outer gaps */
++++	int gappov;           /* vertical outer gaps */
+++ 	unsigned int seltags;
+++ 	unsigned int sellt;
+++ 	unsigned int tagset[2];
+++@@ -200,6 +205,7 @@ static void setclientstate(Client *c, long state);
+++ static void setfocus(Client *c);
+++ static void setfullscreen(Client *c, int fullscreen);
+++ static void setlayout(const Arg *arg);
++++static void setcfact(const Arg *arg);
+++ static void setmfact(const Arg *arg);
+++ static void setup(void);
+++ static void seturgent(Client *c, int urg);
+++@@ -207,7 +213,6 @@ static void showhide(Client *c);
+++ static void spawn(const Arg *arg);
+++ static void tag(const Arg *arg);
+++ static void tagmon(const Arg *arg);
+++-static void tile(Monitor *m);
+++ static void togglebar(const Arg *arg);
+++ static void togglefloating(const Arg *arg);
+++ static void toggletag(const Arg *arg);
+++@@ -640,6 +645,10 @@ createmon(void)
+++ 	m->nmaster = nmaster;
+++ 	m->showbar = showbar;
+++ 	m->topbar = topbar;
++++	m->gappih = gappih;
++++	m->gappiv = gappiv;
++++	m->gappoh = gappoh;
++++	m->gappov = gappov;
+++ 	m->lt[0] = &layouts[0];
+++ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+++ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+++@@ -1042,6 +1051,7 @@ manage(Window w, XWindowAttributes *wa)
+++ 	c->w = c->oldw = wa->width;
+++ 	c->h = c->oldh = wa->height;
+++ 	c->oldbw = wa->border_width;
++++	c->cfact = 1.0;
+++ 
+++ 	updatetitle(c);
+++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+++@@ -1527,6 +1537,24 @@ setlayout(const Arg *arg)
+++ 		drawbar(selmon);
+++ }
+++ 
++++void
++++setcfact(const Arg *arg) {
++++	float f;
++++	Client *c;
++++
++++	c = selmon->sel;
++++
++++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++++		return;
++++	f = arg->f + c->cfact;
++++	if(arg->f == 0.0)
++++		f = 1.0;
++++	else if(f < 0.25 || f > 4.0)
++++		return;
++++	c->cfact = f;
++++	arrange(selmon);
++++}
++++
+++ /* arg > 1.0 will set mfact absolutely */
+++ void
+++ setmfact(const Arg *arg)
+++@@ -1690,34 +1718,6 @@ tagmon(const Arg *arg)
+++ 	sendmon(selmon->sel, dirtomon(arg->i));
+++ }
+++ 
+++-void
+++-tile(Monitor *m)
+++-{
+++-	unsigned int i, n, h, mw, my, ty;
+++-	Client *c;
+++-
+++-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++-	if (n == 0)
+++-		return;
+++-
+++-	if (n > m->nmaster)
+++-		mw = m->nmaster ? m->ww * m->mfact : 0;
+++-	else
+++-		mw = m->ww;
+++-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++-		if (i < m->nmaster) {
+++-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+++-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+++-			if (my + HEIGHT(c) < m->wh)
+++-				my += HEIGHT(c);
+++-		} else {
+++-			h = (m->wh - ty) / (n - i);
+++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+++-			if (ty + HEIGHT(c) < m->wh)
+++-				ty += HEIGHT(c);
+++-		}
+++-}
+++-
+++ void
+++ togglebar(const Arg *arg)
+++ {
+++diff --git a/vanitygaps.c b/vanitygaps.c
+++new file mode 100644
+++index 0000000..1a816b6
+++--- /dev/null
++++++ b/vanitygaps.c
+++@@ -0,0 +1,822 @@
++++/* Key binding functions */
++++static void defaultgaps(const Arg *arg);
++++static void incrgaps(const Arg *arg);
++++static void incrigaps(const Arg *arg);
++++static void incrogaps(const Arg *arg);
++++static void incrohgaps(const Arg *arg);
++++static void incrovgaps(const Arg *arg);
++++static void incrihgaps(const Arg *arg);
++++static void incrivgaps(const Arg *arg);
++++static void togglegaps(const Arg *arg);
++++/* Layouts (delete the ones you do not need) */
++++static void bstack(Monitor *m);
++++static void bstackhoriz(Monitor *m);
++++static void centeredmaster(Monitor *m);
++++static void centeredfloatingmaster(Monitor *m);
++++static void deck(Monitor *m);
++++static void dwindle(Monitor *m);
++++static void fibonacci(Monitor *m, int s);
++++static void grid(Monitor *m);
++++static void nrowgrid(Monitor *m);
++++static void spiral(Monitor *m);
++++static void tile(Monitor *m);
++++/* Internals */
++++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++++static void setgaps(int oh, int ov, int ih, int iv);
++++
++++/* Settings */
++++#if !PERTAG_PATCH
++++static int enablegaps = 1;
++++#endif // PERTAG_PATCH
++++
++++void
++++setgaps(int oh, int ov, int ih, int iv)
++++{
++++	if (oh < 0) oh = 0;
++++	if (ov < 0) ov = 0;
++++	if (ih < 0) ih = 0;
++++	if (iv < 0) iv = 0;
++++
++++	selmon->gappoh = oh;
++++	selmon->gappov = ov;
++++	selmon->gappih = ih;
++++	selmon->gappiv = iv;
++++	arrange(selmon);
++++}
++++
++++void
++++togglegaps(const Arg *arg)
++++{
++++	#if PERTAG_PATCH
++++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++++	#else
++++	enablegaps = !enablegaps;
++++	#endif // PERTAG_PATCH
++++	arrange(NULL);
++++}
++++
++++void
++++defaultgaps(const Arg *arg)
++++{
++++	setgaps(gappoh, gappov, gappih, gappiv);
++++}
++++
++++void
++++incrgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov + arg->i,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++incrigaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++incrogaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov + arg->i,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrohgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh + arg->i,
++++		selmon->gappov,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrovgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov + arg->i,
++++		selmon->gappih,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrihgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih + arg->i,
++++		selmon->gappiv
++++	);
++++}
++++
++++void
++++incrivgaps(const Arg *arg)
++++{
++++	setgaps(
++++		selmon->gappoh,
++++		selmon->gappov,
++++		selmon->gappih,
++++		selmon->gappiv + arg->i
++++	);
++++}
++++
++++void
++++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++++{
++++	unsigned int n, oe, ie;
++++	#if PERTAG_PATCH
++++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++++	#else
++++	oe = ie = enablegaps;
++++	#endif // PERTAG_PATCH
++++	Client *c;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++++	if (smartgaps && n == 1) {
++++		oe = 0; // outer gaps disabled when only one client
++++	}
++++
++++	*oh = m->gappoh*oe; // outer horizontal gap
++++	*ov = m->gappov*oe; // outer vertical gap
++++	*ih = m->gappih*ie; // inner horizontal gap
++++	*iv = m->gappiv*ie; // inner vertical gap
++++	*nc = n;            // number of clients
++++}
++++
++++void
++++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++++{
++++	unsigned int n;
++++	float mfacts = 0, sfacts = 0;
++++	int mtotal = 0, stotal = 0;
++++	Client *c;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (n < m->nmaster)
++++			mfacts += c->cfact;
++++		else
++++			sfacts += c->cfact;
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (n < m->nmaster)
++++			mtotal += msize * (c->cfact / mfacts);
++++		else
++++			stotal += ssize * (c->cfact / sfacts);
++++
++++	*mf = mfacts; // total factor of master area
++++	*sf = sfacts; // total factor of stack area
++++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++++}
++++
++++/***
++++ * Layouts
++++ */
++++
++++/*
++++ * Bottomstack layout + gaps
++++ * https://dwm.suckless.org/patches/bottomstack/
++++ */
++++static void
++++bstack(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sh = (mh - ih) * (1 - m->mfact);
++++		mh = mh - ih - sh;
++++		sx = mx;
++++		sy = my + mh + ih;
++++	}
++++
++++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++	}
++++}
++++
++++static void
++++bstackhoriz(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	mh = m->wh - 2*oh;
++++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++++	sw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sh = (mh - ih) * (1 - m->mfact);
++++		mh = mh - ih - sh;
++++		sy = my + mh + ih;
++++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++++	}
++++
++++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++++			sy += HEIGHT(c) + ih;
++++		}
++++	}
++++}
++++
++++/*
++++ * Centred master layout + gaps
++++ * https://dwm.suckless.org/patches/centeredmaster/
++++ */
++++void
++++centeredmaster(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int lx = 0, ly = 0, lw = 0, lh = 0;
++++	int rx = 0, ry = 0, rw = 0, rh = 0;
++++	float mfacts = 0, lfacts = 0, rfacts = 0;
++++	int mtotal = 0, ltotal = 0, rtotal = 0;
++++	int mrest = 0, lrest = 0, rrest = 0;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	/* initialize areas */
++++	mx = m->wx + ov;
++++	my = m->wy + oh;
++++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++++	mw = m->ww - 2*ov;
++++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		/* go mfact box in the center if more than nmaster clients */
++++		if (n - m->nmaster > 1) {
++++			/* ||<-S->|<---M--->|<-S->|| */
++++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++++			mx += lw + iv;
++++		} else {
++++			/* ||<---M--->|<-S->|| */
++++			mw = (mw - iv) * m->mfact;
++++			lw = 0;
++++			rw = m->ww - mw - iv - 2*ov;
++++		}
++++		lx = m->wx + ov;
++++		ly = m->wy + oh;
++++		rx = mx + mw + iv;
++++		ry = m->wy + oh;
++++	}
++++
++++	/* calculate facts */
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++++		if (!m->nmaster || n < m->nmaster)
++++			mfacts += c->cfact;
++++		else if ((n - m->nmaster) % 2)
++++			lfacts += c->cfact; // total factor of left hand stack area
++++		else
++++			rfacts += c->cfact; // total factor of right hand stack area
++++	}
++++
++++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++++		if (!m->nmaster || n < m->nmaster)
++++			mtotal += mh * (c->cfact / mfacts);
++++		else if ((n - m->nmaster) % 2)
++++			ltotal += lh * (c->cfact / lfacts);
++++		else
++++			rtotal += rh * (c->cfact / rfacts);
++++
++++	mrest = mh - mtotal;
++++	lrest = lh - ltotal;
++++	rrest = rh - rtotal;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		if (!m->nmaster || i < m->nmaster) {
++++			/* nmaster clients are stacked vertically, in the center of the screen */
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			/* stack clients are stacked vertically */
++++			if ((i - m->nmaster) % 2 ) {
++++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++++				ly += HEIGHT(c) + ih;
++++			} else {
++++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++++				ry += HEIGHT(c) + ih;
++++			}
++++		}
++++	}
++++}
++++
++++void
++++centeredfloatingmaster(Monitor *m)
++++{
++++	unsigned int i, n;
++++	float mfacts, sfacts;
++++	float mivf = 1.0; // master inner vertical gap factor
++++	int oh, ov, ih, iv, mrest, srest;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	mw = m->ww - 2*ov - iv*(n - 1);
++++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		mivf = 0.8;
++++		/* go mfact box in the center if more than nmaster clients */
++++		if (m->ww > m->wh) {
++++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++++			mh = m->wh * 0.9;
++++		} else {
++++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++++			mh = m->wh * m->mfact;
++++		}
++++		mx = m->wx + (m->ww - mw) / 2;
++++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++++
++++		sx = m->wx + ov;
++++		sy = m->wy + oh;
++++		sh = m->wh - 2*oh;
++++	}
++++
++++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			/* nmaster clients are stacked horizontally, in the center of the screen */
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv*mivf;
++++		} else {
++++			/* stack clients are stacked horizontally */
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++}
++++
++++/*
++++ * Deck layout + gaps
++++ * https://dwm.suckless.org/patches/deck/
++++ */
++++void
++++deck(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sw = (mw - iv) * (1 - m->mfact);
++++		mw = mw - iv - sw;
++++		sx = mx + mw + iv;
++++		sh = m->wh - 2*oh;
++++	}
++++
++++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	if (n - m->nmaster > 0) /* override layout symbol */
++++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++++		}
++++}
++++
++++/*
++++ * Fibonacci layout + gaps
++++ * https://dwm.suckless.org/patches/fibonacci/
++++ */
++++void
++++fibonacci(Monitor *m, int s)
++++{
++++	unsigned int i, n;
++++	int nx, ny, nw, nh;
++++	int oh, ov, ih, iv;
++++	int nv, hrest = 0, wrest = 0, r = 1;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	nx = m->wx + ov;
++++	ny = m->wy + oh;
++++	nw = m->ww - 2*ov;
++++	nh = m->wh - 2*oh;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++++		if (r) {
++++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++++				r = 0;
++++			}
++++			if (r && i < n - 1) {
++++				if (i % 2) {
++++					nv = (nh - ih) / 2;
++++					hrest = nh - 2*nv - ih;
++++					nh = nv;
++++				} else {
++++					nv = (nw - iv) / 2;
++++					wrest = nw - 2*nv - iv;
++++					nw = nv;
++++				}
++++
++++				if ((i % 4) == 2 && !s)
++++					nx += nw + iv;
++++				else if ((i % 4) == 3 && !s)
++++					ny += nh + ih;
++++			}
++++
++++			if ((i % 4) == 0) {
++++				if (s) {
++++					ny += nh + ih;
++++					nh += hrest;
++++				}
++++				else {
++++					nh -= hrest;
++++					ny -= nh + ih;
++++				}
++++			}
++++			else if ((i % 4) == 1) {
++++				nx += nw + iv;
++++				nw += wrest;
++++			}
++++			else if ((i % 4) == 2) {
++++				ny += nh + ih;
++++				nh += hrest;
++++				if (i < n - 1)
++++					nw += wrest;
++++			}
++++			else if ((i % 4) == 3) {
++++				if (s) {
++++					nx += nw + iv;
++++					nw -= wrest;
++++				} else {
++++					nw -= wrest;
++++					nx -= nw + iv;
++++					nh += hrest;
++++				}
++++			}
++++			if (i == 0)	{
++++				if (n != 1) {
++++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++++					wrest = 0;
++++				}
++++				ny = m->wy + oh;
++++			}
++++			else if (i == 1)
++++				nw = m->ww - nw - iv - 2*ov;
++++			i++;
++++		}
++++
++++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++++	}
++++}
++++
++++void
++++dwindle(Monitor *m)
++++{
++++	fibonacci(m, 1);
++++}
++++
++++void
++++spiral(Monitor *m)
++++{
++++	fibonacci(m, 0);
++++}
++++
++++/*
++++ * Gappless grid layout + gaps (ironically)
++++ * https://dwm.suckless.org/patches/gaplessgrid/
++++ */
++++void
++++gaplessgrid(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++++	int oh, ov, ih, iv;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	/* grid dimensions */
++++	for (cols = 0; cols <= n/2; cols++)
++++		if (cols*cols >= n)
++++			break;
++++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++++		cols = 2;
++++	rows = n/cols;
++++	cn = rn = 0; // reset column no, row no, client count
++++
++++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++++	x = m->wx + ov;
++++	y = m->wy + oh;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++++		if (i/rows + 1 > cols - n%cols) {
++++			rows = n/cols + 1;
++++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++		}
++++		resize(c,
++++			x,
++++			y + rn*(ch + ih) + MIN(rn, rrest),
++++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++++			0);
++++		rn++;
++++		if (rn >= rows) {
++++			rn = 0;
++++			x += cw + ih + (cn < crest ? 1 : 0);
++++			cn++;
++++		}
++++	}
++++}
++++
++++/*
++++ * Gridmode layout + gaps
++++ * https://dwm.suckless.org/patches/gridmode/
++++ */
++++void
++++grid(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++++	int oh, ov, ih, iv;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++
++++	/* grid dimensions */
++++	for (rows = 0; rows <= n/2; rows++)
++++		if (rows*rows >= n)
++++			break;
++++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++++
++++	/* window geoms (cell height/width) */
++++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++++		cc = i / rows;
++++		cr = i % rows;
++++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++++	}
++++}
++++
++++/*
++++ * Horizontal grid layout + gaps
++++ * https://dwm.suckless.org/patches/horizgrid/
++++ */
++++void
++++horizgrid(Monitor *m) {
++++	Client *c;
++++	unsigned int n, i;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	int ntop, nbottom = 1;
++++	float mfacts = 0, sfacts = 0;
++++	int mrest, srest, mtotal = 0, stotal = 0;
++++
++++	/* Count windows */
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	if (n <= 2)
++++		ntop = n;
++++	else {
++++		ntop = n / 2;
++++		nbottom = n - ntop;
++++	}
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	sh = mh = m->wh - 2*oh;
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (n > ntop) {
++++		sh = (mh - ih) / 2;
++++		mh = mh - ih - sh;
++++		sy = my + mh + ih;
++++		mw = m->ww - 2*ov - iv * (ntop - 1);
++++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++++	}
++++
++++	/* calculate facts */
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop)
++++			mfacts += c->cfact;
++++		else
++++			sfacts += c->cfact;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop)
++++			mtotal += mh * (c->cfact / mfacts);
++++		else
++++			stotal += sw * (c->cfact / sfacts);
++++
++++	mrest = mh - mtotal;
++++	srest = sw - stotal;
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < ntop) {
++++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++++			mx += WIDTH(c) + iv;
++++		} else {
++++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++++			sx += WIDTH(c) + iv;
++++		}
++++}
++++
++++/*
++++ * nrowgrid layout + gaps
++++ * https://dwm.suckless.org/patches/nrowgrid/
++++ */
++++void
++++nrowgrid(Monitor *m)
++++{
++++	unsigned int n;
++++	int ri = 0, ci = 0;  /* counters */
++++	int oh, ov, ih, iv;                         /* vanitygap settings */
++++	unsigned int cx, cy, cw, ch;                /* client geometry */
++++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++++	unsigned int cols, rows = m->nmaster + 1;
++++	Client *c;
++++
++++	/* count clients */
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++
++++	/* nothing to do here */
++++	if (n == 0)
++++		return;
++++
++++	/* force 2 clients to always split vertically */
++++	if (FORCE_VSPLIT && n == 2)
++++		rows = 1;
++++
++++	/* never allow empty rows */
++++	if (n < rows)
++++		rows = n;
++++
++++	/* define first row */
++++	cols = n / rows;
++++	uc = cols;
++++	cy = m->wy + oh;
++++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++++	uh = ch;
++++
++++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++++		if (ci == cols) {
++++			uw = 0;
++++			ci = 0;
++++			ri++;
++++
++++			/* next row */
++++			cols = (n - uc) / (rows - ri);
++++			uc += cols;
++++			cy = m->wy + oh + uh + ih;
++++			uh += ch + ih;
++++		}
++++
++++		cx = m->wx + ov + uw;
++++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++++		uw += cw + iv;
++++
++++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++++	}
++++}
++++
++++/*
++++ * Default tile layout + gaps
++++ */
++++static void
++++tile(Monitor *m)
++++{
++++	unsigned int i, n;
++++	int oh, ov, ih, iv;
++++	int mx = 0, my = 0, mh = 0, mw = 0;
++++	int sx = 0, sy = 0, sh = 0, sw = 0;
++++	float mfacts, sfacts;
++++	int mrest, srest;
++++	Client *c;
++++
++++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++++	if (n == 0)
++++		return;
++++
++++	sx = mx = m->wx + ov;
++++	sy = my = m->wy + oh;
++++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++++	sw = mw = m->ww - 2*ov;
++++
++++	if (m->nmaster && n > m->nmaster) {
++++		sw = (mw - iv) * (1 - m->mfact);
++++		mw = mw - iv - sw;
++++		sx = mx + mw + iv;
++++	}
++++
++++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++++
++++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++++		if (i < m->nmaster) {
++++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++++			my += HEIGHT(c) + ih;
++++		} else {
++++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++++			sy += HEIGHT(c) + ih;
++++		}
++++}
+++\ No newline at end of file
++diff --git a/patches_git/dwm-xresources.diff b/patches_git/dwm-xresources.diff
++new file mode 100644
++index 0000000..220fdff
++--- /dev/null
+++++ b/patches_git/dwm-xresources.diff
++@@ -0,0 +1,231 @@
+++diff --git a/config.def.h b/config.def.h
+++index 5a9f2d4..9ed2869 100644
+++--- a/config.def.h
++++++ b/config.def.h
+++@@ -1,27 +1,29 @@
+++ /* See LICENSE file for copyright and license details. */
+++ 
+++ /* appearance */
+++-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+++-static const unsigned int snap      = 32;       /* snap pixel */
++++static unsigned int borderpx  = 1;        /* border pixel of windows */
++++static unsigned int snap      = 32;       /* snap pixel */
+++ static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+++ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+++ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+++ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+++ static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+++ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+++-static const int showbar            = 1;        /* 0 means no bar */
+++-static const int topbar             = 1;        /* 0 means bottom bar */
+++-static const char *fonts[]          = { "monospace:size=10" };
+++-static const char dmenufont[]       = "monospace:size=10";
+++-static const char col_gray1[]       = "#222222";
+++-static const char col_gray2[]       = "#444444";
+++-static const char col_gray3[]       = "#bbbbbb";
+++-static const char col_gray4[]       = "#eeeeee";
+++-static const char col_cyan[]        = "#005577";
+++-static const char *colors[][3]      = {
+++-	/*               fg         bg         border   */
+++-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+++-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++++static int showbar            = 1;        /* 0 means no bar */
++++static int topbar             = 1;        /* 0 means bottom bar */
++++static char font[]            = "monospace:size=10";
++++static char dmenufont[]       = "monospace:size=10";
++++static const char *fonts[]          = { font };
++++static char normbgcolor[]           = "#222222";
++++static char normbordercolor[]       = "#444444";
++++static char normfgcolor[]           = "#bbbbbb";
++++static char selfgcolor[]            = "#eeeeee";
++++static char selbordercolor[]        = "#005577";
++++static char selbgcolor[]            = "#005577";
++++static char *colors[][3] = {
++++       /*               fg           bg           border   */
++++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+++ };
+++ 
+++ /* tagging */
+++@@ -40,9 +42,9 @@ static const Rule rules[] = {
+++ };
+++ 
+++ /* layout(s) */
+++-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++-static const int nmaster     = 1;    /* number of clients in master area */
+++-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++++static int nmaster     = 1;    /* number of clients in master area */
++++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+++ 
+++ #define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+++@@ -82,9 +84,30 @@ static const Layout layouts[] = {
+++ 
+++ /* commands */
+++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+++-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+++ static const char *termcmd[]  = { "st", NULL };
+++ 
++++/*
++++ * Xresources preferences to load at startup
++++ */
++++ResourcePref resources[] = {
++++		{ "font",               STRING,  &font },
++++		{ "dmenufont",          STRING,  &dmenufont },
++++		{ "normbgcolor",        STRING,  &normbgcolor },
++++		{ "normbordercolor",    STRING,  &normbordercolor },
++++		{ "normfgcolor",        STRING,  &normfgcolor },
++++		{ "selbgcolor",         STRING,  &selbgcolor },
++++		{ "selbordercolor",     STRING,  &selbordercolor },
++++		{ "selfgcolor",         STRING,  &selfgcolor },
++++		{ "borderpx",          	INTEGER, &borderpx },
++++		{ "snap",          		INTEGER, &snap },
++++		{ "showbar",          	INTEGER, &showbar },
++++		{ "topbar",          	INTEGER, &topbar },
++++		{ "nmaster",          	INTEGER, &nmaster },
++++		{ "resizehints",       	INTEGER, &resizehints },
++++		{ "mfact",      	 	FLOAT,   &mfact },
++++};
++++
+++ static const Key keys[] = {
+++ 	/* modifier                     key        function        argument */
+++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+++diff --git a/drw.c b/drw.c
+++index c41e6af..6be5dee 100644
+++--- a/drw.c
++++++ b/drw.c
+++@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+++ /* Wrapper to create color schemes. The caller has to call free(3) on the
+++  * returned color scheme when done using it. */
+++ Clr *
+++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+++ {
+++ 	size_t i;
+++ 	Clr *ret;
+++diff --git a/drw.h b/drw.h
+++index 6471431..bdbf950 100644
+++--- a/drw.h
++++++ b/drw.h
+++@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+++ 
+++ /* Colorscheme abstraction */
+++ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+++ 
+++ /* Cursor abstraction */
+++ Cur *drw_cur_create(Drw *drw, int shape);
+++diff --git a/dwm.c b/dwm.c
+++index a424e60..cb3067d 100644
+++--- a/dwm.c
++++++ b/dwm.c
+++@@ -37,6 +37,7 @@
+++ #include <X11/Xlib.h>
+++ #include <X11/Xproto.h>
+++ #include <X11/Xutil.h>
++++#include <X11/Xresource.h>
+++ #ifdef XINERAMA
+++ #include <X11/extensions/Xinerama.h>
+++ #endif /* XINERAMA */
+++@@ -157,6 +158,19 @@ typedef struct {
+++ 	int monitor;
+++ } Rule;
+++ 
++++/* Xresources preferences */
++++enum resource_type {
++++	STRING = 0,
++++	INTEGER = 1,
++++	FLOAT = 2
++++};
++++
++++typedef struct {
++++	char *name;
++++	enum resource_type type;
++++	void *dst;
++++} ResourcePref;
++++
+++ /* function declarations */
+++ static void applyrules(Client *c);
+++ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+++@@ -258,6 +272,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++ static void zoom(const Arg *arg);
++++static void load_xresources(void);
++++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+++ 
+++ static pid_t getparentprocess(pid_t p);
+++ static int isdescprocess(pid_t p, pid_t c);
+++@@ -2717,6 +2733,60 @@ zoom(const Arg *arg)
+++ 	pop(c);
+++ }
+++ 
++++void
++++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++++{
++++	char *sdst = NULL;
++++	int *idst = NULL;
++++	float *fdst = NULL;
++++
++++	sdst = dst;
++++	idst = dst;
++++	fdst = dst;
++++
++++	char fullname[256];
++++	char *type;
++++	XrmValue ret;
++++
++++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++++	fullname[sizeof(fullname) - 1] = '\0';
++++
++++	XrmGetResource(db, fullname, "*", &type, &ret);
++++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++++	{
++++		switch (rtype) {
++++		case STRING:
++++			strcpy(sdst, ret.addr);
++++			break;
++++		case INTEGER:
++++			*idst = strtoul(ret.addr, NULL, 10);
++++			break;
++++		case FLOAT:
++++			*fdst = strtof(ret.addr, NULL);
++++			break;
++++		}
++++	}
++++}
++++
++++void
++++load_xresources(void)
++++{
++++	Display *display;
++++	char *resm;
++++	XrmDatabase db;
++++	ResourcePref *p;
++++
++++	display = XOpenDisplay(NULL);
++++	resm = XResourceManagerString(display);
++++	if (!resm)
++++		return;
++++
++++	db = XrmGetStringDatabase(resm);
++++	for (p = resources; p < resources + LENGTH(resources); p++)
++++		resource_load(db, p->name, p->type, p->dst);
++++	XCloseDisplay(display);
++++}
++++
+++ int
+++ main(int argc, char *argv[])
+++ {
+++@@ -2731,6 +2801,8 @@ main(int argc, char *argv[])
+++ 	if (!(xcon = XGetXCBConnection(dpy)))
+++ 		die("dwm: cannot get xcb connection\n");
+++ 	checkotherwm();
++++	XrmInitialize();
++++	load_xresources();
+++ 	setup();
+++ #ifdef __OpenBSD__
+++ 	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++diff --git a/vanitygaps.c b/vanitygaps.c
++new file mode 100644
++index 0000000..5acce38
++--- /dev/null
+++++ b/vanitygaps.c
++@@ -0,0 +1,837 @@
+++/* Key binding functions */
+++static void defaultgaps(const Arg *arg);
+++static void incrgaps(const Arg *arg);
+++static void incrigaps(const Arg *arg);
+++static void incrogaps(const Arg *arg);
+++static void incrohgaps(const Arg *arg);
+++static void incrovgaps(const Arg *arg);
+++static void incrihgaps(const Arg *arg);
+++static void incrivgaps(const Arg *arg);
+++static void togglegaps(const Arg *arg);
+++static void togglebgaps(const Arg *arg);
+++/* Layouts (delete the ones you do not need) */
+++static void bstack(Monitor *m);
+++static void bstackhoriz(Monitor *m);
+++static void centeredmaster(Monitor *m);
+++static void centeredfloatingmaster(Monitor *m);
+++static void deck(Monitor *m);
+++static void dwindle(Monitor *m);
+++static void fibonacci(Monitor *m, int s);
+++static void grid(Monitor *m);
+++static void nrowgrid(Monitor *m);
+++static void spiral(Monitor *m);
+++static void tile(Monitor *m);
+++/* Internals */
+++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+++static void setgaps(int oh, int ov, int ih, int iv);
+++
+++/* Settings */
+++#if !PERTAG_PATCH
+++static int enablegaps = 1;
+++#endif // PERTAG_PATCH
+++
+++void
+++setgaps(int oh, int ov, int ih, int iv)
+++{
+++	if (oh < 0) oh = 0;
+++	if (ov < 0) ov = 0;
+++	if (ih < 0) ih = 0;
+++	if (iv < 0) iv = 0;
+++
+++	selmon->gappoh = oh;
+++	selmon->gappov = ov;
+++	selmon->gappih = ih;
+++	selmon->gappiv = iv;
+++	arrange(selmon);
+++}
+++
+++void
+++togglegaps(const Arg *arg)
+++{
+++	#if PERTAG_PATCH
+++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	enablegaps = !enablegaps;
+++	#endif // PERTAG_PATCH
+++	arrange(NULL);
+++}
+++
+++static void
+++togglebgaps(const Arg *arg)
+++{
+++    browsergaps = !browsergaps;
+++    arrange(NULL);
+++}
+++
+++void
+++defaultgaps(const Arg *arg)
+++{
+++	setgaps(gappoh, gappov, gappih, gappiv);
+++}
+++
+++void
+++incrgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrigaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrogaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrohgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrovgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrihgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrivgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+++{
+++	unsigned int n, oe, ie;
+++	#if PERTAG_PATCH
+++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	oe = ie = enablegaps;
+++	#endif // PERTAG_PATCH
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++	if (smartgaps && n == 1) {
+++		oe = 0; // outer gaps disabled when only one client
+++	}
+++
+++    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+++        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+++        if (TAGMASK == (1 << 8)){
+++            setgaps(gappoh, gappov, gappih, gappiv);
+++        }
+++    }
+++
+++	*oh = m->gappoh*oe; // outer horizontal gap
+++	*ov = m->gappov*oe; // outer vertical gap
+++	*ih = m->gappih*ie; // inner horizontal gap
+++	*iv = m->gappiv*ie; // inner vertical gap
+++	*nc = n;            // number of clients
+++}
+++
+++void
+++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+++{
+++	unsigned int n;
+++	float mfacts = 0, sfacts = 0;
+++	int mtotal = 0, stotal = 0;
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mtotal += msize * (c->cfact / mfacts);
+++		else
+++			stotal += ssize * (c->cfact / sfacts);
+++
+++	*mf = mfacts; // total factor of master area
+++	*sf = sfacts; // total factor of stack area
+++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+++}
+++
+++/***
+++ * Layouts
+++ */
+++
+++/*
+++ * Bottomstack layout + gaps
+++ * https://dwm.suckless.org/patches/bottomstack/
+++ */
+++static void
+++bstack(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sx = mx;
+++		sy = my + mh + ih;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++	}
+++}
+++
+++static void
+++bstackhoriz(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh;
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+++	}
+++
+++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++	}
+++}
+++
+++/*
+++ * Centred master layout + gaps
+++ * https://dwm.suckless.org/patches/centeredmaster/
+++ */
+++void
+++centeredmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int lx = 0, ly = 0, lw = 0, lh = 0;
+++	int rx = 0, ry = 0, rw = 0, rh = 0;
+++	float mfacts = 0, lfacts = 0, rfacts = 0;
+++	int mtotal = 0, ltotal = 0, rtotal = 0;
+++	int mrest = 0, lrest = 0, rrest = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* initialize areas */
+++	mx = m->wx + ov;
+++	my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+++	mw = m->ww - 2*ov;
+++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (n - m->nmaster > 1) {
+++			/* ||<-S->|<---M--->|<-S->|| */
+++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+++			mx += lw + iv;
+++		} else {
+++			/* ||<---M--->|<-S->|| */
+++			mw = (mw - iv) * m->mfact;
+++			lw = 0;
+++			rw = m->ww - mw - iv - 2*ov;
+++		}
+++		lx = m->wx + ov;
+++		ly = m->wy + oh;
+++		rx = mx + mw + iv;
+++		ry = m->wy + oh;
+++	}
+++
+++	/* calculate facts */
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+++		if (!m->nmaster || n < m->nmaster)
+++			mfacts += c->cfact;
+++		else if ((n - m->nmaster) % 2)
+++			lfacts += c->cfact; // total factor of left hand stack area
+++		else
+++			rfacts += c->cfact; // total factor of right hand stack area
+++	}
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (!m->nmaster || n < m->nmaster)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else if ((n - m->nmaster) % 2)
+++			ltotal += lh * (c->cfact / lfacts);
+++		else
+++			rtotal += rh * (c->cfact / rfacts);
+++
+++	mrest = mh - mtotal;
+++	lrest = lh - ltotal;
+++	rrest = rh - rtotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (!m->nmaster || i < m->nmaster) {
+++			/* nmaster clients are stacked vertically, in the center of the screen */
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			/* stack clients are stacked vertically */
+++			if ((i - m->nmaster) % 2 ) {
+++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+++				ly += HEIGHT(c) + ih;
+++			} else {
+++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+++				ry += HEIGHT(c) + ih;
+++			}
+++		}
+++	}
+++}
+++
+++void
+++centeredfloatingmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	float mfacts, sfacts;
+++	float mivf = 1.0; // master inner vertical gap factor
+++	int oh, ov, ih, iv, mrest, srest;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv*(n - 1);
+++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		mivf = 0.8;
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (m->ww > m->wh) {
+++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * 0.9;
+++		} else {
+++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * m->mfact;
+++		}
+++		mx = m->wx + (m->ww - mw) / 2;
+++		my = m->wy + (m->wh - mh - 2*oh) / 2;
+++
+++		sx = m->wx + ov;
+++		sy = m->wy + oh;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			/* nmaster clients are stacked horizontally, in the center of the screen */
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv*mivf;
+++		} else {
+++			/* stack clients are stacked horizontally */
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * Deck layout + gaps
+++ * https://dwm.suckless.org/patches/deck/
+++ */
+++void
+++deck(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	if (n - m->nmaster > 0) /* override layout symbol */
+++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+++		}
+++}
+++
+++/*
+++ * Fibonacci layout + gaps
+++ * https://dwm.suckless.org/patches/fibonacci/
+++ */
+++void
+++fibonacci(Monitor *m, int s)
+++{
+++	unsigned int i, n;
+++	int nx, ny, nw, nh;
+++	int oh, ov, ih, iv;
+++	int nv, hrest = 0, wrest = 0, r = 1;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	nx = m->wx + ov;
+++	ny = m->wy + oh;
+++	nw = m->ww - 2*ov;
+++	nh = m->wh - 2*oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+++		if (r) {
+++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+++				r = 0;
+++			}
+++			if (r && i < n - 1) {
+++				if (i % 2) {
+++					nv = (nh - ih) / 2;
+++					hrest = nh - 2*nv - ih;
+++					nh = nv;
+++				} else {
+++					nv = (nw - iv) / 2;
+++					wrest = nw - 2*nv - iv;
+++					nw = nv;
+++				}
+++
+++				if ((i % 4) == 2 && !s)
+++					nx += nw + iv;
+++				else if ((i % 4) == 3 && !s)
+++					ny += nh + ih;
+++			}
+++
+++			if ((i % 4) == 0) {
+++				if (s) {
+++					ny += nh + ih;
+++					nh += hrest;
+++				}
+++				else {
+++					nh -= hrest;
+++					ny -= nh + ih;
+++				}
+++			}
+++			else if ((i % 4) == 1) {
+++				nx += nw + iv;
+++				nw += wrest;
+++			}
+++			else if ((i % 4) == 2) {
+++				ny += nh + ih;
+++				nh += hrest;
+++				if (i < n - 1)
+++					nw += wrest;
+++			}
+++			else if ((i % 4) == 3) {
+++				if (s) {
+++					nx += nw + iv;
+++					nw -= wrest;
+++				} else {
+++					nw -= wrest;
+++					nx -= nw + iv;
+++					nh += hrest;
+++				}
+++			}
+++			if (i == 0)	{
+++				if (n != 1) {
+++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+++					wrest = 0;
+++				}
+++				ny = m->wy + oh;
+++			}
+++			else if (i == 1)
+++				nw = m->ww - nw - iv - 2*ov;
+++			i++;
+++		}
+++
+++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+++	}
+++}
+++
+++void
+++dwindle(Monitor *m)
+++{
+++	fibonacci(m, 1);
+++}
+++
+++void
+++spiral(Monitor *m)
+++{
+++	fibonacci(m, 0);
+++}
+++
+++/*
+++ * Gappless grid layout + gaps (ironically)
+++ * https://dwm.suckless.org/patches/gaplessgrid/
+++ */
+++void
+++gaplessgrid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* grid dimensions */
+++	for (cols = 0; cols <= n/2; cols++)
+++		if (cols*cols >= n)
+++			break;
+++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+++		cols = 2;
+++	rows = n/cols;
+++	cn = rn = 0; // reset column no, row no, client count
+++
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	x = m->wx + ov;
+++	y = m->wy + oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+++		if (i/rows + 1 > cols - n%cols) {
+++			rows = n/cols + 1;
+++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++		}
+++		resize(c,
+++			x,
+++			y + rn*(ch + ih) + MIN(rn, rrest),
+++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+++			0);
+++		rn++;
+++		if (rn >= rows) {
+++			rn = 0;
+++			x += cw + ih + (cn < crest ? 1 : 0);
+++			cn++;
+++		}
+++	}
+++}
+++
+++/*
+++ * Gridmode layout + gaps
+++ * https://dwm.suckless.org/patches/gridmode/
+++ */
+++void
+++grid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* grid dimensions */
+++	for (rows = 0; rows <= n/2; rows++)
+++		if (rows*rows >= n)
+++			break;
+++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+++
+++	/* window geoms (cell height/width) */
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		cc = i / rows;
+++		cr = i % rows;
+++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+++	}
+++}
+++
+++/*
+++ * Horizontal grid layout + gaps
+++ * https://dwm.suckless.org/patches/horizgrid/
+++ */
+++void
+++horizgrid(Monitor *m) {
+++	Client *c;
+++	unsigned int n, i;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	int ntop, nbottom = 1;
+++	float mfacts = 0, sfacts = 0;
+++	int mrest, srest, mtotal = 0, stotal = 0;
+++
+++	/* Count windows */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	if (n <= 2)
+++		ntop = n;
+++	else {
+++		ntop = n / 2;
+++		nbottom = n - ntop;
+++	}
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (n > ntop) {
+++		sh = (mh - ih) / 2;
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		mw = m->ww - 2*ov - iv * (ntop - 1);
+++		sw = m->ww - 2*ov - iv * (nbottom - 1);
+++	}
+++
+++	/* calculate facts */
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else
+++			stotal += sw * (c->cfact / sfacts);
+++
+++	mrest = mh - mtotal;
+++	srest = sw - stotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * nrowgrid layout + gaps
+++ * https://dwm.suckless.org/patches/nrowgrid/
+++ */
+++void
+++nrowgrid(Monitor *m)
+++{
+++	unsigned int n;
+++	int ri = 0, ci = 0;  /* counters */
+++	int oh, ov, ih, iv;                         /* vanitygap settings */
+++	unsigned int cx, cy, cw, ch;                /* client geometry */
+++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+++	unsigned int cols, rows = m->nmaster + 1;
+++	Client *c;
+++
+++	/* count clients */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* nothing to do here */
+++	if (n == 0)
+++		return;
+++
+++	/* force 2 clients to always split vertically */
+++	if (FORCE_VSPLIT && n == 2)
+++		rows = 1;
+++
+++	/* never allow empty rows */
+++	if (n < rows)
+++		rows = n;
+++
+++	/* define first row */
+++	cols = n / rows;
+++	uc = cols;
+++	cy = m->wy + oh;
+++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+++	uh = ch;
+++
+++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+++		if (ci == cols) {
+++			uw = 0;
+++			ci = 0;
+++			ri++;
+++
+++			/* next row */
+++			cols = (n - uc) / (rows - ri);
+++			uc += cols;
+++			cy = m->wy + oh + uh + ih;
+++			uh += ch + ih;
+++		}
+++
+++		cx = m->wx + ov + uw;
+++		cw = (m->ww - 2*ov - uw) / (cols - ci);
+++		uw += cw + iv;
+++
+++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+++	}
+++}
+++
+++/*
+++ * Default tile layout + gaps
+++ */
+++static void
+++tile(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++}
+diff --git a/drw.c b/drw.c
+index c41e6af..6be5dee 100644
+--- a/drw.c
++++ b/drw.c
+@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 6471431..bdbf950 100644
+--- a/drw.h
++++ b/drw.h
+@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm-mul_mon.diff b/dwm-mul_mon.diff
+new file mode 100644
+index 0000000..52d8476
+--- /dev/null
++++ b/dwm-mul_mon.diff
+@@ -0,0 +1,288 @@
++diff --git a/config.h b/config.h
++index ec7de9e..3fb3f44 100644
++--- a/config.h
+++++ b/config.h
++@@ -214,7 +214,7 @@ static const Key keys[] = {
++         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++         { MODKEY,                   XK_q,               killclient,         {0} },
++-        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
+++        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
++         { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
++         { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
++         { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
++diff --git a/dwm.c b/dwm.c
++index 6232799..8b14f30 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -200,6 +200,7 @@ static void destroynotify(XEvent *e);
++ static void detach(Client *c);
++ static void detachstack(Client *c);
++ static Monitor *dirtomon(int dir);
+++static Monitor *numtomon(int num);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
++ static int drawstatusbar(Monitor *m, int bh, char* text);
++@@ -207,6 +208,7 @@ static void expose(XEvent *e);
++ static void focus(Client *c);
++ static void focusin(XEvent *e);
++ static void focusmon(const Arg *arg);
+++static void focusnthmon(const Arg *arg);
++ static void focusstack(const Arg *arg);
++ static Atom getatomprop(Client *c, Atom prop);
++ static int getrootptr(int *x, int *y);
++@@ -258,7 +260,12 @@ static void tag(const Arg *arg);
++ static void tagview(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void tagmonview(const Arg *arg);
+++static void tagnextmon(const Arg *arg);
+++static void tagnewmon(const Arg *arg);
+++static void tagnthmon(const Arg *arg);
+++static void tagnthmonview(const Arg *arg);
++ static void togglebar(const Arg *arg);
+++static void togglebars(const Arg *arg);
++ static void togglefloating(const Arg *arg);
++ static void togglescratch(const Arg *arg);
++ static void togglesticky(const Arg *arg);
++@@ -791,7 +798,10 @@ createmon(void)
++ 	Monitor *m;
++ 
++ 	m = ecalloc(1, sizeof(Monitor));
++-	m->tagset[0] = m->tagset[1] = 1;
+++    if (mons)
+++        m->tagset[0] = m->tagset[1] = 2;
+++    else
+++        m->tagset[0] = m->tagset[1] = 1;
++ 	m->mfact = mfact;
++ 	m->nmaster = nmaster;
++ 	m->showbar = showbar;
++@@ -857,6 +867,17 @@ dirtomon(int dir)
++ 	return m;
++ }
++ 
+++Monitor *
+++numtomon(int num)
+++{
+++    Monitor *m = NULL;
+++    int i = 0;
+++
+++    for(m = mons, i=0; m->next && i < num; m = m->next)
+++        i++;
+++    return m;
+++}
+++
++ int
++ drawstatusbar(Monitor *m, int bh, char* stext)
++ {
++@@ -1091,6 +1112,22 @@ focusmon(const Arg *arg)
++ 	focus(NULL);
++ }
++ 
+++void
+++focusnthmon(const Arg *arg)
+++{
+++    Monitor *m;
+++
+++    if (!mons->next)
+++        return;
+++
+++    if ((m = numtomon(arg->i)) == selmon)
+++        return;
+++    unfocus(selmon->sel, 0);
+++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+++    selmon = m;
+++    focus(NULL);
+++}
+++
++ void
++ focusstack(const Arg *arg)
++ {
++@@ -2175,20 +2212,76 @@ stackpos(const Arg *arg) {
++ 		return arg->i;
++ }
++ 
+++//void
+++//tag(const Arg *arg)
+++//{
+++//    if (selmon->sel && arg->ui & TAGMASK) {
+++//        if (mons && mons->next) {
+++//            // Moving to even tag, selected mon != first mon
+++//            if ((arg->ui & 341) == 0 && selmon != mons) {
+++//                selmon->sel->tags = arg->ui & TAGMASK;
+++//                focus(NULL);
+++//                arrange(selmon);
+++//                // Moving to odd tag, selected mon == first mon
+++//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
+++//                selmon->sel->tags = arg->ui & TAGMASK;
+++//                focus(NULL);
+++//                arrange(selmon);
+++//            } else {
+++//                tagnextmon(arg);
+++//            }
+++//        } else {
+++//            if (selmon->sel && arg->ui & TAGMASK) {
+++//                selmon->sel->tags = arg->ui & TAGMASK;
+++//                focus(NULL);
+++//                arrange(selmon);
+++//            }
+++//        }
+++//    }
+++//}
+++
++ void
++ tag(const Arg *arg)
++ {
++-	if (selmon->sel && arg->ui & TAGMASK) {
++-		selmon->sel->tags = arg->ui & TAGMASK;
++-		focus(NULL);
++-		arrange(selmon);
++-	}
+++    if (!(selmon->sel && arg->ui & TAGMASK))
+++        return;
+++
+++    if (mons && mons->next) {
+++        // Moving to even tag, selected mon != first mon
+++        if ((arg->ui & 341) == 0 && selmon != mons) {
+++            selmon->sel->tags = arg->ui & TAGMASK;
+++        }
+++        // Moving to odd tag, selected mon == first mon
+++        else if ((arg->ui & 341) > 0 && selmon == mons) {
+++            selmon->sel->tags = arg->ui & TAGMASK;
+++        } else {
+++            tagnextmon(arg);
+++            return;
+++        }
+++    } else {
+++        selmon->sel->tags = arg->ui & TAGMASK;
+++    }
+++
+++    focus(NULL);
+++    arrange(selmon);
++ }
++ 
++ void
++ tagview(const Arg *arg)
++ {
++     if (selmon->sel && arg->ui & TAGMASK) {
+++        if (mons && mons->next) {
+++            // If first monitor and moving to even tag (second mon)
+++            if ((arg->ui & 341) == 0 && selmon == mons) {
+++                tagnthmonview(&((Arg) { .i = 1 }));
+++                tagnewmon(arg);
+++                return;
+++            } else if ((arg->ui & 341) > 0 && selmon != mons) {
+++                tagnthmonview(&((Arg) { .i = 0 }));
+++                tagnewmon(arg);
+++                return;
+++            }
+++        }
++         selmon->sel->tags = arg->ui & TAGMASK;
++         focus(NULL);
++         arrange(selmon);
++@@ -2212,6 +2305,51 @@ tagmonview(const Arg *arg)
++     sendmonview(selmon->sel, dirtomon(arg->i));
++ }
++ 
+++void
+++tagnextmon(const Arg *arg)
+++{
+++    Client *sel;
+++    Monitor *newmon;
+++
+++    if (!selmon->sel || !mons->next)
+++        return;
+++    sel = selmon->sel;
+++    newmon = dirtomon(1);
+++    sendmon(sel, newmon);
+++    if (sel && arg->ui & TAGMASK) {
+++        sel->tags = arg->ui & TAGMASK;
+++        focus(NULL);
+++        arrange(newmon);
+++    }
+++}
+++
+++void
+++tagnewmon(const Arg *arg)
+++{
+++    if (selmon->sel && arg->ui & TAGMASK) {
+++        selmon->sel->tags = arg->ui & TAGMASK;
+++        focus(NULL);
+++        arrange(selmon);
+++        view(arg);
+++    }
+++}
+++
+++void
+++tagnthmon(const Arg *arg)
+++{
+++    if (!selmon->sel || !mons->next)
+++        return;
+++    sendmon(selmon->sel, numtomon(arg->i));
+++}
+++
+++void
+++tagnthmonview(const Arg *arg)
+++{
+++    if (!selmon->sel || !mons->next)
+++        return;
+++    sendmonview(selmon->sel, numtomon(arg->i));
+++}
+++
++ void
++ togglebar(const Arg *arg)
++ {
++@@ -2221,6 +2359,18 @@ togglebar(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglebars(const Arg *arg)
+++{
+++    Monitor *m;
+++    for (m = mons; m; m = m->next) {
+++        m->showbar = !m->showbar;
+++        updatebarpos(m);
+++        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+++        arrange(m);
+++    }
+++}
+++
++ void
++ togglefloating(const Arg *arg)
++ {
++@@ -2623,16 +2773,27 @@ updatewmhints(Client *c)
++ void
++ view(const Arg *arg)
++ {
++-    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
++-        view(&((Arg) { .ui = 0 }));
++-        return;
+++    if (mons && mons->next) {
+++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+++            return;
+++
+++        // GENIUS 101010101
+++        if ((arg->ui & 341) == 0)
+++            focusnthmon(&((Arg) { .i = 1 }));
+++        else
+++            focusnthmon(&((Arg) { .i = 0 }));
+++    } else {
+++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
+++            view(&((Arg) { .ui = 0 })); 
+++            return; 
+++        } 
++     }
++ 
++-	selmon->seltags ^= 1; /* toggle sel tagset */
++-	if (arg->ui & TAGMASK)
++-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++-	focus(NULL);
++-	arrange(selmon);
+++    selmon->seltags ^= 1; /* toggle sel tagset */
+++    if (arg->ui & TAGMASK)
+++        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+++    focus(NULL);
+++    arrange(selmon);
++ }
++ 
++ pid_t
+diff --git a/dwm.1 b/dwm.1
+index ddc8321..d04bec6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -116,6 +124,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+ .B Mod1\-Shift\-c
+ Close focused window.
+ .TP
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
++.TP
+ .B Mod1\-Shift\-space
+ Toggle focused window between tiled and floating state.
+ .TP
+@@ -152,6 +163,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 1443802..c072985 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -36,10 +37,17 @@
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
++#include <X11/Xresource.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -47,24 +55,33 @@
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define GETINC(X)               ((X) - 2000)
++#define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++#define PREVSEL                 3000
++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -86,14 +103,18 @@ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
++	float cfact;
+ 	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
++    pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++    Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -118,6 +139,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -137,9 +162,24 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -160,17 +200,20 @@ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
++static Monitor *numtomon(int num);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+-static void enternotify(XEvent *e);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
++static void focusnthmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -181,11 +224,11 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+ static void propertynotify(XEvent *e);
++static void pushstack(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -193,23 +236,46 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
++static void sendmonview(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shifttag(const Arg *arg);
++static void shifttagclients(const Arg *arg);
++static void shiftview(const Arg *arg);
++static void shiftviewclients(const Arg *arg);
++static void shiftboth(const Arg *arg);
++static void swaptags(const Arg *arg);
++static void shiftswaptags(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void showhide(Client *c);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
++static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
++static void tagview(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *m);
++static void tagmonview(const Arg *arg);
++static void tagnextmon(const Arg *arg);
++static void tagnewmon(const Arg *arg);
++static void tagnthmon(const Arg *arg);
++static void tagnthmonview(const Arg *arg);
+ static void togglebar(const Arg *arg);
++static void togglebars(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglescratch(const Arg *arg);
++static void togglesticky(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -232,10 +298,25 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
++static void load_xresources(void);
++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
++
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
+-static char stext[256];
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
++static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -248,13 +329,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+-	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+-	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+@@ -267,6 +346,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -296,8 +377,15 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+@@ -307,7 +395,7 @@ applyrules(Client *c)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+@@ -414,6 +502,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -425,28 +560,58 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+-		do
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
+ 			x += TEXTW(tags[i]);
+-		while (ev->x >= x && ++i < LENGTH(tags));
++		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+-		else
+-			click = ClkWinTitle;
++        } else if (ev->x > selmon->ww - statusw) {
++            x = selmon->ww - statusw;
++            click = ClkStatusText;
++
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
+ 	} else if ((c = wintoclient(ev->window))) {
+-		focus(c);
+-		restack(selmon);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -485,7 +650,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	free(scheme);
+ 	XDestroyWindow(dpy, wmcheckwin);
+@@ -524,6 +689,10 @@ clientmessage(XEvent *e)
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -635,11 +804,18 @@ createmon(void)
+ 	Monitor *m;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+-	m->tagset[0] = m->tagset[1] = 1;
++    if (mons)
++        m->tagset[0] = m->tagset[1] = 2;
++    else
++        m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -654,6 +830,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -694,6 +873,139 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++Monitor *
++numtomon(int num)
++{
++    Monitor *m = NULL;
++    int i = 0;
++
++    for(m = mons, i=0; m->next && i < num; m = m->next)
++        i++;
++    return m;
++}
++
++int
++drawstatusbar(Monitor *m, int bh, char* stext)
++{
++    int ret, i, w, x, len;
++    short isCode = 0;
++    char *text;
++    char *p;
++    FILE *ptr;
++    char ch;
++    int hotbool = 0;
++
++    len = strlen(stext) + 1 ;
++    if (!(text = (char*) malloc(sizeof(char)*len)))
++        die("malloc");
++    p = text;
++    memcpy(text, stext, len);
++
++    /* compute width of the status text */
++    w = 0;
++    i = -1;
++    while (text[++i]) {
++        if (text[i] == '^') {
++            if (!isCode) {
++                isCode = 1;
++                text[i] = '\0';
++                w += TEXTW(text) - lrpad;
++                text[i] = '^';
++                if (text[++i] == 'f')
++                    w += atoi(text + ++i);
++            } else {
++                isCode = 0;
++                text = text + i + 1;
++                i = -1;
++            }
++        }
++    }
++    if (!isCode)
++        w += TEXTW(text) - lrpad;
++    else
++        isCode = 0;
++    text = p;
++
++    w += 2; /* 1px padding on both sides */
++    ret = x = m->ww - w;
++
++    drw_setscheme(drw, scheme[LENGTH(colors)]);
++    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++    drw_rect(drw, x, 0, w, bh, 1, 1);
++    x++;
++
++    /* process status text */
++    i = -1;
++    drw_clr_create(drw, &drw->scheme[ColFg], col1);
++
++    while (text[++i]) {
++        if (text[i] == '^' && !isCode) {
++            isCode = 1;
++
++            text[i] = '\0';
++            w = TEXTW(text) - lrpad;
++            drw_text(drw, x, 0, w, bh, 0, text, 0);
++            x += w;
++
++            while (text[++i] != '^') {
++                if (text[i] == '2') {
++                    // Check if weather is hot or not
++                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
++                    if (ptr == NULL) printf("Fail to read wr...");
++                    do{
++                        ch = fgetc(ptr);
++                        // Check if temp is above +20 (= hot)
++                        if (hotbool){
++                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
++                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
++                                break;
++                            }else{
++                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
++                                break;
++                            }
++                        }
++
++                        if (ch == '+'){
++                            hotbool = 1;
++                        }else if (ch == '-') {
++                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
++                            break;
++                        }
++                        else{
++                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
++                            break;
++                        }
++                    } while (ch != EOF);
++                    fclose(ptr);
++                } else if (text[i] == '3') {
++                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
++                } else if (text[i] == '4') {
++                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
++                } else if (text[i] == '5') {
++                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
++                } else if (text[i] == '6') {
++                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
++                }
++            }
++
++            text = text + i + 1;
++            i=-1;
++            isCode = 0;
++        }
++    }
++
++    if (!isCode) {
++        w = TEXTW(text) - lrpad;
++        drw_text(drw, x, 0, w, bh, 0, text, 0);
++    }
++
++    drw_setscheme(drw, scheme[SchemeNorm]);
++    free(p);
++
++    return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -707,26 +1019,24 @@ drawbar(Monitor *m)
+ 		return;
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+-	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++	//if (m == selmon) { /* status is only drawn on selected monitor */
++    if (m == selmon || 1) { 
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-		occ |= c->tags;
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-		if (occ & 1 << i)
+-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+-				urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = TEXTW(m->ltsymbol);
+@@ -734,15 +1044,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -756,25 +1059,6 @@ drawbars(void)
+ 		drawbar(m);
+ }
+ 
+-void
+-enternotify(XEvent *e)
+-{
+-	Client *c;
+-	Monitor *m;
+-	XCrossingEvent *ev = &e->xcrossing;
+-
+-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+-		return;
+-	c = wintoclient(ev->window);
+-	m = c ? c->mon : wintomon(ev->window);
+-	if (m != selmon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-	} else if (!c || c == selmon->sel)
+-		return;
+-	focus(c);
+-}
+-
+ void
+ expose(XEvent *e)
+ {
+@@ -834,30 +1118,35 @@ focusmon(const Arg *arg)
+ 	focus(NULL);
+ }
+ 
++void
++focusnthmon(const Arg *arg)
++{
++    Monitor *m;
++
++    if (!mons->next)
++        return;
++
++    if ((m = numtomon(arg->i)) == selmon)
++        return;
++    unfocus(selmon->sel, 0);
++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++    selmon = m;
++    focus(NULL);
++}
++
+ void
+ focusstack(const Arg *arg)
+ {
+-	Client *c = NULL, *i;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++	if(i < 0)
+ 		return;
+-	if (arg->i > 0) {
+-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+-		if (!c)
+-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+-	} else {
+-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+-			if (ISVISIBLE(i))
+-				c = i;
+-		if (!c)
+-			for (; i; i = i->next)
+-				if (ISVISIBLE(i))
+-					c = i;
+-	}
+-	if (c) {
+-		focus(c);
+-		restack(selmon);
+-	}
++
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+@@ -876,6 +1165,30 @@ getatomprop(Client *c, Atom prop)
+ 	return atom;
+ }
+ 
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
++}
++
+ int
+ getrootptr(int *x, int *y)
+ {
+@@ -1030,18 +1343,20 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+@@ -1050,6 +1365,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1067,6 +1383,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -1084,6 +1404,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -1124,23 +1446,6 @@ monocle(Monitor *m)
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+-void
+-motionnotify(XEvent *e)
+-{
+-	static Monitor *mon = NULL;
+-	Monitor *m;
+-	XMotionEvent *ev = &e->xmotion;
+-
+-	if (ev->window != root)
+-		return;
+-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-		focus(NULL);
+-	}
+-	mon = m;
+-}
+-
+ void
+ movemouse(const Arg *arg)
+ {
+@@ -1244,16 +1549,36 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
+ }
+ 
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -1291,6 +1616,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
+@@ -1389,6 +1721,89 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++//void
++//runautostart(void)
++//{
++//	char *pathpfx;
++//	char *path;
++//	char *xdgdatahome;
++//	char *home;
++//	struct stat sb;
++//
++//	if ((home = getenv("HOME")) == NULL)
++//		/* this is almost impossible */
++//		return;
++//
++//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++//	 * otherwise use ~/.local/share/dwm as autostart script directory
++//	 */
++//	xdgdatahome = getenv("XDG_DATA_HOME");
++//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++//		/* space for path segments, separators and nul */
++//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++//
++//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	} else {
++//		/* space for path segments, separators and nul */
++//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++//		                     + strlen(dwmdir) + 3);
++//
++//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	}
++//
++//	/* check if the autostart script directory exists */
++//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++//		/* the XDG conformant path does not exist or is no directory
++//		 * so we try ~/.dwm instead
++//		 */
++//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++//		if(pathpfx_new == NULL) {
++//			free(pathpfx);
++//			return;
++//		}
++//		pathpfx = pathpfx_new;
++//
++//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++//			free(pathpfx);
++//			return;
++//		}
++//	}
++//
++//	/* try the blocking script first */
++//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++//		free(path);
++//		free(pathpfx);
++//	}
++//
++//	if (access(path, X_OK) == 0)
++//		system(path);
++//
++//	/* now the non-blocking script */
++//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++//		free(path);
++//		free(pathpfx);
++//	}
++//
++//	if (access(path, X_OK) == 0)
++//		system(strcat(path, " &"));
++//
++//	free(pathpfx);
++//	free(path);
++//}
++
++void
++runautostart(void)
++{
++    system("killall -q dwmblocks; dwmblocks &");
++}
++
+ void
+ scan(void)
+ {
+@@ -1432,6 +1847,25 @@ sendmon(Client *c, Monitor *m)
+ 	arrange(NULL);
+ }
+ 
++void
++sendmonview(Client *c, Monitor *m)
++{
++    if (c->mon == m)
++        return;
++    unfocus(c, 1);
++    detach(c);
++    detachstack(c);
++    arrange(c->mon);
++    c->mon = m;
++    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++    attach(c);
++    attachstack(c);
++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++    arrange(m);
++    focus(c);
++    restack(m);
++}
++
+ void
+ setclientstate(Client *c, long state)
+ {
+@@ -1506,6 +1940,23 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1520,6 +1971,206 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++//void
++//shiftview(const Arg *arg) {
++//	Arg shifted;
++//
++//	if(arg->i > 0) /* left circular shift */
++//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++//
++//	else /* right circular shift */
++//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++//
++//	view(&shifted);
++//}
++//
++//void
++//shifttag(const Arg *arg) {
++//	Arg shifted;
++//	Client *c;
++//
++//	if (!selmon->sel)
++//		return;
++//	c = selmon->sel;
++//
++//	if (arg->i > 0) /* left circular shift */
++//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++//			^ (c->tags >> (LENGTH(tags) - arg->i));
++//	else /* right circular shift */
++//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++//			^ (c->tags << (LENGTH(tags) + arg->i));
++//
++//	toggletag(&shifted);
++//}
++
++// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
++// Or this (used below):
++// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
++
++/* Sends a window to the next/prev tag */
++void
++shifttag(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
++	tag(&shifted);
++}
++/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
++void
++shifttagclients(const Arg *arg)
++{
++
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	tag(&shifted);
++}
++/* Navigate to the next/prev tag */
++void
++shiftview(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0) {/* left circular shift */
++		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	} else {	/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	}
++	view(&shifted);
++}
++/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
++void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	view(&shifted);
++}
++/* move the current active window to the next/prev tag and view it. More like following the window */
++void
++shiftboth(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	tag(&shifted);
++	view(&shifted);
++}
++//helper function for shiftswaptags found on:
++//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
++// modified to work with scratchpad
++void
++swaptags(const Arg *arg)
++{
++	Client *c;
++	unsigned int newtag = arg->ui & TAGMASK;
++	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
++		return;
++
++	for (c = selmon->clients; c != NULL; c = c->next) {
++		if ((c->tags & newtag) || (c->tags & curtag))
++			c->tags ^= curtag ^ newtag;
++
++		if (!c->tags)
++			c->tags = newtag;
++	}
++
++	//move to the swaped tag
++	//selmon->tagset[selmon->seltags] = newtag;
++
++	focus(NULL);
++	arrange(selmon);
++}
++/* swaps "tags" (all the clients) with the next/prev tag. */
++void
++shiftswaptags(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	swaptags(&shifted);
++	// uncomment if you also want to "go" (view) the tag where the the clients are going
++	//view(&shifted);
++}
++
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
++}
++
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+@@ -1575,6 +2226,7 @@ setup(void)
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+@@ -1583,7 +2235,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
+@@ -1631,6 +2284,10 @@ showhide(Client *c)
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+@@ -1643,6 +2300,20 @@ showhide(Client *c)
+ 	}
+ }
+ 
++void
++sigstatusbar(const Arg *arg)
++{
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++}
++
+ void
+ spawn(const Arg *arg)
+ {
+@@ -1665,14 +2336,111 @@ spawn(const Arg *arg)
+ 	}
+ }
+ 
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
++//void
++//tag(const Arg *arg)
++//{
++//    if (selmon->sel && arg->ui & TAGMASK) {
++//        if (mons && mons->next) {
++//            // Moving to even tag, selected mon != first mon
++//            if ((arg->ui & 341) == 0 && selmon != mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//                // Moving to odd tag, selected mon == first mon
++//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            } else {
++//                tagnextmon(arg);
++//            }
++//        } else {
++//            if (selmon->sel && arg->ui & TAGMASK) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            }
++//        }
++//    }
++//}
++
+ void
+ tag(const Arg *arg)
+ {
+-	if (selmon->sel && arg->ui & TAGMASK) {
+-		selmon->sel->tags = arg->ui & TAGMASK;
+-		focus(NULL);
+-		arrange(selmon);
+-	}
++    if (!(selmon->sel && arg->ui & TAGMASK))
++        return;
++
++    if (mons && mons->next) {
++        // Moving to even tag, selected mon != first mon
++        if ((arg->ui & 341) == 0 && selmon != mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        }
++        // Moving to odd tag, selected mon == first mon
++        else if ((arg->ui & 341) > 0 && selmon == mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        } else {
++            tagnextmon(arg);
++            return;
++        }
++    } else {
++        selmon->sel->tags = arg->ui & TAGMASK;
++    }
++
++    focus(NULL);
++    arrange(selmon);
++}
++
++void
++tagview(const Arg *arg)
++{
++    if (selmon->sel && arg->ui & TAGMASK) {
++        if (mons && mons->next) {
++            // If first monitor and moving to even tag (second mon)
++            if ((arg->ui & 341) == 0 && selmon == mons) {
++                tagnthmonview(&((Arg) { .i = 1 }));
++                tagnewmon(arg);
++                return;
++            } else if ((arg->ui & 341) > 0 && selmon != mons) {
++                tagnthmonview(&((Arg) { .i = 0 }));
++                tagnewmon(arg);
++                return;
++            }
++        }
++        selmon->sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(selmon);
++        view(arg);
++    }
+ }
+ 
+ void
+@@ -1684,31 +2452,56 @@ tagmon(const Arg *arg)
+ }
+ 
+ void
+-tile(Monitor *m)
++tagmonview(const Arg *arg)
+ {
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmonview(selmon->sel, dirtomon(arg->i));
++}
+ 
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
++void
++tagnextmon(const Arg *arg)
++{
++    Client *sel;
++    Monitor *newmon;
+ 
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
++    if (!selmon->sel || !mons->next)
++        return;
++    sel = selmon->sel;
++    newmon = dirtomon(1);
++    sendmon(sel, newmon);
++    if (sel && arg->ui & TAGMASK) {
++        sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(newmon);
++    }
++}
++
++void
++tagnewmon(const Arg *arg)
++{
++    if (selmon->sel && arg->ui & TAGMASK) {
++        selmon->sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(selmon);
++        view(arg);
++    }
++}
++
++void
++tagnthmon(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmon(selmon->sel, numtomon(arg->i));
++}
++
++void
++tagnthmonview(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmonview(selmon->sel, numtomon(arg->i));
+ }
+ 
+ void
+@@ -1720,6 +2513,18 @@ togglebar(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglebars(const Arg *arg)
++{
++    Monitor *m;
++    for (m = mons; m; m = m->next) {
++        m->showbar = !m->showbar;
++        updatebarpos(m);
++        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++        arrange(m);
++    }
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+@@ -1729,11 +2534,61 @@ togglefloating(const Arg *arg)
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
++	arrange(selmon);
++}
++
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
++void
++togglesticky(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
+ 	arrange(selmon);
+ }
+ 
++void
++togglescratch(const Arg *arg)
++{
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+@@ -1780,6 +2635,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -1795,9 +2664,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2026,6 +2898,9 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+@@ -2052,13 +2927,157 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
+-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+-		return;
+-	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
+-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+-	focus(NULL);
+-	arrange(selmon);
++    if (mons && mons->next) {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++            return;
++
++        // GENIUS 101010101
++        if ((arg->ui & 341) == 0)
++            focusnthmon(&((Arg) { .i = 1 }));
++        else
++            focusnthmon(&((Arg) { .i = 0 }));
++    } else {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
++            view(&((Arg) { .ui = 0 })); 
++            return; 
++        } 
++    }
++
++    selmon->seltags ^= 1; /* toggle sel tagset */
++    if (arg->ui & TAGMASK)
++        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++    focus(NULL);
++    arrange(selmon);
++}
++
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
+ }
+ 
+ Client *
+@@ -2139,6 +3158,60 @@ zoom(const Arg *arg)
+ 	pop(c);
+ }
+ 
++void
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
++}
++
++void
++load_xresources(void)
++{
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
++}
++
+ int
+ main(int argc, char *argv[])
+ {
+@@ -2150,15 +3223,22 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
++	XrmInitialize();
++	load_xresources();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
++    arrange(selmon);
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
++
+diff --git a/patches/dwm-6.0-smfact.diff b/patches/dwm-6.0-smfact.diff
+new file mode 100644
+index 0000000..2032ef0
+--- /dev/null
++++ b/patches/dwm-6.0-smfact.diff
+@@ -0,0 +1,117 @@
++--- config.def.h	2013-04-06 21:01:27.750829760 +0200
+++++ config.def.h	2013-04-06 21:02:19.557495556 +0200
++@@ -10,6 +10,7 @@ static const char selbgcolor[]      = "#
++ static const char selfgcolor[]      = "#eeeeee";
++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
+++static const unsigned int minwsz    = 20;       /* Minimal heigt of a client for smfact */
++ static const Bool showbar           = True;     /* False means no bar */
++ static const Bool topbar            = True;     /* False means bottom bar */
++ 
++@@ -24,6 +25,7 @@ static const Rule rules[] = {
++ 
++ /* layout(s) */
++ static const float mfact      = 0.55; /* factor of master area size [0.05..0.95] */
+++static const float smfact     = 0.00; /* factor of tiled clients [0.00..0.95] */
++ static const int nmaster      = 1;    /* number of clients in master area */
++ static const Bool resizehints = True; /* True means respect size hints in tiled resizals */
++ 
++@@ -60,6 +62,8 @@ static Key keys[] = {
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++	{ MODKEY|ShiftMask,             XK_h,      setsmfact,      {.f = +0.05} },
+++	{ MODKEY|ShiftMask,             XK_l,      setsmfact,      {.f = -0.05} },
++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
++--- dwm.c	2011-12-19 16:02:46.000000000 +0100
+++++ dwm.c	2013-04-06 21:00:46.620830452 +0200
++@@ -69,6 +69,7 @@ typedef union {
++ 	int i;
++ 	unsigned int ui;
++ 	float f;
+++	float sf;
++ 	const void *v;
++ } Arg;
++ 
++@@ -127,6 +128,7 @@ typedef struct {
++ struct Monitor {
++ 	char ltsymbol[16];
++ 	float mfact;
+++	float smfact;
++ 	int nmaster;
++ 	int num;
++ 	int by;               /* bar geometry */
++@@ -220,6 +222,7 @@ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, Bool fullscreen);
++ static void setlayout(const Arg *arg);
++ static void setmfact(const Arg *arg);
+++static void setsmfact(const Arg *arg);
++ static void setup(void);
++ static void showhide(Client *c);
++ static void sigchld(int unused);
++@@ -651,6 +654,7 @@ createmon(void) {
++ 		die("fatal: could not malloc() %u bytes\n", sizeof(Monitor));
++ 	m->tagset[0] = m->tagset[1] = 1;
++ 	m->mfact = mfact;
+++	m->smfact = smfact;
++ 	m->nmaster = nmaster;
++ 	m->showbar = showbar;
++ 	m->topbar = topbar;
++@@ -1581,6 +1585,19 @@ setmfact(const Arg *arg) {
++ }
++ 
++ void
+++setsmfact(const Arg *arg) {
+++	float sf;
+++
+++	if(!arg || !selmon->lt[selmon->sellt]->arrange)
+++		return;
+++	sf = arg->sf < 1.0 ? arg->sf + selmon->smfact : arg->sf - 1.0;
+++	if(sf < 0 || sf > 0.9)
+++		return;
+++	selmon->smfact = sf;
+++	arrange(selmon);
+++}
+++
+++void
++ setup(void) {
++ 	XSetWindowAttributes wa;
++ 
++@@ -1703,7 +1720,7 @@ textnw(const char *text, unsigned int le
++ 
++ void
++ tile(Monitor *m) {
++-	unsigned int i, n, h, mw, my, ty;
+++	unsigned int i, n, h, smh, mw, my, ty;
++ 	Client *c;
++ 
++ 	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++@@ -1721,9 +1738,23 @@ tile(Monitor *m) {
++ 			my += HEIGHT(c);
++ 		}
++ 		else {
++-			h = (m->wh - ty) / (n - i);
++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++-			ty += HEIGHT(c);
+++			smh = m->mh * m->smfact;
+++			if(!(nexttiled(c->next)))
+++				h = (m->wh - ty) / (n - i);
+++			else
+++				h = (m->wh - smh - ty) / (n - i);
+++			if(h < minwsz) {
+++				c->isfloating = True;
+++				XRaiseWindow(dpy, c->win);
+++				resize(c, m->mx + (m->mw / 2 - WIDTH(c) / 2), m->my + (m->mh / 2 - HEIGHT(c) / 2), m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+++				ty -= HEIGHT(c);
+++			}
+++			else
+++				resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+++			if(!(nexttiled(c->next)))
+++				ty += HEIGHT(c) + smh;
+++			else
+++				ty += HEIGHT(c);
++ 		}
++ }
++ 
+diff --git a/patches/dwm-actualfullscreen-20211013-cb3f58a.diff b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
+new file mode 100644
+index 0000000..d3be230
+--- /dev/null
++++ b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
+@@ -0,0 +1,68 @@
++From eea13010ffc3983392857ee1e3804e3aa1064d7a Mon Sep 17 00:00:00 2001
++From: Soenke Lambert <s.lambert@mittwald.de>
++Date: Wed, 13 Oct 2021 18:21:09 +0200
++Subject: [PATCH] Fullscreen current window with [Alt]+[Shift]+[f]
++
++This actually fullscreens a window, instead of just hiding the statusbar
++and applying the monocle layout.
++---
++ config.def.h | 1 +
++ dwm.1        | 3 +++
++ dwm.c        | 8 ++++++++
++ 3 files changed, 12 insertions(+)
++
++diff --git a/config.def.h b/config.def.h
++index 1c0b587..8cd3204 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -78,6 +78,7 @@ static Key keys[] = {
++ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
++ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
++ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
++ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
++ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
++ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
++diff --git a/dwm.1 b/dwm.1
++index 13b3729..a368d05 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
++ .B Mod1\-Shift\-c
++ Close focused window.
++ .TP
+++.B Mod1\-Shift\-f
+++Toggle fullscreen for focused window.
+++.TP
++ .B Mod1\-Shift\-space
++ Toggle focused window between tiled and floating state.
++ .TP
++diff --git a/dwm.c b/dwm.c
++index 4465af1..c1b899a 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -211,6 +211,7 @@ static void tagmon(const Arg *arg);
++ static void tile(Monitor *);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglefullscr(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++ static void unfocus(Client *c, int setfocus);
++@@ -1719,6 +1720,13 @@ togglefloating(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglefullscr(const Arg *arg)
+++{
+++  if(selmon->sel)
+++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
++-- 
++2.30.2
++
+diff --git a/patches/dwm-alpha-20230401-348f655.diff b/patches/dwm-alpha-20230401-348f655.diff
+new file mode 100644
+index 0000000..c948f04
+--- /dev/null
++++ b/patches/dwm-alpha-20230401-348f655.diff
+@@ -0,0 +1,288 @@
++From ad5887df95fda706291c81ee143d0786a1717b12 Mon Sep 17 00:00:00 2001
++From: getimiskon <getimiskon@disroot.org>
++Date: Sat, 1 Apr 2023 16:22:01 +0300
++Subject: [PATCH] Allow dwm to have translucent bars, while keeping all the
++ text on it opaque, just like the alpha-patch for st. Updated for 348f655.
++
++---
++ config.def.h |  7 +++++++
++ config.mk    |  2 +-
++ drw.c        | 26 ++++++++++++-----------
++ drw.h        |  9 +++++---
++ dwm.c        | 59 ++++++++++++++++++++++++++++++++++++++++++++++------
++ 5 files changed, 81 insertions(+), 22 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 9efa774..8b3789a 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -12,11 +12,18 @@ static const char col_gray2[]       = "#444444";
++ static const char col_gray3[]       = "#bbbbbb";
++ static const char col_gray4[]       = "#eeeeee";
++ static const char col_cyan[]        = "#005577";
+++static const unsigned int baralpha = 0xd0;
+++static const unsigned int borderalpha = OPAQUE;
++ static const char *colors[][3]      = {
++ 	/*               fg         bg         border   */
++ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
++ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++ };
+++static const unsigned int alphas[][3]      = {
+++    /*               fg      bg        border*/
+++    [SchemeNorm] = { OPAQUE, baralpha, borderalpha },
+++	[SchemeSel]  = { OPAQUE, baralpha, borderalpha },
+++};
++ 
++ /* tagging */
++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++diff --git a/config.mk b/config.mk
++index ba64d3d..d609c42 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -23,7 +23,7 @@ FREETYPEINC = /usr/include/freetype2
++ 
++ # includes and libs
++ INCS = -I${X11INC} -I${FREETYPEINC}
++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lXrender
++ 
++ # flags
++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++diff --git a/drw.c b/drw.c
++index a58a2b4..d18e8d8 100644
++--- a/drw.c
+++++ b/drw.c
++@@ -61,7 +61,7 @@ utf8decode(const char *c, long *u, size_t clen)
++ }
++ 
++ Drw *
++-drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
+++drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap)
++ {
++ 	Drw *drw = ecalloc(1, sizeof(Drw));
++ 
++@@ -70,8 +70,11 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
++ 	drw->root = root;
++ 	drw->w = w;
++ 	drw->h = h;
++-	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
++-	drw->gc = XCreateGC(dpy, root, 0, NULL);
+++	drw->visual = visual;
+++	drw->depth = depth;
+++	drw->cmap = cmap;
+++	drw->drawable = XCreatePixmap(dpy, root, w, h, depth);
+++	drw->gc = XCreateGC(dpy, drw->drawable, 0, NULL);
++ 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
++ 
++ 	return drw;
++@@ -87,7 +90,7 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
++ 	drw->h = h;
++ 	if (drw->drawable)
++ 		XFreePixmap(drw->dpy, drw->drawable);
++-	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
+++	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, drw->depth);
++ }
++ 
++ void
++@@ -181,21 +184,22 @@ drw_fontset_free(Fnt *font)
++ }
++ 
++ void
++-drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+++drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha)
++ {
++ 	if (!drw || !dest || !clrname)
++ 		return;
++ 
++-	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
++-	                       DefaultColormap(drw->dpy, drw->screen),
+++	if (!XftColorAllocName(drw->dpy, drw->visual, drw->cmap,
++ 	                       clrname, dest))
++ 		die("error, cannot allocate color '%s'", clrname);
+++
+++    dest->pixel = (dest->pixel & 0x00ffffffU) | (alpha << 24);
++ }
++ 
++ /* Wrapper to create color schemes. The caller has to call free(3) on the
++  * returned color scheme when done using it. */
++ Clr *
++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+++drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount)
++ {
++ 	size_t i;
++ 	Clr *ret;
++@@ -205,7 +209,7 @@ drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++ 		return NULL;
++ 
++ 	for (i = 0; i < clrcount; i++)
++-		drw_clr_create(drw, &ret[i], clrnames[i]);
+++		drw_clr_create(drw, &ret[i], clrnames[i], alphas[i]);
++ 	return ret;
++ }
++ 
++@@ -263,9 +267,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
++ 	} else {
++ 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
++ 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
++-		d = XftDrawCreate(drw->dpy, drw->drawable,
++-		                  DefaultVisual(drw->dpy, drw->screen),
++-		                  DefaultColormap(drw->dpy, drw->screen));
+++		d = XftDrawCreate(drw->dpy, drw->drawable, drw->visual, drw->cmap);
++ 		x += lpad;
++ 		w -= lpad;
++ 	}
++diff --git a/drw.h b/drw.h
++index 6471431..2143533 100644
++--- a/drw.h
+++++ b/drw.h
++@@ -20,6 +20,9 @@ typedef struct {
++ 	Display *dpy;
++ 	int screen;
++ 	Window root;
+++    Visual *visual;
+++    unsigned int depth;
+++    Colormap cmap;
++ 	Drawable drawable;
++ 	GC gc;
++ 	Clr *scheme;
++@@ -27,7 +30,7 @@ typedef struct {
++ } Drw;
++ 
++ /* Drawable abstraction */
++-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
+++Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap);
++ void drw_resize(Drw *drw, unsigned int w, unsigned int h);
++ void drw_free(Drw *drw);
++ 
++@@ -39,8 +42,8 @@ unsigned int drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int
++ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
++ 
++ /* Colorscheme abstraction */
++-void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+++void drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha);
+++Clr *drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount);
++ 
++ /* Cursor abstraction */
++ Cur *drw_cur_create(Drw *drw, int shape);
++diff --git a/dwm.c b/dwm.c
++index c2bd871..3b34de8 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -56,6 +56,7 @@
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++#define OPAQUE                  0xffU
++ 
++ /* enums */
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++@@ -232,6 +233,7 @@ static Monitor *wintomon(Window w);
++ static int xerror(Display *dpy, XErrorEvent *ee);
++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+++static void xinitvisual();
++ static void zoom(const Arg *arg);
++ 
++ /* variables */
++@@ -268,6 +270,11 @@ static Drw *drw;
++ static Monitor *mons, *selmon;
++ static Window root, wmcheckwin;
++ 
+++static int useargb = 0;
+++static Visual *visual;
+++static int depth;
+++static Colormap cmap;
+++
++ /* configuration, allows nested code to access above variables */
++ #include "config.h"
++ 
++@@ -1558,7 +1565,8 @@ setup(void)
++ 	sw = DisplayWidth(dpy, screen);
++ 	sh = DisplayHeight(dpy, screen);
++ 	root = RootWindow(dpy, screen);
++-	drw = drw_create(dpy, screen, root, sw, sh);
+++	xinitvisual();
+++	drw = drw_create(dpy, screen, root, sw, sh, visual, depth, cmap);
++ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++ 		die("no fonts could be loaded.");
++ 	lrpad = drw->fonts->h;
++@@ -1586,7 +1594,7 @@ setup(void)
++ 	/* init appearance */
++ 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++ 	for (i = 0; i < LENGTH(colors); i++)
++-		scheme[i] = drw_scm_create(drw, colors[i], 3);
+++		scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 3);
++ 	/* init bars */
++ 	updatebars();
++ 	updatestatus();
++@@ -1813,16 +1821,18 @@ updatebars(void)
++ 	Monitor *m;
++ 	XSetWindowAttributes wa = {
++ 		.override_redirect = True,
++-		.background_pixmap = ParentRelative,
+++		.background_pixel = 0,
+++		.border_pixel = 0,
+++		.colormap = cmap,
++ 		.event_mask = ButtonPressMask|ExposureMask
++ 	};
++ 	XClassHint ch = {"dwm", "dwm"};
++ 	for (m = mons; m; m = m->next) {
++ 		if (m->barwin)
++ 			continue;
++-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++-				CopyFromParent, DefaultVisual(dpy, screen),
++-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, depth,
+++				InputOutput, visual,
+++				CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
++ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++ 		XMapRaised(dpy, m->barwin);
++ 		XSetClassHint(dpy, m->barwin, &ch);
++@@ -2120,6 +2130,43 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
++ 	return -1;
++ }
++ 
+++void
+++xinitvisual()
+++{
+++    XVisualInfo *infos;
+++	XRenderPictFormat *fmt;
+++	int nitems;
+++	int i;
+++
+++	XVisualInfo tpl = {
+++        .screen = screen,
+++		.depth = 32,
+++		.class = TrueColor
+++	};
+++	long masks = VisualScreenMask | VisualDepthMask | VisualClassMask;
+++
+++	infos = XGetVisualInfo(dpy, masks, &tpl, &nitems);
+++	visual = NULL;
+++	for(i = 0; i < nitems; i ++) {
+++        fmt = XRenderFindVisualFormat(dpy, infos[i].visual);
+++		if (fmt->type == PictTypeDirect && fmt->direct.alphaMask) {
+++            visual = infos[i].visual;
+++			depth = infos[i].depth;
+++			cmap = XCreateColormap(dpy, root, visual, AllocNone);
+++			useargb = 1;
+++			break;
+++        }
+++    }
+++
+++	XFree(infos);
+++
+++	if (! visual) {
+++        visual = DefaultVisual(dpy, screen);
+++		depth = DefaultDepth(dpy, screen);
+++		cmap = DefaultColormap(dpy, screen);
+++    }
+++}
+++
++ void
++ zoom(const Arg *arg)
++ {
++-- 
++2.40.0
++
+diff --git a/patches/dwm-autostart-20210120-cb3f58a.diff b/patches/dwm-autostart-20210120-cb3f58a.diff
+new file mode 100644
+index 0000000..efee676
+--- /dev/null
++++ b/patches/dwm-autostart-20210120-cb3f58a.diff
+@@ -0,0 +1,179 @@
++From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
++From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
++Date: Wed, 10 Jun 2020 10:59:02 +0000
++Subject: [PATCH] dwm-xdgautostart-6.2.diff
++
++===================================================================
++---
++ dwm.1 | 23 +++++++++++++++++
++ dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++ 2 files changed, 105 insertions(+)
++
++diff --git a/dwm.1 b/dwm.1
++index 13b3729..9533aa6 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
++ indicated with an empty square in the top left corner.
++ .P
++ dwm draws a small border around windows to indicate the focus state.
+++.P
+++On start, dwm can start additional programs that may be specified in two special
+++shell scripts (see the FILES section below), autostart_blocking.sh and
+++autostart.sh.  The former is executed first and dwm will wait for its
+++termination before starting.  The latter is executed in the background before
+++dwm enters its handler loop.
+++.P
+++Either of these files may be omitted.
++ .SH OPTIONS
++ .TP
++ .B \-v
++@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
++ .TP
++ .B Mod1\-Button3
++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+++.SH FILES
+++The files containing programs to be started along with dwm are searched for in
+++the following directories:
+++.IP "1. $XDG_DATA_HOME/dwm"
+++.IP "2. $HOME/.local/share/dwm"
+++.IP "3. $HOME/.dwm"
+++.P
+++The first existing directory is scanned for any of the autostart files below.
+++.TP 15
+++autostart.sh
+++This file is started as a shell background process before dwm enters its handler
+++loop.
+++.TP 15
+++autostart_blocking.sh
+++This file is started before any autostart.sh; dwm waits for its termination.
++ .SH CUSTOMIZATION
++ dwm is customized by creating a custom config.h and (re)compiling the source
++ code. This keeps it fast, secure and simple.
++diff --git a/dwm.c b/dwm.c
++index 4465af1..2156b49 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -29,6 +29,7 @@
++ #include <string.h>
++ #include <unistd.h>
++ #include <sys/types.h>
+++#include <sys/stat.h>
++ #include <sys/wait.h>
++ #include <X11/cursorfont.h>
++ #include <X11/keysym.h>
++@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
++ static void resizemouse(const Arg *arg);
++ static void restack(Monitor *m);
++ static void run(void);
+++static void runautostart(void);
++ static void scan(void);
++ static int sendevent(Client *c, Atom proto);
++ static void sendmon(Client *c, Monitor *m);
++@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
++ 
++ /* variables */
+++static const char autostartblocksh[] = "autostart_blocking.sh";
+++static const char autostartsh[] = "autostart.sh";
++ static const char broken[] = "broken";
+++static const char dwmdir[] = "dwm";
+++static const char localshare[] = ".local/share";
++ static char stext[256];
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++@@ -1380,6 +1386,83 @@ run(void)
++ 			handler[ev.type](&ev); /* call handler */
++ }
++ 
+++void
+++runautostart(void)
+++{
+++	char *pathpfx;
+++	char *path;
+++	char *xdgdatahome;
+++	char *home;
+++	struct stat sb;
+++
+++	if ((home = getenv("HOME")) == NULL)
+++		/* this is almost impossible */
+++		return;
+++
+++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+++	 * otherwise use ~/.local/share/dwm as autostart script directory
+++	 */
+++	xdgdatahome = getenv("XDG_DATA_HOME");
+++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+++		/* space for path segments, separators and nul */
+++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+++
+++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	} else {
+++		/* space for path segments, separators and nul */
+++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+++		                     + strlen(dwmdir) + 3);
+++
+++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	}
+++
+++	/* check if the autostart script directory exists */
+++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+++		/* the XDG conformant path does not exist or is no directory
+++		 * so we try ~/.dwm instead
+++		 */
+++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+++		if(pathpfx_new == NULL) {
+++			free(pathpfx);
+++			return;
+++		}
+++		pathpfx = pathpfx_new;
+++
+++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	}
+++
+++	/* try the blocking script first */
+++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+++		free(path);
+++		free(pathpfx);
+++	}
+++
+++	if (access(path, X_OK) == 0)
+++		system(path);
+++
+++	/* now the non-blocking script */
+++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+++		free(path);
+++		free(pathpfx);
+++	}
+++
+++	if (access(path, X_OK) == 0)
+++		system(strcat(path, " &"));
+++
+++	free(pathpfx);
+++	free(path);
+++}
+++
++ void
++ scan(void)
++ {
++@@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
+++	runautostart();
++ 	run();
++ 	cleanup();
++ 	XCloseDisplay(dpy);
++-- 
++2.27.0
++
+diff --git a/patches/dwm-cfacts-vanitygaps-6.4_combo.diff b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
+new file mode 100644
+index 0000000..db2cc14
+--- /dev/null
++++ b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
+@@ -0,0 +1,1018 @@
++diff --git a/config.def.h b/config.def.h
++index 9efa774..357dc6f 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -3,6 +3,11 @@
++ /* appearance */
++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
+++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
++ static const int showbar            = 1;        /* 0 means no bar */
++ static const int topbar             = 1;        /* 0 means bottom bar */
++ static const char *fonts[]          = { "monospace:size=10" };
++@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
++ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++ 
+++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+++#include "vanitygaps.c"
+++
++ static const Layout layouts[] = {
++ 	/* symbol     arrange function */
++ 	{ "[]=",      tile },    /* first entry is default */
++-	{ "><>",      NULL },    /* no layout function means floating behavior */
++ 	{ "[M]",      monocle },
+++	{ "[@]",      spiral },
+++	{ "[\\]",     dwindle },
+++	{ "H[]",      deck },
+++	{ "TTT",      bstack },
+++	{ "===",      bstackhoriz },
+++	{ "HHH",      grid },
+++	{ "###",      nrowgrid },
+++	{ "---",      horizgrid },
+++	{ ":::",      gaplessgrid },
+++	{ "|M|",      centeredmaster },
+++	{ ">M>",      centeredfloatingmaster },
+++	{ "><>",      NULL },    /* no layout function means floating behavior */
+++	{ NULL,       NULL },
++ };
++ 
++ /* key definitions */
++@@ -71,7 +91,26 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
++ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
++diff --git a/dwm.c b/dwm.c
++index f1d86b2..5bbd733 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -87,6 +87,7 @@ typedef struct Client Client;
++ struct Client {
++ 	char name[256];
++ 	float mina, maxa;
+++	float cfact;
++ 	int x, y, w, h;
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++@@ -119,6 +120,10 @@ struct Monitor {
++ 	int by;               /* bar geometry */
++ 	int mx, my, mw, mh;   /* screen size */
++ 	int wx, wy, ww, wh;   /* window area  */
+++	int gappih;           /* horizontal gap between windows */
+++	int gappiv;           /* vertical gap between windows */
+++	int gappoh;           /* horizontal outer gaps */
+++	int gappov;           /* vertical outer gaps */
++ 	unsigned int seltags;
++ 	unsigned int sellt;
++ 	unsigned int tagset[2];
++@@ -201,6 +206,7 @@ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
++ static void setlayout(const Arg *arg);
+++static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
++@@ -208,7 +214,6 @@ static void showhide(Client *c);
++ static void spawn(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++-static void tile(Monitor *m);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
++ static void toggletag(const Arg *arg);
++@@ -641,6 +646,10 @@ createmon(void)
++ 	m->nmaster = nmaster;
++ 	m->showbar = showbar;
++ 	m->topbar = topbar;
+++	m->gappih = gappih;
+++	m->gappiv = gappiv;
+++	m->gappoh = gappoh;
+++	m->gappov = gappov;
++ 	m->lt[0] = &layouts[0];
++ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++@@ -1043,6 +1052,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->w = c->oldw = wa->width;
++ 	c->h = c->oldh = wa->height;
++ 	c->oldbw = wa->border_width;
+++	c->cfact = 1.0;
++ 
++ 	updatetitle(c);
++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++@@ -1521,6 +1531,24 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++setcfact(const Arg *arg) {
+++	float f;
+++	Client *c;
+++
+++	c = selmon->sel;
+++
+++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+++		return;
+++	f = arg->f + c->cfact;
+++	if(arg->f == 0.0)
+++		f = 1.0;
+++	else if(f < 0.25 || f > 4.0)
+++		return;
+++	c->cfact = f;
+++	arrange(selmon);
+++}
+++
++ /* arg > 1.0 will set mfact absolutely */
++ void
++ setmfact(const Arg *arg)
++@@ -1684,34 +1712,6 @@ tagmon(const Arg *arg)
++ 	sendmon(selmon->sel, dirtomon(arg->i));
++ }
++ 
++-void
++-tile(Monitor *m)
++-{
++-	unsigned int i, n, h, mw, my, ty;
++-	Client *c;
++-
++-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-	if (n == 0)
++-		return;
++-
++-	if (n > m->nmaster)
++-		mw = m->nmaster ? m->ww * m->mfact : 0;
++-	else
++-		mw = m->ww;
++-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-		if (i < m->nmaster) {
++-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
++-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (my + HEIGHT(c) < m->wh)
++-				my += HEIGHT(c);
++-		} else {
++-			h = (m->wh - ty) / (n - i);
++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (ty + HEIGHT(c) < m->wh)
++-				ty += HEIGHT(c);
++-		}
++-}
++-
++ void
++ togglebar(const Arg *arg)
++ {
++diff --git a/vanitygaps.c b/vanitygaps.c
++new file mode 100644
++index 0000000..1a816b6
++--- /dev/null
+++++ b/vanitygaps.c
++@@ -0,0 +1,822 @@
+++/* Key binding functions */
+++static void defaultgaps(const Arg *arg);
+++static void incrgaps(const Arg *arg);
+++static void incrigaps(const Arg *arg);
+++static void incrogaps(const Arg *arg);
+++static void incrohgaps(const Arg *arg);
+++static void incrovgaps(const Arg *arg);
+++static void incrihgaps(const Arg *arg);
+++static void incrivgaps(const Arg *arg);
+++static void togglegaps(const Arg *arg);
+++/* Layouts (delete the ones you do not need) */
+++static void bstack(Monitor *m);
+++static void bstackhoriz(Monitor *m);
+++static void centeredmaster(Monitor *m);
+++static void centeredfloatingmaster(Monitor *m);
+++static void deck(Monitor *m);
+++static void dwindle(Monitor *m);
+++static void fibonacci(Monitor *m, int s);
+++static void grid(Monitor *m);
+++static void nrowgrid(Monitor *m);
+++static void spiral(Monitor *m);
+++static void tile(Monitor *m);
+++/* Internals */
+++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+++static void setgaps(int oh, int ov, int ih, int iv);
+++
+++/* Settings */
+++#if !PERTAG_PATCH
+++static int enablegaps = 1;
+++#endif // PERTAG_PATCH
+++
+++void
+++setgaps(int oh, int ov, int ih, int iv)
+++{
+++	if (oh < 0) oh = 0;
+++	if (ov < 0) ov = 0;
+++	if (ih < 0) ih = 0;
+++	if (iv < 0) iv = 0;
+++
+++	selmon->gappoh = oh;
+++	selmon->gappov = ov;
+++	selmon->gappih = ih;
+++	selmon->gappiv = iv;
+++	arrange(selmon);
+++}
+++
+++void
+++togglegaps(const Arg *arg)
+++{
+++	#if PERTAG_PATCH
+++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	enablegaps = !enablegaps;
+++	#endif // PERTAG_PATCH
+++	arrange(NULL);
+++}
+++
+++void
+++defaultgaps(const Arg *arg)
+++{
+++	setgaps(gappoh, gappov, gappih, gappiv);
+++}
+++
+++void
+++incrgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrigaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrogaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrohgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrovgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrihgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrivgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+++{
+++	unsigned int n, oe, ie;
+++	#if PERTAG_PATCH
+++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	oe = ie = enablegaps;
+++	#endif // PERTAG_PATCH
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++	if (smartgaps && n == 1) {
+++		oe = 0; // outer gaps disabled when only one client
+++	}
+++
+++	*oh = m->gappoh*oe; // outer horizontal gap
+++	*ov = m->gappov*oe; // outer vertical gap
+++	*ih = m->gappih*ie; // inner horizontal gap
+++	*iv = m->gappiv*ie; // inner vertical gap
+++	*nc = n;            // number of clients
+++}
+++
+++void
+++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+++{
+++	unsigned int n;
+++	float mfacts = 0, sfacts = 0;
+++	int mtotal = 0, stotal = 0;
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mtotal += msize * (c->cfact / mfacts);
+++		else
+++			stotal += ssize * (c->cfact / sfacts);
+++
+++	*mf = mfacts; // total factor of master area
+++	*sf = sfacts; // total factor of stack area
+++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+++}
+++
+++/***
+++ * Layouts
+++ */
+++
+++/*
+++ * Bottomstack layout + gaps
+++ * https://dwm.suckless.org/patches/bottomstack/
+++ */
+++static void
+++bstack(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sx = mx;
+++		sy = my + mh + ih;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++	}
+++}
+++
+++static void
+++bstackhoriz(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh;
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+++	}
+++
+++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++	}
+++}
+++
+++/*
+++ * Centred master layout + gaps
+++ * https://dwm.suckless.org/patches/centeredmaster/
+++ */
+++void
+++centeredmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int lx = 0, ly = 0, lw = 0, lh = 0;
+++	int rx = 0, ry = 0, rw = 0, rh = 0;
+++	float mfacts = 0, lfacts = 0, rfacts = 0;
+++	int mtotal = 0, ltotal = 0, rtotal = 0;
+++	int mrest = 0, lrest = 0, rrest = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* initialize areas */
+++	mx = m->wx + ov;
+++	my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+++	mw = m->ww - 2*ov;
+++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (n - m->nmaster > 1) {
+++			/* ||<-S->|<---M--->|<-S->|| */
+++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+++			mx += lw + iv;
+++		} else {
+++			/* ||<---M--->|<-S->|| */
+++			mw = (mw - iv) * m->mfact;
+++			lw = 0;
+++			rw = m->ww - mw - iv - 2*ov;
+++		}
+++		lx = m->wx + ov;
+++		ly = m->wy + oh;
+++		rx = mx + mw + iv;
+++		ry = m->wy + oh;
+++	}
+++
+++	/* calculate facts */
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+++		if (!m->nmaster || n < m->nmaster)
+++			mfacts += c->cfact;
+++		else if ((n - m->nmaster) % 2)
+++			lfacts += c->cfact; // total factor of left hand stack area
+++		else
+++			rfacts += c->cfact; // total factor of right hand stack area
+++	}
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (!m->nmaster || n < m->nmaster)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else if ((n - m->nmaster) % 2)
+++			ltotal += lh * (c->cfact / lfacts);
+++		else
+++			rtotal += rh * (c->cfact / rfacts);
+++
+++	mrest = mh - mtotal;
+++	lrest = lh - ltotal;
+++	rrest = rh - rtotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (!m->nmaster || i < m->nmaster) {
+++			/* nmaster clients are stacked vertically, in the center of the screen */
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			/* stack clients are stacked vertically */
+++			if ((i - m->nmaster) % 2 ) {
+++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+++				ly += HEIGHT(c) + ih;
+++			} else {
+++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+++				ry += HEIGHT(c) + ih;
+++			}
+++		}
+++	}
+++}
+++
+++void
+++centeredfloatingmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	float mfacts, sfacts;
+++	float mivf = 1.0; // master inner vertical gap factor
+++	int oh, ov, ih, iv, mrest, srest;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv*(n - 1);
+++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		mivf = 0.8;
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (m->ww > m->wh) {
+++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * 0.9;
+++		} else {
+++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * m->mfact;
+++		}
+++		mx = m->wx + (m->ww - mw) / 2;
+++		my = m->wy + (m->wh - mh - 2*oh) / 2;
+++
+++		sx = m->wx + ov;
+++		sy = m->wy + oh;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			/* nmaster clients are stacked horizontally, in the center of the screen */
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv*mivf;
+++		} else {
+++			/* stack clients are stacked horizontally */
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * Deck layout + gaps
+++ * https://dwm.suckless.org/patches/deck/
+++ */
+++void
+++deck(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	if (n - m->nmaster > 0) /* override layout symbol */
+++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+++		}
+++}
+++
+++/*
+++ * Fibonacci layout + gaps
+++ * https://dwm.suckless.org/patches/fibonacci/
+++ */
+++void
+++fibonacci(Monitor *m, int s)
+++{
+++	unsigned int i, n;
+++	int nx, ny, nw, nh;
+++	int oh, ov, ih, iv;
+++	int nv, hrest = 0, wrest = 0, r = 1;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	nx = m->wx + ov;
+++	ny = m->wy + oh;
+++	nw = m->ww - 2*ov;
+++	nh = m->wh - 2*oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+++		if (r) {
+++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+++				r = 0;
+++			}
+++			if (r && i < n - 1) {
+++				if (i % 2) {
+++					nv = (nh - ih) / 2;
+++					hrest = nh - 2*nv - ih;
+++					nh = nv;
+++				} else {
+++					nv = (nw - iv) / 2;
+++					wrest = nw - 2*nv - iv;
+++					nw = nv;
+++				}
+++
+++				if ((i % 4) == 2 && !s)
+++					nx += nw + iv;
+++				else if ((i % 4) == 3 && !s)
+++					ny += nh + ih;
+++			}
+++
+++			if ((i % 4) == 0) {
+++				if (s) {
+++					ny += nh + ih;
+++					nh += hrest;
+++				}
+++				else {
+++					nh -= hrest;
+++					ny -= nh + ih;
+++				}
+++			}
+++			else if ((i % 4) == 1) {
+++				nx += nw + iv;
+++				nw += wrest;
+++			}
+++			else if ((i % 4) == 2) {
+++				ny += nh + ih;
+++				nh += hrest;
+++				if (i < n - 1)
+++					nw += wrest;
+++			}
+++			else if ((i % 4) == 3) {
+++				if (s) {
+++					nx += nw + iv;
+++					nw -= wrest;
+++				} else {
+++					nw -= wrest;
+++					nx -= nw + iv;
+++					nh += hrest;
+++				}
+++			}
+++			if (i == 0)	{
+++				if (n != 1) {
+++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+++					wrest = 0;
+++				}
+++				ny = m->wy + oh;
+++			}
+++			else if (i == 1)
+++				nw = m->ww - nw - iv - 2*ov;
+++			i++;
+++		}
+++
+++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+++	}
+++}
+++
+++void
+++dwindle(Monitor *m)
+++{
+++	fibonacci(m, 1);
+++}
+++
+++void
+++spiral(Monitor *m)
+++{
+++	fibonacci(m, 0);
+++}
+++
+++/*
+++ * Gappless grid layout + gaps (ironically)
+++ * https://dwm.suckless.org/patches/gaplessgrid/
+++ */
+++void
+++gaplessgrid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* grid dimensions */
+++	for (cols = 0; cols <= n/2; cols++)
+++		if (cols*cols >= n)
+++			break;
+++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+++		cols = 2;
+++	rows = n/cols;
+++	cn = rn = 0; // reset column no, row no, client count
+++
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	x = m->wx + ov;
+++	y = m->wy + oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+++		if (i/rows + 1 > cols - n%cols) {
+++			rows = n/cols + 1;
+++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++		}
+++		resize(c,
+++			x,
+++			y + rn*(ch + ih) + MIN(rn, rrest),
+++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+++			0);
+++		rn++;
+++		if (rn >= rows) {
+++			rn = 0;
+++			x += cw + ih + (cn < crest ? 1 : 0);
+++			cn++;
+++		}
+++	}
+++}
+++
+++/*
+++ * Gridmode layout + gaps
+++ * https://dwm.suckless.org/patches/gridmode/
+++ */
+++void
+++grid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* grid dimensions */
+++	for (rows = 0; rows <= n/2; rows++)
+++		if (rows*rows >= n)
+++			break;
+++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+++
+++	/* window geoms (cell height/width) */
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		cc = i / rows;
+++		cr = i % rows;
+++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+++	}
+++}
+++
+++/*
+++ * Horizontal grid layout + gaps
+++ * https://dwm.suckless.org/patches/horizgrid/
+++ */
+++void
+++horizgrid(Monitor *m) {
+++	Client *c;
+++	unsigned int n, i;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	int ntop, nbottom = 1;
+++	float mfacts = 0, sfacts = 0;
+++	int mrest, srest, mtotal = 0, stotal = 0;
+++
+++	/* Count windows */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	if (n <= 2)
+++		ntop = n;
+++	else {
+++		ntop = n / 2;
+++		nbottom = n - ntop;
+++	}
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (n > ntop) {
+++		sh = (mh - ih) / 2;
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		mw = m->ww - 2*ov - iv * (ntop - 1);
+++		sw = m->ww - 2*ov - iv * (nbottom - 1);
+++	}
+++
+++	/* calculate facts */
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else
+++			stotal += sw * (c->cfact / sfacts);
+++
+++	mrest = mh - mtotal;
+++	srest = sw - stotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * nrowgrid layout + gaps
+++ * https://dwm.suckless.org/patches/nrowgrid/
+++ */
+++void
+++nrowgrid(Monitor *m)
+++{
+++	unsigned int n;
+++	int ri = 0, ci = 0;  /* counters */
+++	int oh, ov, ih, iv;                         /* vanitygap settings */
+++	unsigned int cx, cy, cw, ch;                /* client geometry */
+++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+++	unsigned int cols, rows = m->nmaster + 1;
+++	Client *c;
+++
+++	/* count clients */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* nothing to do here */
+++	if (n == 0)
+++		return;
+++
+++	/* force 2 clients to always split vertically */
+++	if (FORCE_VSPLIT && n == 2)
+++		rows = 1;
+++
+++	/* never allow empty rows */
+++	if (n < rows)
+++		rows = n;
+++
+++	/* define first row */
+++	cols = n / rows;
+++	uc = cols;
+++	cy = m->wy + oh;
+++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+++	uh = ch;
+++
+++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+++		if (ci == cols) {
+++			uw = 0;
+++			ci = 0;
+++			ri++;
+++
+++			/* next row */
+++			cols = (n - uc) / (rows - ri);
+++			uc += cols;
+++			cy = m->wy + oh + uh + ih;
+++			uh += ch + ih;
+++		}
+++
+++		cx = m->wx + ov + uw;
+++		cw = (m->ww - 2*ov - uw) / (cols - ci);
+++		uw += cw + iv;
+++
+++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+++	}
+++}
+++
+++/*
+++ * Default tile layout + gaps
+++ */
+++static void
+++tile(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++}
++\ No newline at end of file
+diff --git a/patches/dwm-focusonclick-20200110-61bb8b2.diff b/patches/dwm-focusonclick-20200110-61bb8b2.diff
+new file mode 100644
+index 0000000..59c7a1d
+--- /dev/null
++++ b/patches/dwm-focusonclick-20200110-61bb8b2.diff
+@@ -0,0 +1,130 @@
++From 7ac0b812540e21b470f2f6947c6cc1e30bf24b42 Mon Sep 17 00:00:00 2001
++From: iofq <cjriddz@protonmail.com>
++Date: Sun, 10 Jan 2021 22:43:16 -0600
++Subject: [PATCH] tweak fixes floating window mouse controls
++
++---
++ config.def.h |  1 +
++ dwm.c        | 47 ++++-------------------------------------------
++ 2 files changed, 5 insertions(+), 43 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 1c0b587..4f2c946 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -5,6 +5,7 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
++ static const int showbar            = 1;        /* 0 means no bar */
++ static const int topbar             = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
++ static const char *fonts[]          = { "monospace:size=10" };
++ static const char dmenufont[]       = "monospace:size=10";
++ static const char col_gray1[]       = "#222222";
++diff --git a/dwm.c b/dwm.c
++index 664c527..de3e883 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -163,7 +163,6 @@ static void detachstack(Client *c);
++ static Monitor *dirtomon(int dir);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
++-static void enternotify(XEvent *e);
++ static void expose(XEvent *e);
++ static void focus(Client *c);
++ static void focusin(XEvent *e);
++@@ -182,7 +181,6 @@ static void manage(Window w, XWindowAttributes *wa);
++ static void mappingnotify(XEvent *e);
++ static void maprequest(XEvent *e);
++ static void monocle(Monitor *m);
++-static void motionnotify(XEvent *e);
++ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *);
++@@ -250,13 +248,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
++ 	[ConfigureRequest] = configurerequest,
++ 	[ConfigureNotify] = configurenotify,
++ 	[DestroyNotify] = destroynotify,
++-	[EnterNotify] = enternotify,
++ 	[Expose] = expose,
++ 	[FocusIn] = focusin,
++ 	[KeyPress] = keypress,
++ 	[MappingNotify] = mappingnotify,
++ 	[MapRequest] = maprequest,
++-	[MotionNotify] = motionnotify,
++ 	[PropertyNotify] = propertynotify,
++ 	[UnmapNotify] = unmapnotify
++ };
++@@ -425,7 +421,8 @@ buttonpress(XEvent *e)
++ 
++ 	click = ClkRootWin;
++ 	/* focus monitor if necessary */
++-	if ((m = wintomon(ev->window)) && m != selmon) {
+++	if ((m = wintomon(ev->window)) && m != selmon
+++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++ 		unfocus(selmon->sel, 1);
++ 		selmon = m;
++ 		focus(NULL);
++@@ -445,8 +442,8 @@ buttonpress(XEvent *e)
++ 		else
++ 			click = ClkWinTitle;
++ 	} else if ((c = wintoclient(ev->window))) {
++-		focus(c);
++-		restack(selmon);
+++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+++			focus(c);
++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++ 		click = ClkClientWin;
++ 	}
++@@ -752,25 +749,6 @@ drawbars(void)
++ 		drawbar(m);
++ }
++ 
++-void
++-enternotify(XEvent *e)
++-{
++-	Client *c;
++-	Monitor *m;
++-	XCrossingEvent *ev = &e->xcrossing;
++-
++-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++-		return;
++-	c = wintoclient(ev->window);
++-	m = c ? c->mon : wintomon(ev->window);
++-	if (m != selmon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-	} else if (!c || c == selmon->sel)
++-		return;
++-	focus(c);
++-}
++-
++ void
++ expose(XEvent *e)
++ {
++@@ -1116,23 +1094,6 @@ monocle(Monitor *m)
++ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++ }
++ 
++-void
++-motionnotify(XEvent *e)
++-{
++-	static Monitor *mon = NULL;
++-	Monitor *m;
++-	XMotionEvent *ev = &e->xmotion;
++-
++-	if (ev->window != root)
++-		return;
++-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-		focus(NULL);
++-	}
++-	mon = m;
++-}
++-
++ void
++ movemouse(const Arg *arg)
++ {
++-- 
++2.30.0
++
+diff --git a/patches/dwm-hide_vacant_tags-6.4.diff b/patches/dwm-hide_vacant_tags-6.4.diff
+new file mode 100644
+index 0000000..42d9c05
+--- /dev/null
++++ b/patches/dwm-hide_vacant_tags-6.4.diff
+@@ -0,0 +1,48 @@
++:100644 100644 f1d86b2 0000000 M	dwm.c
++
++diff --git a/dwm.c b/dwm.c
++index f1d86b2..d41cc14 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -433,9 +433,15 @@ buttonpress(XEvent *e)
++ 	}
++ 	if (ev->window == selmon->barwin) {
++ 		i = x = 0;
++-		do
+++		unsigned int occ = 0;
+++		for(c = m->clients; c; c=c->next)
+++			occ |= c->tags == TAGMASK ? 0 : c->tags;
+++		do {
+++			/* Do not reserve space for vacant tags */
+++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++				continue;
++ 			x += TEXTW(tags[i]);
++-		while (ev->x >= x && ++i < LENGTH(tags));
+++		} while (ev->x >= x && ++i < LENGTH(tags));
++ 		if (i < LENGTH(tags)) {
++ 			click = ClkTagBar;
++ 			arg.ui = 1 << i;
++@@ -715,19 +721,18 @@ drawbar(Monitor *m)
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++-		occ |= c->tags;
+++		occ |= c->tags == TAGMASK ? 0 : c->tags;
++ 		if (c->isurgent)
++ 			urg |= c->tags;
++ 	}
++ 	x = 0;
++ 	for (i = 0; i < LENGTH(tags); i++) {
+++		/* Do not draw vacant tags */
+++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++			continue;
++ 		w = TEXTW(tags[i]);
++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++-		if (occ & 1 << i)
++-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
++-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
++-				urg & 1 << i);
++ 		x += w;
++ 	}
++ 	w = TEXTW(m->ltsymbol);
+diff --git a/patches/dwm-noborder-6.2.diff b/patches/dwm-noborder-6.2.diff
+new file mode 100644
+index 0000000..f381eb8
+--- /dev/null
++++ b/patches/dwm-noborder-6.2.diff
+@@ -0,0 +1,30 @@
++From 9102fdb9c670218373bbe83c891c8e8138d6a6f4 Mon Sep 17 00:00:00 2001
++From: redacted <redacted@example.com>
++Date: Tue, 23 Apr 2019 00:39:27 +0100
++Subject: [PATCH] added noborder patch
++
++---
++ dwm.c | 7 +++++++
++ 1 file changed, 7 insertions(+)
++
++diff --git a/dwm.c b/dwm.c
++index 4465af1..685eca1 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -1282,6 +1282,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
++ 	c->oldw = c->w; c->w = wc.width = w;
++ 	c->oldh = c->h; c->h = wc.height = h;
++ 	wc.border_width = c->bw;
+++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+++	    && !c->isfullscreen && !c->isfloating) {
+++		c->w = wc.width += c->bw * 2;
+++		c->h = wc.height += c->bw * 2;
+++		wc.border_width = 0;
+++	}
++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++ 	configure(c);
++ 	XSync(dpy, False);
++-- 
++2.21.0
++
+diff --git a/patches/dwm-notitle-20210715-138b405.diff b/patches/dwm-notitle-20210715-138b405.diff
+new file mode 100644
+index 0000000..bc8a3e5
+--- /dev/null
++++ b/patches/dwm-notitle-20210715-138b405.diff
+@@ -0,0 +1,81 @@
++From a3a7e94f59553689656871a65ea9ce90169a7c91 Mon Sep 17 00:00:00 2001
++From: birdalicous <jack.bird@durham.ac.uk>
++Date: Thu, 15 Jul 2021 12:28:29 +0100
++Subject: [PATCH] notitle patch applied#
++
++---
++ config.def.h |  1 -
++ dwm.c        | 20 ++++----------------
++ 2 files changed, 4 insertions(+), 17 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index a2ac963..eac20b4 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -103,7 +103,6 @@ static Button buttons[] = {
++ 	/* click                event mask      button          function        argument */
++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++diff --git a/dwm.c b/dwm.c
++index 5e4d494..6cd9fb7 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -64,8 +64,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+++       ClkRootWin, ClkLast }; /* clicks */
++ 
++ typedef union {
++ 	int i;
++@@ -440,10 +440,8 @@ buttonpress(XEvent *e)
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + blw)
++ 			click = ClkLtSymbol;
++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++-			click = ClkStatusText;
++ 		else
++-			click = ClkWinTitle;
+++			click = ClkStatusText;
++ 	} else if ((c = wintoclient(ev->window))) {
++ 		focus(c);
++ 		restack(selmon);
++@@ -730,15 +728,8 @@ drawbar(Monitor *m)
++ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++ 
++ 	if ((w = m->ww - tw - x) > bh) {
++-		if (m->sel) {
++-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
++-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++-			if (m->sel->isfloating)
++-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
++-		} else {
++ 			drw_setscheme(drw, scheme[SchemeNorm]);
++ 			drw_rect(drw, x, 0, w, bh, 1, 1);
++-		}
++ 	}
++ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++ }
++@@ -1236,11 +1227,8 @@ propertynotify(XEvent *e)
++ 			drawbars();
++ 			break;
++ 		}
++-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++ 			updatetitle(c);
++-			if (c == c->mon->sel)
++-				drawbar(c->mon);
++-		}
++ 		if (ev->atom == netatom[NetWMWindowType])
++ 			updatewindowtype(c);
++ 	}
++-- 
++2.32.0
++
+diff --git a/patches/dwm-savefloats-20181212-b69c870.diff b/patches/dwm-savefloats-20181212-b69c870.diff
+new file mode 100644
+index 0000000..f5d8ed8
+--- /dev/null
++++ b/patches/dwm-savefloats-20181212-b69c870.diff
+@@ -0,0 +1,42 @@
++diff --git i/dwm.c w/dwm.c
++index 4465af1..96b0b26 100644
++--- i/dwm.c
+++++ w/dwm.c
++@@ -88,6 +88,7 @@ struct Client {
++ 	char name[256];
++ 	float mina, maxa;
++ 	int x, y, w, h;
+++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
++ 	int bw, oldbw;
++@@ -1056,6 +1057,10 @@ manage(Window w, XWindowAttributes *wa)
++ 	updatewindowtype(c);
++ 	updatesizehints(c);
++ 	updatewmhints(c);
+++	c->sfx = c->x;
+++	c->sfy = c->y;
+++	c->sfw = c->w;
+++	c->sfh = c->h;
++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++ 	grabbuttons(c, 0);
++ 	if (!c->isfloating)
++@@ -1714,8 +1719,16 @@ togglefloating(const Arg *arg)
++ 		return;
++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++ 	if (selmon->sel->isfloating)
++-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
++-			selmon->sel->w, selmon->sel->h, 0);
+++		/* restore last known float dimensions */
+++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+++		       selmon->sel->sfw, selmon->sel->sfh, False);
+++	else {
+++		/* save last known float dimensions */
+++		selmon->sel->sfx = selmon->sel->x;
+++		selmon->sel->sfy = selmon->sel->y;
+++		selmon->sel->sfw = selmon->sel->w;
+++		selmon->sel->sfh = selmon->sel->h;
+++	}
++ 	arrange(selmon);
++ }
++ 
+diff --git a/patches/dwm-scratchpads-20200414-728d397b.diff b/patches/dwm-scratchpads-20200414-728d397b.diff
+new file mode 100644
+index 0000000..d3e90c0
+--- /dev/null
++++ b/patches/dwm-scratchpads-20200414-728d397b.diff
+@@ -0,0 +1,199 @@
++From 728d397b21982af88737277fd9d6939a7b558786 Mon Sep 17 00:00:00 2001
++From: Christian Tenllado <ctenllado@gmail.com>
++Date: Tue, 14 Apr 2020 23:31:15 +0200
++Subject: [PATCH] Multiple scratchpads
++
++This patch enables multiple scratchpads, each with one asigned window.
++This enables the same scratchpad workflow that you have in i3.
++
++Scratchpads are implemented as special tags, whose mask does not
++apply to new spawned windows. To assign a window to a scratchpad you
++have to set up a rule, as you do with regular tags.
++
++Windows tagged with scratchpad tags can be set floating or not in the
++rules array. Most users would probably want them floating (i3 style),
++but having them tiled does also perfectly work and might fit better the
++DWM approach. In case they are set floating, the patch moves them to the
++center of the screen whenever they are shown. The patch can easily be
++modified to make this last feature configurable in the rules array (see
++the center patch).
++
++The togglescratch function, borrowed from the previous scratchpad patch
++and slightly modified, can be used to spawn a registered scratchpad
++process or toggle its view. This function looks for a window tagged with
++the selected scratchpad tag. If it is found its view is toggled. If it is
++not found the corresponding registered command is spawned. The
++config.def.h shows three examples of its use to spawn a terminal in the
++first scratchpad tag, a second terminal running ranger on the second
++scratchpad tag and the keepassxc application to manage passwords on a
++third scratchpad tag.
++
++If you prefer to spawn your scratchpad applications from the startup
++script, you might opt for binding keys to toggleview instead, as
++scratchpads are just special tags (you may even extend the TAGKEYS macro
++to generalize the key bindings).
++---
++ config.def.h | 28 ++++++++++++++++++++++++----
++ dwm.c        | 43 +++++++++++++++++++++++++++++++++++++++++--
++ 2 files changed, 65 insertions(+), 6 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 1c0b587..06265e1 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -18,17 +18,33 @@ static const char *colors[][3]      = {
++ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++ };
++ 
+++typedef struct {
+++	const char *name;
+++	const void *cmd;
+++} Sp;
+++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+++const char *spcmd3[] = {"keepassxc", NULL };
+++static Sp scratchpads[] = {
+++	/* name          cmd  */
+++	{"spterm",      spcmd1},
+++	{"spranger",    spcmd2},
+++	{"keepassxc",   spcmd3},
+++};
+++
++ /* tagging */
++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++-
++ static const Rule rules[] = {
++ 	/* xprop(1):
++ 	 *	WM_CLASS(STRING) = instance, class
++ 	 *	WM_NAME(STRING) = title
++ 	 */
++ 	/* class      instance    title       tags mask     isfloating   monitor */
++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+++	{ "Gimp",	  NULL,			NULL,		0,				1,			 -1 },
+++	{ "Firefox",  NULL,			NULL,		1 << 8,			0,			 -1 },
+++	{ NULL,		  "spterm",		NULL,		SPTAG(0),		1,			 -1 },
+++	{ NULL,		  "spfm",		NULL,		SPTAG(1),		1,			 -1 },
+++	{ NULL,		  "keepassxc",	NULL,		SPTAG(2),		0,			 -1 },
++ };
++ 
++ /* layout(s) */
++@@ -59,6 +75,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++ static const char *termcmd[]  = { "st", NULL };
++ 
+++
++ static Key keys[] = {
++ 	/* modifier                     key        function        argument */
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++@@ -84,6 +101,9 @@ static Key keys[] = {
++ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
++ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
++ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
++ 	TAGKEYS(                        XK_1,                      0)
++ 	TAGKEYS(                        XK_2,                      1)
++ 	TAGKEYS(                        XK_3,                      2)
++@@ -106,7 +126,7 @@ static Button buttons[] = {
++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
++ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
++ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
++ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++diff --git a/dwm.c b/dwm.c
++index 4465af1..646aa1a 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -54,7 +54,10 @@
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+++#define TAGMASK     			((1 << NUMTAGS) - 1)
+++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++ 
++ /* enums */
++@@ -211,6 +214,7 @@ static void tagmon(const Arg *arg);
++ static void tile(Monitor *);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglescratch(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++ static void unfocus(Client *c, int setfocus);
++@@ -299,6 +303,11 @@ applyrules(Client *c)
++ 		{
++ 			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
+++			if ((r->tags & SPTAGMASK) && r->isfloating) {
+++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++			}
+++
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++ 			if (m)
++ 				c->mon = m;
++@@ -308,7 +317,7 @@ applyrules(Client *c)
++ 		XFree(ch.res_class);
++ 	if (ch.res_name)
++ 		XFree(ch.res_name);
++-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++ }
++ 
++ int
++@@ -1616,6 +1625,10 @@ showhide(Client *c)
++ 	if (!c)
++ 		return;
++ 	if (ISVISIBLE(c)) {
+++		if ((c->tags & SPTAGMASK) && c->isfloating) {
+++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++		}
++ 		/* show clients top down */
++ 		XMoveWindow(dpy, c->win, c->x, c->y);
++ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++@@ -1719,6 +1732,32 @@ togglefloating(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglescratch(const Arg *arg)
+++{
+++	Client *c;
+++	unsigned int found = 0;
+++	unsigned int scratchtag = SPTAG(arg->ui);
+++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+++
+++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+++	if (found) {
+++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+++		if (newtagset) {
+++			selmon->tagset[selmon->seltags] = newtagset;
+++			focus(NULL);
+++			arrange(selmon);
+++		}
+++		if (ISVISIBLE(c)) {
+++			focus(c);
+++			restack(selmon);
+++		}
+++	} else {
+++		selmon->tagset[selmon->seltags] |= scratchtag;
+++		spawn(&sparg);
+++	}
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
++-- 
++2.20.1
++
+diff --git a/patches/dwm-stacker-6.2.diff b/patches/dwm-stacker-6.2.diff
+new file mode 100644
+index 0000000..8fe3b80
+--- /dev/null
++++ b/patches/dwm-stacker-6.2.diff
+@@ -0,0 +1,197 @@
++From d04f2d00688c8b0969d4f10f460c980dd91dac37 Mon Sep 17 00:00:00 2001
++From: MLquest8 <miskuzius@gmail.com>
++Date: Fri, 12 Jun 2020 16:04:18 +0400
++Subject: [PATCH] stacker updated for version 6.2
++
++---
++ config.def.h | 14 +++++++--
++ dwm.c        | 88 ++++++++++++++++++++++++++++++++++++++++------------
++ 2 files changed, 80 insertions(+), 22 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 1c0b587..d28f8fc 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -50,6 +50,14 @@ static const Layout layouts[] = {
++ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+++#define STACKKEYS(MOD,ACTION) \
+++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
+++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
+++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
+++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
+++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
+++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
+++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
++ 
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++@@ -64,8 +72,8 @@ static Key keys[] = {
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
++ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
++-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
++-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+++	STACKKEYS(MODKEY,                          focus)
+++	STACKKEYS(MODKEY|ShiftMask,                push)
++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++@@ -93,7 +101,7 @@ static Key keys[] = {
++ 	TAGKEYS(                        XK_7,                      6)
++ 	TAGKEYS(                        XK_8,                      7)
++ 	TAGKEYS(                        XK_9,                      8)
++-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
++ };
++ 
++ /* button definitions */
++diff --git a/dwm.c b/dwm.c
++index 9fd0286..6c302c3 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -47,15 +47,21 @@
++ /* macros */
++ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+++#define GETINC(X)               ((X) - 2000)
+++#define INC(X)                  ((X) + 2000)
++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+++#define PREVSEL                 3000
++ #define LENGTH(X)               (sizeof X / sizeof X[0])
+++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++ 
++ /* enums */
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++@@ -187,6 +193,7 @@ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *);
++ static void propertynotify(XEvent *e);
+++static void pushstack(const Arg *arg);
++ static void quit(const Arg *arg);
++ static Monitor *recttomon(int x, int y, int w, int h);
++ static void resize(Client *c, int x, int y, int w, int h, int interact);
++@@ -207,6 +214,7 @@ static void seturgent(Client *c, int urg);
++ static void showhide(Client *c);
++ static void sigchld(int unused);
++ static void spawn(const Arg *arg);
+++static int stackpos(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void tile(Monitor *);
++@@ -833,27 +841,16 @@ focusmon(const Arg *arg)
++ void
++ focusstack(const Arg *arg)
++ {
++-	Client *c = NULL, *i;
+++	int i = stackpos(arg);
+++	Client *c, *p;
++ 
++-	if (!selmon->sel)
+++	if(i < 0)
++ 		return;
++-	if (arg->i > 0) {
++-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
++-		if (!c)
++-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
++-	} else {
++-		for (i = selmon->clients; i != selmon->sel; i = i->next)
++-			if (ISVISIBLE(i))
++-				c = i;
++-		if (!c)
++-			for (; i; i = i->next)
++-				if (ISVISIBLE(i))
++-					c = i;
++-	}
++-	if (c) {
++-		focus(c);
++-		restack(selmon);
++-	}
+++
+++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+++	focus(c ? c : p);
+++	restack(selmon);
++ }
++ 
++ Atom
++@@ -1246,6 +1243,29 @@ propertynotify(XEvent *e)
++ 	}
++ }
++ 
+++void
+++pushstack(const Arg *arg) {
+++	int i = stackpos(arg);
+++	Client *sel = selmon->sel, *c, *p;
+++
+++	if(i < 0)
+++		return;
+++	else if(i == 0) {
+++		detach(sel);
+++		attach(sel);
+++	}
+++	else {
+++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+++			if(!(i -= (ISVISIBLE(c) && c != sel)))
+++				break;
+++		c = c ? c : p;
+++		detach(sel);
+++		sel->next = c->next;
+++		c->next = sel;
+++	}
+++	arrange(selmon);
+++}
+++
++ void
++ quit(const Arg *arg)
++ {
++@@ -1653,6 +1673,36 @@ spawn(const Arg *arg)
++ 	}
++ }
++ 
+++int
+++stackpos(const Arg *arg) {
+++	int n, i;
+++	Client *c, *l;
+++
+++	if(!selmon->clients)
+++		return -1;
+++
+++	if(arg->i == PREVSEL) {
+++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+++		if(!l)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return i;
+++	}
+++	else if(ISINC(arg->i)) {
+++		if(!selmon->sel)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MOD(i + GETINC(arg->i), n);
+++	}
+++	else if(arg->i < 0) {
+++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MAX(i + arg->i, 0);
+++	}
+++	else
+++		return arg->i;
+++}
+++
++ void
++ tag(const Arg *arg)
++ {
++-- 
++2.26.2
++
+diff --git a/patches/dwm-status2d-6.3.diff b/patches/dwm-status2d-6.3.diff
+new file mode 100644
+index 0000000..52bf58d
+--- /dev/null
++++ b/patches/dwm-status2d-6.3.diff
+@@ -0,0 +1,166 @@
++diff --git a/dwm.c b/dwm.c
++index a96f33c..24b1eeb 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -163,6 +163,7 @@ static void detachstack(Client *c);
++ static Monitor *dirtomon(int dir);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
+++static int drawstatusbar(Monitor *m, int bh, char* text);
++ static void enternotify(XEvent *e);
++ static void expose(XEvent *e);
++ static void focus(Client *c);
++@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
++ 
++ /* variables */
++ static const char broken[] = "broken";
++-static char stext[256];
+++static char stext[1024];
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh, blw = 0;      /* bar geometry */
++@@ -485,7 +486,7 @@ cleanup(void)
++ 		cleanupmon(mons);
++ 	for (i = 0; i < CurLast; i++)
++ 		drw_cur_free(drw, cursor[i]);
++-	for (i = 0; i < LENGTH(colors); i++)
+++	for (i = 0; i < LENGTH(colors) + 1; i++)
++ 		free(scheme[i]);
++ 	XDestroyWindow(dpy, wmcheckwin);
++ 	drw_free(drw);
++@@ -693,6 +694,114 @@ dirtomon(int dir)
++ 	return m;
++ }
++ 
+++int
+++drawstatusbar(Monitor *m, int bh, char* stext) {
+++	int ret, i, w, x, len;
+++	short isCode = 0;
+++	char *text;
+++	char *p;
+++
+++	len = strlen(stext) + 1 ;
+++	if (!(text = (char*) malloc(sizeof(char)*len)))
+++		die("malloc");
+++	p = text;
+++	memcpy(text, stext, len);
+++
+++	/* compute width of the status text */
+++	w = 0;
+++	i = -1;
+++	while (text[++i]) {
+++		if (text[i] == '^') {
+++			if (!isCode) {
+++				isCode = 1;
+++				text[i] = '\0';
+++				w += TEXTW(text) - lrpad;
+++				text[i] = '^';
+++				if (text[++i] == 'f')
+++					w += atoi(text + ++i);
+++			} else {
+++				isCode = 0;
+++				text = text + i + 1;
+++				i = -1;
+++			}
+++		}
+++	}
+++	if (!isCode)
+++		w += TEXTW(text) - lrpad;
+++	else
+++		isCode = 0;
+++	text = p;
+++
+++	w += 2; /* 1px padding on both sides */
+++	ret = x = m->ww - w;
+++
+++	drw_setscheme(drw, scheme[LENGTH(colors)]);
+++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+++	drw_rect(drw, x, 0, w, bh, 1, 1);
+++	x++;
+++
+++	/* process status text */
+++	i = -1;
+++	while (text[++i]) {
+++		if (text[i] == '^' && !isCode) {
+++			isCode = 1;
+++
+++			text[i] = '\0';
+++			w = TEXTW(text) - lrpad;
+++			drw_text(drw, x, 0, w, bh, 0, text, 0);
+++
+++			x += w;
+++
+++			/* process code */
+++			while (text[++i] != '^') {
+++				if (text[i] == 'c') {
+++					char buf[8];
+++					memcpy(buf, (char*)text+i+1, 7);
+++					buf[7] = '\0';
+++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+++					i += 7;
+++				} else if (text[i] == 'b') {
+++					char buf[8];
+++					memcpy(buf, (char*)text+i+1, 7);
+++					buf[7] = '\0';
+++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+++					i += 7;
+++				} else if (text[i] == 'd') {
+++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+++				} else if (text[i] == 'r') {
+++					int rx = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int ry = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int rw = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int rh = atoi(text + ++i);
+++
+++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+++				} else if (text[i] == 'f') {
+++					x += atoi(text + ++i);
+++				}
+++			}
+++
+++			text = text + i + 1;
+++			i=-1;
+++			isCode = 0;
+++		}
+++	}
+++
+++	if (!isCode) {
+++		w = TEXTW(text) - lrpad;
+++		drw_text(drw, x, 0, w, bh, 0, text, 0);
+++	}
+++
+++	drw_setscheme(drw, scheme[SchemeNorm]);
+++	free(p);
+++
+++	return ret;
+++}
+++
++ void
++ drawbar(Monitor *m)
++ {
++@@ -707,9 +816,7 @@ drawbar(Monitor *m)
++ 
++ 	/* draw status first so it can be overdrawn by tags later */
++ 	if (m == selmon) { /* status is only drawn on selected monitor */
++-		drw_setscheme(drw, scheme[SchemeNorm]);
++-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
++-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+++		tw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++@@ -1571,7 +1678,8 @@ setup(void)
++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++ 	/* init appearance */
++-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++ 	for (i = 0; i < LENGTH(colors); i++)
++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
++ 	/* init bars */
+diff --git a/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
+new file mode 100644
+index 0000000..4adb383
+--- /dev/null
++++ b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
+@@ -0,0 +1,188 @@
++From 05f9b3c45d4267d52724b2a76f333ba00353cab3 Mon Sep 17 00:00:00 2001
++From: Daniel Bylinka <daniel.bylinka@gmail.com>
++Date: Fri, 2 Apr 2021 19:04:58 +0200
++Subject: [PATCH] [statuscmd] status2d compatibility
++
++---
++ config.def.h |  6 +++-
++ dwm.c        | 83 ++++++++++++++++++++++++++++++++++++++++++++++++----
++ 2 files changed, 83 insertions(+), 6 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 1c0b587..154a59b 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -54,6 +54,8 @@ static const Layout layouts[] = {
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++ 
+++#define STATUSBAR "dwmblocks"
+++
++ /* commands */
++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++@@ -103,7 +105,9 @@ static Button buttons[] = {
++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++diff --git a/dwm.c b/dwm.c
++index acbe6c9..ba478b9 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -173,6 +173,7 @@ static void focusstack(const Arg *arg);
++ static Atom getatomprop(Client *c, Atom prop);
++ static int getrootptr(int *x, int *y);
++ static long getstate(Window w);
+++static pid_t getstatusbarpid();
++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++ static void grabbuttons(Client *c, int focused);
++ static void grabkeys(void);
++@@ -207,6 +208,7 @@ static void setup(void);
++ static void seturgent(Client *c, int urg);
++ static void showhide(Client *c);
++ static void sigchld(int unused);
+++static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++@@ -239,6 +241,9 @@ static void zoom(const Arg *arg);
++ /* variables */
++ static const char broken[] = "broken";
++ static char stext[1024];
+++static int statussig;
+++static int statusw;
+++static pid_t statuspid = -1;
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh, blw = 0;      /* bar geometry */
++@@ -441,9 +446,34 @@ buttonpress(XEvent *e)
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + blw)
++ 			click = ClkLtSymbol;
++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+++		else if (ev->x > selmon->ww - statusw) {
+++			x = selmon->ww - statusw;
++ 			click = ClkStatusText;
++-		else
+++
+++			char *text, *s, ch;
+++			statussig = 0;
+++			for (text = s = stext; *s && x <= ev->x; s++) {
+++				if ((unsigned char)(*s) < ' ') {
+++					ch = *s;
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = ch;
+++					text = s + 1;
+++					if (x >= ev->x)
+++						break;
+++					statussig = ch;
+++				} else if (*s == '^') {
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = '^';
+++					if (*(++s) == 'f')
+++						x += atoi(++s);
+++					while (*(s++) != '^');
+++					text = s;
+++					s--;
+++				}
+++			}
+++		} else
++ 			click = ClkWinTitle;
++ 	} else if ((c = wintoclient(ev->window))) {
++ 		focus(c);
++@@ -696,7 +726,7 @@ dirtomon(int dir)
++ 
++ int
++ drawstatusbar(Monitor *m, int bh, char* stext) {
++-	int ret, i, w, x, len;
+++	int ret, i, j, w, x, len;
++ 	short isCode = 0;
++ 	char *text;
++ 	char *p;
++@@ -705,7 +735,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
++ 	if (!(text = (char*) malloc(sizeof(char)*len)))
++ 		die("malloc");
++ 	p = text;
++-	memcpy(text, stext, len);
+++
+++	i = -1, j = 0;
+++	while (stext[++i])
+++		if ((unsigned char)stext[i] >= ' ')
+++			text[j++] = stext[i];
+++	text[j] = '\0';
++ 
++ 	/* compute width of the status text */
++ 	w = 0;
++@@ -813,7 +848,7 @@ drawbar(Monitor *m)
++ 
++ 	/* draw status first so it can be overdrawn by tags later */
++ 	if (m == selmon) { /* status is only drawn on selected monitor */
++-		tw = m->ww - drawstatusbar(m, bh, stext);
+++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++@@ -979,6 +1014,30 @@ getatomprop(Client *c, Atom prop)
++ 	return atom;
++ }
++ 
+++pid_t
+++getstatusbarpid()
+++{
+++	char buf[32], *str = buf, *c;
+++	FILE *fp;
+++
+++	if (statuspid > 0) {
+++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+++		if ((fp = fopen(buf, "r"))) {
+++			fgets(buf, sizeof(buf), fp);
+++			while ((c = strchr(str, '/')))
+++				str = c + 1;
+++			fclose(fp);
+++			if (!strcmp(str, STATUSBAR))
+++				return statuspid;
+++		}
+++	}
+++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+++		return -1;
+++	fgets(buf, sizeof(buf), fp);
+++	pclose(fp);
+++	return strtoul(buf, NULL, 10);
+++}
+++
++ int
++ getrootptr(int *x, int *y)
++ {
++@@ -1745,6 +1804,20 @@ sigchld(int unused)
++ 	while (0 < waitpid(-1, NULL, WNOHANG));
++ }
++ 
+++void
+++sigstatusbar(const Arg *arg)
+++{
+++	union sigval sv;
+++
+++	if (!statussig)
+++		return;
+++	sv.sival_int = arg->i;
+++	if ((statuspid = getstatusbarpid()) <= 0)
+++		return;
+++
+++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+++}
+++
++ void
++ spawn(const Arg *arg)
++ {
++-- 
++2.31.0
++
+diff --git a/patches/dwm-sticky-20240927-60f7034.diff b/patches/dwm-sticky-20240927-60f7034.diff
+new file mode 100644
+index 0000000..055d019
+--- /dev/null
++++ b/patches/dwm-sticky-20240927-60f7034.diff
+@@ -0,0 +1,146 @@
++From 60f7034ca1573e10cf9e005e2ef5a44e6b76ea9b Mon Sep 17 00:00:00 2001
++From: elbachir-one <bachiralfa@gmail.com>
++Date: Fri, 27 Sep 2024 12:35:36 +0100
++Subject: [PATCH] Added the missing keybinding
++
++---
++ config.def.h |  1 +
++ dwm.c        | 43 ++++++++++++++++++++++++++++++++++++++++---
++ 2 files changed, 41 insertions(+), 3 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 9efa774..55c0a6c 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -95,6 +95,7 @@ static const Key keys[] = {
++ 	TAGKEYS(                        XK_8,                      7)
++ 	TAGKEYS(                        XK_9,                      8)
++ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
++ };
++ 
++ /* button definitions */
++diff --git a/dwm.c b/dwm.c
++index 67c6b2b..e8ed755 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -49,7 +49,7 @@
++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++ #define LENGTH(X)               (sizeof X / sizeof X[0])
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++@@ -61,7 +61,7 @@
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++ enum { SchemeNorm, SchemeSel }; /* color schemes */
++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++@@ -92,7 +92,7 @@ struct Client {
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
++ 	Client *next;
++ 	Client *snext;
++ 	Monitor *mon;
++@@ -200,6 +200,7 @@ static void sendmon(Client *c, Monitor *m);
++ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
+++static void setsticky(Client *c, int sticky);
++ static void setlayout(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++@@ -211,6 +212,7 @@ static void tagmon(const Arg *arg);
++ static void tile(Monitor *m);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglesticky(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++ static void unfocus(Client *c, int setfocus);
++@@ -525,6 +527,10 @@ clientmessage(XEvent *e)
++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+++
+++        if (cme->data.l[1] == netatom[NetWMSticky]
+++                || cme->data.l[2] == netatom[NetWMSticky])
+++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
++ 		if (c != selmon->sel && !c->isurgent)
++ 			seturgent(c, 1);
++@@ -1507,6 +1513,23 @@ setfullscreen(Client *c, int fullscreen)
++ 	}
++ }
++ 
+++void
+++	 setsticky(Client *c, int sticky)
+++	 {
+++
+++		 if(sticky && !c->issticky) {
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+++			 c->issticky = 1;
+++		 } else if(!sticky && c->issticky){
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *)0, 0);
+++			 c->issticky = 0;
+++			 arrange(c->mon);
+++		 }
+++	 }
+++
+++
++ void
++ setlayout(const Arg *arg)
++ {
++@@ -1576,6 +1599,7 @@ setup(void)
++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++@@ -1735,6 +1759,15 @@ togglefloating(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglesticky(const Arg *arg)
+++{
+++	if (!selmon->sel)
+++		return;
+++	setsticky(selmon->sel, !selmon->sel->issticky);
+++	arrange(selmon);
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
++@@ -2027,6 +2060,9 @@ updatewindowtype(Client *c)
++ 
++ 	if (state == netatom[NetWMFullscreen])
++ 		setfullscreen(c, 1);
+++	if (state == netatom[NetWMSticky]) {
+++		setsticky(c, 1);
+++	}
++ 	if (wtype == netatom[NetWMWindowTypeDialog])
++ 		c->isfloating = 1;
++ }
++@@ -2163,3 +2199,4 @@ main(int argc, char *argv[])
++ 	XCloseDisplay(dpy);
++ 	return EXIT_SUCCESS;
++ }
+++
++-- 
++2.46.0
++
+diff --git a/patches/dwm-swallow-6.3.diff b/patches/dwm-swallow-6.3.diff
+new file mode 100644
+index 0000000..47586a0
+--- /dev/null
++++ b/patches/dwm-swallow-6.3.diff
+@@ -0,0 +1,412 @@
++From 0cf9a007511f7dfd7dd94171b172562ebac9b6d5 Mon Sep 17 00:00:00 2001
++From: Tom Schwindl <schwindl@posteo.de>
++Date: Sat, 10 Sep 2022 12:51:09 +0200
++Subject: [PATCH] 6.3 swallow patch
++
++---
++ config.def.h |   9 +-
++ config.mk    |   3 +-
++ dwm.c        | 235 +++++++++++++++++++++++++++++++++++++++++++++++++--
++ 3 files changed, 237 insertions(+), 10 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 061ad662f82a..0b2b8ffd30d5 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -3,6 +3,7 @@
++ /* appearance */
++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
+++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
++ static const int showbar            = 1;        /* 0 means no bar */
++ static const int topbar             = 1;        /* 0 means bottom bar */
++ static const char *fonts[]          = { "monospace:size=10" };
++@@ -26,9 +27,11 @@ static const Rule rules[] = {
++ 	 *	WM_CLASS(STRING) = instance, class
++ 	 *	WM_NAME(STRING) = title
++ 	 */
++-	/* class      instance    title       tags mask     isfloating   monitor */
++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
++ };
++ 
++ /* layout(s) */
++diff --git a/config.mk b/config.mk
++index 81c493ef4aff..52d1ebf30bec 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
++ # OpenBSD (uncomment)
++ #FREETYPEINC = ${X11INC}/freetype2
++ #MANPREFIX = ${PREFIX}/man
+++#KVMLIB = -lkvm
++ 
++ # includes and libs
++ INCS = -I${X11INC} -I${FREETYPEINC}
++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
++ 
++ # flags
++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++diff --git a/dwm.c b/dwm.c
++index e5efb6a22806..e68294b6b679 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -40,6 +40,12 @@
++ #include <X11/extensions/Xinerama.h>
++ #endif /* XINERAMA */
++ #include <X11/Xft/Xft.h>
+++#include <X11/Xlib-xcb.h>
+++#include <xcb/res.h>
+++#ifdef __OpenBSD__
+++#include <sys/sysctl.h>
+++#include <kvm.h>
+++#endif /* __OpenBSD */
++ 
++ #include "drw.h"
++ #include "util.h"
++@@ -92,9 +98,11 @@ struct Client {
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
+++	pid_t pid;
++ 	Client *next;
++ 	Client *snext;
+++	Client *swallowing;
++ 	Monitor *mon;
++ 	Window win;
++ };
++@@ -138,6 +146,8 @@ typedef struct {
++ 	const char *title;
++ 	unsigned int tags;
++ 	int isfloating;
+++	int isterminal;
+++	int noswallow;
++ 	int monitor;
++ } Rule;
++ 
++@@ -235,6 +245,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
++ 
+++static pid_t getparentprocess(pid_t p);
+++static int isdescprocess(pid_t p, pid_t c);
+++static Client *swallowingclient(Window w);
+++static Client *termforwin(const Client *c);
+++static pid_t winpid(Window w);
+++
++ /* variables */
++ static const char broken[] = "broken";
++ static char stext[256];
++@@ -269,6 +285,8 @@ static Drw *drw;
++ static Monitor *mons, *selmon;
++ static Window root, wmcheckwin;
++ 
+++static xcb_connection_t *xcon;
+++
++ /* configuration, allows nested code to access above variables */
++ #include "config.h"
++ 
++@@ -298,6 +316,8 @@ applyrules(Client *c)
++ 		&& (!r->class || strstr(class, r->class))
++ 		&& (!r->instance || strstr(instance, r->instance)))
++ 		{
+++			c->isterminal = r->isterminal;
+++			c->noswallow  = r->noswallow;
++ 			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++@@ -416,6 +436,53 @@ attachstack(Client *c)
++ 	c->mon->stack = c;
++ }
++ 
+++void
+++swallow(Client *p, Client *c)
+++{
+++
+++	if (c->noswallow || c->isterminal)
+++		return;
+++	if (c->noswallow && !swallowfloating && c->isfloating)
+++		return;
+++
+++	detach(c);
+++	detachstack(c);
+++
+++	setclientstate(c, WithdrawnState);
+++	XUnmapWindow(dpy, p->win);
+++
+++	p->swallowing = c;
+++	c->mon = p->mon;
+++
+++	Window w = p->win;
+++	p->win = c->win;
+++	c->win = w;
+++	updatetitle(p);
+++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+++	arrange(p->mon);
+++	configure(p);
+++	updateclientlist();
+++}
+++
+++void
+++unswallow(Client *c)
+++{
+++	c->win = c->swallowing->win;
+++
+++	free(c->swallowing);
+++	c->swallowing = NULL;
+++
+++	/* unfullscreen the client */
+++	setfullscreen(c, 0);
+++	updatetitle(c);
+++	arrange(c->mon);
+++	XMapWindow(dpy, c->win);
+++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+++	setclientstate(c, NormalState);
+++	focus(NULL);
+++	arrange(c->mon);
+++}
+++
++ void
++ buttonpress(XEvent *e)
++ {
++@@ -656,6 +723,9 @@ destroynotify(XEvent *e)
++ 
++ 	if ((c = wintoclient(ev->window)))
++ 		unmanage(c, 1);
+++
+++	else if ((c = swallowingclient(ev->window)))
+++		unmanage(c->swallowing, 1);
++ }
++ 
++ void
++@@ -1022,12 +1092,13 @@ killclient(const Arg *arg)
++ void
++ manage(Window w, XWindowAttributes *wa)
++ {
++-	Client *c, *t = NULL;
+++	Client *c, *t = NULL, *term = NULL;
++ 	Window trans = None;
++ 	XWindowChanges wc;
++ 
++ 	c = ecalloc(1, sizeof(Client));
++ 	c->win = w;
+++	c->pid = winpid(w);
++ 	/* geometry */
++ 	c->x = c->oldx = wa->x;
++ 	c->y = c->oldy = wa->y;
++@@ -1042,6 +1113,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	} else {
++ 		c->mon = selmon;
++ 		applyrules(c);
+++		term = termforwin(c);
++ 	}
++ 
++ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++@@ -1076,6 +1148,8 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->mon->sel = c;
++ 	arrange(c->mon);
++ 	XMapWindow(dpy, c->win);
+++	if (term)
+++		swallow(term, c);
++ 	focus(NULL);
++ }
++ 
++@@ -1763,6 +1837,20 @@ unmanage(Client *c, int destroyed)
++ 	Monitor *m = c->mon;
++ 	XWindowChanges wc;
++ 
+++	if (c->swallowing) {
+++		unswallow(c);
+++		return;
+++	}
+++
+++	Client *s = swallowingclient(c->win);
+++	if (s) {
+++		free(s->swallowing);
+++		s->swallowing = NULL;
+++		arrange(m);
+++		focus(NULL);
+++		return;
+++	}
+++
++ 	detach(c);
++ 	detachstack(c);
++ 	if (!destroyed) {
++@@ -1778,9 +1866,12 @@ unmanage(Client *c, int destroyed)
++ 		XUngrabServer(dpy);
++ 	}
++ 	free(c);
++-	focus(NULL);
++-	updateclientlist();
++-	arrange(m);
+++
+++	if (!s) {
+++		arrange(m);
+++		focus(NULL);
+++		updateclientlist();
+++	}
++ }
++ 
++ void
++@@ -2044,6 +2135,136 @@ view(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++pid_t
+++winpid(Window w)
+++{
+++
+++	pid_t result = 0;
+++
+++#ifdef __linux__
+++	xcb_res_client_id_spec_t spec = {0};
+++	spec.client = w;
+++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+++
+++	xcb_generic_error_t *e = NULL;
+++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+++
+++	if (!r)
+++		return (pid_t)0;
+++
+++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+++		spec = i.data->spec;
+++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+++			uint32_t *t = xcb_res_client_id_value_value(i.data);
+++			result = *t;
+++			break;
+++		}
+++	}
+++
+++	free(r);
+++
+++	if (result == (pid_t)-1)
+++		result = 0;
+++
+++#endif /* __linux__ */
+++
+++#ifdef __OpenBSD__
+++        Atom type;
+++        int format;
+++        unsigned long len, bytes;
+++        unsigned char *prop;
+++        pid_t ret;
+++
+++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+++               return 0;
+++
+++        ret = *(pid_t*)prop;
+++        XFree(prop);
+++        result = ret;
+++
+++#endif /* __OpenBSD__ */
+++	return result;
+++}
+++
+++pid_t
+++getparentprocess(pid_t p)
+++{
+++	unsigned int v = 0;
+++
+++#ifdef __linux__
+++	FILE *f;
+++	char buf[256];
+++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+++
+++	if (!(f = fopen(buf, "r")))
+++		return 0;
+++
+++	fscanf(f, "%*u %*s %*c %u", &v);
+++	fclose(f);
+++#endif /* __linux__*/
+++
+++#ifdef __OpenBSD__
+++	int n;
+++	kvm_t *kd;
+++	struct kinfo_proc *kp;
+++
+++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+++	if (!kd)
+++		return 0;
+++
+++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+++	v = kp->p_ppid;
+++#endif /* __OpenBSD__ */
+++
+++	return (pid_t)v;
+++}
+++
+++int
+++isdescprocess(pid_t p, pid_t c)
+++{
+++	while (p != c && c != 0)
+++		c = getparentprocess(c);
+++
+++	return (int)c;
+++}
+++
+++Client *
+++termforwin(const Client *w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	if (!w->pid || w->isterminal)
+++		return NULL;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
+++Client *
+++swallowingclient(Window w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->swallowing && c->swallowing->win == w)
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
++ Client *
++ wintoclient(Window w)
++ {
++@@ -2133,10 +2354,12 @@ main(int argc, char *argv[])
++ 		fputs("warning: no locale support\n", stderr);
++ 	if (!(dpy = XOpenDisplay(NULL)))
++ 		die("dwm: cannot open display");
+++	if (!(xcon = XGetXCBConnection(dpy)))
+++		die("dwm: cannot get xcb connection\n");
++ 	checkotherwm();
++ 	setup();
++ #ifdef __OpenBSD__
++-	if (pledge("stdio rpath proc exec", NULL) == -1)
+++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
++-- 
++2.37.2
++
+diff --git a/patches/dwm-tagshift-6.3.diff b/patches/dwm-tagshift-6.3.diff
+new file mode 100644
+index 0000000..fb4d1d7
+--- /dev/null
++++ b/patches/dwm-tagshift-6.3.diff
+@@ -0,0 +1,69 @@
++diff --git a/config.def.h b/config.def.h
++index a2ac963..1bbede2 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -69,6 +69,10 @@ static Key keys[] = {
++ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
+++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
+++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++diff --git a/dwm.c b/dwm.c
++index a96f33c..4bf0f70 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -204,6 +204,8 @@ static void setlayout(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
+++static void shiftview(const Arg *arg);
+++static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
++ static void sigchld(int unused);
++ static void spawn(const Arg *arg);
++@@ -1632,6 +1634,40 @@ showhide(Client *c)
++ 	}
++ }
++ 
+++void
+++shiftview(const Arg *arg) {
+++	Arg shifted;
+++
+++	if(arg->i > 0) /* left circular shift */
+++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++
+++	else /* right circular shift */
+++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++
+++	view(&shifted);
+++}
+++
+++void
+++shifttag(const Arg *arg) {
+++	Arg shifted;
+++	Client *c;
+++
+++	if (!selmon->sel)
+++		return;
+++	c = selmon->sel;
+++
+++	if (arg->i > 0) /* left circular shift */
+++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++			^ (c->tags >> (LENGTH(tags) - arg->i));
+++	else /* right circular shift */
+++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++			^ (c->tags << (LENGTH(tags) + arg->i));
+++
+++	toggletag(&shifted);
+++}
+++
++ void
++ sigchld(int unused)
++ {
+diff --git a/patches/dwm-xresources-20210827-138b405.diff b/patches/dwm-xresources-20210827-138b405.diff
+new file mode 100644
+index 0000000..29852a9
+--- /dev/null
++++ b/patches/dwm-xresources-20210827-138b405.diff
+@@ -0,0 +1,240 @@
++From f30583c6e2ab5e7de6ef4ebf156076ac0f6e69fc Mon Sep 17 00:00:00 2001
++From: Jack Bird <jack.bird@durham.ac.uk>
++Date: Fri, 27 Aug 2021 00:53:14 +0100
++Subject: [PATCH] xresources updated for 138b405
++
++---
++ config.def.h | 61 ++++++++++++++++++++++++++++++--------------
++ drw.c        |  2 +-
++ drw.h        |  2 +-
++ dwm.c        | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++++
++ 4 files changed, 116 insertions(+), 21 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index a2ac963..87ac198 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -1,21 +1,23 @@
++ /* See LICENSE file for copyright and license details. */
++ 
++ /* appearance */
++-static const unsigned int borderpx  = 1;        /* border pixel of windows */
++-static const unsigned int snap      = 32;       /* snap pixel */
++-static const int showbar            = 1;        /* 0 means no bar */
++-static const int topbar             = 1;        /* 0 means bottom bar */
++-static const char *fonts[]          = { "monospace:size=10" };
++-static const char dmenufont[]       = "monospace:size=10";
++-static const char col_gray1[]       = "#222222";
++-static const char col_gray2[]       = "#444444";
++-static const char col_gray3[]       = "#bbbbbb";
++-static const char col_gray4[]       = "#eeeeee";
++-static const char col_cyan[]        = "#005577";
++-static const char *colors[][3]      = {
++-	/*               fg         bg         border   */
++-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
++-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+++static unsigned int borderpx  = 1;        /* border pixel of windows */
+++static unsigned int snap      = 32;       /* snap pixel */
+++static int showbar            = 1;        /* 0 means no bar */
+++static int topbar             = 1;        /* 0 means bottom bar */
+++static char font[]            = "monospace:size=10";
+++static char dmenufont[]       = "monospace:size=10";
+++static const char *fonts[]          = { font };
+++static char normbgcolor[]           = "#222222";
+++static char normbordercolor[]       = "#444444";
+++static char normfgcolor[]           = "#bbbbbb";
+++static char selfgcolor[]            = "#eeeeee";
+++static char selbordercolor[]        = "#005577";
+++static char selbgcolor[]            = "#005577";
+++static char *colors[][3] = {
+++       /*               fg           bg           border   */
+++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
++ };
++ 
++ /* tagging */
++@@ -32,9 +34,9 @@ static const Rule rules[] = {
++ };
++ 
++ /* layout(s) */
++-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++-static const int nmaster     = 1;    /* number of clients in master area */
++-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++static int nmaster     = 1;    /* number of clients in master area */
+++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++ 
++ static const Layout layouts[] = {
++@@ -57,9 +59,30 @@ static const Layout layouts[] = {
++ 
++ /* commands */
++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
++ static const char *termcmd[]  = { "st", NULL };
++ 
+++/*
+++ * Xresources preferences to load at startup
+++ */
+++ResourcePref resources[] = {
+++		{ "font",               STRING,  &font },
+++		{ "dmenufont",          STRING,  &dmenufont },
+++		{ "normbgcolor",        STRING,  &normbgcolor },
+++		{ "normbordercolor",    STRING,  &normbordercolor },
+++		{ "normfgcolor",        STRING,  &normfgcolor },
+++		{ "selbgcolor",         STRING,  &selbgcolor },
+++		{ "selbordercolor",     STRING,  &selbordercolor },
+++		{ "selfgcolor",         STRING,  &selfgcolor },
+++		{ "borderpx",          	INTEGER, &borderpx },
+++		{ "snap",          		INTEGER, &snap },
+++		{ "showbar",          	INTEGER, &showbar },
+++		{ "topbar",          	INTEGER, &topbar },
+++		{ "nmaster",          	INTEGER, &nmaster },
+++		{ "resizehints",       	INTEGER, &resizehints },
+++		{ "mfact",      	 	FLOAT,   &mfact },
+++};
+++
++ static Key keys[] = {
++ 	/* modifier                     key        function        argument */
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++diff --git a/drw.c b/drw.c
++index 4cdbcbe..8f1059e 100644
++--- a/drw.c
+++++ b/drw.c
++@@ -208,7 +208,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++ /* Wrapper to create color schemes. The caller has to call free(3) on the
++  * returned color scheme when done using it. */
++ Clr *
++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
++ {
++ 	size_t i;
++ 	Clr *ret;
++diff --git a/drw.h b/drw.h
++index 4bcd5ad..42b04ce 100644
++--- a/drw.h
+++++ b/drw.h
++@@ -39,7 +39,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
++ 
++ /* Colorscheme abstraction */
++ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
++ 
++ /* Cursor abstraction */
++ Cur *drw_cur_create(Drw *drw, int shape);
++diff --git a/dwm.c b/dwm.c
++index 5e4d494..2214b19 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -36,6 +36,7 @@
++ #include <X11/Xlib.h>
++ #include <X11/Xproto.h>
++ #include <X11/Xutil.h>
+++#include <X11/Xresource.h>
++ #ifdef XINERAMA
++ #include <X11/extensions/Xinerama.h>
++ #endif /* XINERAMA */
++@@ -141,6 +142,19 @@ typedef struct {
++ 	int monitor;
++ } Rule;
++ 
+++/* Xresources preferences */
+++enum resource_type {
+++	STRING = 0,
+++	INTEGER = 1,
+++	FLOAT = 2
+++};
+++
+++typedef struct {
+++	char *name;
+++	enum resource_type type;
+++	void *dst;
+++} ResourcePref;
+++
++ /* function declarations */
++ static void applyrules(Client *c);
++ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++@@ -234,6 +248,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
+++static void load_xresources(void);
+++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
++ 
++ /* variables */
++ static const char broken[] = "broken";
++@@ -2127,6 +2143,60 @@ zoom(const Arg *arg)
++ 	pop(c);
++ }
++ 
+++void
+++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+++{
+++	char *sdst = NULL;
+++	int *idst = NULL;
+++	float *fdst = NULL;
+++
+++	sdst = dst;
+++	idst = dst;
+++	fdst = dst;
+++
+++	char fullname[256];
+++	char *type;
+++	XrmValue ret;
+++
+++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+++	fullname[sizeof(fullname) - 1] = '\0';
+++
+++	XrmGetResource(db, fullname, "*", &type, &ret);
+++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+++	{
+++		switch (rtype) {
+++		case STRING:
+++			strcpy(sdst, ret.addr);
+++			break;
+++		case INTEGER:
+++			*idst = strtoul(ret.addr, NULL, 10);
+++			break;
+++		case FLOAT:
+++			*fdst = strtof(ret.addr, NULL);
+++			break;
+++		}
+++	}
+++}
+++
+++void
+++load_xresources(void)
+++{
+++	Display *display;
+++	char *resm;
+++	XrmDatabase db;
+++	ResourcePref *p;
+++
+++	display = XOpenDisplay(NULL);
+++	resm = XResourceManagerString(display);
+++	if (!resm)
+++		return;
+++
+++	db = XrmGetStringDatabase(resm);
+++	for (p = resources; p < resources + LENGTH(resources); p++)
+++		resource_load(db, p->name, p->type, p->dst);
+++	XCloseDisplay(display);
+++}
+++
++ int
++ main(int argc, char *argv[])
++ {
++@@ -2139,6 +2209,8 @@ main(int argc, char *argv[])
++ 	if (!(dpy = XOpenDisplay(NULL)))
++ 		die("dwm: cannot open display");
++ 	checkotherwm();
+++	XrmInitialize();
+++	load_xresources();
++ 	setup();
++ #ifdef __OpenBSD__
++ 	if (pledge("stdio rpath proc exec", NULL) == -1)
++-- 
++2.33.0
++
+diff --git a/patches/get.sh b/patches/get.sh
+new file mode 100755
+index 0000000..8c998a9
+--- /dev/null
++++ b/patches/get.sh
+@@ -0,0 +1,86 @@
++# Example
++# https://dwm.suckless.org/patches/alpha/
++# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
++# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
++# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
++# exit 0
++
++download_if_not_exists() {
++  local url="$1"
++  local filename=$(basename "$url") # Extract the file name from the URL
++
++  # Check if the file already exists
++  if [[ -f "$filename" ]]; then
++    echo "File '$filename' already exists. Skipping download."
++  else
++    echo "Downloading '$filename'..."
++    curl -O "$url"
++    if [[ $? -eq 0 ]]; then
++      echo "Downloaded '$filename' successfully."
++    else
++      echo "Failed to download '$filename'."
++    fi
++  fi
++}
++
++# https://dwm.suckless.org/patches/noborder/
++download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborder-6.2.diff
++#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderfloatingfix-6.2.diff
++#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderselflickerfix-2022042627-d93ff48803f0.diff
++
++# https://dwm.suckless.org/patches/stackmfact/
++download_if_not_exists https://dwm.suckless.org/patches/stackmfact/dwm-6.0-smfact.diff
++
++# https://dwm.suckless.org/patches/notitle/
++download_if_not_exists https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
++
++# https://dwm.suckless.org/patches/sticky/
++download_if_not_exists https://dwm.suckless.org/patches/sticky/dwm-sticky-20240927-60f7034.diff
++
++# https://dwm.suckless.org/patches/actualfullscreen/
++download_if_not_exists https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
++
++# https://dwm.suckless.org/patches/tagshift/
++download_if_not_exists https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
++
++# https://dwm.suckless.org/patches/statuscmd/
++#download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20241009-8933ebc.diff
++download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-status2d-20210405-60bb3df.diff
++
++# https://dwm.suckless.org/patches/swallow/
++download_if_not_exists https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
++
++# https://dwm.suckless.org/patches/xresources/
++download_if_not_exists https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
++
++# https://dwm.suckless.org/patches/hide_vacant_tags/
++download_if_not_exists https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.4.diff
++
++# https://dwm.suckless.org/patches/stacker/
++download_if_not_exists https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
++
++# https://dwm.suckless.org/patches/vanitygaps/
++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-20190508-6.2.diff
++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
++#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
++download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
++
++# https://dwm.suckless.org/patches/autostart/
++download_if_not_exists https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
++
++# https://dwm.suckless.org/patches/scratchpad/
++#download_if_not_exists https://dwm.suckless.org/patches/scratchpad/dwm-scratchpad-20240321-061e9fe.diff
++
++#https://dwm.suckless.org/patches/scratchpads/
++download_if_not_exists https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
++
++# https://dwm.suckless.org/patches/focusonclick/
++download_if_not_exists https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
++
++# https://dwm.suckless.org/patches/save_floats/
++download_if_not_exists https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
++
++# https://dwm.suckless.org/patches/status2d/
++#download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-systray-6.4.diff
++download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-6.3.diff
++
+diff --git a/patches_git/dwm-actualfullscreen.diff b/patches_git/dwm-actualfullscreen.diff
+new file mode 100644
+index 0000000..5aa0294
+--- /dev/null
++++ b/patches_git/dwm-actualfullscreen.diff
+@@ -0,0 +1,52 @@
++diff --git a/config.def.h b/config.def.h
++index 583f383..880a46a 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -118,6 +118,7 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
++ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
++ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
++ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
++ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
++ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
++diff --git a/dwm.1 b/dwm.1
++index ddc8321..3d310ac 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
++ .B Mod1\-Shift\-c
++ Close focused window.
++ .TP
+++.B Mod1\-Shift\-f
+++Toggle fullscreen for focused window.
+++.TP
++ .B Mod1\-Shift\-space
++ Toggle focused window between tiled and floating state.
++ .TP
++diff --git a/dwm.c b/dwm.c
++index f9989e1..9ae5616 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -216,6 +216,7 @@ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglefullscr(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++ static void unfocus(Client *c, int setfocus);
++@@ -1837,6 +1838,13 @@ togglefloating(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglefullscr(const Arg *arg)
+++{
+++  if(selmon->sel)
+++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
+diff --git a/patches_git/dwm-autostart.diff b/patches_git/dwm-autostart.diff
+new file mode 100644
+index 0000000..a09e438
+--- /dev/null
++++ b/patches_git/dwm-autostart.diff
+@@ -0,0 +1,165 @@
++diff --git a/dwm.1 b/dwm.1
++index 3d310ac..d04bec6 100644
++--- a/dwm.1
+++++ b/dwm.1
++@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
++ indicated with an empty square in the top left corner.
++ .P
++ dwm draws a small border around windows to indicate the focus state.
+++.P
+++On start, dwm can start additional programs that may be specified in two special
+++shell scripts (see the FILES section below), autostart_blocking.sh and
+++autostart.sh.  The former is executed first and dwm will wait for its
+++termination before starting.  The latter is executed in the background before
+++dwm enters its handler loop.
+++.P
+++Either of these files may be omitted.
++ .SH OPTIONS
++ .TP
++ .B \-v
++@@ -155,6 +163,21 @@ Toggles focused window between floating and tiled state.
++ .TP
++ .B Mod1\-Button3
++ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+++.SH FILES
+++The files containing programs to be started along with dwm are searched for in
+++the following directories:
+++.IP "1. $XDG_DATA_HOME/dwm"
+++.IP "2. $HOME/.local/share/dwm"
+++.IP "3. $HOME/.dwm"
+++.P
+++The first existing directory is scanned for any of the autostart files below.
+++.TP 15
+++autostart.sh
+++This file is started as a shell background process before dwm enters its handler
+++loop.
+++.TP 15
+++autostart_blocking.sh
+++This file is started before any autostart.sh; dwm waits for its termination.
++ .SH CUSTOMIZATION
++ dwm is customized by creating a custom config.h and (re)compiling the source
++ code. This keeps it fast, secure and simple.
++diff --git a/dwm.c b/dwm.c
++index 758c5ac..91fac46 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -29,6 +29,7 @@
++ #include <string.h>
++ #include <unistd.h>
++ #include <sys/types.h>
+++#include <sys/stat.h>
++ #include <sys/wait.h>
++ #include <X11/cursorfont.h>
++ #include <X11/keysym.h>
++@@ -200,6 +201,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
++ static void resizemouse(const Arg *arg);
++ static void restack(Monitor *m);
++ static void run(void);
+++static void runautostart(void);
++ static void scan(void);
++ static int sendevent(Client *c, Atom proto);
++ static void sendmon(Client *c, Monitor *m);
++@@ -244,7 +246,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
++ 
++ /* variables */
+++static const char autostartblocksh[] = "autostart_blocking.sh";
+++static const char autostartsh[] = "autostart.sh";
++ static const char broken[] = "broken";
+++static const char dwmdir[] = "dwm";
+++static const char localshare[] = ".local/share";
++ static char stext[1024];
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++@@ -1514,6 +1520,83 @@ run(void)
++ 			handler[ev.type](&ev); /* call handler */
++ }
++ 
+++void
+++runautostart(void)
+++{
+++	char *pathpfx;
+++	char *path;
+++	char *xdgdatahome;
+++	char *home;
+++	struct stat sb;
+++
+++	if ((home = getenv("HOME")) == NULL)
+++		/* this is almost impossible */
+++		return;
+++
+++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+++	 * otherwise use ~/.local/share/dwm as autostart script directory
+++	 */
+++	xdgdatahome = getenv("XDG_DATA_HOME");
+++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+++		/* space for path segments, separators and nul */
+++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+++
+++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	} else {
+++		/* space for path segments, separators and nul */
+++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+++		                     + strlen(dwmdir) + 3);
+++
+++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	}
+++
+++	/* check if the autostart script directory exists */
+++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+++		/* the XDG conformant path does not exist or is no directory
+++		 * so we try ~/.dwm instead
+++		 */
+++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+++		if(pathpfx_new == NULL) {
+++			free(pathpfx);
+++			return;
+++		}
+++		pathpfx = pathpfx_new;
+++
+++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+++			free(pathpfx);
+++			return;
+++		}
+++	}
+++
+++	/* try the blocking script first */
+++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+++		free(path);
+++		free(pathpfx);
+++	}
+++
+++	if (access(path, X_OK) == 0)
+++		system(path);
+++
+++	/* now the non-blocking script */
+++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+++		free(path);
+++		free(pathpfx);
+++	}
+++
+++	if (access(path, X_OK) == 0)
+++		system(strcat(path, " &"));
+++
+++	free(pathpfx);
+++	free(path);
+++}
+++
++ void
++ scan(void)
++ {
++@@ -2322,6 +2405,7 @@ main(int argc, char *argv[])
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
+++	runautostart();
++ 	run();
++ 	cleanup();
++ 	XCloseDisplay(dpy);
+diff --git a/patches_git/dwm-focusonclick.diff b/patches_git/dwm-focusonclick.diff
+new file mode 100644
+index 0000000..baf3978
+--- /dev/null
++++ b/patches_git/dwm-focusonclick.diff
+@@ -0,0 +1,117 @@
++diff --git a/config.def.h b/config.def.h
++index 69d4822..0c94360 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -11,6 +11,7 @@ static const unsigned int gappov    = 30;       /* vert outer gap between window
++ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
++ static int showbar            = 1;        /* 0 means no bar */
++ static int topbar             = 1;        /* 0 means bottom bar */
+++static const int focusonwheel       = 0;
++ static char font[]            = "monospace:size=10";
++ static char dmenufont[]       = "monospace:size=10";
++ static const char *fonts[]          = { font };
++diff --git a/dwm.c b/dwm.c
++index c71fa3c..aec2675 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -203,7 +203,6 @@ static Monitor *dirtomon(int dir);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
++ static int drawstatusbar(Monitor *m, int bh, char* text);
++-static void enternotify(XEvent *e);
++ static void expose(XEvent *e);
++ static void focus(Client *c);
++ static void focusin(XEvent *e);
++@@ -223,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
++ static void mappingnotify(XEvent *e);
++ static void maprequest(XEvent *e);
++ static void monocle(Monitor *m);
++-static void motionnotify(XEvent *e);
++ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *c);
++@@ -315,13 +313,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
++ 	[ConfigureRequest] = configurerequest,
++ 	[ConfigureNotify] = configurenotify,
++ 	[DestroyNotify] = destroynotify,
++-	[EnterNotify] = enternotify,
++ 	[Expose] = expose,
++ 	[FocusIn] = focusin,
++ 	[KeyPress] = keypress,
++ 	[MappingNotify] = mappingnotify,
++ 	[MapRequest] = maprequest,
++-	[MotionNotify] = motionnotify,
++ 	[PropertyNotify] = propertynotify,
++ 	[UnmapNotify] = unmapnotify
++ };
++@@ -548,7 +544,8 @@ buttonpress(XEvent *e)
++ 
++ 	click = ClkRootWin;
++ 	/* focus monitor if necessary */
++-	if ((m = wintomon(ev->window)) && m != selmon) {
+++	if ((m = wintomon(ev->window)) && m != selmon
+++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
++ 		unfocus(selmon->sel, 1);
++ 		selmon = m;
++ 		focus(NULL);
++@@ -597,8 +594,8 @@ buttonpress(XEvent *e)
++ 				}
++ 			}
++ 	} else if ((c = wintoclient(ev->window))) {
++-		focus(c);
++-		restack(selmon);
+++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+++			focus(c);
++ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++ 		click = ClkClientWin;
++ 	}
++@@ -1022,25 +1019,6 @@ drawbars(void)
++ 		drawbar(m);
++ }
++ 
++-void
++-enternotify(XEvent *e)
++-{
++-	Client *c;
++-	Monitor *m;
++-	XCrossingEvent *ev = &e->xcrossing;
++-
++-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++-		return;
++-	c = wintoclient(ev->window);
++-	m = c ? c->mon : wintomon(ev->window);
++-	if (m != selmon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-	} else if (!c || c == selmon->sel)
++-		return;
++-	focus(c);
++-}
++-
++ void
++ expose(XEvent *e)
++ {
++@@ -1412,23 +1390,6 @@ monocle(Monitor *m)
++ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++ }
++ 
++-void
++-motionnotify(XEvent *e)
++-{
++-	static Monitor *mon = NULL;
++-	Monitor *m;
++-	XMotionEvent *ev = &e->xmotion;
++-
++-	if (ev->window != root)
++-		return;
++-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++-		unfocus(selmon->sel, 1);
++-		selmon = m;
++-		focus(NULL);
++-	}
++-	mon = m;
++-}
++-
++ void
++ movemouse(const Arg *arg)
++ {
+diff --git a/patches_git/dwm-hide_vacant_tags.diff b/patches_git/dwm-hide_vacant_tags.diff
+new file mode 100644
+index 0000000..b9320f6
+--- /dev/null
++++ b/patches_git/dwm-hide_vacant_tags.diff
+@@ -0,0 +1,46 @@
++diff --git a/dwm.c b/dwm.c
++index 0d205d0..34d25b6 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -441,9 +441,15 @@ buttonpress(XEvent *e)
++ 	}
++ 	if (ev->window == selmon->barwin) {
++ 		i = x = 0;
++-		do
+++		unsigned int occ = 0;
+++		for(c = m->clients; c; c=c->next)
+++			occ |= c->tags == TAGMASK ? 0 : c->tags;
+++		do {
+++			/* Do not reserve space for vacant tags */
+++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++				continue;
++ 			x += TEXTW(tags[i]);
++-		while (ev->x >= x && ++i < LENGTH(tags));
+++		} while (ev->x >= x && ++i < LENGTH(tags));
++ 		if (i < LENGTH(tags)) {
++ 			click = ClkTagBar;
++ 			arg.ui = 1 << i;
++@@ -831,19 +837,18 @@ drawbar(Monitor *m)
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++-		occ |= c->tags;
+++		occ |= c->tags == TAGMASK ? 0 : c->tags;
++ 		if (c->isurgent)
++ 			urg |= c->tags;
++ 	}
++ 	x = 0;
++ 	for (i = 0; i < LENGTH(tags); i++) {
+++		/* Do not draw vacant tags */
+++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+++			continue;
++ 		w = TEXTW(tags[i]);
++ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++-		if (occ & 1 << i)
++-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
++-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
++-				urg & 1 << i);
++ 		x += w;
++ 	}
++ 	w = TEXTW(m->ltsymbol);
+diff --git a/patches_git/dwm-noborder.diff b/patches_git/dwm-noborder.diff
+new file mode 100644
+index 0000000..59cf669
+--- /dev/null
++++ b/patches_git/dwm-noborder.diff
+@@ -0,0 +1,18 @@
++diff --git a/dwm.c b/dwm.c
++index 1443802..857c396 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -1291,6 +1291,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
++ 	c->oldw = c->w; c->w = wc.width = w;
++ 	c->oldh = c->h; c->h = wc.height = h;
++ 	wc.border_width = c->bw;
+++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+++	    && !c->isfullscreen && !c->isfloating) {
+++		c->w = wc.width += c->bw * 2;
+++		c->h = wc.height += c->bw * 2;
+++		wc.border_width = 0;
+++	}
++ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++ 	configure(c);
++ 	XSync(dpy, False);
+diff --git a/patches_git/dwm-notitle.diff b/patches_git/dwm-notitle.diff
+new file mode 100644
+index 0000000..b23989f
+--- /dev/null
++++ b/patches_git/dwm-notitle.diff
+@@ -0,0 +1,68 @@
++diff --git a/config.def.h b/config.def.h
++index 357dc6f..583f383 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -142,7 +142,6 @@ static const Button buttons[] = {
++ 	/* click                event mask      button          function        argument */
++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++diff --git a/dwm.c b/dwm.c
++index 82fc028..f9989e1 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -63,8 +63,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+++       ClkRootWin, ClkLast }; /* clicks */
++ 
++ typedef union {
++ 	int i;
++@@ -446,10 +446,8 @@ buttonpress(XEvent *e)
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++ 			click = ClkLtSymbol;
++-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++-			click = ClkStatusText;
++ 		else
++-			click = ClkWinTitle;
+++			click = ClkStatusText;
++ 	} else if ((c = wintoclient(ev->window))) {
++ 		focus(c);
++ 		restack(selmon);
++@@ -850,15 +848,8 @@ drawbar(Monitor *m)
++ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++ 
++ 	if ((w = m->ww - tw - x) > bh) {
++-		if (m->sel) {
++-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
++-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++-			if (m->sel->isfloating)
++-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
++-		} else {
++ 			drw_setscheme(drw, scheme[SchemeNorm]);
++ 			drw_rect(drw, x, 0, w, bh, 1, 1);
++-		}
++ 	}
++ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++ }
++@@ -1361,11 +1352,8 @@ propertynotify(XEvent *e)
++ 			drawbars();
++ 			break;
++ 		}
++-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
++ 			updatetitle(c);
++-			if (c == c->mon->sel)
++-				drawbar(c->mon);
++-		}
++ 		if (ev->atom == netatom[NetWMWindowType])
++ 			updatewindowtype(c);
++ 	}
+diff --git a/patches_git/dwm-savefloats.diff b/patches_git/dwm-savefloats.diff
+new file mode 100644
+index 0000000..b66f755
+--- /dev/null
++++ b/patches_git/dwm-savefloats.diff
+@@ -0,0 +1,42 @@
++diff --git a/dwm.c b/dwm.c
++index 34d25b6..758c5ac 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -88,6 +88,7 @@ struct Client {
++ 	float mina, maxa;
++ 	float cfact;
++ 	int x, y, w, h;
+++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++@@ -1183,6 +1184,10 @@ manage(Window w, XWindowAttributes *wa)
++ 	updatewindowtype(c);
++ 	updatesizehints(c);
++ 	updatewmhints(c);
+++	c->sfx = c->x;
+++	c->sfy = c->y;
+++	c->sfw = c->w;
+++	c->sfh = c->h;
++ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++ 	grabbuttons(c, 0);
++ 	if (!c->isfloating)
++@@ -1874,8 +1879,16 @@ togglefloating(const Arg *arg)
++ 		return;
++ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++ 	if (selmon->sel->isfloating)
++-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
++-			selmon->sel->w, selmon->sel->h, 0);
+++		/* restore last known float dimensions */
+++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+++		       selmon->sel->sfw, selmon->sel->sfh, False);
+++	else {
+++		/* save last known float dimensions */
+++		selmon->sel->sfx = selmon->sel->x;
+++		selmon->sel->sfy = selmon->sel->y;
+++		selmon->sel->sfw = selmon->sel->w;
+++		selmon->sel->sfh = selmon->sel->h;
+++	}
++ 	arrange(selmon);
++ }
++ 
+diff --git a/patches_git/dwm-scratchpads.diff b/patches_git/dwm-scratchpads.diff
+new file mode 100644
+index 0000000..0bef30e
+--- /dev/null
++++ b/patches_git/dwm-scratchpads.diff
+@@ -0,0 +1,133 @@
++diff --git a/config.def.h b/config.def.h
++index 1919b6c..69d4822 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -26,6 +26,20 @@ static char *colors[][3] = {
++        [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
++ };
++ 
+++typedef struct {
+++	const char *name;
+++	const void *cmd;
+++} Sp;
+++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+++const char *spcmd3[] = {"keepassxc", NULL };
+++static Sp scratchpads[] = {
+++	/* name          cmd  */
+++	{"spterm",      spcmd1},
+++	{"spranger",    spcmd2},
+++	{"keepassxc",   spcmd3},
+++};
+++
++ /* tagging */
++ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++ 
++@@ -165,6 +179,9 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
++ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
++ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
++ 	TAGKEYS(                        XK_1,                      0)
++ 	TAGKEYS(                        XK_2,                      1)
++ 	TAGKEYS(                        XK_3,                      2)
++@@ -189,7 +206,7 @@ static const Button buttons[] = {
++ 	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
++ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
++ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
++ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++diff --git a/dwm.c b/dwm.c
++index 87bc8c5..c71fa3c 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -66,7 +66,10 @@
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+++#define TAGMASK     			((1 << NUMTAGS) - 1)
+++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++ #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++ 
++@@ -256,6 +259,7 @@ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglescratch(const Arg *arg);
++ static void togglesticky(const Arg *arg);
++ static void togglefullscr(const Arg *arg);
++ static void toggletag(const Arg *arg);
++@@ -365,6 +369,11 @@ applyrules(Client *c)
++ 			c->noswallow  = r->noswallow;
++ 			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
+++			if ((r->tags & SPTAGMASK) && r->isfloating) {
+++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++			}
+++
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++ 			if (m)
++ 				c->mon = m;
++@@ -374,7 +383,7 @@ applyrules(Client *c)
++ 		XFree(ch.res_class);
++ 	if (ch.res_name)
++ 		XFree(ch.res_name);
++-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
++ }
++ 
++ int
++@@ -2085,6 +2094,10 @@ showhide(Client *c)
++ 	if (!c)
++ 		return;
++ 	if (ISVISIBLE(c)) {
+++		if ((c->tags & SPTAGMASK) && c->isfloating) {
+++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+++		}
++ 		/* show clients top down */
++ 		XMoveWindow(dpy, c->win, c->x, c->y);
++ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++@@ -2228,6 +2241,32 @@ togglesticky(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++void
+++togglescratch(const Arg *arg)
+++{
+++	Client *c;
+++	unsigned int found = 0;
+++	unsigned int scratchtag = SPTAG(arg->ui);
+++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+++
+++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+++	if (found) {
+++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+++		if (newtagset) {
+++			selmon->tagset[selmon->seltags] = newtagset;
+++			focus(NULL);
+++			arrange(selmon);
+++		}
+++		if (ISVISIBLE(c)) {
+++			focus(c);
+++			restack(selmon);
+++		}
+++	} else {
+++		selmon->tagset[selmon->seltags] |= scratchtag;
+++		spawn(&sparg);
+++	}
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
+diff --git a/patches_git/dwm-shifttool-changes.diff b/patches_git/dwm-shifttool-changes.diff
+new file mode 100644
+index 0000000..b0c2a71
+--- /dev/null
++++ b/patches_git/dwm-shifttool-changes.diff
+@@ -0,0 +1,239 @@
++diff --git a/config.h b/config.h
++index 3fb3f44..4613e1b 100644
++--- a/config.h
+++++ b/config.h
++@@ -209,8 +209,8 @@ static const Key keys[] = {
++         { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
++         { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
++         { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
++-        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
++-        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
+++        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
+++        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
++         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
++         { MODKEY,                   XK_q,               killclient,         {0} },
++diff --git a/dwm.c b/dwm.c
++index 8b14f30..c072985 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -250,8 +250,14 @@ static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
++-static void shiftview(const Arg *arg);
++ static void shifttag(const Arg *arg);
+++static void shifttagclients(const Arg *arg);
+++static void shiftview(const Arg *arg);
+++static void shiftviewclients(const Arg *arg);
+++static void shiftboth(const Arg *arg);
+++static void swaptags(const Arg *arg);
+++static void shiftswaptags(const Arg *arg);
+++static void setcfact(const Arg *arg);
++ static void showhide(Client *c);
++ static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
++@@ -1965,38 +1971,186 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++//void
+++//shiftview(const Arg *arg) {
+++//	Arg shifted;
+++//
+++//	if(arg->i > 0) /* left circular shift */
+++//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++//
+++//	else /* right circular shift */
+++//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++//
+++//	view(&shifted);
+++//}
+++//
+++//void
+++//shifttag(const Arg *arg) {
+++//	Arg shifted;
+++//	Client *c;
+++//
+++//	if (!selmon->sel)
+++//		return;
+++//	c = selmon->sel;
+++//
+++//	if (arg->i > 0) /* left circular shift */
+++//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++//			^ (c->tags >> (LENGTH(tags) - arg->i));
+++//	else /* right circular shift */
+++//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++//			^ (c->tags << (LENGTH(tags) + arg->i));
+++//
+++//	toggletag(&shifted);
+++//}
+++
+++// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
+++// Or this (used below):
+++// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
+++
+++/* Sends a window to the next/prev tag */
++ void
++-shiftview(const Arg *arg) {
+++shifttag(const Arg *arg)
+++{
++ 	Arg shifted;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++ 
++-	if(arg->i > 0) /* left circular shift */
++-		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++-		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++ 
++-	else /* right circular shift */
++-		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++-		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++	if (arg->i > 0)	/* left circular shift */
+++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+++	else		/* right circular shift */
+++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
+++	tag(&shifted);
+++}
+++/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
+++void
+++shifttagclients(const Arg *arg)
+++{
++ 
+++	Arg shifted;
+++	Client *c;
+++	unsigned int tagmask = 0;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+++
+++	for (c = selmon->clients; c; c = c->next)
+++		if (!(c->tags & SPTAGMASK))
+++			tagmask = tagmask | c->tags;
+++
+++
+++	if (arg->i > 0)	/* left circular shift */
+++		do {
+++			shifted.ui = (shifted.ui << arg->i)
+++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+++			shifted.ui &= ~SPTAGMASK;
+++		} while (tagmask && !(shifted.ui & tagmask));
+++	else		/* right circular shift */
+++		do {
+++			shifted.ui = (shifted.ui >> (- arg->i)
+++			   | shifted.ui << (LENGTH(tags) + arg->i));
+++			shifted.ui &= ~SPTAGMASK;
+++		} while (tagmask && !(shifted.ui & tagmask));
+++	tag(&shifted);
+++}
+++/* Navigate to the next/prev tag */
+++void
+++shiftview(const Arg *arg)
+++{
+++	Arg shifted;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+++
+++	if (arg->i > 0) {/* left circular shift */
+++		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
+++		shifted.ui &= ~SPTAGMASK;
+++	} else {	/* right circular shift */
+++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
+++		shifted.ui &= ~SPTAGMASK;
+++	}
++ 	view(&shifted);
++ }
+++/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
+++void
+++shiftviewclients(const Arg *arg)
+++{
+++	Arg shifted;
+++	Client *c;
+++	unsigned int tagmask = 0;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+++
+++	for (c = selmon->clients; c; c = c->next)
+++		if (!(c->tags & SPTAGMASK))
+++			tagmask = tagmask | c->tags;
++ 
+++
+++	if (arg->i > 0)	/* left circular shift */
+++		do {
+++			shifted.ui = (shifted.ui << arg->i)
+++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+++			shifted.ui &= ~SPTAGMASK;
+++		} while (tagmask && !(shifted.ui & tagmask));
+++	else		/* right circular shift */
+++		do {
+++			shifted.ui = (shifted.ui >> (- arg->i)
+++			   | shifted.ui << (LENGTH(tags) + arg->i));
+++			shifted.ui &= ~SPTAGMASK;
+++		} while (tagmask && !(shifted.ui & tagmask));
+++	view(&shifted);
+++}
+++/* move the current active window to the next/prev tag and view it. More like following the window */
++ void
++-shifttag(const Arg *arg) {
+++shiftboth(const Arg *arg)
+++{
++ 	Arg shifted;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+++
+++	if (arg->i > 0)	/* left circular shift */
+++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+++	else		/* right circular shift */
+++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+++	tag(&shifted);
+++	view(&shifted);
+++}
+++//helper function for shiftswaptags found on:
+++//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
+++// modified to work with scratchpad
+++void
+++swaptags(const Arg *arg)
+++{
++ 	Client *c;
+++	unsigned int newtag = arg->ui & TAGMASK;
+++	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++ 
++-	if (!selmon->sel)
+++	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
++ 		return;
++-	c = selmon->sel;
++ 
++-	if (arg->i > 0) /* left circular shift */
++-		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++-			^ (c->tags >> (LENGTH(tags) - arg->i));
++-	else /* right circular shift */
++-		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++-			^ (c->tags << (LENGTH(tags) + arg->i));
+++	for (c = selmon->clients; c != NULL; c = c->next) {
+++		if ((c->tags & newtag) || (c->tags & curtag))
+++			c->tags ^= curtag ^ newtag;
+++
+++		if (!c->tags)
+++			c->tags = newtag;
+++	}
++ 
++-	toggletag(&shifted);
+++	//move to the swaped tag
+++	//selmon->tagset[selmon->seltags] = newtag;
+++
+++	focus(NULL);
+++	arrange(selmon);
+++}
+++/* swaps "tags" (all the clients) with the next/prev tag. */
+++void
+++shiftswaptags(const Arg *arg)
+++{
+++	Arg shifted;
+++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+++
+++	if (arg->i > 0)	/* left circular shift */
+++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+++	else		/* right circular shift */
+++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+++	swaptags(&shifted);
+++	// uncomment if you also want to "go" (view) the tag where the the clients are going
+++	//view(&shifted);
++ }
++ 
++ void
+diff --git a/patches_git/dwm-stacker.diff b/patches_git/dwm-stacker.diff
+new file mode 100644
+index 0000000..cde0a99
+--- /dev/null
++++ b/patches_git/dwm-stacker.diff
+@@ -0,0 +1,183 @@
++diff --git a/config.def.h b/config.def.h
++index 9ed2869..1919b6c 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -76,6 +76,14 @@ static const Layout layouts[] = {
++ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
++ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+++#define STACKKEYS(MOD,ACTION) \
+++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
+++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
+++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
+++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
+++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
+++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
+++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
++ 
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++@@ -113,8 +121,8 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
++ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
++-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
++-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+++	STACKKEYS(MODKEY,                          focus)
+++	STACKKEYS(MODKEY|ShiftMask,                push)
++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++ 	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++@@ -166,7 +174,7 @@ static const Key keys[] = {
++ 	TAGKEYS(                        XK_7,                      6)
++ 	TAGKEYS(                        XK_8,                      7)
++ 	TAGKEYS(                        XK_9,                      8)
++-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
++ 	{ MODKEY,                       XK_s,      togglesticky,   {0} },
++ };
++ 
++diff --git a/dwm.c b/dwm.c
++index cb3067d..87bc8c5 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -55,14 +55,20 @@
++ /* macros */
++ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+++#define GETINC(X)               ((X) - 2000)
+++#define INC(X)                  ((X) + 2000)
++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
++ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+++#define PREVSEL                 3000
+++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
++ 
++ /* enums */
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++@@ -219,6 +225,7 @@ static void movemouse(const Arg *arg);
++ static Client *nexttiled(Client *c);
++ static void pop(Client *c);
++ static void propertynotify(XEvent *e);
+++static void pushstack(const Arg *arg);
++ static void quit(const Arg *arg);
++ static Monitor *recttomon(int x, int y, int w, int h);
++ static void resize(Client *c, int x, int y, int w, int h, int interact);
++@@ -244,6 +251,7 @@ static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
++ static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
+++static int stackpos(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void togglebar(const Arg *arg);
++@@ -1086,27 +1094,16 @@ focusmon(const Arg *arg)
++ void
++ focusstack(const Arg *arg)
++ {
++-	Client *c = NULL, *i;
+++	int i = stackpos(arg);
+++	Client *c, *p;
++ 
++-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+++	if(i < 0)
++ 		return;
++-	if (arg->i > 0) {
++-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
++-		if (!c)
++-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
++-	} else {
++-		for (i = selmon->clients; i != selmon->sel; i = i->next)
++-			if (ISVISIBLE(i))
++-				c = i;
++-		if (!c)
++-			for (; i; i = i->next)
++-				if (ISVISIBLE(i))
++-					c = i;
++-	}
++-	if (c) {
++-		focus(c);
++-		restack(selmon);
++-	}
+++
+++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+++	focus(c ? c : p);
+++	restack(selmon);
++ }
++ 
++ Atom
++@@ -1533,6 +1530,29 @@ propertynotify(XEvent *e)
++ 	}
++ }
++ 
+++void
+++pushstack(const Arg *arg) {
+++	int i = stackpos(arg);
+++	Client *sel = selmon->sel, *c, *p;
+++
+++	if(i < 0)
+++		return;
+++	else if(i == 0) {
+++		detach(sel);
+++		attach(sel);
+++	}
+++	else {
+++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+++			if(!(i -= (ISVISIBLE(c) && c != sel)))
+++				break;
+++		c = c ? c : p;
+++		detach(sel);
+++		sel->next = c->next;
+++		c->next = sel;
+++	}
+++	arrange(selmon);
+++}
+++
++ void
++ quit(const Arg *arg)
++ {
++@@ -2113,6 +2133,36 @@ spawn(const Arg *arg)
++ 	}
++ }
++ 
+++int
+++stackpos(const Arg *arg) {
+++	int n, i;
+++	Client *c, *l;
+++
+++	if(!selmon->clients)
+++		return -1;
+++
+++	if(arg->i == PREVSEL) {
+++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+++		if(!l)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return i;
+++	}
+++	else if(ISINC(arg->i)) {
+++		if(!selmon->sel)
+++			return -1;
+++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MOD(i + GETINC(arg->i), n);
+++	}
+++	else if(arg->i < 0) {
+++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+++		return MAX(i + arg->i, 0);
+++	}
+++	else
+++		return arg->i;
+++}
+++
++ void
++ tag(const Arg *arg)
++ {
+diff --git a/patches_git/dwm-status2d.diff b/patches_git/dwm-status2d.diff
+new file mode 100644
+index 0000000..c600b66
+--- /dev/null
++++ b/patches_git/dwm-status2d.diff
+@@ -0,0 +1,166 @@
++diff --git a/dwm.c b/dwm.c
++index db7e0c8..82fc028 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -167,6 +167,7 @@ static void detachstack(Client *c);
++ static Monitor *dirtomon(int dir);
++ static void drawbar(Monitor *m);
++ static void drawbars(void);
+++static int drawstatusbar(Monitor *m, int bh, char* text);
++ static void enternotify(XEvent *e);
++ static void expose(XEvent *e);
++ static void focus(Client *c);
++@@ -240,7 +241,7 @@ static void zoom(const Arg *arg);
++ 
++ /* variables */
++ static const char broken[] = "broken";
++-static char stext[256];
+++static char stext[1024];
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh;               /* bar height */
++@@ -490,7 +491,7 @@ cleanup(void)
++ 		cleanupmon(mons);
++ 	for (i = 0; i < CurLast; i++)
++ 		drw_cur_free(drw, cursor[i]);
++-	for (i = 0; i < LENGTH(colors); i++)
+++	for (i = 0; i < LENGTH(colors) + 1; i++)
++ 		free(scheme[i]);
++ 	free(scheme);
++ 	XDestroyWindow(dpy, wmcheckwin);
++@@ -703,6 +704,114 @@ dirtomon(int dir)
++ 	return m;
++ }
++ 
+++int
+++drawstatusbar(Monitor *m, int bh, char* stext) {
+++	int ret, i, w, x, len;
+++	short isCode = 0;
+++	char *text;
+++	char *p;
+++
+++	len = strlen(stext) + 1 ;
+++	if (!(text = (char*) malloc(sizeof(char)*len)))
+++		die("malloc");
+++	p = text;
+++	memcpy(text, stext, len);
+++
+++	/* compute width of the status text */
+++	w = 0;
+++	i = -1;
+++	while (text[++i]) {
+++		if (text[i] == '^') {
+++			if (!isCode) {
+++				isCode = 1;
+++				text[i] = '\0';
+++				w += TEXTW(text) - lrpad;
+++				text[i] = '^';
+++				if (text[++i] == 'f')
+++					w += atoi(text + ++i);
+++			} else {
+++				isCode = 0;
+++				text = text + i + 1;
+++				i = -1;
+++			}
+++		}
+++	}
+++	if (!isCode)
+++		w += TEXTW(text) - lrpad;
+++	else
+++		isCode = 0;
+++	text = p;
+++
+++	w += 2; /* 1px padding on both sides */
+++	ret = x = m->ww - w;
+++
+++	drw_setscheme(drw, scheme[LENGTH(colors)]);
+++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+++	drw_rect(drw, x, 0, w, bh, 1, 1);
+++	x++;
+++
+++	/* process status text */
+++	i = -1;
+++	while (text[++i]) {
+++		if (text[i] == '^' && !isCode) {
+++			isCode = 1;
+++
+++			text[i] = '\0';
+++			w = TEXTW(text) - lrpad;
+++			drw_text(drw, x, 0, w, bh, 0, text, 0);
+++
+++			x += w;
+++
+++			/* process code */
+++			while (text[++i] != '^') {
+++				if (text[i] == 'c') {
+++					char buf[8];
+++					memcpy(buf, (char*)text+i+1, 7);
+++					buf[7] = '\0';
+++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+++					i += 7;
+++				} else if (text[i] == 'b') {
+++					char buf[8];
+++					memcpy(buf, (char*)text+i+1, 7);
+++					buf[7] = '\0';
+++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+++					i += 7;
+++				} else if (text[i] == 'd') {
+++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+++				} else if (text[i] == 'r') {
+++					int rx = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int ry = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int rw = atoi(text + ++i);
+++					while (text[++i] != ',');
+++					int rh = atoi(text + ++i);
+++
+++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+++				} else if (text[i] == 'f') {
+++					x += atoi(text + ++i);
+++				}
+++			}
+++
+++			text = text + i + 1;
+++			i=-1;
+++			isCode = 0;
+++		}
+++	}
+++
+++	if (!isCode) {
+++		w = TEXTW(text) - lrpad;
+++		drw_text(drw, x, 0, w, bh, 0, text, 0);
+++	}
+++
+++	drw_setscheme(drw, scheme[SchemeNorm]);
+++	free(p);
+++
+++	return ret;
+++}
+++
++ void
++ drawbar(Monitor *m)
++ {
++@@ -717,9 +826,7 @@ drawbar(Monitor *m)
++ 
++ 	/* draw status first so it can be overdrawn by tags later */
++ 	if (m == selmon) { /* status is only drawn on selected monitor */
++-		drw_setscheme(drw, scheme[SchemeNorm]);
++-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
++-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+++		tw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++@@ -1618,7 +1725,8 @@ setup(void)
++ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++ 	/* init appearance */
++-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++ 	for (i = 0; i < LENGTH(colors); i++)
++ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
++ 	/* init bars */
+diff --git a/patches_git/dwm-statuscmd-status2d.diff b/patches_git/dwm-statuscmd-status2d.diff
+new file mode 100644
+index 0000000..bac794e
+--- /dev/null
++++ b/patches_git/dwm-statuscmd-status2d.diff
+@@ -0,0 +1,174 @@
++diff --git a/config.def.h b/config.def.h
++index 2099993..f74867c 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -75,6 +75,8 @@ static const Layout layouts[] = {
++ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
++ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++ 
+++#define STATUSBAR "dwmblocks"
+++
++ /* commands */
++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++@@ -148,7 +150,9 @@ static const Button buttons[] = {
++ 	/* click                event mask      button          function        argument */
++ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
++ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++diff --git a/dwm.c b/dwm.c
++index 2fddeb1..ed799c2 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -179,6 +179,7 @@ static void focusstack(const Arg *arg);
++ static Atom getatomprop(Client *c, Atom prop);
++ static int getrootptr(int *x, int *y);
++ static long getstate(Window w);
+++static pid_t getstatusbarpid();
++ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++ static void grabbuttons(Client *c, int focused);
++ static void grabkeys(void);
++@@ -217,6 +218,7 @@ static void seturgent(Client *c, int urg);
++ static void shiftview(const Arg *arg);
++ static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
+++static void sigstatusbar(const Arg *arg);
++ static void spawn(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++@@ -254,6 +256,9 @@ static const char broken[] = "broken";
++ static const char dwmdir[] = "dwm";
++ static const char localshare[] = ".local/share";
++ static char stext[1024];
+++static int statussig;
+++static int statusw;
+++static pid_t statuspid = -1;
++ static int screen;
++ static int sw, sh;           /* X display screen geometry width, height */
++ static int bh;               /* bar height */
++@@ -464,8 +469,33 @@ buttonpress(XEvent *e)
++ 			arg.ui = 1 << i;
++ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
++ 			click = ClkLtSymbol;
++-		else
++-			click = ClkStatusText;
+++        } else if (ev->x > selmon->ww - statusw) {
+++            x = selmon->ww - statusw;
+++            click = ClkStatusText;
+++
+++			char *text, *s, ch;
+++			statussig = 0;
+++			for (text = s = stext; *s && x <= ev->x; s++) {
+++				if ((unsigned char)(*s) < ' ') {
+++					ch = *s;
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = ch;
+++					text = s + 1;
+++					if (x >= ev->x)
+++						break;
+++					statussig = ch;
+++				} else if (*s == '^') {
+++					*s = '\0';
+++					x += TEXTW(text) - lrpad;
+++					*s = '^';
+++					if (*(++s) == 'f')
+++						x += atoi(++s);
+++					while (*(s++) != '^');
+++					text = s;
+++					s--;
+++				}
+++			}
++ 	} else if ((c = wintoclient(ev->window))) {
++ 		focus(c);
++ 		restack(selmon);
++@@ -726,7 +756,7 @@ dirtomon(int dir)
++ 
++ int
++ drawstatusbar(Monitor *m, int bh, char* stext) {
++-	int ret, i, w, x, len;
+++	int ret, i, j, w, x, len;
++ 	short isCode = 0;
++ 	char *text;
++ 	char *p;
++@@ -735,7 +765,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
++ 	if (!(text = (char*) malloc(sizeof(char)*len)))
++ 		die("malloc");
++ 	p = text;
++-	memcpy(text, stext, len);
+++
+++	i = -1, j = 0;
+++	while (stext[++i])
+++		if ((unsigned char)stext[i] >= ' ')
+++			text[j++] = stext[i];
+++	text[j] = '\0';
++ 
++ 	/* compute width of the status text */
++ 	w = 0;
++@@ -846,7 +881,7 @@ drawbar(Monitor *m)
++ 
++ 	/* draw status first so it can be overdrawn by tags later */
++ 	if (m == selmon) { /* status is only drawn on selected monitor */
++-		tw = m->ww - drawstatusbar(m, bh, stext);
+++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
++ 	}
++ 
++ 	for (c = m->clients; c; c = c->next) {
++@@ -1004,6 +1039,30 @@ getatomprop(Client *c, Atom prop)
++ 	return atom;
++ }
++ 
+++pid_t
+++getstatusbarpid()
+++{
+++	char buf[32], *str = buf, *c;
+++	FILE *fp;
+++
+++	if (statuspid > 0) {
+++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+++		if ((fp = fopen(buf, "r"))) {
+++			fgets(buf, sizeof(buf), fp);
+++			while ((c = strchr(str, '/')))
+++				str = c + 1;
+++			fclose(fp);
+++			if (!strcmp(str, STATUSBAR))
+++				return statuspid;
+++		}
+++	}
+++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+++		return -1;
+++	fgets(buf, sizeof(buf), fp);
+++	pclose(fp);
+++	return strtoul(buf, NULL, 10);
+++}
+++
++ int
++ getrootptr(int *x, int *y)
++ {
++@@ -1928,6 +1987,20 @@ showhide(Client *c)
++ 	}
++ }
++ 
+++void
+++sigstatusbar(const Arg *arg)
+++{
+++	union sigval sv;
+++
+++	if (!statussig)
+++		return;
+++	sv.sival_int = arg->i;
+++	if ((statuspid = getstatusbarpid()) <= 0)
+++		return;
+++
+++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+++}
+++
++ void
++ spawn(const Arg *arg)
++ {
+diff --git a/patches_git/dwm-sticky.diff b/patches_git/dwm-sticky.diff
+new file mode 100644
+index 0000000..0657003
+--- /dev/null
++++ b/patches_git/dwm-sticky.diff
+@@ -0,0 +1,133 @@
++diff --git a/config.def.h b/config.def.h
++index f6c7894..2099993 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -139,6 +139,7 @@ static const Key keys[] = {
++ 	TAGKEYS(                        XK_8,                      7)
++ 	TAGKEYS(                        XK_9,                      8)
++ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
++ };
++ 
++ /* button definitions */
++diff --git a/dwm.c b/dwm.c
++index 91fac46..2fddeb1 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -50,7 +50,7 @@
++ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++@@ -61,7 +61,7 @@
++ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++ enum { SchemeNorm, SchemeSel }; /* color schemes */
++ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
++        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++@@ -94,7 +94,7 @@ struct Client {
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
++ 	Client *next;
++ 	Client *snext;
++ 	Monitor *mon;
++@@ -208,6 +208,7 @@ static void sendmon(Client *c, Monitor *m);
++ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
+++static void setsticky(Client *c, int sticky);
++ static void setlayout(const Arg *arg);
++ static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++@@ -221,6 +222,7 @@ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
+++static void togglesticky(const Arg *arg);
++ static void togglefullscr(const Arg *arg);
++ static void toggletag(const Arg *arg);
++ static void toggleview(const Arg *arg);
++@@ -544,6 +546,10 @@ clientmessage(XEvent *e)
++ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
++ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+++
+++        if (cme->data.l[1] == netatom[NetWMSticky]
+++                || cme->data.l[2] == netatom[NetWMSticky])
+++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
++ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
++ 		if (c != selmon->sel && !c->isurgent)
++ 			seturgent(c, 1);
++@@ -1714,6 +1720,23 @@ setfullscreen(Client *c, int fullscreen)
++ 	}
++ }
++ 
+++void
+++	 setsticky(Client *c, int sticky)
+++	 {
+++
+++		 if(sticky && !c->issticky) {
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+++			 c->issticky = 1;
+++		 } else if(!sticky && c->issticky){
+++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+++					 PropModeReplace, (unsigned char *)0, 0);
+++			 c->issticky = 0;
+++			 arrange(c->mon);
+++		 }
+++	 }
+++
+++
++ void
++ setlayout(const Arg *arg)
++ {
++@@ -1835,6 +1858,7 @@ setup(void)
++ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
++ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++@@ -1982,6 +2006,15 @@ togglefullscr(const Arg *arg)
++     setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++ }
++ 
+++void
+++togglesticky(const Arg *arg)
+++{
+++	if (!selmon->sel)
+++		return;
+++	setsticky(selmon->sel, !selmon->sel->issticky);
+++	arrange(selmon);
+++}
+++
++ void
++ toggletag(const Arg *arg)
++ {
++@@ -2274,6 +2307,9 @@ updatewindowtype(Client *c)
++ 
++ 	if (state == netatom[NetWMFullscreen])
++ 		setfullscreen(c, 1);
+++	if (state == netatom[NetWMSticky]) {
+++		setsticky(c, 1);
+++	}
++ 	if (wtype == netatom[NetWMWindowTypeDialog])
++ 		c->isfloating = 1;
++ }
++@@ -2411,3 +2447,4 @@ main(int argc, char *argv[])
++ 	XCloseDisplay(dpy);
++ 	return EXIT_SUCCESS;
++ }
+++
+diff --git a/patches_git/dwm-swallow.diff b/patches_git/dwm-swallow.diff
+new file mode 100644
+index 0000000..8119113
+--- /dev/null
++++ b/patches_git/dwm-swallow.diff
+@@ -0,0 +1,398 @@
++diff --git a/config.def.h b/config.def.h
++index f74867c..5a9f2d4 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -3,6 +3,7 @@
++ /* appearance */
++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
+++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
++ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++@@ -31,9 +32,11 @@ static const Rule rules[] = {
++ 	 *	WM_CLASS(STRING) = instance, class
++ 	 *	WM_NAME(STRING) = title
++ 	 */
++-	/* class      instance    title       tags mask     isfloating   monitor */
++-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
++-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
++ };
++ 
++ /* layout(s) */
++diff --git a/config.mk b/config.mk
++index 8efca9a..a933c0b 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
++ # OpenBSD (uncomment)
++ #FREETYPEINC = ${X11INC}/freetype2
++ #MANPREFIX = ${PREFIX}/man
+++#KVMLIB = -lkvm
++ 
++ # includes and libs
++ INCS = -I${X11INC} -I${FREETYPEINC}
++-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
++ 
++ # flags
++ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
++diff --git a/dwm.c b/dwm.c
++index ed799c2..a424e60 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -41,6 +41,12 @@
++ #include <X11/extensions/Xinerama.h>
++ #endif /* XINERAMA */
++ #include <X11/Xft/Xft.h>
+++#include <X11/Xlib-xcb.h>
+++#include <xcb/res.h>
+++#ifdef __OpenBSD__
+++#include <sys/sysctl.h>
+++#include <kvm.h>
+++#endif /* __OpenBSD */
++ 
++ #include "drw.h"
++ #include "util.h"
++@@ -94,9 +100,11 @@ struct Client {
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++ 	int bw, oldbw;
++ 	unsigned int tags;
++-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+++    pid_t pid;
++ 	Client *next;
++ 	Client *snext;
+++    Client *swallowing;
++ 	Monitor *mon;
++ 	Window win;
++ };
++@@ -144,6 +152,8 @@ typedef struct {
++ 	const char *title;
++ 	unsigned int tags;
++ 	int isfloating;
+++	int isterminal;
+++	int noswallow;
++ 	int monitor;
++ } Rule;
++ 
++@@ -249,6 +259,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
++ 
+++static pid_t getparentprocess(pid_t p);
+++static int isdescprocess(pid_t p, pid_t c);
+++static Client *swallowingclient(Window w);
+++static Client *termforwin(const Client *c);
+++static pid_t winpid(Window w);
+++
++ /* variables */
++ static const char autostartblocksh[] = "autostart_blocking.sh";
++ static const char autostartsh[] = "autostart.sh";
++@@ -290,6 +306,8 @@ static Drw *drw;
++ static Monitor *mons, *selmon;
++ static Window root, wmcheckwin;
++ 
+++static xcb_connection_t *xcon;
+++
++ /* configuration, allows nested code to access above variables */
++ #include "config.h"
++ 
++@@ -319,6 +337,8 @@ applyrules(Client *c)
++ 		&& (!r->class || strstr(class, r->class))
++ 		&& (!r->instance || strstr(instance, r->instance)))
++ 		{
+++			c->isterminal = r->isterminal;
+++			c->noswallow  = r->noswallow;
++ 			c->isfloating = r->isfloating;
++ 			c->tags |= r->tags;
++ 			for (m = mons; m && m->num != r->monitor; m = m->next);
++@@ -437,6 +457,53 @@ attachstack(Client *c)
++ 	c->mon->stack = c;
++ }
++ 
+++void
+++swallow(Client *p, Client *c)
+++{
+++
+++	if (c->noswallow || c->isterminal)
+++		return;
+++	if (c->noswallow && !swallowfloating && c->isfloating)
+++		return;
+++
+++	detach(c);
+++	detachstack(c);
+++
+++	setclientstate(c, WithdrawnState);
+++	XUnmapWindow(dpy, p->win);
+++
+++	p->swallowing = c;
+++	c->mon = p->mon;
+++
+++	Window w = p->win;
+++	p->win = c->win;
+++	c->win = w;
+++	updatetitle(p);
+++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+++	arrange(p->mon);
+++	configure(p);
+++	updateclientlist();
+++}
+++
+++void
+++unswallow(Client *c)
+++{
+++	c->win = c->swallowing->win;
+++
+++	free(c->swallowing);
+++	c->swallowing = NULL;
+++
+++	/* unfullscreen the client */
+++	setfullscreen(c, 0);
+++	updatetitle(c);
+++	arrange(c->mon);
+++	XMapWindow(dpy, c->win);
+++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+++	setclientstate(c, NormalState);
+++	focus(NULL);
+++	arrange(c->mon);
+++}
+++
++ void
++ buttonpress(XEvent *e)
++ {
++@@ -714,6 +781,9 @@ destroynotify(XEvent *e)
++ 
++ 	if ((c = wintoclient(ev->window)))
++ 		unmanage(c, 1);
+++
+++	else if ((c = swallowingclient(ev->window)))
+++		unmanage(c->swallowing, 1);
++ }
++ 
++ void
++@@ -1217,12 +1287,13 @@ killclient(const Arg *arg)
++ void
++ manage(Window w, XWindowAttributes *wa)
++ {
++-	Client *c, *t = NULL;
+++	Client *c, *t = NULL, *term = NULL;
++ 	Window trans = None;
++ 	XWindowChanges wc;
++ 
++ 	c = ecalloc(1, sizeof(Client));
++ 	c->win = w;
+++	c->pid = winpid(w);
++ 	/* geometry */
++ 	c->x = c->oldx = wa->x;
++ 	c->y = c->oldy = wa->y;
++@@ -1238,6 +1309,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	} else {
++ 		c->mon = selmon;
++ 		applyrules(c);
+++		term = termforwin(c);
++ 	}
++ 
++ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
++@@ -1276,6 +1348,8 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->mon->sel = c;
++ 	arrange(c->mon);
++ 	XMapWindow(dpy, c->win);
+++	if (term)
+++		swallow(term, c);
++ 	focus(NULL);
++ }
++ 
++@@ -2134,6 +2208,20 @@ unmanage(Client *c, int destroyed)
++ 	Monitor *m = c->mon;
++ 	XWindowChanges wc;
++ 
+++	if (c->swallowing) {
+++		unswallow(c);
+++		return;
+++	}
+++
+++	Client *s = swallowingclient(c->win);
+++	if (s) {
+++		free(s->swallowing);
+++		s->swallowing = NULL;
+++		arrange(m);
+++		focus(NULL);
+++		return;
+++	}
+++
++ 	detach(c);
++ 	detachstack(c);
++ 	if (!destroyed) {
++@@ -2149,9 +2237,12 @@ unmanage(Client *c, int destroyed)
++ 		XUngrabServer(dpy);
++ 	}
++ 	free(c);
++-	focus(NULL);
++-	updateclientlist();
++-	arrange(m);
+++
+++	if (!s) {
+++		arrange(m);
+++		focus(NULL);
+++		updateclientlist();
+++	}
++ }
++ 
++ void
++@@ -2418,6 +2509,136 @@ view(const Arg *arg)
++ 	arrange(selmon);
++ }
++ 
+++pid_t
+++winpid(Window w)
+++{
+++
+++	pid_t result = 0;
+++
+++#ifdef __linux__
+++	xcb_res_client_id_spec_t spec = {0};
+++	spec.client = w;
+++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+++
+++	xcb_generic_error_t *e = NULL;
+++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+++
+++	if (!r)
+++		return (pid_t)0;
+++
+++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+++		spec = i.data->spec;
+++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+++			uint32_t *t = xcb_res_client_id_value_value(i.data);
+++			result = *t;
+++			break;
+++		}
+++	}
+++
+++	free(r);
+++
+++	if (result == (pid_t)-1)
+++		result = 0;
+++
+++#endif /* __linux__ */
+++
+++#ifdef __OpenBSD__
+++        Atom type;
+++        int format;
+++        unsigned long len, bytes;
+++        unsigned char *prop;
+++        pid_t ret;
+++
+++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+++               return 0;
+++
+++        ret = *(pid_t*)prop;
+++        XFree(prop);
+++        result = ret;
+++
+++#endif /* __OpenBSD__ */
+++	return result;
+++}
+++
+++pid_t
+++getparentprocess(pid_t p)
+++{
+++	unsigned int v = 0;
+++
+++#ifdef __linux__
+++	FILE *f;
+++	char buf[256];
+++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+++
+++	if (!(f = fopen(buf, "r")))
+++		return 0;
+++
+++	fscanf(f, "%*u %*s %*c %u", &v);
+++	fclose(f);
+++#endif /* __linux__*/
+++
+++#ifdef __OpenBSD__
+++	int n;
+++	kvm_t *kd;
+++	struct kinfo_proc *kp;
+++
+++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+++	if (!kd)
+++		return 0;
+++
+++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+++	v = kp->p_ppid;
+++#endif /* __OpenBSD__ */
+++
+++	return (pid_t)v;
+++}
+++
+++int
+++isdescprocess(pid_t p, pid_t c)
+++{
+++	while (p != c && c != 0)
+++		c = getparentprocess(c);
+++
+++	return (int)c;
+++}
+++
+++Client *
+++termforwin(const Client *w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	if (!w->pid || w->isterminal)
+++		return NULL;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
+++Client *
+++swallowingclient(Window w)
+++{
+++	Client *c;
+++	Monitor *m;
+++
+++	for (m = mons; m; m = m->next) {
+++		for (c = m->clients; c; c = c->next) {
+++			if (c->swallowing && c->swallowing->win == w)
+++				return c;
+++		}
+++	}
+++
+++	return NULL;
+++}
+++
++ Client *
++ wintoclient(Window w)
++ {
++@@ -2507,10 +2728,12 @@ main(int argc, char *argv[])
++ 		fputs("warning: no locale support\n", stderr);
++ 	if (!(dpy = XOpenDisplay(NULL)))
++ 		die("dwm: cannot open display");
+++	if (!(xcon = XGetXCBConnection(dpy)))
+++		die("dwm: cannot get xcb connection\n");
++ 	checkotherwm();
++ 	setup();
++ #ifdef __OpenBSD__
++-	if (pledge("stdio rpath proc exec", NULL) == -1)
+++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++ 		die("pledge");
++ #endif /* __OpenBSD__ */
++ 	scan();
+diff --git a/patches_git/dwm-tagshift.diff b/patches_git/dwm-tagshift.diff
+new file mode 100644
+index 0000000..b416cd8
+--- /dev/null
++++ b/patches_git/dwm-tagshift.diff
+@@ -0,0 +1,69 @@
++diff --git a/config.def.h b/config.def.h
++index 880a46a..f6c7894 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -89,6 +89,10 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
+++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
+++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++ 	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++diff --git a/dwm.c b/dwm.c
++index 9ae5616..0d205d0 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -210,6 +210,8 @@ static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
+++static void shiftview(const Arg *arg);
+++static void shifttag(const Arg *arg);
++ static void showhide(Client *c);
++ static void spawn(const Arg *arg);
++ static void tag(const Arg *arg);
++@@ -1633,6 +1635,40 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++shiftview(const Arg *arg) {
+++	Arg shifted;
+++
+++	if(arg->i > 0) /* left circular shift */
+++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+++
+++	else /* right circular shift */
+++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+++
+++	view(&shifted);
+++}
+++
+++void
+++shifttag(const Arg *arg) {
+++	Arg shifted;
+++	Client *c;
+++
+++	if (!selmon->sel)
+++		return;
+++	c = selmon->sel;
+++
+++	if (arg->i > 0) /* left circular shift */
+++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+++			^ (c->tags >> (LENGTH(tags) - arg->i));
+++	else /* right circular shift */
+++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+++			^ (c->tags << (LENGTH(tags) + arg->i));
+++
+++	toggletag(&shifted);
+++}
+++
++ void
++ setcfact(const Arg *arg) {
++ 	float f;
+diff --git a/patches_git/dwm-vanitygaps.diff b/patches_git/dwm-vanitygaps.diff
+new file mode 100644
+index 0000000..1f1b7b5
+--- /dev/null
++++ b/patches_git/dwm-vanitygaps.diff
+@@ -0,0 +1,1018 @@
++diff --git a/config.def.h b/config.def.h
++index 9efa774..357dc6f 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -3,6 +3,11 @@
++ /* appearance */
++ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++ static const unsigned int snap      = 32;       /* snap pixel */
+++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
++ static const int showbar            = 1;        /* 0 means no bar */
++ static const int topbar             = 1;        /* 0 means bottom bar */
++ static const char *fonts[]          = { "monospace:size=10" };
++@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
++ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++ 
+++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+++#include "vanitygaps.c"
+++
++ static const Layout layouts[] = {
++ 	/* symbol     arrange function */
++ 	{ "[]=",      tile },    /* first entry is default */
++-	{ "><>",      NULL },    /* no layout function means floating behavior */
++ 	{ "[M]",      monocle },
+++	{ "[@]",      spiral },
+++	{ "[\\]",     dwindle },
+++	{ "H[]",      deck },
+++	{ "TTT",      bstack },
+++	{ "===",      bstackhoriz },
+++	{ "HHH",      grid },
+++	{ "###",      nrowgrid },
+++	{ "---",      horizgrid },
+++	{ ":::",      gaplessgrid },
+++	{ "|M|",      centeredmaster },
+++	{ ">M>",      centeredfloatingmaster },
+++	{ "><>",      NULL },    /* no layout function means floating behavior */
+++	{ NULL,       NULL },
++ };
++ 
++ /* key definitions */
++@@ -71,7 +91,26 @@ static const Key keys[] = {
++ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
++ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
++ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
+++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
+++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
++ 	{ MODKEY,                       XK_Tab,    view,           {0} },
++ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
++ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
++diff --git a/dwm.c b/dwm.c
++index 857c396..db7e0c8 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -86,6 +86,7 @@ typedef struct Client Client;
++ struct Client {
++ 	char name[256];
++ 	float mina, maxa;
+++	float cfact;
++ 	int x, y, w, h;
++ 	int oldx, oldy, oldw, oldh;
++ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
++@@ -118,6 +119,10 @@ struct Monitor {
++ 	int by;               /* bar geometry */
++ 	int mx, my, mw, mh;   /* screen size */
++ 	int wx, wy, ww, wh;   /* window area  */
+++	int gappih;           /* horizontal gap between windows */
+++	int gappiv;           /* vertical gap between windows */
+++	int gappoh;           /* horizontal outer gaps */
+++	int gappov;           /* vertical outer gaps */
++ 	unsigned int seltags;
++ 	unsigned int sellt;
++ 	unsigned int tagset[2];
++@@ -200,6 +205,7 @@ static void setclientstate(Client *c, long state);
++ static void setfocus(Client *c);
++ static void setfullscreen(Client *c, int fullscreen);
++ static void setlayout(const Arg *arg);
+++static void setcfact(const Arg *arg);
++ static void setmfact(const Arg *arg);
++ static void setup(void);
++ static void seturgent(Client *c, int urg);
++@@ -207,7 +213,6 @@ static void showhide(Client *c);
++ static void spawn(const Arg *arg);
++ static void tag(const Arg *arg);
++ static void tagmon(const Arg *arg);
++-static void tile(Monitor *m);
++ static void togglebar(const Arg *arg);
++ static void togglefloating(const Arg *arg);
++ static void toggletag(const Arg *arg);
++@@ -640,6 +645,10 @@ createmon(void)
++ 	m->nmaster = nmaster;
++ 	m->showbar = showbar;
++ 	m->topbar = topbar;
+++	m->gappih = gappih;
+++	m->gappiv = gappiv;
+++	m->gappoh = gappoh;
+++	m->gappov = gappov;
++ 	m->lt[0] = &layouts[0];
++ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++@@ -1042,6 +1051,7 @@ manage(Window w, XWindowAttributes *wa)
++ 	c->w = c->oldw = wa->width;
++ 	c->h = c->oldh = wa->height;
++ 	c->oldbw = wa->border_width;
+++	c->cfact = 1.0;
++ 
++ 	updatetitle(c);
++ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++@@ -1527,6 +1537,24 @@ setlayout(const Arg *arg)
++ 		drawbar(selmon);
++ }
++ 
+++void
+++setcfact(const Arg *arg) {
+++	float f;
+++	Client *c;
+++
+++	c = selmon->sel;
+++
+++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+++		return;
+++	f = arg->f + c->cfact;
+++	if(arg->f == 0.0)
+++		f = 1.0;
+++	else if(f < 0.25 || f > 4.0)
+++		return;
+++	c->cfact = f;
+++	arrange(selmon);
+++}
+++
++ /* arg > 1.0 will set mfact absolutely */
++ void
++ setmfact(const Arg *arg)
++@@ -1690,34 +1718,6 @@ tagmon(const Arg *arg)
++ 	sendmon(selmon->sel, dirtomon(arg->i));
++ }
++ 
++-void
++-tile(Monitor *m)
++-{
++-	unsigned int i, n, h, mw, my, ty;
++-	Client *c;
++-
++-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++-	if (n == 0)
++-		return;
++-
++-	if (n > m->nmaster)
++-		mw = m->nmaster ? m->ww * m->mfact : 0;
++-	else
++-		mw = m->ww;
++-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++-		if (i < m->nmaster) {
++-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
++-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (my + HEIGHT(c) < m->wh)
++-				my += HEIGHT(c);
++-		} else {
++-			h = (m->wh - ty) / (n - i);
++-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
++-			if (ty + HEIGHT(c) < m->wh)
++-				ty += HEIGHT(c);
++-		}
++-}
++-
++ void
++ togglebar(const Arg *arg)
++ {
++diff --git a/vanitygaps.c b/vanitygaps.c
++new file mode 100644
++index 0000000..1a816b6
++--- /dev/null
+++++ b/vanitygaps.c
++@@ -0,0 +1,822 @@
+++/* Key binding functions */
+++static void defaultgaps(const Arg *arg);
+++static void incrgaps(const Arg *arg);
+++static void incrigaps(const Arg *arg);
+++static void incrogaps(const Arg *arg);
+++static void incrohgaps(const Arg *arg);
+++static void incrovgaps(const Arg *arg);
+++static void incrihgaps(const Arg *arg);
+++static void incrivgaps(const Arg *arg);
+++static void togglegaps(const Arg *arg);
+++/* Layouts (delete the ones you do not need) */
+++static void bstack(Monitor *m);
+++static void bstackhoriz(Monitor *m);
+++static void centeredmaster(Monitor *m);
+++static void centeredfloatingmaster(Monitor *m);
+++static void deck(Monitor *m);
+++static void dwindle(Monitor *m);
+++static void fibonacci(Monitor *m, int s);
+++static void grid(Monitor *m);
+++static void nrowgrid(Monitor *m);
+++static void spiral(Monitor *m);
+++static void tile(Monitor *m);
+++/* Internals */
+++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+++static void setgaps(int oh, int ov, int ih, int iv);
+++
+++/* Settings */
+++#if !PERTAG_PATCH
+++static int enablegaps = 1;
+++#endif // PERTAG_PATCH
+++
+++void
+++setgaps(int oh, int ov, int ih, int iv)
+++{
+++	if (oh < 0) oh = 0;
+++	if (ov < 0) ov = 0;
+++	if (ih < 0) ih = 0;
+++	if (iv < 0) iv = 0;
+++
+++	selmon->gappoh = oh;
+++	selmon->gappov = ov;
+++	selmon->gappih = ih;
+++	selmon->gappiv = iv;
+++	arrange(selmon);
+++}
+++
+++void
+++togglegaps(const Arg *arg)
+++{
+++	#if PERTAG_PATCH
+++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	enablegaps = !enablegaps;
+++	#endif // PERTAG_PATCH
+++	arrange(NULL);
+++}
+++
+++void
+++defaultgaps(const Arg *arg)
+++{
+++	setgaps(gappoh, gappov, gappih, gappiv);
+++}
+++
+++void
+++incrgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrigaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++incrogaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrohgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh + arg->i,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrovgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov + arg->i,
+++		selmon->gappih,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrihgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih + arg->i,
+++		selmon->gappiv
+++	);
+++}
+++
+++void
+++incrivgaps(const Arg *arg)
+++{
+++	setgaps(
+++		selmon->gappoh,
+++		selmon->gappov,
+++		selmon->gappih,
+++		selmon->gappiv + arg->i
+++	);
+++}
+++
+++void
+++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+++{
+++	unsigned int n, oe, ie;
+++	#if PERTAG_PATCH
+++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+++	#else
+++	oe = ie = enablegaps;
+++	#endif // PERTAG_PATCH
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+++	if (smartgaps && n == 1) {
+++		oe = 0; // outer gaps disabled when only one client
+++	}
+++
+++	*oh = m->gappoh*oe; // outer horizontal gap
+++	*ov = m->gappov*oe; // outer vertical gap
+++	*ih = m->gappih*ie; // inner horizontal gap
+++	*iv = m->gappiv*ie; // inner vertical gap
+++	*nc = n;            // number of clients
+++}
+++
+++void
+++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+++{
+++	unsigned int n;
+++	float mfacts = 0, sfacts = 0;
+++	int mtotal = 0, stotal = 0;
+++	Client *c;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (n < m->nmaster)
+++			mtotal += msize * (c->cfact / mfacts);
+++		else
+++			stotal += ssize * (c->cfact / sfacts);
+++
+++	*mf = mfacts; // total factor of master area
+++	*sf = sfacts; // total factor of stack area
+++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+++}
+++
+++/***
+++ * Layouts
+++ */
+++
+++/*
+++ * Bottomstack layout + gaps
+++ * https://dwm.suckless.org/patches/bottomstack/
+++ */
+++static void
+++bstack(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sx = mx;
+++		sy = my + mh + ih;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++	}
+++}
+++
+++static void
+++bstackhoriz(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh;
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+++	sw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sh = (mh - ih) * (1 - m->mfact);
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+++	}
+++
+++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++	}
+++}
+++
+++/*
+++ * Centred master layout + gaps
+++ * https://dwm.suckless.org/patches/centeredmaster/
+++ */
+++void
+++centeredmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int lx = 0, ly = 0, lw = 0, lh = 0;
+++	int rx = 0, ry = 0, rw = 0, rh = 0;
+++	float mfacts = 0, lfacts = 0, rfacts = 0;
+++	int mtotal = 0, ltotal = 0, rtotal = 0;
+++	int mrest = 0, lrest = 0, rrest = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* initialize areas */
+++	mx = m->wx + ov;
+++	my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+++	mw = m->ww - 2*ov;
+++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (n - m->nmaster > 1) {
+++			/* ||<-S->|<---M--->|<-S->|| */
+++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+++			mx += lw + iv;
+++		} else {
+++			/* ||<---M--->|<-S->|| */
+++			mw = (mw - iv) * m->mfact;
+++			lw = 0;
+++			rw = m->ww - mw - iv - 2*ov;
+++		}
+++		lx = m->wx + ov;
+++		ly = m->wy + oh;
+++		rx = mx + mw + iv;
+++		ry = m->wy + oh;
+++	}
+++
+++	/* calculate facts */
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+++		if (!m->nmaster || n < m->nmaster)
+++			mfacts += c->cfact;
+++		else if ((n - m->nmaster) % 2)
+++			lfacts += c->cfact; // total factor of left hand stack area
+++		else
+++			rfacts += c->cfact; // total factor of right hand stack area
+++	}
+++
+++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+++		if (!m->nmaster || n < m->nmaster)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else if ((n - m->nmaster) % 2)
+++			ltotal += lh * (c->cfact / lfacts);
+++		else
+++			rtotal += rh * (c->cfact / rfacts);
+++
+++	mrest = mh - mtotal;
+++	lrest = lh - ltotal;
+++	rrest = rh - rtotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		if (!m->nmaster || i < m->nmaster) {
+++			/* nmaster clients are stacked vertically, in the center of the screen */
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			/* stack clients are stacked vertically */
+++			if ((i - m->nmaster) % 2 ) {
+++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+++				ly += HEIGHT(c) + ih;
+++			} else {
+++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+++				ry += HEIGHT(c) + ih;
+++			}
+++		}
+++	}
+++}
+++
+++void
+++centeredfloatingmaster(Monitor *m)
+++{
+++	unsigned int i, n;
+++	float mfacts, sfacts;
+++	float mivf = 1.0; // master inner vertical gap factor
+++	int oh, ov, ih, iv, mrest, srest;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	mw = m->ww - 2*ov - iv*(n - 1);
+++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		mivf = 0.8;
+++		/* go mfact box in the center if more than nmaster clients */
+++		if (m->ww > m->wh) {
+++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * 0.9;
+++		} else {
+++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+++			mh = m->wh * m->mfact;
+++		}
+++		mx = m->wx + (m->ww - mw) / 2;
+++		my = m->wy + (m->wh - mh - 2*oh) / 2;
+++
+++		sx = m->wx + ov;
+++		sy = m->wy + oh;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			/* nmaster clients are stacked horizontally, in the center of the screen */
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv*mivf;
+++		} else {
+++			/* stack clients are stacked horizontally */
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * Deck layout + gaps
+++ * https://dwm.suckless.org/patches/deck/
+++ */
+++void
+++deck(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++		sh = m->wh - 2*oh;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	if (n - m->nmaster > 0) /* override layout symbol */
+++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+++		}
+++}
+++
+++/*
+++ * Fibonacci layout + gaps
+++ * https://dwm.suckless.org/patches/fibonacci/
+++ */
+++void
+++fibonacci(Monitor *m, int s)
+++{
+++	unsigned int i, n;
+++	int nx, ny, nw, nh;
+++	int oh, ov, ih, iv;
+++	int nv, hrest = 0, wrest = 0, r = 1;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	nx = m->wx + ov;
+++	ny = m->wy + oh;
+++	nw = m->ww - 2*ov;
+++	nh = m->wh - 2*oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+++		if (r) {
+++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+++				r = 0;
+++			}
+++			if (r && i < n - 1) {
+++				if (i % 2) {
+++					nv = (nh - ih) / 2;
+++					hrest = nh - 2*nv - ih;
+++					nh = nv;
+++				} else {
+++					nv = (nw - iv) / 2;
+++					wrest = nw - 2*nv - iv;
+++					nw = nv;
+++				}
+++
+++				if ((i % 4) == 2 && !s)
+++					nx += nw + iv;
+++				else if ((i % 4) == 3 && !s)
+++					ny += nh + ih;
+++			}
+++
+++			if ((i % 4) == 0) {
+++				if (s) {
+++					ny += nh + ih;
+++					nh += hrest;
+++				}
+++				else {
+++					nh -= hrest;
+++					ny -= nh + ih;
+++				}
+++			}
+++			else if ((i % 4) == 1) {
+++				nx += nw + iv;
+++				nw += wrest;
+++			}
+++			else if ((i % 4) == 2) {
+++				ny += nh + ih;
+++				nh += hrest;
+++				if (i < n - 1)
+++					nw += wrest;
+++			}
+++			else if ((i % 4) == 3) {
+++				if (s) {
+++					nx += nw + iv;
+++					nw -= wrest;
+++				} else {
+++					nw -= wrest;
+++					nx -= nw + iv;
+++					nh += hrest;
+++				}
+++			}
+++			if (i == 0)	{
+++				if (n != 1) {
+++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+++					wrest = 0;
+++				}
+++				ny = m->wy + oh;
+++			}
+++			else if (i == 1)
+++				nw = m->ww - nw - iv - 2*ov;
+++			i++;
+++		}
+++
+++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+++	}
+++}
+++
+++void
+++dwindle(Monitor *m)
+++{
+++	fibonacci(m, 1);
+++}
+++
+++void
+++spiral(Monitor *m)
+++{
+++	fibonacci(m, 0);
+++}
+++
+++/*
+++ * Gappless grid layout + gaps (ironically)
+++ * https://dwm.suckless.org/patches/gaplessgrid/
+++ */
+++void
+++gaplessgrid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	/* grid dimensions */
+++	for (cols = 0; cols <= n/2; cols++)
+++		if (cols*cols >= n)
+++			break;
+++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+++		cols = 2;
+++	rows = n/cols;
+++	cn = rn = 0; // reset column no, row no, client count
+++
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	x = m->wx + ov;
+++	y = m->wy + oh;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+++		if (i/rows + 1 > cols - n%cols) {
+++			rows = n/cols + 1;
+++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++		}
+++		resize(c,
+++			x,
+++			y + rn*(ch + ih) + MIN(rn, rrest),
+++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+++			0);
+++		rn++;
+++		if (rn >= rows) {
+++			rn = 0;
+++			x += cw + ih + (cn < crest ? 1 : 0);
+++			cn++;
+++		}
+++	}
+++}
+++
+++/*
+++ * Gridmode layout + gaps
+++ * https://dwm.suckless.org/patches/gridmode/
+++ */
+++void
+++grid(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+++	int oh, ov, ih, iv;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* grid dimensions */
+++	for (rows = 0; rows <= n/2; rows++)
+++		if (rows*rows >= n)
+++			break;
+++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+++
+++	/* window geoms (cell height/width) */
+++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+++		cc = i / rows;
+++		cr = i % rows;
+++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+++	}
+++}
+++
+++/*
+++ * Horizontal grid layout + gaps
+++ * https://dwm.suckless.org/patches/horizgrid/
+++ */
+++void
+++horizgrid(Monitor *m) {
+++	Client *c;
+++	unsigned int n, i;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	int ntop, nbottom = 1;
+++	float mfacts = 0, sfacts = 0;
+++	int mrest, srest, mtotal = 0, stotal = 0;
+++
+++	/* Count windows */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	if (n <= 2)
+++		ntop = n;
+++	else {
+++		ntop = n / 2;
+++		nbottom = n - ntop;
+++	}
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	sh = mh = m->wh - 2*oh;
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (n > ntop) {
+++		sh = (mh - ih) / 2;
+++		mh = mh - ih - sh;
+++		sy = my + mh + ih;
+++		mw = m->ww - 2*ov - iv * (ntop - 1);
+++		sw = m->ww - 2*ov - iv * (nbottom - 1);
+++	}
+++
+++	/* calculate facts */
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mfacts += c->cfact;
+++		else
+++			sfacts += c->cfact;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop)
+++			mtotal += mh * (c->cfact / mfacts);
+++		else
+++			stotal += sw * (c->cfact / sfacts);
+++
+++	mrest = mh - mtotal;
+++	srest = sw - stotal;
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < ntop) {
+++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+++			mx += WIDTH(c) + iv;
+++		} else {
+++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+++			sx += WIDTH(c) + iv;
+++		}
+++}
+++
+++/*
+++ * nrowgrid layout + gaps
+++ * https://dwm.suckless.org/patches/nrowgrid/
+++ */
+++void
+++nrowgrid(Monitor *m)
+++{
+++	unsigned int n;
+++	int ri = 0, ci = 0;  /* counters */
+++	int oh, ov, ih, iv;                         /* vanitygap settings */
+++	unsigned int cx, cy, cw, ch;                /* client geometry */
+++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+++	unsigned int cols, rows = m->nmaster + 1;
+++	Client *c;
+++
+++	/* count clients */
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++
+++	/* nothing to do here */
+++	if (n == 0)
+++		return;
+++
+++	/* force 2 clients to always split vertically */
+++	if (FORCE_VSPLIT && n == 2)
+++		rows = 1;
+++
+++	/* never allow empty rows */
+++	if (n < rows)
+++		rows = n;
+++
+++	/* define first row */
+++	cols = n / rows;
+++	uc = cols;
+++	cy = m->wy + oh;
+++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+++	uh = ch;
+++
+++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+++		if (ci == cols) {
+++			uw = 0;
+++			ci = 0;
+++			ri++;
+++
+++			/* next row */
+++			cols = (n - uc) / (rows - ri);
+++			uc += cols;
+++			cy = m->wy + oh + uh + ih;
+++			uh += ch + ih;
+++		}
+++
+++		cx = m->wx + ov + uw;
+++		cw = (m->ww - 2*ov - uw) / (cols - ci);
+++		uw += cw + iv;
+++
+++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+++	}
+++}
+++
+++/*
+++ * Default tile layout + gaps
+++ */
+++static void
+++tile(Monitor *m)
+++{
+++	unsigned int i, n;
+++	int oh, ov, ih, iv;
+++	int mx = 0, my = 0, mh = 0, mw = 0;
+++	int sx = 0, sy = 0, sh = 0, sw = 0;
+++	float mfacts, sfacts;
+++	int mrest, srest;
+++	Client *c;
+++
+++	getgaps(m, &oh, &ov, &ih, &iv, &n);
+++	if (n == 0)
+++		return;
+++
+++	sx = mx = m->wx + ov;
+++	sy = my = m->wy + oh;
+++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+++	sw = mw = m->ww - 2*ov;
+++
+++	if (m->nmaster && n > m->nmaster) {
+++		sw = (mw - iv) * (1 - m->mfact);
+++		mw = mw - iv - sw;
+++		sx = mx + mw + iv;
+++	}
+++
+++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+++
+++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+++		if (i < m->nmaster) {
+++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+++			my += HEIGHT(c) + ih;
+++		} else {
+++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+++			sy += HEIGHT(c) + ih;
+++		}
+++}
++\ No newline at end of file
+diff --git a/patches_git/dwm-xresources.diff b/patches_git/dwm-xresources.diff
+new file mode 100644
+index 0000000..220fdff
+--- /dev/null
++++ b/patches_git/dwm-xresources.diff
+@@ -0,0 +1,231 @@
++diff --git a/config.def.h b/config.def.h
++index 5a9f2d4..9ed2869 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -1,27 +1,29 @@
++ /* See LICENSE file for copyright and license details. */
++ 
++ /* appearance */
++-static const unsigned int borderpx  = 1;        /* border pixel of windows */
++-static const unsigned int snap      = 32;       /* snap pixel */
+++static unsigned int borderpx  = 1;        /* border pixel of windows */
+++static unsigned int snap      = 32;       /* snap pixel */
++ static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
++ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++ static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
++-static const int showbar            = 1;        /* 0 means no bar */
++-static const int topbar             = 1;        /* 0 means bottom bar */
++-static const char *fonts[]          = { "monospace:size=10" };
++-static const char dmenufont[]       = "monospace:size=10";
++-static const char col_gray1[]       = "#222222";
++-static const char col_gray2[]       = "#444444";
++-static const char col_gray3[]       = "#bbbbbb";
++-static const char col_gray4[]       = "#eeeeee";
++-static const char col_cyan[]        = "#005577";
++-static const char *colors[][3]      = {
++-	/*               fg         bg         border   */
++-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
++-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+++static int showbar            = 1;        /* 0 means no bar */
+++static int topbar             = 1;        /* 0 means bottom bar */
+++static char font[]            = "monospace:size=10";
+++static char dmenufont[]       = "monospace:size=10";
+++static const char *fonts[]          = { font };
+++static char normbgcolor[]           = "#222222";
+++static char normbordercolor[]       = "#444444";
+++static char normfgcolor[]           = "#bbbbbb";
+++static char selfgcolor[]            = "#eeeeee";
+++static char selbordercolor[]        = "#005577";
+++static char selbgcolor[]            = "#005577";
+++static char *colors[][3] = {
+++       /*               fg           bg           border   */
+++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
++ };
++ 
++ /* tagging */
++@@ -40,9 +42,9 @@ static const Rule rules[] = {
++ };
++ 
++ /* layout(s) */
++-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++-static const int nmaster     = 1;    /* number of clients in master area */
++-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+++static int nmaster     = 1;    /* number of clients in master area */
+++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
++ 
++ #define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++@@ -82,9 +84,30 @@ static const Layout layouts[] = {
++ 
++ /* commands */
++ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
++ static const char *termcmd[]  = { "st", NULL };
++ 
+++/*
+++ * Xresources preferences to load at startup
+++ */
+++ResourcePref resources[] = {
+++		{ "font",               STRING,  &font },
+++		{ "dmenufont",          STRING,  &dmenufont },
+++		{ "normbgcolor",        STRING,  &normbgcolor },
+++		{ "normbordercolor",    STRING,  &normbordercolor },
+++		{ "normfgcolor",        STRING,  &normfgcolor },
+++		{ "selbgcolor",         STRING,  &selbgcolor },
+++		{ "selbordercolor",     STRING,  &selbordercolor },
+++		{ "selfgcolor",         STRING,  &selfgcolor },
+++		{ "borderpx",          	INTEGER, &borderpx },
+++		{ "snap",          		INTEGER, &snap },
+++		{ "showbar",          	INTEGER, &showbar },
+++		{ "topbar",          	INTEGER, &topbar },
+++		{ "nmaster",          	INTEGER, &nmaster },
+++		{ "resizehints",       	INTEGER, &resizehints },
+++		{ "mfact",      	 	FLOAT,   &mfact },
+++};
+++
++ static const Key keys[] = {
++ 	/* modifier                     key        function        argument */
++ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
++diff --git a/drw.c b/drw.c
++index c41e6af..6be5dee 100644
++--- a/drw.c
+++++ b/drw.c
++@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++ /* Wrapper to create color schemes. The caller has to call free(3) on the
++  * returned color scheme when done using it. */
++ Clr *
++-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
++ {
++ 	size_t i;
++ 	Clr *ret;
++diff --git a/drw.h b/drw.h
++index 6471431..bdbf950 100644
++--- a/drw.h
+++++ b/drw.h
++@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
++ 
++ /* Colorscheme abstraction */
++ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
++-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
++ 
++ /* Cursor abstraction */
++ Cur *drw_cur_create(Drw *drw, int shape);
++diff --git a/dwm.c b/dwm.c
++index a424e60..cb3067d 100644
++--- a/dwm.c
+++++ b/dwm.c
++@@ -37,6 +37,7 @@
++ #include <X11/Xlib.h>
++ #include <X11/Xproto.h>
++ #include <X11/Xutil.h>
+++#include <X11/Xresource.h>
++ #ifdef XINERAMA
++ #include <X11/extensions/Xinerama.h>
++ #endif /* XINERAMA */
++@@ -157,6 +158,19 @@ typedef struct {
++ 	int monitor;
++ } Rule;
++ 
+++/* Xresources preferences */
+++enum resource_type {
+++	STRING = 0,
+++	INTEGER = 1,
+++	FLOAT = 2
+++};
+++
+++typedef struct {
+++	char *name;
+++	enum resource_type type;
+++	void *dst;
+++} ResourcePref;
+++
++ /* function declarations */
++ static void applyrules(Client *c);
++ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++@@ -258,6 +272,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
++ static int xerrordummy(Display *dpy, XErrorEvent *ee);
++ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++ static void zoom(const Arg *arg);
+++static void load_xresources(void);
+++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
++ 
++ static pid_t getparentprocess(pid_t p);
++ static int isdescprocess(pid_t p, pid_t c);
++@@ -2717,6 +2733,60 @@ zoom(const Arg *arg)
++ 	pop(c);
++ }
++ 
+++void
+++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+++{
+++	char *sdst = NULL;
+++	int *idst = NULL;
+++	float *fdst = NULL;
+++
+++	sdst = dst;
+++	idst = dst;
+++	fdst = dst;
+++
+++	char fullname[256];
+++	char *type;
+++	XrmValue ret;
+++
+++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+++	fullname[sizeof(fullname) - 1] = '\0';
+++
+++	XrmGetResource(db, fullname, "*", &type, &ret);
+++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+++	{
+++		switch (rtype) {
+++		case STRING:
+++			strcpy(sdst, ret.addr);
+++			break;
+++		case INTEGER:
+++			*idst = strtoul(ret.addr, NULL, 10);
+++			break;
+++		case FLOAT:
+++			*fdst = strtof(ret.addr, NULL);
+++			break;
+++		}
+++	}
+++}
+++
+++void
+++load_xresources(void)
+++{
+++	Display *display;
+++	char *resm;
+++	XrmDatabase db;
+++	ResourcePref *p;
+++
+++	display = XOpenDisplay(NULL);
+++	resm = XResourceManagerString(display);
+++	if (!resm)
+++		return;
+++
+++	db = XrmGetStringDatabase(resm);
+++	for (p = resources; p < resources + LENGTH(resources); p++)
+++		resource_load(db, p->name, p->type, p->dst);
+++	XCloseDisplay(display);
+++}
+++
++ int
++ main(int argc, char *argv[])
++ {
++@@ -2731,6 +2801,8 @@ main(int argc, char *argv[])
++ 	if (!(xcon = XGetXCBConnection(dpy)))
++ 		die("dwm: cannot get xcb connection\n");
++ 	checkotherwm();
+++	XrmInitialize();
+++	load_xresources();
++ 	setup();
++ #ifdef __OpenBSD__
++ 	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+diff --git a/vanitygaps.c b/vanitygaps.c
+new file mode 100644
+index 0000000..5acce38
+--- /dev/null
++++ b/vanitygaps.c
+@@ -0,0 +1,837 @@
++/* Key binding functions */
++static void defaultgaps(const Arg *arg);
++static void incrgaps(const Arg *arg);
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
++static void togglegaps(const Arg *arg);
++static void togglebgaps(const Arg *arg);
++/* Layouts (delete the ones you do not need) */
++static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
++static void centeredmaster(Monitor *m);
++static void centeredfloatingmaster(Monitor *m);
++static void deck(Monitor *m);
++static void dwindle(Monitor *m);
++static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
++static void spiral(Monitor *m);
++static void tile(Monitor *m);
++/* Internals */
++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++static void setgaps(int oh, int ov, int ih, int iv);
++
++/* Settings */
++#if !PERTAG_PATCH
++static int enablegaps = 1;
++#endif // PERTAG_PATCH
++
++void
++setgaps(int oh, int ov, int ih, int iv)
++{
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
++}
++
++void
++togglegaps(const Arg *arg)
++{
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
++}
++
++static void
++togglebgaps(const Arg *arg)
++{
++    browsergaps = !browsergaps;
++    arrange(NULL);
++}
++
++void
++defaultgaps(const Arg *arg)
++{
++	setgaps(gappoh, gappov, gappih, gappiv);
++}
++
++void
++incrgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++{
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
++
++    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
++        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
++        if (TAGMASK == (1 << 8)){
++            setgaps(gappoh, gappov, gappih, gappiv);
++        }
++    }
++
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
++}
++
++void
++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++{
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++}
++
++/***
++ * Layouts
++ */
++
++/*
++ * Bottomstack layout + gaps
++ * https://dwm.suckless.org/patches/bottomstack/
++ */
++static void
++bstack(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
++
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
++}
++
++/*
++ * Centred master layout + gaps
++ * https://dwm.suckless.org/patches/centeredmaster/
++ */
++void
++centeredmaster(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
++}
++
++void
++centeredfloatingmaster(Monitor *m)
++{
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * Deck layout + gaps
++ * https://dwm.suckless.org/patches/deck/
++ */
++void
++deck(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
++}
++
++/*
++ * Fibonacci layout + gaps
++ * https://dwm.suckless.org/patches/fibonacci/
++ */
++void
++fibonacci(Monitor *m, int s)
++{
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
++}
++
++void
++dwindle(Monitor *m)
++{
++	fibonacci(m, 1);
++}
++
++void
++spiral(Monitor *m)
++{
++	fibonacci(m, 0);
++}
++
++/*
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
++ */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
++
++/*
++ * Default tile layout + gaps
++ */
++static void
++tile(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++}
diff --git a/drw.c b/drw.c
index c41e6af..11387e5 100644
--- a/drw.c
+++ b/drw.c
@@ -176,12 +176,14 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 	                       DefaultColormap(drw->dpy, drw->screen),
 	                       clrname, dest))
 		die("error, cannot allocate color '%s'", clrname);
+
+    dest->pixel |= 0xff << 24;
 }
 
 /* Wrapper to create color schemes. The caller has to call free(3) on the
  * returned color scheme when done using it. */
 Clr *
-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
 {
 	size_t i;
 	Clr *ret;
diff --git a/drw.h b/drw.h
index 6471431..bdbf950 100644
--- a/drw.h
+++ b/drw.h
@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
 
 /* Colorscheme abstraction */
 void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
 
 /* Cursor abstraction */
 Cur *drw_cur_create(Drw *drw, int shape);
diff --git a/dwm-mul_mon.diff b/dwm-mul_mon.diff
new file mode 100644
index 0000000..52d8476
--- /dev/null
+++ b/dwm-mul_mon.diff
@@ -0,0 +1,288 @@
+diff --git a/config.h b/config.h
+index ec7de9e..3fb3f44 100644
+--- a/config.h
++++ b/config.h
+@@ -214,7 +214,7 @@ static const Key keys[] = {
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         { MODKEY,                   XK_q,               killclient,         {0} },
+-        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
++        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
+         { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
+         { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
+         { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
+diff --git a/dwm.c b/dwm.c
+index 6232799..8b14f30 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -200,6 +200,7 @@ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
++static Monitor *numtomon(int num);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+@@ -207,6 +208,7 @@ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
++static void focusnthmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+@@ -258,7 +260,12 @@ static void tag(const Arg *arg);
+ static void tagview(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tagmonview(const Arg *arg);
++static void tagnextmon(const Arg *arg);
++static void tagnewmon(const Arg *arg);
++static void tagnthmon(const Arg *arg);
++static void tagnthmonview(const Arg *arg);
+ static void togglebar(const Arg *arg);
++static void togglebars(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglescratch(const Arg *arg);
+ static void togglesticky(const Arg *arg);
+@@ -791,7 +798,10 @@ createmon(void)
+ 	Monitor *m;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+-	m->tagset[0] = m->tagset[1] = 1;
++    if (mons)
++        m->tagset[0] = m->tagset[1] = 2;
++    else
++        m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+@@ -857,6 +867,17 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++Monitor *
++numtomon(int num)
++{
++    Monitor *m = NULL;
++    int i = 0;
++
++    for(m = mons, i=0; m->next && i < num; m = m->next)
++        i++;
++    return m;
++}
++
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext)
+ {
+@@ -1091,6 +1112,22 @@ focusmon(const Arg *arg)
+ 	focus(NULL);
+ }
+ 
++void
++focusnthmon(const Arg *arg)
++{
++    Monitor *m;
++
++    if (!mons->next)
++        return;
++
++    if ((m = numtomon(arg->i)) == selmon)
++        return;
++    unfocus(selmon->sel, 0);
++    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
++    selmon = m;
++    focus(NULL);
++}
++
+ void
+ focusstack(const Arg *arg)
+ {
+@@ -2175,20 +2212,76 @@ stackpos(const Arg *arg) {
+ 		return arg->i;
+ }
+ 
++//void
++//tag(const Arg *arg)
++//{
++//    if (selmon->sel && arg->ui & TAGMASK) {
++//        if (mons && mons->next) {
++//            // Moving to even tag, selected mon != first mon
++//            if ((arg->ui & 341) == 0 && selmon != mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//                // Moving to odd tag, selected mon == first mon
++//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            } else {
++//                tagnextmon(arg);
++//            }
++//        } else {
++//            if (selmon->sel && arg->ui & TAGMASK) {
++//                selmon->sel->tags = arg->ui & TAGMASK;
++//                focus(NULL);
++//                arrange(selmon);
++//            }
++//        }
++//    }
++//}
++
+ void
+ tag(const Arg *arg)
+ {
+-	if (selmon->sel && arg->ui & TAGMASK) {
+-		selmon->sel->tags = arg->ui & TAGMASK;
+-		focus(NULL);
+-		arrange(selmon);
+-	}
++    if (!(selmon->sel && arg->ui & TAGMASK))
++        return;
++
++    if (mons && mons->next) {
++        // Moving to even tag, selected mon != first mon
++        if ((arg->ui & 341) == 0 && selmon != mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        }
++        // Moving to odd tag, selected mon == first mon
++        else if ((arg->ui & 341) > 0 && selmon == mons) {
++            selmon->sel->tags = arg->ui & TAGMASK;
++        } else {
++            tagnextmon(arg);
++            return;
++        }
++    } else {
++        selmon->sel->tags = arg->ui & TAGMASK;
++    }
++
++    focus(NULL);
++    arrange(selmon);
+ }
+ 
+ void
+ tagview(const Arg *arg)
+ {
+     if (selmon->sel && arg->ui & TAGMASK) {
++        if (mons && mons->next) {
++            // If first monitor and moving to even tag (second mon)
++            if ((arg->ui & 341) == 0 && selmon == mons) {
++                tagnthmonview(&((Arg) { .i = 1 }));
++                tagnewmon(arg);
++                return;
++            } else if ((arg->ui & 341) > 0 && selmon != mons) {
++                tagnthmonview(&((Arg) { .i = 0 }));
++                tagnewmon(arg);
++                return;
++            }
++        }
+         selmon->sel->tags = arg->ui & TAGMASK;
+         focus(NULL);
+         arrange(selmon);
+@@ -2212,6 +2305,51 @@ tagmonview(const Arg *arg)
+     sendmonview(selmon->sel, dirtomon(arg->i));
+ }
+ 
++void
++tagnextmon(const Arg *arg)
++{
++    Client *sel;
++    Monitor *newmon;
++
++    if (!selmon->sel || !mons->next)
++        return;
++    sel = selmon->sel;
++    newmon = dirtomon(1);
++    sendmon(sel, newmon);
++    if (sel && arg->ui & TAGMASK) {
++        sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(newmon);
++    }
++}
++
++void
++tagnewmon(const Arg *arg)
++{
++    if (selmon->sel && arg->ui & TAGMASK) {
++        selmon->sel->tags = arg->ui & TAGMASK;
++        focus(NULL);
++        arrange(selmon);
++        view(arg);
++    }
++}
++
++void
++tagnthmon(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmon(selmon->sel, numtomon(arg->i));
++}
++
++void
++tagnthmonview(const Arg *arg)
++{
++    if (!selmon->sel || !mons->next)
++        return;
++    sendmonview(selmon->sel, numtomon(arg->i));
++}
++
+ void
+ togglebar(const Arg *arg)
+ {
+@@ -2221,6 +2359,18 @@ togglebar(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglebars(const Arg *arg)
++{
++    Monitor *m;
++    for (m = mons; m; m = m->next) {
++        m->showbar = !m->showbar;
++        updatebarpos(m);
++        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++        arrange(m);
++    }
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+@@ -2623,16 +2773,27 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
+-    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
+-        view(&((Arg) { .ui = 0 }));
+-        return;
++    if (mons && mons->next) {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++            return;
++
++        // GENIUS 101010101
++        if ((arg->ui & 341) == 0)
++            focusnthmon(&((Arg) { .i = 1 }));
++        else
++            focusnthmon(&((Arg) { .i = 0 }));
++    } else {
++        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
++            view(&((Arg) { .ui = 0 })); 
++            return; 
++        } 
+     }
+ 
+-	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
+-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+-	focus(NULL);
+-	arrange(selmon);
++    selmon->seltags ^= 1; /* toggle sel tagset */
++    if (arg->ui & TAGMASK)
++        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++    focus(NULL);
++    arrange(selmon);
+ }
+ 
+ pid_t
diff --git a/dwm.1 b/dwm.1
index ddc8321..d04bec6 100644
--- a/dwm.1
+++ b/dwm.1
@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
 indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
+.P
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
@@ -116,6 +124,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
 .B Mod1\-Shift\-c
 Close focused window.
 .TP
+.B Mod1\-Shift\-f
+Toggle fullscreen for focused window.
+.TP
 .B Mod1\-Shift\-space
 Toggle focused window between tiled and floating state.
 .TP
@@ -152,6 +163,21 @@ Toggles focused window between floating and tiled state.
 .TP
 .B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+.SH FILES
+The files containing programs to be started along with dwm are searched for in
+the following directories:
+.IP "1. $XDG_DATA_HOME/dwm"
+.IP "2. $HOME/.local/share/dwm"
+.IP "3. $HOME/.dwm"
+.P
+The first existing directory is scanned for any of the autostart files below.
+.TP 15
+autostart.sh
+This file is started as a shell background process before dwm enters its handler
+loop.
+.TP 15
+autostart_blocking.sh
+This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
diff --git a/dwm.c b/dwm.c
index 1443802..ce6c5f5 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -36,10 +37,17 @@
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
 #include <X11/Xutil.h>
+#include <X11/Xresource.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
 #include <X11/Xft/Xft.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
 
 #include "drw.h"
 #include "util.h"
@@ -47,24 +55,33 @@
 /* macros */
 #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+#define GETINC(X)               ((X) - 2000)
+#define INC(X)                  ((X) + 2000)
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+#define PREVSEL                 3000
+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+#define TAGMASK     			((1 << NUMTAGS) - 1)
+#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
 enum { SchemeNorm, SchemeSel }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
 	int i;
@@ -86,14 +103,18 @@ typedef struct Client Client;
 struct Client {
 	char name[256];
 	float mina, maxa;
+	float cfact;
 	int x, y, w, h;
+	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
 	int oldx, oldy, oldw, oldh;
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
 	int bw, oldbw;
 	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
+    pid_t pid;
 	Client *next;
 	Client *snext;
+    Client *swallowing;
 	Monitor *mon;
 	Window win;
 };
@@ -118,6 +139,10 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -137,9 +162,24 @@ typedef struct {
 	const char *title;
 	unsigned int tags;
 	int isfloating;
+	int isterminal;
+	int noswallow;
 	int monitor;
 } Rule;
 
+/* Xresources preferences */
+enum resource_type {
+	STRING = 0,
+	INTEGER = 1,
+	FLOAT = 2
+};
+
+typedef struct {
+	char *name;
+	enum resource_type type;
+	void *dst;
+} ResourcePref;
+
 /* function declarations */
 static void applyrules(Client *c);
 static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
@@ -160,17 +200,20 @@ static void destroynotify(XEvent *e);
 static void detach(Client *c);
 static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
+static Monitor *numtomon(int num);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-static void enternotify(XEvent *e);
+static int drawstatusbar(Monitor *m, int bh, char* text);
 static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
+static void focusnthmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
 static long getstate(Window w);
+static pid_t getstatusbarpid();
 static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
@@ -181,11 +224,11 @@ static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
 static void monocle(Monitor *m);
-static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *c);
 static void propertynotify(XEvent *e);
+static void pushstack(const Arg *arg);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
 static void resize(Client *c, int x, int y, int w, int h, int interact);
@@ -193,23 +236,46 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
+static void sendmonview(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
+static void setsticky(Client *c, int sticky);
 static void setlayout(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shifttag(const Arg *arg);
+static void shifttagclients(const Arg *arg);
+static void shiftview(const Arg *arg);
+static void shiftviewclients(const Arg *arg);
+static void shiftboth(const Arg *arg);
+static void swaptags(const Arg *arg);
+static void shiftswaptags(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void showhide(Client *c);
+static void sigstatusbar(const Arg *arg);
 static void spawn(const Arg *arg);
+static int stackpos(const Arg *arg);
 static void tag(const Arg *arg);
+static void tagview(const Arg *arg);
 static void tagmon(const Arg *arg);
-static void tile(Monitor *m);
+static void tagmonview(const Arg *arg);
+static void tagnextmon(const Arg *arg);
+static void tagnewmon(const Arg *arg);
+static void tagnthmon(const Arg *arg);
+static void tagnthmonview(const Arg *arg);
 static void togglebar(const Arg *arg);
+static void togglebars(const Arg *arg);
 static void togglefloating(const Arg *arg);
+static void togglescratch(const Arg *arg);
+static void togglesticky(const Arg *arg);
+static void togglefullscr(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -232,10 +298,25 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void load_xresources(void);
+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+
+static pid_t getparentprocess(pid_t p);
+static int isdescprocess(pid_t p, pid_t c);
+static Client *swallowingclient(Window w);
+static Client *termforwin(const Client *c);
+static pid_t winpid(Window w);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
-static char stext[256];
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
+static int statussig;
+static int statusw;
+static pid_t statuspid = -1;
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
@@ -248,13 +329,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[ConfigureRequest] = configurerequest,
 	[ConfigureNotify] = configurenotify,
 	[DestroyNotify] = destroynotify,
-	[EnterNotify] = enternotify,
 	[Expose] = expose,
 	[FocusIn] = focusin,
 	[KeyPress] = keypress,
 	[MappingNotify] = mappingnotify,
 	[MapRequest] = maprequest,
-	[MotionNotify] = motionnotify,
 	[PropertyNotify] = propertynotify,
 	[UnmapNotify] = unmapnotify
 };
@@ -267,6 +346,8 @@ static Drw *drw;
 static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
 
+static xcb_connection_t *xcon;
+
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
@@ -296,8 +377,15 @@ applyrules(Client *c)
 		&& (!r->class || strstr(class, r->class))
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
+			c->isterminal = r->isterminal;
+			c->noswallow  = r->noswallow;
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
+			if ((r->tags & SPTAGMASK) && r->isfloating) {
+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+			}
+
 			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
 				c->mon = m;
@@ -307,7 +395,7 @@ applyrules(Client *c)
 		XFree(ch.res_class);
 	if (ch.res_name)
 		XFree(ch.res_name);
-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
 }
 
 int
@@ -414,6 +502,53 @@ attachstack(Client *c)
 	c->mon->stack = c;
 }
 
+void
+swallow(Client *p, Client *c)
+{
+
+	if (c->noswallow || c->isterminal)
+		return;
+	if (c->noswallow && !swallowfloating && c->isfloating)
+		return;
+
+	detach(c);
+	detachstack(c);
+
+	setclientstate(c, WithdrawnState);
+	XUnmapWindow(dpy, p->win);
+
+	p->swallowing = c;
+	c->mon = p->mon;
+
+	Window w = p->win;
+	p->win = c->win;
+	c->win = w;
+	updatetitle(p);
+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+	arrange(p->mon);
+	configure(p);
+	updateclientlist();
+}
+
+void
+unswallow(Client *c)
+{
+	c->win = c->swallowing->win;
+
+	free(c->swallowing);
+	c->swallowing = NULL;
+
+	/* unfullscreen the client */
+	setfullscreen(c, 0);
+	updatetitle(c);
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	setclientstate(c, NormalState);
+	focus(NULL);
+	arrange(c->mon);
+}
+
 void
 buttonpress(XEvent *e)
 {
@@ -425,28 +560,58 @@ buttonpress(XEvent *e)
 
 	click = ClkRootWin;
 	/* focus monitor if necessary */
-	if ((m = wintomon(ev->window)) && m != selmon) {
+	if ((m = wintomon(ev->window)) && m != selmon
+	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
 		unfocus(selmon->sel, 1);
 		selmon = m;
 		focus(NULL);
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
-		do
+		unsigned int occ = 0;
+		for(c = m->clients; c; c=c->next)
+			occ |= c->tags == TAGMASK ? 0 : c->tags;
+		do {
+			/* Do not reserve space for vacant tags */
+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+				continue;
 			x += TEXTW(tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
+		} while (ev->x >= x && ++i < LENGTH(tags));
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
-			click = ClkStatusText;
-		else
-			click = ClkWinTitle;
+        } else if (ev->x > selmon->ww - statusw) {
+            x = selmon->ww - statusw;
+            click = ClkStatusText;
+
+			char *text, *s, ch;
+			statussig = 0;
+			for (text = s = stext; *s && x <= ev->x; s++) {
+				if ((unsigned char)(*s) < ' ') {
+					ch = *s;
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = ch;
+					text = s + 1;
+					if (x >= ev->x)
+						break;
+					statussig = ch;
+				} else if (*s == '^') {
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = '^';
+					if (*(++s) == 'f')
+						x += atoi(++s);
+					while (*(s++) != '^');
+					text = s;
+					s--;
+				}
+			}
 	} else if ((c = wintoclient(ev->window))) {
-		focus(c);
-		restack(selmon);
+		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+			focus(c);
 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
 		click = ClkClientWin;
 	}
@@ -485,7 +650,7 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors); i++)
+	for (i = 0; i < LENGTH(colors) + 1; i++)
 		free(scheme[i]);
 	free(scheme);
 	XDestroyWindow(dpy, wmcheckwin);
@@ -524,6 +689,10 @@ clientmessage(XEvent *e)
 		|| cme->data.l[2] == netatom[NetWMFullscreen])
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+
+        if (cme->data.l[1] == netatom[NetWMSticky]
+                || cme->data.l[2] == netatom[NetWMSticky])
+            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -635,11 +804,18 @@ createmon(void)
 	Monitor *m;
 
 	m = ecalloc(1, sizeof(Monitor));
-	m->tagset[0] = m->tagset[1] = 1;
+    if (mons)
+        m->tagset[0] = m->tagset[1] = 2;
+    else
+        m->tagset[0] = m->tagset[1] = 1;
 	m->mfact = mfact;
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
@@ -654,6 +830,9 @@ destroynotify(XEvent *e)
 
 	if ((c = wintoclient(ev->window)))
 		unmanage(c, 1);
+
+	else if ((c = swallowingclient(ev->window)))
+		unmanage(c->swallowing, 1);
 }
 
 void
@@ -694,6 +873,139 @@ dirtomon(int dir)
 	return m;
 }
 
+Monitor *
+numtomon(int num)
+{
+    Monitor *m = NULL;
+    int i = 0;
+
+    for(m = mons, i=0; m->next && i < num; m = m->next)
+        i++;
+    return m;
+}
+
+int
+drawstatusbar(Monitor *m, int bh, char* stext)
+{
+    int ret, i, w, x, len;
+    short isCode = 0;
+    char *text;
+    char *p;
+    FILE *ptr;
+    char ch;
+    int hotbool = 0;
+
+    len = strlen(stext) + 1 ;
+    if (!(text = (char*) malloc(sizeof(char)*len)))
+        die("malloc");
+    p = text;
+    memcpy(text, stext, len);
+
+    /* compute width of the status text */
+    w = 0;
+    i = -1;
+    while (text[++i]) {
+        if (text[i] == '^') {
+            if (!isCode) {
+                isCode = 1;
+                text[i] = '\0';
+                w += TEXTW(text) - lrpad;
+                text[i] = '^';
+                if (text[++i] == 'f')
+                    w += atoi(text + ++i);
+            } else {
+                isCode = 0;
+                text = text + i + 1;
+                i = -1;
+            }
+        }
+    }
+    if (!isCode)
+        w += TEXTW(text) - lrpad;
+    else
+        isCode = 0;
+    text = p;
+
+    w += 2; /* 1px padding on both sides */
+    ret = x = m->ww - w;
+
+    drw_setscheme(drw, scheme[LENGTH(colors)]);
+    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+    drw_rect(drw, x, 0, w, bh, 1, 1);
+    x++;
+
+    /* process status text */
+    i = -1;
+    drw_clr_create(drw, &drw->scheme[ColFg], col1);
+
+    while (text[++i]) {
+        if (text[i] == '^' && !isCode) {
+            isCode = 1;
+
+            text[i] = '\0';
+            w = TEXTW(text) - lrpad;
+            drw_text(drw, x, 0, w, bh, 0, text, 0);
+            x += w;
+
+            while (text[++i] != '^') {
+                if (text[i] == '2') {
+                    // Check if weather is hot or not
+                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
+                    if (ptr == NULL) printf("Fail to read wr...");
+                    do{
+                        ch = fgetc(ptr);
+                        // Check if temp is above +20 (= hot)
+                        if (hotbool){
+                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
+                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
+                                break;
+                            }else{
+                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
+                                break;
+                            }
+                        }
+
+                        if (ch == '+'){
+                            hotbool = 1;
+                        }else if (ch == '-') {
+                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
+                            break;
+                        }
+                        else{
+                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
+                            break;
+                        }
+                    } while (ch != EOF);
+                    fclose(ptr);
+                } else if (text[i] == '3') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
+                } else if (text[i] == '4') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
+                } else if (text[i] == '5') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
+                } else if (text[i] == '6') {
+                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
+                }
+            }
+
+            text = text + i + 1;
+            i=-1;
+            isCode = 0;
+        }
+    }
+
+    if (!isCode) {
+        w = TEXTW(text) - lrpad;
+        drw_text(drw, x, 0, w, bh, 0, text, 0);
+    }
+
+    drw_setscheme(drw, scheme[SchemeNorm]);
+    free(p);
+
+    return ret;
+}
+
 void
 drawbar(Monitor *m)
 {
@@ -707,26 +1019,24 @@ drawbar(Monitor *m)
 		return;
 
 	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+	//if (m == selmon) { /* status is only drawn on selected monitor */
+    if (m == selmon || 1) { 
+		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
 	}
 
 	for (c = m->clients; c; c = c->next) {
-		occ |= c->tags;
+		occ |= c->tags == TAGMASK ? 0 : c->tags;
 		if (c->isurgent)
 			urg |= c->tags;
 	}
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
+		/* Do not draw vacant tags */
+		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+			continue;
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-				urg & 1 << i);
 		x += w;
 	}
 	w = TEXTW(m->ltsymbol);
@@ -734,15 +1044,8 @@ drawbar(Monitor *m)
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
 
 	if ((w = m->ww - tw - x) > bh) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
 			drw_rect(drw, x, 0, w, bh, 1, 1);
-		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
@@ -756,25 +1059,6 @@ drawbars(void)
 		drawbar(m);
 }
 
-void
-enternotify(XEvent *e)
-{
-	Client *c;
-	Monitor *m;
-	XCrossingEvent *ev = &e->xcrossing;
-
-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
-		return;
-	c = wintoclient(ev->window);
-	m = c ? c->mon : wintomon(ev->window);
-	if (m != selmon) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-	} else if (!c || c == selmon->sel)
-		return;
-	focus(c);
-}
-
 void
 expose(XEvent *e)
 {
@@ -834,30 +1118,35 @@ focusmon(const Arg *arg)
 	focus(NULL);
 }
 
+void
+focusnthmon(const Arg *arg)
+{
+    Monitor *m;
+
+    if (!mons->next)
+        return;
+
+    if ((m = numtomon(arg->i)) == selmon)
+        return;
+    unfocus(selmon->sel, 0);
+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+    selmon = m;
+    focus(NULL);
+}
+
 void
 focusstack(const Arg *arg)
 {
-	Client *c = NULL, *i;
+	int i = stackpos(arg);
+	Client *c, *p;
 
-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+	if(i < 0)
 		return;
-	if (arg->i > 0) {
-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
-		if (!c)
-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
-	} else {
-		for (i = selmon->clients; i != selmon->sel; i = i->next)
-			if (ISVISIBLE(i))
-				c = i;
-		if (!c)
-			for (; i; i = i->next)
-				if (ISVISIBLE(i))
-					c = i;
-	}
-	if (c) {
-		focus(c);
-		restack(selmon);
-	}
+
+	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+	focus(c ? c : p);
+	restack(selmon);
 }
 
 Atom
@@ -876,6 +1165,30 @@ getatomprop(Client *c, Atom prop)
 	return atom;
 }
 
+pid_t
+getstatusbarpid()
+{
+	char buf[32], *str = buf, *c;
+	FILE *fp;
+
+	if (statuspid > 0) {
+		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+		if ((fp = fopen(buf, "r"))) {
+			fgets(buf, sizeof(buf), fp);
+			while ((c = strchr(str, '/')))
+				str = c + 1;
+			fclose(fp);
+			if (!strcmp(str, STATUSBAR))
+				return statuspid;
+		}
+	}
+	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+		return -1;
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+	return strtoul(buf, NULL, 10);
+}
+
 int
 getrootptr(int *x, int *y)
 {
@@ -1030,18 +1343,20 @@ killclient(const Arg *arg)
 void
 manage(Window w, XWindowAttributes *wa)
 {
-	Client *c, *t = NULL;
+	Client *c, *t = NULL, *term = NULL;
 	Window trans = None;
 	XWindowChanges wc;
 
 	c = ecalloc(1, sizeof(Client));
 	c->win = w;
+	c->pid = winpid(w);
 	/* geometry */
 	c->x = c->oldx = wa->x;
 	c->y = c->oldy = wa->y;
 	c->w = c->oldw = wa->width;
 	c->h = c->oldh = wa->height;
 	c->oldbw = wa->border_width;
+	c->cfact = 1.0;
 
 	updatetitle(c);
 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
@@ -1050,6 +1365,7 @@ manage(Window w, XWindowAttributes *wa)
 	} else {
 		c->mon = selmon;
 		applyrules(c);
+		term = termforwin(c);
 	}
 
 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
@@ -1067,6 +1383,10 @@ manage(Window w, XWindowAttributes *wa)
 	updatewindowtype(c);
 	updatesizehints(c);
 	updatewmhints(c);
+	c->sfx = c->x;
+	c->sfy = c->y;
+	c->sfw = c->w;
+	c->sfh = c->h;
 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
 	grabbuttons(c, 0);
 	if (!c->isfloating)
@@ -1084,6 +1404,8 @@ manage(Window w, XWindowAttributes *wa)
 	c->mon->sel = c;
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
+	if (term)
+		swallow(term, c);
 	focus(NULL);
 }
 
@@ -1124,23 +1446,6 @@ monocle(Monitor *m)
 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
 }
 
-void
-motionnotify(XEvent *e)
-{
-	static Monitor *mon = NULL;
-	Monitor *m;
-	XMotionEvent *ev = &e->xmotion;
-
-	if (ev->window != root)
-		return;
-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-		focus(NULL);
-	}
-	mon = m;
-}
-
 void
 movemouse(const Arg *arg)
 {
@@ -1244,16 +1549,36 @@ propertynotify(XEvent *e)
 			drawbars();
 			break;
 		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
 			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
 		if (ev->atom == netatom[NetWMWindowType])
 			updatewindowtype(c);
 	}
 }
 
+void
+pushstack(const Arg *arg) {
+	int i = stackpos(arg);
+	Client *sel = selmon->sel, *c, *p;
+
+	if(i < 0)
+		return;
+	else if(i == 0) {
+		detach(sel);
+		attach(sel);
+	}
+	else {
+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+			if(!(i -= (ISVISIBLE(c) && c != sel)))
+				break;
+		c = c ? c : p;
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	arrange(selmon);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1291,6 +1616,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
 	c->oldw = c->w; c->w = wc.width = w;
 	c->oldh = c->h; c->h = wc.height = h;
 	wc.border_width = c->bw;
+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+	    && !c->isfullscreen && !c->isfloating) {
+        wc.width += c->bw * 2;
+        wc.height += c->bw * 2;
+		wc.border_width = 0;
+	}
 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
 	configure(c);
 	XSync(dpy, False);
@@ -1389,6 +1721,89 @@ run(void)
 			handler[ev.type](&ev); /* call handler */
 }
 
+//void
+//runautostart(void)
+//{
+//	char *pathpfx;
+//	char *path;
+//	char *xdgdatahome;
+//	char *home;
+//	struct stat sb;
+//
+//	if ((home = getenv("HOME")) == NULL)
+//		/* this is almost impossible */
+//		return;
+//
+//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+//	 * otherwise use ~/.local/share/dwm as autostart script directory
+//	 */
+//	xdgdatahome = getenv("XDG_DATA_HOME");
+//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+//
+//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	} else {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+//		                     + strlen(dwmdir) + 3);
+//
+//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* check if the autostart script directory exists */
+//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+//		/* the XDG conformant path does not exist or is no directory
+//		 * so we try ~/.dwm instead
+//		 */
+//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+//		if(pathpfx_new == NULL) {
+//			free(pathpfx);
+//			return;
+//		}
+//		pathpfx = pathpfx_new;
+//
+//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* try the blocking script first */
+//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(path);
+//
+//	/* now the non-blocking script */
+//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(strcat(path, " &"));
+//
+//	free(pathpfx);
+//	free(path);
+//}
+
+void
+runautostart(void)
+{
+    system("killall -q dwmblocks; dwmblocks &");
+}
+
 void
 scan(void)
 {
@@ -1432,6 +1847,25 @@ sendmon(Client *c, Monitor *m)
 	arrange(NULL);
 }
 
+void
+sendmonview(Client *c, Monitor *m)
+{
+    if (c->mon == m)
+        return;
+    unfocus(c, 1);
+    detach(c);
+    detachstack(c);
+    arrange(c->mon);
+    c->mon = m;
+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+    attach(c);
+    attachstack(c);
+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
+    arrange(m);
+    focus(c);
+    restack(m);
+}
+
 void
 setclientstate(Client *c, long state)
 {
@@ -1506,6 +1940,23 @@ setfullscreen(Client *c, int fullscreen)
 	}
 }
 
+void
+	 setsticky(Client *c, int sticky)
+	 {
+
+		 if(sticky && !c->issticky) {
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+			 c->issticky = 1;
+		 } else if(!sticky && c->issticky){
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *)0, 0);
+			 c->issticky = 0;
+			 arrange(c->mon);
+		 }
+	 }
+
+
 void
 setlayout(const Arg *arg)
 {
@@ -1520,6 +1971,206 @@ setlayout(const Arg *arg)
 		drawbar(selmon);
 }
 
+//void
+//shiftview(const Arg *arg) {
+//	Arg shifted;
+//
+//	if(arg->i > 0) /* left circular shift */
+//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+//
+//	else /* right circular shift */
+//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+//
+//	view(&shifted);
+//}
+//
+//void
+//shifttag(const Arg *arg) {
+//	Arg shifted;
+//	Client *c;
+//
+//	if (!selmon->sel)
+//		return;
+//	c = selmon->sel;
+//
+//	if (arg->i > 0) /* left circular shift */
+//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+//			^ (c->tags >> (LENGTH(tags) - arg->i));
+//	else /* right circular shift */
+//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+//			^ (c->tags << (LENGTH(tags) + arg->i));
+//
+//	toggletag(&shifted);
+//}
+
+// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
+// Or this (used below):
+// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
+
+/* Sends a window to the next/prev tag */
+void
+shifttag(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
+	tag(&shifted);
+}
+/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
+void
+shifttagclients(const Arg *arg)
+{
+
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	for (c = selmon->clients; c; c = c->next)
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	else		/* right circular shift */
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	tag(&shifted);
+}
+/* Navigate to the next/prev tag */
+void
+shiftview(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (arg->i > 0) {/* left circular shift */
+		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
+		shifted.ui &= ~SPTAGMASK;
+	} else {	/* right circular shift */
+		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
+		shifted.ui &= ~SPTAGMASK;
+	}
+	view(&shifted);
+}
+/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
+void
+shiftviewclients(const Arg *arg)
+{
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	for (c = selmon->clients; c; c = c->next)
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	else		/* right circular shift */
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	view(&shifted);
+}
+/* move the current active window to the next/prev tag and view it. More like following the window */
+void
+shiftboth(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+	tag(&shifted);
+	view(&shifted);
+}
+//helper function for shiftswaptags found on:
+//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
+// modified to work with scratchpad
+void
+swaptags(const Arg *arg)
+{
+	Client *c;
+	unsigned int newtag = arg->ui & TAGMASK;
+	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
+		return;
+
+	for (c = selmon->clients; c != NULL; c = c->next) {
+		if ((c->tags & newtag) || (c->tags & curtag))
+			c->tags ^= curtag ^ newtag;
+
+		if (!c->tags)
+			c->tags = newtag;
+	}
+
+	//move to the swaped tag
+	//selmon->tagset[selmon->seltags] = newtag;
+
+	focus(NULL);
+	arrange(selmon);
+}
+/* swaps "tags" (all the clients) with the next/prev tag. */
+void
+shiftswaptags(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+	swaptags(&shifted);
+	// uncomment if you also want to "go" (view) the tag where the the clients are going
+	//view(&shifted);
+}
+
+void
+setcfact(const Arg *arg) {
+	float f;
+	Client *c;
+
+	c = selmon->sel;
+
+	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f + c->cfact;
+	if(arg->f == 0.0)
+		f = 1.0;
+	else if(f < 0.25 || f > 4.0)
+		return;
+	c->cfact = f;
+	arrange(selmon);
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -1575,6 +2226,7 @@ setup(void)
 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
@@ -1583,7 +2235,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
@@ -1631,6 +2284,10 @@ showhide(Client *c)
 	if (!c)
 		return;
 	if (ISVISIBLE(c)) {
+		if ((c->tags & SPTAGMASK) && c->isfloating) {
+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+		}
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
@@ -1643,6 +2300,20 @@ showhide(Client *c)
 	}
 }
 
+void
+sigstatusbar(const Arg *arg)
+{
+	union sigval sv;
+
+	if (!statussig)
+		return;
+	sv.sival_int = arg->i;
+	if ((statuspid = getstatusbarpid()) <= 0)
+		return;
+
+	sigqueue(statuspid, SIGRTMIN+statussig, sv);
+}
+
 void
 spawn(const Arg *arg)
 {
@@ -1665,14 +2336,111 @@ spawn(const Arg *arg)
 	}
 }
 
+int
+stackpos(const Arg *arg) {
+	int n, i;
+	Client *c, *l;
+
+	if(!selmon->clients)
+		return -1;
+
+	if(arg->i == PREVSEL) {
+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+		if(!l)
+			return -1;
+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return i;
+	}
+	else if(ISINC(arg->i)) {
+		if(!selmon->sel)
+			return -1;
+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MOD(i + GETINC(arg->i), n);
+	}
+	else if(arg->i < 0) {
+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MAX(i + arg->i, 0);
+	}
+	else
+		return arg->i;
+}
+
+//void
+//tag(const Arg *arg)
+//{
+//    if (selmon->sel && arg->ui & TAGMASK) {
+//        if (mons && mons->next) {
+//            // Moving to even tag, selected mon != first mon
+//            if ((arg->ui & 341) == 0 && selmon != mons) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//                // Moving to odd tag, selected mon == first mon
+//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//            } else {
+//                tagnextmon(arg);
+//            }
+//        } else {
+//            if (selmon->sel && arg->ui & TAGMASK) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//            }
+//        }
+//    }
+//}
+
 void
 tag(const Arg *arg)
 {
-	if (selmon->sel && arg->ui & TAGMASK) {
-		selmon->sel->tags = arg->ui & TAGMASK;
-		focus(NULL);
-		arrange(selmon);
-	}
+    if (!(selmon->sel && arg->ui & TAGMASK))
+        return;
+
+    if (mons && mons->next) {
+        // Moving to even tag, selected mon != first mon
+        if ((arg->ui & 341) == 0 && selmon != mons) {
+            selmon->sel->tags = arg->ui & TAGMASK;
+        }
+        // Moving to odd tag, selected mon == first mon
+        else if ((arg->ui & 341) > 0 && selmon == mons) {
+            selmon->sel->tags = arg->ui & TAGMASK;
+        } else {
+            tagnextmon(arg);
+            return;
+        }
+    } else {
+        selmon->sel->tags = arg->ui & TAGMASK;
+    }
+
+    focus(NULL);
+    arrange(selmon);
+}
+
+void
+tagview(const Arg *arg)
+{
+    if (selmon->sel && arg->ui & TAGMASK) {
+        if (mons && mons->next) {
+            // If first monitor and moving to even tag (second mon)
+            if ((arg->ui & 341) == 0 && selmon == mons) {
+                tagnthmonview(&((Arg) { .i = 1 }));
+                tagnewmon(arg);
+                return;
+            } else if ((arg->ui & 341) > 0 && selmon != mons) {
+                tagnthmonview(&((Arg) { .i = 0 }));
+                tagnewmon(arg);
+                return;
+            }
+        }
+        selmon->sel->tags = arg->ui & TAGMASK;
+        focus(NULL);
+        arrange(selmon);
+        view(arg);
+    }
 }
 
 void
@@ -1684,31 +2452,56 @@ tagmon(const Arg *arg)
 }
 
 void
-tile(Monitor *m)
+tagmonview(const Arg *arg)
 {
-	unsigned int i, n, h, mw, my, ty;
-	Client *c;
+    if (!selmon->sel || !mons->next)
+        return;
+    sendmonview(selmon->sel, dirtomon(arg->i));
+}
 
-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
-		return;
+void
+tagnextmon(const Arg *arg)
+{
+    Client *sel;
+    Monitor *newmon;
 
-	if (n > m->nmaster)
-		mw = m->nmaster ? m->ww * m->mfact : 0;
-	else
-		mw = m->ww;
-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
-			if (my + HEIGHT(c) < m->wh)
-				my += HEIGHT(c);
-		} else {
-			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) < m->wh)
-				ty += HEIGHT(c);
-		}
+    if (!selmon->sel || !mons->next)
+        return;
+    sel = selmon->sel;
+    newmon = dirtomon(1);
+    sendmon(sel, newmon);
+    if (sel && arg->ui & TAGMASK) {
+        sel->tags = arg->ui & TAGMASK;
+        focus(NULL);
+        arrange(newmon);
+    }
+}
+
+void
+tagnewmon(const Arg *arg)
+{
+    if (selmon->sel && arg->ui & TAGMASK) {
+        selmon->sel->tags = arg->ui & TAGMASK;
+        focus(NULL);
+        arrange(selmon);
+        view(arg);
+    }
+}
+
+void
+tagnthmon(const Arg *arg)
+{
+    if (!selmon->sel || !mons->next)
+        return;
+    sendmon(selmon->sel, numtomon(arg->i));
+}
+
+void
+tagnthmonview(const Arg *arg)
+{
+    if (!selmon->sel || !mons->next)
+        return;
+    sendmonview(selmon->sel, numtomon(arg->i));
 }
 
 void
@@ -1720,6 +2513,18 @@ togglebar(const Arg *arg)
 	arrange(selmon);
 }
 
+void
+togglebars(const Arg *arg)
+{
+    Monitor *m;
+    for (m = mons; m; m = m->next) {
+        m->showbar = !m->showbar;
+        updatebarpos(m);
+        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+        arrange(m);
+    }
+}
+
 void
 togglefloating(const Arg *arg)
 {
@@ -1728,12 +2533,74 @@ togglefloating(const Arg *arg)
 	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
 		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+
 	if (selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
+		/* restore last known float dimensions */
+		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+		       selmon->sel->sfw, selmon->sel->sfh, False);
+	else {
+		/* save last known float dimensions */
+		selmon->sel->sfx = selmon->sel->x;
+		selmon->sel->sfy = selmon->sel->y;
+		selmon->sel->sfw = selmon->sel->w;
+		selmon->sel->sfh = selmon->sel->h;
+	}
+
+ 	//if (selmon->sel->isfloating)
+ 	//	resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+ 	//		//selmon->sel->w, selmon->sel->h, 0);
+ 	//		900, 600, 0);
+
+    if (!selmon->sel->sfx) {
+        selmon->sel->x = selmon->sel->mon->mx + (selmon->sel->mon->mw - WIDTH(selmon->sel)) / 2;
+        selmon->sel->y = selmon->sel->mon->my + (selmon->sel->mon->mh - HEIGHT(selmon->sel)) / 2;
+    }
+
 	arrange(selmon);
 }
 
+void
+togglefullscr(const Arg *arg)
+{
+  if(selmon->sel)
+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+}
+
+void
+togglesticky(const Arg *arg)
+{
+	if (!selmon->sel)
+		return;
+	setsticky(selmon->sel, !selmon->sel->issticky);
+	arrange(selmon);
+}
+
+void
+togglescratch(const Arg *arg)
+{
+	Client *c;
+	unsigned int found = 0;
+	unsigned int scratchtag = SPTAG(arg->ui);
+	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+
+	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+	if (found) {
+		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+		if (newtagset) {
+			selmon->tagset[selmon->seltags] = newtagset;
+			focus(NULL);
+			arrange(selmon);
+		}
+		if (ISVISIBLE(c)) {
+			focus(c);
+			restack(selmon);
+		}
+	} else {
+		selmon->tagset[selmon->seltags] |= scratchtag;
+		spawn(&sparg);
+	}
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -1780,6 +2647,20 @@ unmanage(Client *c, int destroyed)
 	Monitor *m = c->mon;
 	XWindowChanges wc;
 
+	if (c->swallowing) {
+		unswallow(c);
+		return;
+	}
+
+	Client *s = swallowingclient(c->win);
+	if (s) {
+		free(s->swallowing);
+		s->swallowing = NULL;
+		arrange(m);
+		focus(NULL);
+		return;
+	}
+
 	detach(c);
 	detachstack(c);
 	if (!destroyed) {
@@ -1795,9 +2676,12 @@ unmanage(Client *c, int destroyed)
 		XUngrabServer(dpy);
 	}
 	free(c);
-	focus(NULL);
-	updateclientlist();
-	arrange(m);
+
+	if (!s) {
+		arrange(m);
+		focus(NULL);
+		updateclientlist();
+	}
 }
 
 void
@@ -2026,6 +2910,9 @@ updatewindowtype(Client *c)
 
 	if (state == netatom[NetWMFullscreen])
 		setfullscreen(c, 1);
+	if (state == netatom[NetWMSticky]) {
+		setsticky(c, 1);
+	}
 	if (wtype == netatom[NetWMWindowTypeDialog])
 		c->isfloating = 1;
 }
@@ -2052,13 +2939,157 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-		return;
-	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-	focus(NULL);
-	arrange(selmon);
+    if (mons && mons->next) {
+        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+            return;
+
+        // GENIUS 101010101
+        if ((arg->ui & 341) == 0)
+            focusnthmon(&((Arg) { .i = 1 }));
+        else
+            focusnthmon(&((Arg) { .i = 0 }));
+    } else {
+        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
+            view(&((Arg) { .ui = 0 })); 
+            return; 
+        } 
+    }
+
+    selmon->seltags ^= 1; /* toggle sel tagset */
+    if (arg->ui & TAGMASK)
+        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+    focus(NULL);
+    arrange(selmon);
+}
+
+pid_t
+winpid(Window w)
+{
+
+	pid_t result = 0;
+
+#ifdef __linux__
+	xcb_res_client_id_spec_t spec = {0};
+	spec.client = w;
+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+
+	xcb_generic_error_t *e = NULL;
+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+
+	if (!r)
+		return (pid_t)0;
+
+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+		spec = i.data->spec;
+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+			uint32_t *t = xcb_res_client_id_value_value(i.data);
+			result = *t;
+			break;
+		}
+	}
+
+	free(r);
+
+	if (result == (pid_t)-1)
+		result = 0;
+
+#endif /* __linux__ */
+
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
+
+#endif /* __OpenBSD__ */
+	return result;
+}
+
+pid_t
+getparentprocess(pid_t p)
+{
+	unsigned int v = 0;
+
+#ifdef __linux__
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+
+	if (!(f = fopen(buf, "r")))
+		return 0;
+
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+#endif /* __linux__*/
+
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
+
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
+
+	return (pid_t)v;
+}
+
+int
+isdescprocess(pid_t p, pid_t c)
+{
+	while (p != c && c != 0)
+		c = getparentprocess(c);
+
+	return (int)c;
+}
+
+Client *
+termforwin(const Client *w)
+{
+	Client *c;
+	Monitor *m;
+
+	if (!w->pid || w->isterminal)
+		return NULL;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
+Client *
+swallowingclient(Window w)
+{
+	Client *c;
+	Monitor *m;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->swallowing && c->swallowing->win == w)
+				return c;
+		}
+	}
+
+	return NULL;
 }
 
 Client *
@@ -2139,6 +3170,60 @@ zoom(const Arg *arg)
 	pop(c);
 }
 
+void
+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+{
+	char *sdst = NULL;
+	int *idst = NULL;
+	float *fdst = NULL;
+
+	sdst = dst;
+	idst = dst;
+	fdst = dst;
+
+	char fullname[256];
+	char *type;
+	XrmValue ret;
+
+	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+	fullname[sizeof(fullname) - 1] = '\0';
+
+	XrmGetResource(db, fullname, "*", &type, &ret);
+	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+	{
+		switch (rtype) {
+		case STRING:
+			strcpy(sdst, ret.addr);
+			break;
+		case INTEGER:
+			*idst = strtoul(ret.addr, NULL, 10);
+			break;
+		case FLOAT:
+			*fdst = strtof(ret.addr, NULL);
+			break;
+		}
+	}
+}
+
+void
+load_xresources(void)
+{
+	Display *display;
+	char *resm;
+	XrmDatabase db;
+	ResourcePref *p;
+
+	display = XOpenDisplay(NULL);
+	resm = XResourceManagerString(display);
+	if (!resm)
+		return;
+
+	db = XrmGetStringDatabase(resm);
+	for (p = resources; p < resources + LENGTH(resources); p++)
+		resource_load(db, p->name, p->type, p->dst);
+	XCloseDisplay(display);
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -2150,15 +3235,22 @@ main(int argc, char *argv[])
 		fputs("warning: no locale support\n", stderr);
 	if (!(dpy = XOpenDisplay(NULL)))
 		die("dwm: cannot open display");
+	if (!(xcon = XGetXCBConnection(dpy)))
+		die("dwm: cannot get xcb connection\n");
 	checkotherwm();
+	XrmInitialize();
+	load_xresources();
 	setup();
 #ifdef __OpenBSD__
-	if (pledge("stdio rpath proc exec", NULL) == -1)
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
+	runautostart();
+    arrange(selmon);
 	run();
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
diff --git a/patches/dwm-6.0-smfact.diff b/patches/dwm-6.0-smfact.diff
new file mode 100644
index 0000000..2032ef0
--- /dev/null
+++ b/patches/dwm-6.0-smfact.diff
@@ -0,0 +1,117 @@
+--- config.def.h	2013-04-06 21:01:27.750829760 +0200
++++ config.def.h	2013-04-06 21:02:19.557495556 +0200
+@@ -10,6 +10,7 @@ static const char selbgcolor[]      = "#
+ static const char selfgcolor[]      = "#eeeeee";
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int minwsz    = 20;       /* Minimal heigt of a client for smfact */
+ static const Bool showbar           = True;     /* False means no bar */
+ static const Bool topbar            = True;     /* False means bottom bar */
+ 
+@@ -24,6 +25,7 @@ static const Rule rules[] = {
+ 
+ /* layout(s) */
+ static const float mfact      = 0.55; /* factor of master area size [0.05..0.95] */
++static const float smfact     = 0.00; /* factor of tiled clients [0.00..0.95] */
+ static const int nmaster      = 1;    /* number of clients in master area */
+ static const Bool resizehints = True; /* True means respect size hints in tiled resizals */
+ 
+@@ -60,6 +62,8 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setsmfact,      {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_l,      setsmfact,      {.f = -0.05} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+--- dwm.c	2011-12-19 16:02:46.000000000 +0100
++++ dwm.c	2013-04-06 21:00:46.620830452 +0200
+@@ -69,6 +69,7 @@ typedef union {
+ 	int i;
+ 	unsigned int ui;
+ 	float f;
++	float sf;
+ 	const void *v;
+ } Arg;
+ 
+@@ -127,6 +128,7 @@ typedef struct {
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
++	float smfact;
+ 	int nmaster;
+ 	int num;
+ 	int by;               /* bar geometry */
+@@ -220,6 +222,7 @@ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, Bool fullscreen);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
++static void setsmfact(const Arg *arg);
+ static void setup(void);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+@@ -651,6 +654,7 @@ createmon(void) {
+ 		die("fatal: could not malloc() %u bytes\n", sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
++	m->smfact = smfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
+@@ -1581,6 +1585,19 @@ setmfact(const Arg *arg) {
+ }
+ 
+ void
++setsmfact(const Arg *arg) {
++	float sf;
++
++	if(!arg || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	sf = arg->sf < 1.0 ? arg->sf + selmon->smfact : arg->sf - 1.0;
++	if(sf < 0 || sf > 0.9)
++		return;
++	selmon->smfact = sf;
++	arrange(selmon);
++}
++
++void
+ setup(void) {
+ 	XSetWindowAttributes wa;
+ 
+@@ -1703,7 +1720,7 @@ textnw(const char *text, unsigned int le
+ 
+ void
+ tile(Monitor *m) {
+-	unsigned int i, n, h, mw, my, ty;
++	unsigned int i, n, h, smh, mw, my, ty;
+ 	Client *c;
+ 
+ 	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+@@ -1721,9 +1738,23 @@ tile(Monitor *m) {
+ 			my += HEIGHT(c);
+ 		}
+ 		else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+-			ty += HEIGHT(c);
++			smh = m->mh * m->smfact;
++			if(!(nexttiled(c->next)))
++				h = (m->wh - ty) / (n - i);
++			else
++				h = (m->wh - smh - ty) / (n - i);
++			if(h < minwsz) {
++				c->isfloating = True;
++				XRaiseWindow(dpy, c->win);
++				resize(c, m->mx + (m->mw / 2 - WIDTH(c) / 2), m->my + (m->mh / 2 - HEIGHT(c) / 2), m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++				ty -= HEIGHT(c);
++			}
++			else
++				resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
++			if(!(nexttiled(c->next)))
++				ty += HEIGHT(c) + smh;
++			else
++				ty += HEIGHT(c);
+ 		}
+ }
+ 
diff --git a/patches/dwm-actualfullscreen-20211013-cb3f58a.diff b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
new file mode 100644
index 0000000..d3be230
--- /dev/null
+++ b/patches/dwm-actualfullscreen-20211013-cb3f58a.diff
@@ -0,0 +1,68 @@
+From eea13010ffc3983392857ee1e3804e3aa1064d7a Mon Sep 17 00:00:00 2001
+From: Soenke Lambert <s.lambert@mittwald.de>
+Date: Wed, 13 Oct 2021 18:21:09 +0200
+Subject: [PATCH] Fullscreen current window with [Alt]+[Shift]+[f]
+
+This actually fullscreens a window, instead of just hiding the statusbar
+and applying the monocle layout.
+---
+ config.def.h | 1 +
+ dwm.1        | 3 +++
+ dwm.c        | 8 ++++++++
+ 3 files changed, 12 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..8cd3204 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -78,6 +78,7 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..a368d05 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+ .B Mod1\-Shift\-c
+ Close focused window.
+ .TP
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
++.TP
+ .B Mod1\-Shift\-space
+ Toggle focused window between tiled and floating state.
+ .TP
+diff --git a/dwm.c b/dwm.c
+index 4465af1..c1b899a 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -211,6 +211,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -1719,6 +1720,13 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+-- 
+2.30.2
+
diff --git a/patches/dwm-alpha-20230401-348f655.diff b/patches/dwm-alpha-20230401-348f655.diff
new file mode 100644
index 0000000..c948f04
--- /dev/null
+++ b/patches/dwm-alpha-20230401-348f655.diff
@@ -0,0 +1,288 @@
+From ad5887df95fda706291c81ee143d0786a1717b12 Mon Sep 17 00:00:00 2001
+From: getimiskon <getimiskon@disroot.org>
+Date: Sat, 1 Apr 2023 16:22:01 +0300
+Subject: [PATCH] Allow dwm to have translucent bars, while keeping all the
+ text on it opaque, just like the alpha-patch for st. Updated for 348f655.
+
+---
+ config.def.h |  7 +++++++
+ config.mk    |  2 +-
+ drw.c        | 26 ++++++++++++-----------
+ drw.h        |  9 +++++---
+ dwm.c        | 59 ++++++++++++++++++++++++++++++++++++++++++++++------
+ 5 files changed, 81 insertions(+), 22 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 9efa774..8b3789a 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -12,11 +12,18 @@ static const char col_gray2[]       = "#444444";
+ static const char col_gray3[]       = "#bbbbbb";
+ static const char col_gray4[]       = "#eeeeee";
+ static const char col_cyan[]        = "#005577";
++static const unsigned int baralpha = 0xd0;
++static const unsigned int borderalpha = OPAQUE;
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ };
++static const unsigned int alphas[][3]      = {
++    /*               fg      bg        border*/
++    [SchemeNorm] = { OPAQUE, baralpha, borderalpha },
++	[SchemeSel]  = { OPAQUE, baralpha, borderalpha },
++};
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+diff --git a/config.mk b/config.mk
+index ba64d3d..d609c42 100644
+--- a/config.mk
++++ b/config.mk
+@@ -23,7 +23,7 @@ FREETYPEINC = /usr/include/freetype2
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lXrender
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/drw.c b/drw.c
+index a58a2b4..d18e8d8 100644
+--- a/drw.c
++++ b/drw.c
+@@ -61,7 +61,7 @@ utf8decode(const char *c, long *u, size_t clen)
+ }
+ 
+ Drw *
+-drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
++drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap)
+ {
+ 	Drw *drw = ecalloc(1, sizeof(Drw));
+ 
+@@ -70,8 +70,11 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
+ 	drw->root = root;
+ 	drw->w = w;
+ 	drw->h = h;
+-	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+-	drw->gc = XCreateGC(dpy, root, 0, NULL);
++	drw->visual = visual;
++	drw->depth = depth;
++	drw->cmap = cmap;
++	drw->drawable = XCreatePixmap(dpy, root, w, h, depth);
++	drw->gc = XCreateGC(dpy, drw->drawable, 0, NULL);
+ 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+ 
+ 	return drw;
+@@ -87,7 +90,7 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
+ 	drw->h = h;
+ 	if (drw->drawable)
+ 		XFreePixmap(drw->dpy, drw->drawable);
+-	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
++	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, drw->depth);
+ }
+ 
+ void
+@@ -181,21 +184,22 @@ drw_fontset_free(Fnt *font)
+ }
+ 
+ void
+-drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
++drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha)
+ {
+ 	if (!drw || !dest || !clrname)
+ 		return;
+ 
+-	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+-	                       DefaultColormap(drw->dpy, drw->screen),
++	if (!XftColorAllocName(drw->dpy, drw->visual, drw->cmap,
+ 	                       clrname, dest))
+ 		die("error, cannot allocate color '%s'", clrname);
++
++    dest->pixel = (dest->pixel & 0x00ffffffU) | (alpha << 24);
+ }
+ 
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+@@ -205,7 +209,7 @@ drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+ 		return NULL;
+ 
+ 	for (i = 0; i < clrcount; i++)
+-		drw_clr_create(drw, &ret[i], clrnames[i]);
++		drw_clr_create(drw, &ret[i], clrnames[i], alphas[i]);
+ 	return ret;
+ }
+ 
+@@ -263,9 +267,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
+ 	} else {
+ 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+ 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+-		d = XftDrawCreate(drw->dpy, drw->drawable,
+-		                  DefaultVisual(drw->dpy, drw->screen),
+-		                  DefaultColormap(drw->dpy, drw->screen));
++		d = XftDrawCreate(drw->dpy, drw->drawable, drw->visual, drw->cmap);
+ 		x += lpad;
+ 		w -= lpad;
+ 	}
+diff --git a/drw.h b/drw.h
+index 6471431..2143533 100644
+--- a/drw.h
++++ b/drw.h
+@@ -20,6 +20,9 @@ typedef struct {
+ 	Display *dpy;
+ 	int screen;
+ 	Window root;
++    Visual *visual;
++    unsigned int depth;
++    Colormap cmap;
+ 	Drawable drawable;
+ 	GC gc;
+ 	Clr *scheme;
+@@ -27,7 +30,7 @@ typedef struct {
+ } Drw;
+ 
+ /* Drawable abstraction */
+-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
++Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h, Visual *visual, unsigned int depth, Colormap cmap);
+ void drw_resize(Drw *drw, unsigned int w, unsigned int h);
+ void drw_free(Drw *drw);
+ 
+@@ -39,8 +42,8 @@ unsigned int drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int
+ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
+ 
+ /* Colorscheme abstraction */
+-void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++void drw_clr_create(Drw *drw, Clr *dest, const char *clrname, unsigned int alpha);
++Clr *drw_scm_create(Drw *drw, const char *clrnames[], const unsigned int alphas[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index c2bd871..3b34de8 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -56,6 +56,7 @@
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define OPAQUE                  0xffU
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -232,6 +233,7 @@ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++static void xinitvisual();
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
+@@ -268,6 +270,11 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static int useargb = 0;
++static Visual *visual;
++static int depth;
++static Colormap cmap;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -1558,7 +1565,8 @@ setup(void)
+ 	sw = DisplayWidth(dpy, screen);
+ 	sh = DisplayHeight(dpy, screen);
+ 	root = RootWindow(dpy, screen);
+-	drw = drw_create(dpy, screen, root, sw, sh);
++	xinitvisual();
++	drw = drw_create(dpy, screen, root, sw, sh, visual, depth, cmap);
+ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+ 		die("no fonts could be loaded.");
+ 	lrpad = drw->fonts->h;
+@@ -1586,7 +1594,7 @@ setup(void)
+ 	/* init appearance */
+ 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+ 	for (i = 0; i < LENGTH(colors); i++)
+-		scheme[i] = drw_scm_create(drw, colors[i], 3);
++		scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 3);
+ 	/* init bars */
+ 	updatebars();
+ 	updatestatus();
+@@ -1813,16 +1821,18 @@ updatebars(void)
+ 	Monitor *m;
+ 	XSetWindowAttributes wa = {
+ 		.override_redirect = True,
+-		.background_pixmap = ParentRelative,
++		.background_pixel = 0,
++		.border_pixel = 0,
++		.colormap = cmap,
+ 		.event_mask = ButtonPressMask|ExposureMask
+ 	};
+ 	XClassHint ch = {"dwm", "dwm"};
+ 	for (m = mons; m; m = m->next) {
+ 		if (m->barwin)
+ 			continue;
+-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+-				CopyFromParent, DefaultVisual(dpy, screen),
+-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, depth,
++				InputOutput, visual,
++				CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
+ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+ 		XMapRaised(dpy, m->barwin);
+ 		XSetClassHint(dpy, m->barwin, &ch);
+@@ -2120,6 +2130,43 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
+ 	return -1;
+ }
+ 
++void
++xinitvisual()
++{
++    XVisualInfo *infos;
++	XRenderPictFormat *fmt;
++	int nitems;
++	int i;
++
++	XVisualInfo tpl = {
++        .screen = screen,
++		.depth = 32,
++		.class = TrueColor
++	};
++	long masks = VisualScreenMask | VisualDepthMask | VisualClassMask;
++
++	infos = XGetVisualInfo(dpy, masks, &tpl, &nitems);
++	visual = NULL;
++	for(i = 0; i < nitems; i ++) {
++        fmt = XRenderFindVisualFormat(dpy, infos[i].visual);
++		if (fmt->type == PictTypeDirect && fmt->direct.alphaMask) {
++            visual = infos[i].visual;
++			depth = infos[i].depth;
++			cmap = XCreateColormap(dpy, root, visual, AllocNone);
++			useargb = 1;
++			break;
++        }
++    }
++
++	XFree(infos);
++
++	if (! visual) {
++        visual = DefaultVisual(dpy, screen);
++		depth = DefaultDepth(dpy, screen);
++		cmap = DefaultColormap(dpy, screen);
++    }
++}
++
+ void
+ zoom(const Arg *arg)
+ {
+-- 
+2.40.0
+
diff --git a/patches/dwm-autostart-20210120-cb3f58a.diff b/patches/dwm-autostart-20210120-cb3f58a.diff
new file mode 100644
index 0000000..efee676
--- /dev/null
+++ b/patches/dwm-autostart-20210120-cb3f58a.diff
@@ -0,0 +1,179 @@
+From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
+From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
+Date: Wed, 10 Jun 2020 10:59:02 +0000
+Subject: [PATCH] dwm-xdgautostart-6.2.diff
+
+===================================================================
+---
+ dwm.1 | 23 +++++++++++++++++
+ dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 105 insertions(+)
+
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..9533aa6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 4465af1..2156b49 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
+ static char stext[256];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+@@ -1380,6 +1386,83 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++		pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
+ void
+ scan(void)
+ {
+@@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+-- 
+2.27.0
+
diff --git a/patches/dwm-cfacts-vanitygaps-6.4_combo.diff b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
new file mode 100644
index 0000000..db2cc14
--- /dev/null
+++ b/patches/dwm-cfacts-vanitygaps-6.4_combo.diff
@@ -0,0 +1,1018 @@
+diff --git a/config.def.h b/config.def.h
+index 9efa774..357dc6f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,11 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+@@ -71,7 +91,26 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+diff --git a/dwm.c b/dwm.c
+index f1d86b2..5bbd733 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -87,6 +87,7 @@ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
++	float cfact;
+ 	int x, y, w, h;
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+@@ -119,6 +120,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -201,6 +206,7 @@ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+@@ -208,7 +214,6 @@ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -641,6 +646,10 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -1043,6 +1052,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+@@ -1521,6 +1531,24 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
++}
++
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+@@ -1684,34 +1712,6 @@ tagmon(const Arg *arg)
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
+-void
+-tile(Monitor *m)
+-{
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
+-
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
+-
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
+-}
+-
+ void
+ togglebar(const Arg *arg)
+ {
+diff --git a/vanitygaps.c b/vanitygaps.c
+new file mode 100644
+index 0000000..1a816b6
+--- /dev/null
++++ b/vanitygaps.c
+@@ -0,0 +1,822 @@
++/* Key binding functions */
++static void defaultgaps(const Arg *arg);
++static void incrgaps(const Arg *arg);
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
++static void togglegaps(const Arg *arg);
++/* Layouts (delete the ones you do not need) */
++static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
++static void centeredmaster(Monitor *m);
++static void centeredfloatingmaster(Monitor *m);
++static void deck(Monitor *m);
++static void dwindle(Monitor *m);
++static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
++static void spiral(Monitor *m);
++static void tile(Monitor *m);
++/* Internals */
++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++static void setgaps(int oh, int ov, int ih, int iv);
++
++/* Settings */
++#if !PERTAG_PATCH
++static int enablegaps = 1;
++#endif // PERTAG_PATCH
++
++void
++setgaps(int oh, int ov, int ih, int iv)
++{
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
++}
++
++void
++togglegaps(const Arg *arg)
++{
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
++}
++
++void
++defaultgaps(const Arg *arg)
++{
++	setgaps(gappoh, gappov, gappih, gappiv);
++}
++
++void
++incrgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++{
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
++
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
++}
++
++void
++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++{
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++}
++
++/***
++ * Layouts
++ */
++
++/*
++ * Bottomstack layout + gaps
++ * https://dwm.suckless.org/patches/bottomstack/
++ */
++static void
++bstack(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
++
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
++}
++
++/*
++ * Centred master layout + gaps
++ * https://dwm.suckless.org/patches/centeredmaster/
++ */
++void
++centeredmaster(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
++}
++
++void
++centeredfloatingmaster(Monitor *m)
++{
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * Deck layout + gaps
++ * https://dwm.suckless.org/patches/deck/
++ */
++void
++deck(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
++}
++
++/*
++ * Fibonacci layout + gaps
++ * https://dwm.suckless.org/patches/fibonacci/
++ */
++void
++fibonacci(Monitor *m, int s)
++{
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
++}
++
++void
++dwindle(Monitor *m)
++{
++	fibonacci(m, 1);
++}
++
++void
++spiral(Monitor *m)
++{
++	fibonacci(m, 0);
++}
++
++/*
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
++ */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
++
++/*
++ * Default tile layout + gaps
++ */
++static void
++tile(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++}
+\ No newline at end of file
diff --git a/patches/dwm-focusonclick-20200110-61bb8b2.diff b/patches/dwm-focusonclick-20200110-61bb8b2.diff
new file mode 100644
index 0000000..59c7a1d
--- /dev/null
+++ b/patches/dwm-focusonclick-20200110-61bb8b2.diff
@@ -0,0 +1,130 @@
+From 7ac0b812540e21b470f2f6947c6cc1e30bf24b42 Mon Sep 17 00:00:00 2001
+From: iofq <cjriddz@protonmail.com>
+Date: Sun, 10 Jan 2021 22:43:16 -0600
+Subject: [PATCH] tweak fixes floating window mouse controls
+
+---
+ config.def.h |  1 +
+ dwm.c        | 47 ++++-------------------------------------------
+ 2 files changed, 5 insertions(+), 43 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..4f2c946 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -5,6 +5,7 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ static const char *fonts[]          = { "monospace:size=10" };
+ static const char dmenufont[]       = "monospace:size=10";
+ static const char col_gray1[]       = "#222222";
+diff --git a/dwm.c b/dwm.c
+index 664c527..de3e883 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,7 +163,6 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+-static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+@@ -182,7 +181,6 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+@@ -250,13 +248,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+-	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+-	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+@@ -425,7 +421,8 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+@@ -445,8 +442,8 @@ buttonpress(XEvent *e)
+ 		else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+-		focus(c);
+-		restack(selmon);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -752,25 +749,6 @@ drawbars(void)
+ 		drawbar(m);
+ }
+ 
+-void
+-enternotify(XEvent *e)
+-{
+-	Client *c;
+-	Monitor *m;
+-	XCrossingEvent *ev = &e->xcrossing;
+-
+-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+-		return;
+-	c = wintoclient(ev->window);
+-	m = c ? c->mon : wintomon(ev->window);
+-	if (m != selmon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-	} else if (!c || c == selmon->sel)
+-		return;
+-	focus(c);
+-}
+-
+ void
+ expose(XEvent *e)
+ {
+@@ -1116,23 +1094,6 @@ monocle(Monitor *m)
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+-void
+-motionnotify(XEvent *e)
+-{
+-	static Monitor *mon = NULL;
+-	Monitor *m;
+-	XMotionEvent *ev = &e->xmotion;
+-
+-	if (ev->window != root)
+-		return;
+-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-		focus(NULL);
+-	}
+-	mon = m;
+-}
+-
+ void
+ movemouse(const Arg *arg)
+ {
+-- 
+2.30.0
+
diff --git a/patches/dwm-hide_vacant_tags-6.4.diff b/patches/dwm-hide_vacant_tags-6.4.diff
new file mode 100644
index 0000000..42d9c05
--- /dev/null
+++ b/patches/dwm-hide_vacant_tags-6.4.diff
@@ -0,0 +1,48 @@
+:100644 100644 f1d86b2 0000000 M	dwm.c
+
+diff --git a/dwm.c b/dwm.c
+index f1d86b2..d41cc14 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -433,9 +433,15 @@ buttonpress(XEvent *e)
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+-		do
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
+ 			x += TEXTW(tags[i]);
+-		while (ev->x >= x && ++i < LENGTH(tags));
++		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+@@ -715,19 +721,18 @@ drawbar(Monitor *m)
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-		occ |= c->tags;
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-		if (occ & 1 << i)
+-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+-				urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = TEXTW(m->ltsymbol);
diff --git a/patches/dwm-noborder-6.2.diff b/patches/dwm-noborder-6.2.diff
new file mode 100644
index 0000000..f381eb8
--- /dev/null
+++ b/patches/dwm-noborder-6.2.diff
@@ -0,0 +1,30 @@
+From 9102fdb9c670218373bbe83c891c8e8138d6a6f4 Mon Sep 17 00:00:00 2001
+From: redacted <redacted@example.com>
+Date: Tue, 23 Apr 2019 00:39:27 +0100
+Subject: [PATCH] added noborder patch
+
+---
+ dwm.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/dwm.c b/dwm.c
+index 4465af1..685eca1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -1282,6 +1282,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
+-- 
+2.21.0
+
diff --git a/patches/dwm-notitle-20210715-138b405.diff b/patches/dwm-notitle-20210715-138b405.diff
new file mode 100644
index 0000000..bc8a3e5
--- /dev/null
+++ b/patches/dwm-notitle-20210715-138b405.diff
@@ -0,0 +1,81 @@
+From a3a7e94f59553689656871a65ea9ce90169a7c91 Mon Sep 17 00:00:00 2001
+From: birdalicous <jack.bird@durham.ac.uk>
+Date: Thu, 15 Jul 2021 12:28:29 +0100
+Subject: [PATCH] notitle patch applied#
+
+---
+ config.def.h |  1 -
+ dwm.c        | 20 ++++----------------
+ 2 files changed, 4 insertions(+), 17 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..eac20b4 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -103,7 +103,6 @@ static Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..6cd9fb7 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -64,8 +64,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -440,10 +440,8 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+ 		else
+-			click = ClkWinTitle;
++			click = ClkStatusText;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -730,15 +728,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -1236,11 +1227,8 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
+-- 
+2.32.0
+
diff --git a/patches/dwm-savefloats-20181212-b69c870.diff b/patches/dwm-savefloats-20181212-b69c870.diff
new file mode 100644
index 0000000..f5d8ed8
--- /dev/null
+++ b/patches/dwm-savefloats-20181212-b69c870.diff
@@ -0,0 +1,42 @@
+diff --git i/dwm.c w/dwm.c
+index 4465af1..96b0b26 100644
+--- i/dwm.c
++++ w/dwm.c
+@@ -88,6 +88,7 @@ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
+ 	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+ 	int bw, oldbw;
+@@ -1056,6 +1057,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -1714,8 +1719,16 @@ togglefloating(const Arg *arg)
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
+ 	arrange(selmon);
+ }
+ 
diff --git a/patches/dwm-scratchpads-20200414-728d397b.diff b/patches/dwm-scratchpads-20200414-728d397b.diff
new file mode 100644
index 0000000..d3e90c0
--- /dev/null
+++ b/patches/dwm-scratchpads-20200414-728d397b.diff
@@ -0,0 +1,199 @@
+From 728d397b21982af88737277fd9d6939a7b558786 Mon Sep 17 00:00:00 2001
+From: Christian Tenllado <ctenllado@gmail.com>
+Date: Tue, 14 Apr 2020 23:31:15 +0200
+Subject: [PATCH] Multiple scratchpads
+
+This patch enables multiple scratchpads, each with one asigned window.
+This enables the same scratchpad workflow that you have in i3.
+
+Scratchpads are implemented as special tags, whose mask does not
+apply to new spawned windows. To assign a window to a scratchpad you
+have to set up a rule, as you do with regular tags.
+
+Windows tagged with scratchpad tags can be set floating or not in the
+rules array. Most users would probably want them floating (i3 style),
+but having them tiled does also perfectly work and might fit better the
+DWM approach. In case they are set floating, the patch moves them to the
+center of the screen whenever they are shown. The patch can easily be
+modified to make this last feature configurable in the rules array (see
+the center patch).
+
+The togglescratch function, borrowed from the previous scratchpad patch
+and slightly modified, can be used to spawn a registered scratchpad
+process or toggle its view. This function looks for a window tagged with
+the selected scratchpad tag. If it is found its view is toggled. If it is
+not found the corresponding registered command is spawned. The
+config.def.h shows three examples of its use to spawn a terminal in the
+first scratchpad tag, a second terminal running ranger on the second
+scratchpad tag and the keepassxc application to manage passwords on a
+third scratchpad tag.
+
+If you prefer to spawn your scratchpad applications from the startup
+script, you might opt for binding keys to toggleview instead, as
+scratchpads are just special tags (you may even extend the TAGKEYS macro
+to generalize the key bindings).
+---
+ config.def.h | 28 ++++++++++++++++++++++++----
+ dwm.c        | 43 +++++++++++++++++++++++++++++++++++++++++--
+ 2 files changed, 65 insertions(+), 6 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..06265e1 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -18,17 +18,33 @@ static const char *colors[][3]      = {
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ };
+ 
++typedef struct {
++	const char *name;
++	const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++const char *spcmd3[] = {"keepassxc", NULL };
++static Sp scratchpads[] = {
++	/* name          cmd  */
++	{"spterm",      spcmd1},
++	{"spranger",    spcmd2},
++	{"keepassxc",   spcmd3},
++};
++
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+-
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	{ "Gimp",	  NULL,			NULL,		0,				1,			 -1 },
++	{ "Firefox",  NULL,			NULL,		1 << 8,			0,			 -1 },
++	{ NULL,		  "spterm",		NULL,		SPTAG(0),		1,			 -1 },
++	{ NULL,		  "spfm",		NULL,		SPTAG(1),		1,			 -1 },
++	{ NULL,		  "keepassxc",	NULL,		SPTAG(2),		0,			 -1 },
+ };
+ 
+ /* layout(s) */
+@@ -59,6 +75,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++
+ static Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+@@ -84,6 +101,9 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+@@ -106,7 +126,7 @@ static Button buttons[] = {
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+diff --git a/dwm.c b/dwm.c
+index 4465af1..646aa1a 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -54,7 +54,10 @@
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ 
+ /* enums */
+@@ -211,6 +214,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglescratch(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -299,6 +303,11 @@ applyrules(Client *c)
+ 		{
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+@@ -308,7 +317,7 @@ applyrules(Client *c)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+@@ -1616,6 +1625,10 @@ showhide(Client *c)
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+@@ -1719,6 +1732,32 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglescratch(const Arg *arg)
++{
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+-- 
+2.20.1
+
diff --git a/patches/dwm-stacker-6.2.diff b/patches/dwm-stacker-6.2.diff
new file mode 100644
index 0000000..8fe3b80
--- /dev/null
+++ b/patches/dwm-stacker-6.2.diff
@@ -0,0 +1,197 @@
+From d04f2d00688c8b0969d4f10f460c980dd91dac37 Mon Sep 17 00:00:00 2001
+From: MLquest8 <miskuzius@gmail.com>
+Date: Fri, 12 Jun 2020 16:04:18 +0400
+Subject: [PATCH] stacker updated for version 6.2
+
+---
+ config.def.h | 14 +++++++--
+ dwm.c        | 88 ++++++++++++++++++++++++++++++++++++++++------------
+ 2 files changed, 80 insertions(+), 22 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..d28f8fc 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -50,6 +50,14 @@ static const Layout layouts[] = {
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++#define STACKKEYS(MOD,ACTION) \
++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+@@ -64,8 +72,8 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++	STACKKEYS(MODKEY,                          focus)
++	STACKKEYS(MODKEY|ShiftMask,                push)
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+@@ -93,7 +101,7 @@ static Key keys[] = {
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 9fd0286..6c302c3 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -47,15 +47,21 @@
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define GETINC(X)               ((X) - 2000)
++#define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define PREVSEL                 3000
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -187,6 +193,7 @@ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+ static void propertynotify(XEvent *e);
++static void pushstack(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -207,6 +214,7 @@ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
++static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+@@ -833,27 +841,16 @@ focusmon(const Arg *arg)
+ void
+ focusstack(const Arg *arg)
+ {
+-	Client *c = NULL, *i;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-	if (!selmon->sel)
++	if(i < 0)
+ 		return;
+-	if (arg->i > 0) {
+-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+-		if (!c)
+-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+-	} else {
+-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+-			if (ISVISIBLE(i))
+-				c = i;
+-		if (!c)
+-			for (; i; i = i->next)
+-				if (ISVISIBLE(i))
+-					c = i;
+-	}
+-	if (c) {
+-		focus(c);
+-		restack(selmon);
+-	}
++
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+@@ -1246,6 +1243,29 @@ propertynotify(XEvent *e)
+ 	}
+ }
+ 
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -1653,6 +1673,36 @@ spawn(const Arg *arg)
+ 	}
+ }
+ 
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
+ void
+ tag(const Arg *arg)
+ {
+-- 
+2.26.2
+
diff --git a/patches/dwm-status2d-6.3.diff b/patches/dwm-status2d-6.3.diff
new file mode 100644
index 0000000..52bf58d
--- /dev/null
+++ b/patches/dwm-status2d-6.3.diff
@@ -0,0 +1,166 @@
+diff --git a/dwm.c b/dwm.c
+index a96f33c..24b1eeb 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,6 +163,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -485,7 +486,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+@@ -693,6 +694,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -707,9 +816,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1571,7 +1678,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
diff --git a/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
new file mode 100644
index 0000000..4adb383
--- /dev/null
+++ b/patches/dwm-statuscmd-status2d-20210405-60bb3df.diff
@@ -0,0 +1,188 @@
+From 05f9b3c45d4267d52724b2a76f333ba00353cab3 Mon Sep 17 00:00:00 2001
+From: Daniel Bylinka <daniel.bylinka@gmail.com>
+Date: Fri, 2 Apr 2021 19:04:58 +0200
+Subject: [PATCH] [statuscmd] status2d compatibility
+
+---
+ config.def.h |  6 +++-
+ dwm.c        | 83 ++++++++++++++++++++++++++++++++++++++++++++++++----
+ 2 files changed, 83 insertions(+), 6 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..154a59b 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -54,6 +54,8 @@ static const Layout layouts[] = {
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+@@ -103,7 +105,9 @@ static Button buttons[] = {
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+diff --git a/dwm.c b/dwm.c
+index acbe6c9..ba478b9 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -173,6 +173,7 @@ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -207,6 +208,7 @@ static void setup(void);
+ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+@@ -239,6 +241,9 @@ static void zoom(const Arg *arg);
+ /* variables */
+ static const char broken[] = "broken";
+ static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -441,9 +446,34 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++		else if (ev->x > selmon->ww - statusw) {
++			x = selmon->ww - statusw;
+ 			click = ClkStatusText;
+-		else
++
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
++		} else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+@@ -696,7 +726,7 @@ dirtomon(int dir)
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+-	int ret, i, w, x, len;
++	int ret, i, j, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+@@ -705,7 +735,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+-	memcpy(text, stext, len);
++
++	i = -1, j = 0;
++	while (stext[++i])
++		if ((unsigned char)stext[i] >= ' ')
++			text[j++] = stext[i];
++	text[j] = '\0';
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+@@ -813,7 +848,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		tw = m->ww - drawstatusbar(m, bh, stext);
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -979,6 +1014,30 @@ getatomprop(Client *c, Atom prop)
+ 	return atom;
+ }
+ 
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
++}
++
+ int
+ getrootptr(int *x, int *y)
+ {
+@@ -1745,6 +1804,20 @@ sigchld(int unused)
+ 	while (0 < waitpid(-1, NULL, WNOHANG));
+ }
+ 
++void
++sigstatusbar(const Arg *arg)
++{
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++}
++
+ void
+ spawn(const Arg *arg)
+ {
+-- 
+2.31.0
+
diff --git a/patches/dwm-sticky-20240927-60f7034.diff b/patches/dwm-sticky-20240927-60f7034.diff
new file mode 100644
index 0000000..055d019
--- /dev/null
+++ b/patches/dwm-sticky-20240927-60f7034.diff
@@ -0,0 +1,146 @@
+From 60f7034ca1573e10cf9e005e2ef5a44e6b76ea9b Mon Sep 17 00:00:00 2001
+From: elbachir-one <bachiralfa@gmail.com>
+Date: Fri, 27 Sep 2024 12:35:36 +0100
+Subject: [PATCH] Added the missing keybinding
+
+---
+ config.def.h |  1 +
+ dwm.c        | 43 ++++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 41 insertions(+), 3 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 9efa774..55c0a6c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -95,6 +95,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 67c6b2b..e8ed755 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -49,7 +49,7 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+@@ -61,7 +61,7 @@
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+@@ -92,7 +92,7 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -200,6 +200,7 @@ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+@@ -211,6 +212,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglesticky(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -525,6 +527,10 @@ clientmessage(XEvent *e)
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -1507,6 +1513,23 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1576,6 +1599,7 @@ setup(void)
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+@@ -1735,6 +1759,15 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglesticky(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
++	arrange(selmon);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+@@ -2027,6 +2060,9 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+@@ -2163,3 +2199,4 @@ main(int argc, char *argv[])
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
++
+-- 
+2.46.0
+
diff --git a/patches/dwm-swallow-6.3.diff b/patches/dwm-swallow-6.3.diff
new file mode 100644
index 0000000..47586a0
--- /dev/null
+++ b/patches/dwm-swallow-6.3.diff
@@ -0,0 +1,412 @@
+From 0cf9a007511f7dfd7dd94171b172562ebac9b6d5 Mon Sep 17 00:00:00 2001
+From: Tom Schwindl <schwindl@posteo.de>
+Date: Sat, 10 Sep 2022 12:51:09 +0200
+Subject: [PATCH] 6.3 swallow patch
+
+---
+ config.def.h |   9 +-
+ config.mk    |   3 +-
+ dwm.c        | 235 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ 3 files changed, 237 insertions(+), 10 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 061ad662f82a..0b2b8ffd30d5 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,7 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -26,9 +27,11 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+diff --git a/config.mk b/config.mk
+index 81c493ef4aff..52d1ebf30bec 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/dwm.c b/dwm.c
+index e5efb6a22806..e68294b6b679 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -40,6 +40,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -92,9 +98,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++	pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++	Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -138,6 +146,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -235,6 +245,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
+ static const char broken[] = "broken";
+ static char stext[256];
+@@ -269,6 +285,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -298,6 +316,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -416,6 +436,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -656,6 +723,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -1022,12 +1092,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1042,6 +1113,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1076,6 +1148,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -1763,6 +1837,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -1778,9 +1866,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2044,6 +2135,136 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2133,10 +2354,12 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
+-- 
+2.37.2
+
diff --git a/patches/dwm-tagshift-6.3.diff b/patches/dwm-tagshift-6.3.diff
new file mode 100644
index 0000000..fb4d1d7
--- /dev/null
+++ b/patches/dwm-tagshift-6.3.diff
@@ -0,0 +1,69 @@
+diff --git a/config.def.h b/config.def.h
+index a2ac963..1bbede2 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -69,6 +69,10 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+diff --git a/dwm.c b/dwm.c
+index a96f33c..4bf0f70 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -204,6 +204,8 @@ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shiftview(const Arg *arg);
++static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+@@ -1632,6 +1634,40 @@ showhide(Client *c)
+ 	}
+ }
+ 
++void
++shiftview(const Arg *arg) {
++	Arg shifted;
++
++	if(arg->i > 0) /* left circular shift */
++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++
++	else /* right circular shift */
++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++
++	view(&shifted);
++}
++
++void
++shifttag(const Arg *arg) {
++	Arg shifted;
++	Client *c;
++
++	if (!selmon->sel)
++		return;
++	c = selmon->sel;
++
++	if (arg->i > 0) /* left circular shift */
++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++			^ (c->tags >> (LENGTH(tags) - arg->i));
++	else /* right circular shift */
++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++			^ (c->tags << (LENGTH(tags) + arg->i));
++
++	toggletag(&shifted);
++}
++
+ void
+ sigchld(int unused)
+ {
diff --git a/patches/dwm-togglefloatingcenter-20210806-138b405f.diff b/patches/dwm-togglefloatingcenter-20210806-138b405f.diff
new file mode 100644
index 0000000..ab38989
--- /dev/null
+++ b/patches/dwm-togglefloatingcenter-20210806-138b405f.diff
@@ -0,0 +1,31 @@
+From efa326b2c71f0df1d097fd52a17684f5ccc5df6c Mon Sep 17 00:00:00 2001
+From: Rizqi Nur Assyaufi <bandithijo@gmail.com>
+Date: Sat, 7 Aug 2021 00:24:01 +0800
+Subject: [PATCH] [dwm][patch][togglefloatingcenter] centered togglefloating
+ window
+
+Default behaviour when togglefloating() is floating from top-left corner.
+This patch will allows you to toggle floating window client will be centered
+position.
+---
+ dwm.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..cbedb09 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -1719,6 +1719,10 @@ togglefloating(const Arg *arg)
+ 	if (selmon->sel->isfloating)
+ 		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+ 			selmon->sel->w, selmon->sel->h, 0);
++
++    selmon->sel->x = selmon->sel->mon->mx + (selmon->sel->mon->mw - WIDTH(selmon->sel)) / 2;
++    selmon->sel->y = selmon->sel->mon->my + (selmon->sel->mon->mh - HEIGHT(selmon->sel)) / 2;
++
+ 	arrange(selmon);
+ }
+ 
+-- 
+2.31.1
+
diff --git a/patches/dwm-xresources-20210827-138b405.diff b/patches/dwm-xresources-20210827-138b405.diff
new file mode 100644
index 0000000..29852a9
--- /dev/null
+++ b/patches/dwm-xresources-20210827-138b405.diff
@@ -0,0 +1,240 @@
+From f30583c6e2ab5e7de6ef4ebf156076ac0f6e69fc Mon Sep 17 00:00:00 2001
+From: Jack Bird <jack.bird@durham.ac.uk>
+Date: Fri, 27 Aug 2021 00:53:14 +0100
+Subject: [PATCH] xresources updated for 138b405
+
+---
+ config.def.h | 61 ++++++++++++++++++++++++++++++--------------
+ drw.c        |  2 +-
+ drw.h        |  2 +-
+ dwm.c        | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 116 insertions(+), 21 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..87ac198 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -1,21 +1,23 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+-static const unsigned int snap      = 32;       /* snap pixel */
+-static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static unsigned int borderpx  = 1;        /* border pixel of windows */
++static unsigned int snap      = 32;       /* snap pixel */
++static int showbar            = 1;        /* 0 means no bar */
++static int topbar             = 1;        /* 0 means bottom bar */
++static char font[]            = "monospace:size=10";
++static char dmenufont[]       = "monospace:size=10";
++static const char *fonts[]          = { font };
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
+ /* tagging */
+@@ -32,9 +34,9 @@ static const Rule rules[] = {
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+-static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ static const Layout layouts[] = {
+@@ -57,9 +59,30 @@ static const Layout layouts[] = {
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",               STRING,  &font },
++		{ "dmenufont",          STRING,  &dmenufont },
++		{ "normbgcolor",        STRING,  &normbgcolor },
++		{ "normbordercolor",    STRING,  &normbordercolor },
++		{ "normfgcolor",        STRING,  &normfgcolor },
++		{ "selbgcolor",         STRING,  &selbgcolor },
++		{ "selbordercolor",     STRING,  &selbordercolor },
++		{ "selfgcolor",         STRING,  &selfgcolor },
++		{ "borderpx",          	INTEGER, &borderpx },
++		{ "snap",          		INTEGER, &snap },
++		{ "showbar",          	INTEGER, &showbar },
++		{ "topbar",          	INTEGER, &topbar },
++		{ "nmaster",          	INTEGER, &nmaster },
++		{ "resizehints",       	INTEGER, &resizehints },
++		{ "mfact",      	 	FLOAT,   &mfact },
++};
++
+ static Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+diff --git a/drw.c b/drw.c
+index 4cdbcbe..8f1059e 100644
+--- a/drw.c
++++ b/drw.c
+@@ -208,7 +208,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 4bcd5ad..42b04ce 100644
+--- a/drw.h
++++ b/drw.h
+@@ -39,7 +39,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..2214b19 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -36,6 +36,7 @@
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
++#include <X11/Xresource.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+@@ -141,6 +142,19 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -234,6 +248,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
++static void load_xresources(void);
++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+@@ -2127,6 +2143,60 @@ zoom(const Arg *arg)
+ 	pop(c);
+ }
+ 
++void
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
++}
++
++void
++load_xresources(void)
++{
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
++}
++
+ int
+ main(int argc, char *argv[])
+ {
+@@ -2139,6 +2209,8 @@ main(int argc, char *argv[])
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
+ 	checkotherwm();
++	XrmInitialize();
++	load_xresources();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec", NULL) == -1)
+-- 
+2.33.0
+
diff --git a/patches/get.sh b/patches/get.sh
new file mode 100755
index 0000000..32420dc
--- /dev/null
+++ b/patches/get.sh
@@ -0,0 +1,89 @@
+# Example
+# https://dwm.suckless.org/patches/alpha/
+# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
+# exit 0
+
+download_if_not_exists() {
+  local url="$1"
+  local filename=$(basename "$url") # Extract the file name from the URL
+
+  # Check if the file already exists
+  if [[ -f "$filename" ]]; then
+    echo "File '$filename' already exists. Skipping download."
+  else
+    echo "Downloading '$filename'..."
+    curl -O "$url"
+    if [[ $? -eq 0 ]]; then
+      echo "Downloaded '$filename' successfully."
+    else
+      echo "Failed to download '$filename'."
+    fi
+  fi
+}
+
+# https://dwm.suckless.org/patches/noborder/
+download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborder-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderfloatingfix-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/noborder/dwm-noborderselflickerfix-2022042627-d93ff48803f0.diff
+
+# https://dwm.suckless.org/patches/stackmfact/
+download_if_not_exists https://dwm.suckless.org/patches/stackmfact/dwm-6.0-smfact.diff
+
+# https://dwm.suckless.org/patches/notitle/
+download_if_not_exists https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
+
+# https://dwm.suckless.org/patches/sticky/
+download_if_not_exists https://dwm.suckless.org/patches/sticky/dwm-sticky-20240927-60f7034.diff
+
+# https://dwm.suckless.org/patches/actualfullscreen/
+download_if_not_exists https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
+
+# https://dwm.suckless.org/patches/tagshift/
+download_if_not_exists https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
+
+# https://dwm.suckless.org/patches/statuscmd/
+#download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20241009-8933ebc.diff
+download_if_not_exists https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-status2d-20210405-60bb3df.diff
+
+# https://dwm.suckless.org/patches/swallow/
+download_if_not_exists https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
+
+# https://dwm.suckless.org/patches/xresources/
+download_if_not_exists https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
+
+# https://dwm.suckless.org/patches/hide_vacant_tags/
+download_if_not_exists https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.4.diff
+
+# https://dwm.suckless.org/patches/stacker/
+download_if_not_exists https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
+
+# https://dwm.suckless.org/patches/vanitygaps/
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-20190508-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
+#download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
+download_if_not_exists https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
+
+# https://dwm.suckless.org/patches/autostart/
+download_if_not_exists https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
+
+# https://dwm.suckless.org/patches/scratchpad/
+#download_if_not_exists https://dwm.suckless.org/patches/scratchpad/dwm-scratchpad-20240321-061e9fe.diff
+
+#https://dwm.suckless.org/patches/scratchpads/
+download_if_not_exists https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
+
+# https://dwm.suckless.org/patches/focusonclick/
+download_if_not_exists https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
+
+# https://dwm.suckless.org/patches/save_floats/
+download_if_not_exists https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
+
+# https://dwm.suckless.org/patches/status2d/
+#download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-systray-6.4.diff
+download_if_not_exists https://dwm.suckless.org/patches/status2d/dwm-status2d-6.3.diff
+
+# https://dwm.suckless.org/patches/togglefloatingcenter/
+download_if_not_exists https://dwm.suckless.org/patches/togglefloatingcenter/dwm-togglefloatingcenter-20210806-138b405f.diff
+
diff --git a/patches_git/dwm-actualfullscreen.diff b/patches_git/dwm-actualfullscreen.diff
new file mode 100644
index 0000000..5aa0294
--- /dev/null
+++ b/patches_git/dwm-actualfullscreen.diff
@@ -0,0 +1,52 @@
+diff --git a/config.def.h b/config.def.h
+index 583f383..880a46a 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -118,6 +118,7 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+diff --git a/dwm.1 b/dwm.1
+index ddc8321..3d310ac 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -116,6 +116,9 @@ Zooms/cycles focused window to/from master area (tiled layouts only).
+ .B Mod1\-Shift\-c
+ Close focused window.
+ .TP
++.B Mod1\-Shift\-f
++Toggle fullscreen for focused window.
++.TP
+ .B Mod1\-Shift\-space
+ Toggle focused window between tiled and floating state.
+ .TP
+diff --git a/dwm.c b/dwm.c
+index f9989e1..9ae5616 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -216,6 +216,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -1837,6 +1838,13 @@ togglefloating(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-autostart.diff b/patches_git/dwm-autostart.diff
new file mode 100644
index 0000000..a09e438
--- /dev/null
+++ b/patches_git/dwm-autostart.diff
@@ -0,0 +1,165 @@
+diff --git a/dwm.1 b/dwm.1
+index 3d310ac..d04bec6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -155,6 +163,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 758c5ac..91fac46 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -200,6 +201,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -244,7 +246,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
+ static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+@@ -1514,6 +1520,83 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++		pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
+ void
+ scan(void)
+ {
+@@ -2322,6 +2405,7 @@ main(int argc, char *argv[])
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
diff --git a/patches_git/dwm-focusonclick.diff b/patches_git/dwm-focusonclick.diff
new file mode 100644
index 0000000..baf3978
--- /dev/null
+++ b/patches_git/dwm-focusonclick.diff
@@ -0,0 +1,117 @@
+diff --git a/config.def.h b/config.def.h
+index 69d4822..0c94360 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -11,6 +11,7 @@ static const unsigned int gappov    = 30;       /* vert outer gap between window
+ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static int showbar            = 1;        /* 0 means no bar */
+ static int topbar             = 1;        /* 0 means bottom bar */
++static const int focusonwheel       = 0;
+ static char font[]            = "monospace:size=10";
+ static char dmenufont[]       = "monospace:size=10";
+ static const char *fonts[]          = { font };
+diff --git a/dwm.c b/dwm.c
+index c71fa3c..aec2675 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -203,7 +203,6 @@ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+-static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+@@ -223,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+-static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+@@ -315,13 +313,11 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+-	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+-	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+@@ -548,7 +544,8 @@ buttonpress(XEvent *e)
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+-	if ((m = wintomon(ev->window)) && m != selmon) {
++	if ((m = wintomon(ev->window)) && m != selmon
++	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+@@ -597,8 +594,8 @@ buttonpress(XEvent *e)
+ 				}
+ 			}
+ 	} else if ((c = wintoclient(ev->window))) {
+-		focus(c);
+-		restack(selmon);
++		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
++			focus(c);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+@@ -1022,25 +1019,6 @@ drawbars(void)
+ 		drawbar(m);
+ }
+ 
+-void
+-enternotify(XEvent *e)
+-{
+-	Client *c;
+-	Monitor *m;
+-	XCrossingEvent *ev = &e->xcrossing;
+-
+-	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+-		return;
+-	c = wintoclient(ev->window);
+-	m = c ? c->mon : wintomon(ev->window);
+-	if (m != selmon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-	} else if (!c || c == selmon->sel)
+-		return;
+-	focus(c);
+-}
+-
+ void
+ expose(XEvent *e)
+ {
+@@ -1412,23 +1390,6 @@ monocle(Monitor *m)
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+-void
+-motionnotify(XEvent *e)
+-{
+-	static Monitor *mon = NULL;
+-	Monitor *m;
+-	XMotionEvent *ev = &e->xmotion;
+-
+-	if (ev->window != root)
+-		return;
+-	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+-		unfocus(selmon->sel, 1);
+-		selmon = m;
+-		focus(NULL);
+-	}
+-	mon = m;
+-}
+-
+ void
+ movemouse(const Arg *arg)
+ {
diff --git a/patches_git/dwm-hide_vacant_tags.diff b/patches_git/dwm-hide_vacant_tags.diff
new file mode 100644
index 0000000..b9320f6
--- /dev/null
+++ b/patches_git/dwm-hide_vacant_tags.diff
@@ -0,0 +1,46 @@
+diff --git a/dwm.c b/dwm.c
+index 0d205d0..34d25b6 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -441,9 +441,15 @@ buttonpress(XEvent *e)
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+-		do
++		unsigned int occ = 0;
++		for(c = m->clients; c; c=c->next)
++			occ |= c->tags == TAGMASK ? 0 : c->tags;
++		do {
++			/* Do not reserve space for vacant tags */
++			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++				continue;
+ 			x += TEXTW(tags[i]);
+-		while (ev->x >= x && ++i < LENGTH(tags));
++		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+@@ -831,19 +837,18 @@ drawbar(Monitor *m)
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-		occ |= c->tags;
++		occ |= c->tags == TAGMASK ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
++		/* Do not draw vacant tags */
++		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
++			continue;
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+-		if (occ & 1 << i)
+-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+-				urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = TEXTW(m->ltsymbol);
diff --git a/patches_git/dwm-noborder.diff b/patches_git/dwm-noborder.diff
new file mode 100644
index 0000000..59cf669
--- /dev/null
+++ b/patches_git/dwm-noborder.diff
@@ -0,0 +1,18 @@
+diff --git a/dwm.c b/dwm.c
+index 1443802..857c396 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -1291,6 +1291,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
diff --git a/patches_git/dwm-notitle.diff b/patches_git/dwm-notitle.diff
new file mode 100644
index 0000000..b23989f
--- /dev/null
+++ b/patches_git/dwm-notitle.diff
@@ -0,0 +1,68 @@
+diff --git a/config.def.h b/config.def.h
+index 357dc6f..583f383 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -142,7 +142,6 @@ static const Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+diff --git a/dwm.c b/dwm.c
+index 82fc028..f9989e1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -63,8 +63,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -446,10 +446,8 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+ 		else
+-			click = ClkWinTitle;
++			click = ClkStatusText;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -850,15 +848,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -1361,11 +1352,8 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
diff --git a/patches_git/dwm-savefloats.diff b/patches_git/dwm-savefloats.diff
new file mode 100644
index 0000000..b66f755
--- /dev/null
+++ b/patches_git/dwm-savefloats.diff
@@ -0,0 +1,42 @@
+diff --git a/dwm.c b/dwm.c
+index 34d25b6..758c5ac 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -88,6 +88,7 @@ struct Client {
+ 	float mina, maxa;
+ 	float cfact;
+ 	int x, y, w, h;
++	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+@@ -1183,6 +1184,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	c->sfx = c->x;
++	c->sfy = c->y;
++	c->sfw = c->w;
++	c->sfh = c->h;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -1874,8 +1879,16 @@ togglefloating(const Arg *arg)
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
++		/* restore last known float dimensions */
++		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
++		       selmon->sel->sfw, selmon->sel->sfh, False);
++	else {
++		/* save last known float dimensions */
++		selmon->sel->sfx = selmon->sel->x;
++		selmon->sel->sfy = selmon->sel->y;
++		selmon->sel->sfw = selmon->sel->w;
++		selmon->sel->sfh = selmon->sel->h;
++	}
+ 	arrange(selmon);
+ }
+ 
diff --git a/patches_git/dwm-scratchpads.diff b/patches_git/dwm-scratchpads.diff
new file mode 100644
index 0000000..0bef30e
--- /dev/null
+++ b/patches_git/dwm-scratchpads.diff
@@ -0,0 +1,133 @@
+diff --git a/config.def.h b/config.def.h
+index 1919b6c..69d4822 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -26,6 +26,20 @@ static char *colors[][3] = {
+        [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
++typedef struct {
++	const char *name;
++	const void *cmd;
++} Sp;
++const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
++const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
++const char *spcmd3[] = {"keepassxc", NULL };
++static Sp scratchpads[] = {
++	/* name          cmd  */
++	{"spterm",      spcmd1},
++	{"spranger",    spcmd2},
++	{"keepassxc",   spcmd3},
++};
++
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+@@ -165,6 +179,9 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
++	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
++	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+@@ -189,7 +206,7 @@ static const Button buttons[] = {
+ 	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+diff --git a/dwm.c b/dwm.c
+index 87bc8c5..c71fa3c 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -66,7 +66,10 @@
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
++#define TAGMASK     			((1 << NUMTAGS) - 1)
++#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
++#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+@@ -256,6 +259,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglescratch(const Arg *arg);
+ static void togglesticky(const Arg *arg);
+ static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -365,6 +369,11 @@ applyrules(Client *c)
+ 			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
++			if ((r->tags & SPTAGMASK) && r->isfloating) {
++				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++			}
++
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+@@ -374,7 +383,7 @@ applyrules(Client *c)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+@@ -2085,6 +2094,10 @@ showhide(Client *c)
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
++		if ((c->tags & SPTAGMASK) && c->isfloating) {
++			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
++			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
++		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+@@ -2228,6 +2241,32 @@ togglesticky(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglescratch(const Arg *arg)
++{
++	Client *c;
++	unsigned int found = 0;
++	unsigned int scratchtag = SPTAG(arg->ui);
++	Arg sparg = {.v = scratchpads[arg->ui].cmd};
++
++	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
++	if (found) {
++		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
++		if (newtagset) {
++			selmon->tagset[selmon->seltags] = newtagset;
++			focus(NULL);
++			arrange(selmon);
++		}
++		if (ISVISIBLE(c)) {
++			focus(c);
++			restack(selmon);
++		}
++	} else {
++		selmon->tagset[selmon->seltags] |= scratchtag;
++		spawn(&sparg);
++	}
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-shifttool-changes.diff b/patches_git/dwm-shifttool-changes.diff
new file mode 100644
index 0000000..b0c2a71
--- /dev/null
+++ b/patches_git/dwm-shifttool-changes.diff
@@ -0,0 +1,239 @@
+diff --git a/config.h b/config.h
+index 3fb3f44..4613e1b 100644
+--- a/config.h
++++ b/config.h
+@@ -209,8 +209,8 @@ static const Key keys[] = {
+         { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
+         { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
+         { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
+-        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
+-        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
++        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
++        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
+         { MODKEY,                   XK_q,               killclient,         {0} },
+diff --git a/dwm.c b/dwm.c
+index 8b14f30..c072985 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -250,8 +250,14 @@ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+-static void shiftview(const Arg *arg);
+ static void shifttag(const Arg *arg);
++static void shifttagclients(const Arg *arg);
++static void shiftview(const Arg *arg);
++static void shiftviewclients(const Arg *arg);
++static void shiftboth(const Arg *arg);
++static void swaptags(const Arg *arg);
++static void shiftswaptags(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+@@ -1965,38 +1971,186 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++//void
++//shiftview(const Arg *arg) {
++//	Arg shifted;
++//
++//	if(arg->i > 0) /* left circular shift */
++//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++//
++//	else /* right circular shift */
++//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++//
++//	view(&shifted);
++//}
++//
++//void
++//shifttag(const Arg *arg) {
++//	Arg shifted;
++//	Client *c;
++//
++//	if (!selmon->sel)
++//		return;
++//	c = selmon->sel;
++//
++//	if (arg->i > 0) /* left circular shift */
++//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++//			^ (c->tags >> (LENGTH(tags) - arg->i));
++//	else /* right circular shift */
++//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++//			^ (c->tags << (LENGTH(tags) + arg->i));
++//
++//	toggletag(&shifted);
++//}
++
++// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
++// Or this (used below):
++// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
++
++/* Sends a window to the next/prev tag */
+ void
+-shiftview(const Arg *arg) {
++shifttag(const Arg *arg)
++{
+ 	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+ 
+-	if(arg->i > 0) /* left circular shift */
+-		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+-		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+ 
+-	else /* right circular shift */
+-		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+-		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
++	tag(&shifted);
++}
++/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
++void
++shifttagclients(const Arg *arg)
++{
+ 
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	tag(&shifted);
++}
++/* Navigate to the next/prev tag */
++void
++shiftview(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0) {/* left circular shift */
++		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	} else {	/* right circular shift */
++		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
++		shifted.ui &= ~SPTAGMASK;
++	}
+ 	view(&shifted);
+ }
++/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
++void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	for (c = selmon->clients; c; c = c->next)
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
+ 
++
++	if (arg->i > 0)	/* left circular shift */
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	else		/* right circular shift */
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			shifted.ui &= ~SPTAGMASK;
++		} while (tagmask && !(shifted.ui & tagmask));
++	view(&shifted);
++}
++/* move the current active window to the next/prev tag and view it. More like following the window */
+ void
+-shifttag(const Arg *arg) {
++shiftboth(const Arg *arg)
++{
+ 	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	tag(&shifted);
++	view(&shifted);
++}
++//helper function for shiftswaptags found on:
++//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
++// modified to work with scratchpad
++void
++swaptags(const Arg *arg)
++{
+ 	Client *c;
++	unsigned int newtag = arg->ui & TAGMASK;
++	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+ 
+-	if (!selmon->sel)
++	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
+ 		return;
+-	c = selmon->sel;
+ 
+-	if (arg->i > 0) /* left circular shift */
+-		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+-			^ (c->tags >> (LENGTH(tags) - arg->i));
+-	else /* right circular shift */
+-		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+-			^ (c->tags << (LENGTH(tags) + arg->i));
++	for (c = selmon->clients; c != NULL; c = c->next) {
++		if ((c->tags & newtag) || (c->tags & curtag))
++			c->tags ^= curtag ^ newtag;
++
++		if (!c->tags)
++			c->tags = newtag;
++	}
+ 
+-	toggletag(&shifted);
++	//move to the swaped tag
++	//selmon->tagset[selmon->seltags] = newtag;
++
++	focus(NULL);
++	arrange(selmon);
++}
++/* swaps "tags" (all the clients) with the next/prev tag. */
++void
++shiftswaptags(const Arg *arg)
++{
++	Arg shifted;
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++
++	if (arg->i > 0)	/* left circular shift */
++		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
++	else		/* right circular shift */
++		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
++	swaptags(&shifted);
++	// uncomment if you also want to "go" (view) the tag where the the clients are going
++	//view(&shifted);
+ }
+ 
+ void
diff --git a/patches_git/dwm-stacker.diff b/patches_git/dwm-stacker.diff
new file mode 100644
index 0000000..cde0a99
--- /dev/null
+++ b/patches_git/dwm-stacker.diff
@@ -0,0 +1,183 @@
+diff --git a/config.def.h b/config.def.h
+index 9ed2869..1919b6c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -76,6 +76,14 @@ static const Layout layouts[] = {
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++#define STACKKEYS(MOD,ACTION) \
++	{ MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
++	{ MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
++	{ MOD, XK_grave, ACTION##stack, {.i = PREVSEL } }, \
++	{ MOD, XK_q,     ACTION##stack, {.i = 0 } }, \
++	{ MOD, XK_a,     ACTION##stack, {.i = 1 } }, \
++	{ MOD, XK_z,     ACTION##stack, {.i = 2 } }, \
++	{ MOD, XK_x,     ACTION##stack, {.i = -1 } },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+@@ -113,8 +121,8 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
++	STACKKEYS(MODKEY,                          focus)
++	STACKKEYS(MODKEY|ShiftMask,                push)
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
+@@ -166,7 +174,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ShiftMask,             XK_BackSpace, quit,        {0} },
+ 	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+diff --git a/dwm.c b/dwm.c
+index cb3067d..87bc8c5 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -55,14 +55,20 @@
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define GETINC(X)               ((X) - 2000)
++#define INC(X)                  ((X) + 2000)
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++#define ISINC(X)                ((X) > 1000 && (X) < 3000)
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
++#define PREVSEL                 3000
++#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -219,6 +225,7 @@ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *c);
+ static void propertynotify(XEvent *e);
++static void pushstack(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -244,6 +251,7 @@ static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
++static int stackpos(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+@@ -1086,27 +1094,16 @@ focusmon(const Arg *arg)
+ void
+ focusstack(const Arg *arg)
+ {
+-	Client *c = NULL, *i;
++	int i = stackpos(arg);
++	Client *c, *p;
+ 
+-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++	if(i < 0)
+ 		return;
+-	if (arg->i > 0) {
+-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+-		if (!c)
+-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+-	} else {
+-		for (i = selmon->clients; i != selmon->sel; i = i->next)
+-			if (ISVISIBLE(i))
+-				c = i;
+-		if (!c)
+-			for (; i; i = i->next)
+-				if (ISVISIBLE(i))
+-					c = i;
+-	}
+-	if (c) {
+-		focus(c);
+-		restack(selmon);
+-	}
++
++	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
++	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
++	focus(c ? c : p);
++	restack(selmon);
+ }
+ 
+ Atom
+@@ -1533,6 +1530,29 @@ propertynotify(XEvent *e)
+ 	}
+ }
+ 
++void
++pushstack(const Arg *arg) {
++	int i = stackpos(arg);
++	Client *sel = selmon->sel, *c, *p;
++
++	if(i < 0)
++		return;
++	else if(i == 0) {
++		detach(sel);
++		attach(sel);
++	}
++	else {
++		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
++			if(!(i -= (ISVISIBLE(c) && c != sel)))
++				break;
++		c = c ? c : p;
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	arrange(selmon);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -2113,6 +2133,36 @@ spawn(const Arg *arg)
+ 	}
+ }
+ 
++int
++stackpos(const Arg *arg) {
++	int n, i;
++	Client *c, *l;
++
++	if(!selmon->clients)
++		return -1;
++
++	if(arg->i == PREVSEL) {
++		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
++		if(!l)
++			return -1;
++		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return i;
++	}
++	else if(ISINC(arg->i)) {
++		if(!selmon->sel)
++			return -1;
++		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MOD(i + GETINC(arg->i), n);
++	}
++	else if(arg->i < 0) {
++		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
++		return MAX(i + arg->i, 0);
++	}
++	else
++		return arg->i;
++}
++
+ void
+ tag(const Arg *arg)
+ {
diff --git a/patches_git/dwm-status2d.diff b/patches_git/dwm-status2d.diff
new file mode 100644
index 0000000..c600b66
--- /dev/null
+++ b/patches_git/dwm-status2d.diff
@@ -0,0 +1,166 @@
+diff --git a/dwm.c b/dwm.c
+index db7e0c8..82fc028 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -167,6 +167,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -240,7 +241,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -490,7 +491,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	free(scheme);
+ 	XDestroyWindow(dpy, wmcheckwin);
+@@ -703,6 +704,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -717,9 +826,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1618,7 +1725,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
diff --git a/patches_git/dwm-statuscmd-status2d.diff b/patches_git/dwm-statuscmd-status2d.diff
new file mode 100644
index 0000000..bac794e
--- /dev/null
+++ b/patches_git/dwm-statuscmd-status2d.diff
@@ -0,0 +1,174 @@
+diff --git a/config.def.h b/config.def.h
+index 2099993..f74867c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -75,6 +75,8 @@ static const Layout layouts[] = {
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
++#define STATUSBAR "dwmblocks"
++
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+@@ -148,7 +150,9 @@ static const Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
++	{ ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
++	{ ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+diff --git a/dwm.c b/dwm.c
+index 2fddeb1..ed799c2 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -179,6 +179,7 @@ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static pid_t getstatusbarpid();
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -217,6 +218,7 @@ static void seturgent(Client *c, int urg);
+ static void shiftview(const Arg *arg);
+ static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
++static void sigstatusbar(const Arg *arg);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+@@ -254,6 +256,9 @@ static const char broken[] = "broken";
+ static const char dwmdir[] = "dwm";
+ static const char localshare[] = ".local/share";
+ static char stext[1024];
++static int statussig;
++static int statusw;
++static pid_t statuspid = -1;
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh;               /* bar height */
+@@ -464,8 +469,33 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+ 			click = ClkLtSymbol;
+-		else
+-			click = ClkStatusText;
++        } else if (ev->x > selmon->ww - statusw) {
++            x = selmon->ww - statusw;
++            click = ClkStatusText;
++
++			char *text, *s, ch;
++			statussig = 0;
++			for (text = s = stext; *s && x <= ev->x; s++) {
++				if ((unsigned char)(*s) < ' ') {
++					ch = *s;
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = ch;
++					text = s + 1;
++					if (x >= ev->x)
++						break;
++					statussig = ch;
++				} else if (*s == '^') {
++					*s = '\0';
++					x += TEXTW(text) - lrpad;
++					*s = '^';
++					if (*(++s) == 'f')
++						x += atoi(++s);
++					while (*(s++) != '^');
++					text = s;
++					s--;
++				}
++			}
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -726,7 +756,7 @@ dirtomon(int dir)
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+-	int ret, i, w, x, len;
++	int ret, i, j, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+@@ -735,7 +765,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+-	memcpy(text, stext, len);
++
++	i = -1, j = 0;
++	while (stext[++i])
++		if ((unsigned char)stext[i] >= ' ')
++			text[j++] = stext[i];
++	text[j] = '\0';
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+@@ -846,7 +881,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		tw = m->ww - drawstatusbar(m, bh, stext);
++		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1004,6 +1039,30 @@ getatomprop(Client *c, Atom prop)
+ 	return atom;
+ }
+ 
++pid_t
++getstatusbarpid()
++{
++	char buf[32], *str = buf, *c;
++	FILE *fp;
++
++	if (statuspid > 0) {
++		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
++		if ((fp = fopen(buf, "r"))) {
++			fgets(buf, sizeof(buf), fp);
++			while ((c = strchr(str, '/')))
++				str = c + 1;
++			fclose(fp);
++			if (!strcmp(str, STATUSBAR))
++				return statuspid;
++		}
++	}
++	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
++		return -1;
++	fgets(buf, sizeof(buf), fp);
++	pclose(fp);
++	return strtoul(buf, NULL, 10);
++}
++
+ int
+ getrootptr(int *x, int *y)
+ {
+@@ -1928,6 +1987,20 @@ showhide(Client *c)
+ 	}
+ }
+ 
++void
++sigstatusbar(const Arg *arg)
++{
++	union sigval sv;
++
++	if (!statussig)
++		return;
++	sv.sival_int = arg->i;
++	if ((statuspid = getstatusbarpid()) <= 0)
++		return;
++
++	sigqueue(statuspid, SIGRTMIN+statussig, sv);
++}
++
+ void
+ spawn(const Arg *arg)
+ {
diff --git a/patches_git/dwm-sticky.diff b/patches_git/dwm-sticky.diff
new file mode 100644
index 0000000..0657003
--- /dev/null
+++ b/patches_git/dwm-sticky.diff
@@ -0,0 +1,133 @@
+diff --git a/config.def.h b/config.def.h
+index f6c7894..2099993 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -139,6 +139,7 @@ static const Key keys[] = {
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY,                       XK_s,      togglesticky,   {0} },
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.c b/dwm.c
+index 91fac46..2fddeb1 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -50,7 +50,7 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+@@ -61,7 +61,7 @@
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+@@ -94,7 +94,7 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -208,6 +208,7 @@ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setsticky(Client *c, int sticky);
+ static void setlayout(const Arg *arg);
+ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+@@ -221,6 +222,7 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglesticky(const Arg *arg);
+ static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+@@ -544,6 +546,10 @@ clientmessage(XEvent *e)
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++
++        if (cme->data.l[1] == netatom[NetWMSticky]
++                || cme->data.l[2] == netatom[NetWMSticky])
++            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -1714,6 +1720,23 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++	 setsticky(Client *c, int sticky)
++	 {
++
++		 if(sticky && !c->issticky) {
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
++			 c->issticky = 1;
++		 } else if(!sticky && c->issticky){
++			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++					 PropModeReplace, (unsigned char *)0, 0);
++			 c->issticky = 0;
++			 arrange(c->mon);
++		 }
++	 }
++
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1835,6 +1858,7 @@ setup(void)
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+@@ -1982,6 +2006,15 @@ togglefullscr(const Arg *arg)
+     setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+ }
+ 
++void
++togglesticky(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	setsticky(selmon->sel, !selmon->sel->issticky);
++	arrange(selmon);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+@@ -2274,6 +2307,9 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
++	if (state == netatom[NetWMSticky]) {
++		setsticky(c, 1);
++	}
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+@@ -2411,3 +2447,4 @@ main(int argc, char *argv[])
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
++
diff --git a/patches_git/dwm-swallow.diff b/patches_git/dwm-swallow.diff
new file mode 100644
index 0000000..8119113
--- /dev/null
+++ b/patches_git/dwm-swallow.diff
@@ -0,0 +1,398 @@
+diff --git a/config.def.h b/config.def.h
+index f74867c..5a9f2d4 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,7 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+@@ -31,9 +32,11 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+diff --git a/config.mk b/config.mk
+index 8efca9a..a933c0b 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/dwm.c b/dwm.c
+index ed799c2..a424e60 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -41,6 +41,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -94,9 +100,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky;
++    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
++    pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++    Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -144,6 +152,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -249,6 +259,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
+ static const char autostartblocksh[] = "autostart_blocking.sh";
+ static const char autostartsh[] = "autostart.sh";
+@@ -290,6 +306,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -319,6 +337,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -437,6 +457,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -714,6 +781,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -1217,12 +1287,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1238,6 +1309,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1276,6 +1348,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -2134,6 +2208,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -2149,9 +2237,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2418,6 +2509,136 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2507,10 +2728,12 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
diff --git a/patches_git/dwm-tagshift.diff b/patches_git/dwm-tagshift.diff
new file mode 100644
index 0000000..b416cd8
--- /dev/null
+++ b/patches_git/dwm-tagshift.diff
@@ -0,0 +1,69 @@
+diff --git a/config.def.h b/config.def.h
+index 880a46a..f6c7894 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -89,6 +89,10 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
++	{ MODKEY,                       XK_Left,   shiftview,      {.i = -1 } },
++	{ MODKEY,                       XK_Right,  shiftview,      {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   shifttag,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  shifttag,       {.i = +1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ 	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+diff --git a/dwm.c b/dwm.c
+index 9ae5616..0d205d0 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -210,6 +210,8 @@ static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shiftview(const Arg *arg);
++static void shifttag(const Arg *arg);
+ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+@@ -1633,6 +1635,40 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++shiftview(const Arg *arg) {
++	Arg shifted;
++
++	if(arg->i > 0) /* left circular shift */
++		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
++		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
++
++	else /* right circular shift */
++		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
++		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
++
++	view(&shifted);
++}
++
++void
++shifttag(const Arg *arg) {
++	Arg shifted;
++	Client *c;
++
++	if (!selmon->sel)
++		return;
++	c = selmon->sel;
++
++	if (arg->i > 0) /* left circular shift */
++		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
++			^ (c->tags >> (LENGTH(tags) - arg->i));
++	else /* right circular shift */
++		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
++			^ (c->tags << (LENGTH(tags) + arg->i));
++
++	toggletag(&shifted);
++}
++
+ void
+ setcfact(const Arg *arg) {
+ 	float f;
diff --git a/patches_git/dwm-vanitygaps.diff b/patches_git/dwm-vanitygaps.diff
new file mode 100644
index 0000000..1f1b7b5
--- /dev/null
+++ b/patches_git/dwm-vanitygaps.diff
@@ -0,0 +1,1018 @@
+diff --git a/config.def.h b/config.def.h
+index 9efa774..357dc6f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,11 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -37,11 +42,26 @@ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++#include "vanitygaps.c"
++
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+@@ -71,7 +91,26 @@ static const Key keys[] = {
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
++	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
++	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
++	{ MODKEY|Mod4Mask,              XK_u,      incrgaps,       {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_u,      incrgaps,       {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_i,      incrigaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_i,      incrigaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_o,      incrogaps,      {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_o,      incrogaps,      {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_6,      incrihgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_6,      incrihgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_7,      incrivgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_7,      incrivgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_8,      incrohgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_8,      incrohgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_9,      incrovgaps,     {.i = +1 } },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_9,      incrovgaps,     {.i = -1 } },
++	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
++	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+diff --git a/dwm.c b/dwm.c
+index 857c396..db7e0c8 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -86,6 +86,7 @@ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
++	float cfact;
+ 	int x, y, w, h;
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+@@ -118,6 +119,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -200,6 +205,7 @@ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setlayout(const Arg *arg);
++static void setcfact(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+@@ -207,7 +213,6 @@ static void showhide(Client *c);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *m);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -640,6 +645,10 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -1042,6 +1051,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
++	c->cfact = 1.0;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+@@ -1527,6 +1537,24 @@ setlayout(const Arg *arg)
+ 		drawbar(selmon);
+ }
+ 
++void
++setcfact(const Arg *arg) {
++	float f;
++	Client *c;
++
++	c = selmon->sel;
++
++	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f + c->cfact;
++	if(arg->f == 0.0)
++		f = 1.0;
++	else if(f < 0.25 || f > 4.0)
++		return;
++	c->cfact = f;
++	arrange(selmon);
++}
++
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+@@ -1690,34 +1718,6 @@ tagmon(const Arg *arg)
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
+-void
+-tile(Monitor *m)
+-{
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
+-
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
+-
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
+-}
+-
+ void
+ togglebar(const Arg *arg)
+ {
+diff --git a/vanitygaps.c b/vanitygaps.c
+new file mode 100644
+index 0000000..1a816b6
+--- /dev/null
++++ b/vanitygaps.c
+@@ -0,0 +1,822 @@
++/* Key binding functions */
++static void defaultgaps(const Arg *arg);
++static void incrgaps(const Arg *arg);
++static void incrigaps(const Arg *arg);
++static void incrogaps(const Arg *arg);
++static void incrohgaps(const Arg *arg);
++static void incrovgaps(const Arg *arg);
++static void incrihgaps(const Arg *arg);
++static void incrivgaps(const Arg *arg);
++static void togglegaps(const Arg *arg);
++/* Layouts (delete the ones you do not need) */
++static void bstack(Monitor *m);
++static void bstackhoriz(Monitor *m);
++static void centeredmaster(Monitor *m);
++static void centeredfloatingmaster(Monitor *m);
++static void deck(Monitor *m);
++static void dwindle(Monitor *m);
++static void fibonacci(Monitor *m, int s);
++static void grid(Monitor *m);
++static void nrowgrid(Monitor *m);
++static void spiral(Monitor *m);
++static void tile(Monitor *m);
++/* Internals */
++static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
++static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
++static void setgaps(int oh, int ov, int ih, int iv);
++
++/* Settings */
++#if !PERTAG_PATCH
++static int enablegaps = 1;
++#endif // PERTAG_PATCH
++
++void
++setgaps(int oh, int ov, int ih, int iv)
++{
++	if (oh < 0) oh = 0;
++	if (ov < 0) ov = 0;
++	if (ih < 0) ih = 0;
++	if (iv < 0) iv = 0;
++
++	selmon->gappoh = oh;
++	selmon->gappov = ov;
++	selmon->gappih = ih;
++	selmon->gappiv = iv;
++	arrange(selmon);
++}
++
++void
++togglegaps(const Arg *arg)
++{
++	#if PERTAG_PATCH
++	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	enablegaps = !enablegaps;
++	#endif // PERTAG_PATCH
++	arrange(NULL);
++}
++
++void
++defaultgaps(const Arg *arg)
++{
++	setgaps(gappoh, gappov, gappih, gappiv);
++}
++
++void
++incrgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrigaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++incrogaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrohgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh + arg->i,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrovgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov + arg->i,
++		selmon->gappih,
++		selmon->gappiv
++	);
++}
++
++void
++incrihgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih + arg->i,
++		selmon->gappiv
++	);
++}
++
++void
++incrivgaps(const Arg *arg)
++{
++	setgaps(
++		selmon->gappoh,
++		selmon->gappov,
++		selmon->gappih,
++		selmon->gappiv + arg->i
++	);
++}
++
++void
++getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
++{
++	unsigned int n, oe, ie;
++	#if PERTAG_PATCH
++	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
++	#else
++	oe = ie = enablegaps;
++	#endif // PERTAG_PATCH
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
++	if (smartgaps && n == 1) {
++		oe = 0; // outer gaps disabled when only one client
++	}
++
++	*oh = m->gappoh*oe; // outer horizontal gap
++	*ov = m->gappov*oe; // outer vertical gap
++	*ih = m->gappih*ie; // inner horizontal gap
++	*iv = m->gappiv*ie; // inner vertical gap
++	*nc = n;            // number of clients
++}
++
++void
++getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
++{
++	unsigned int n;
++	float mfacts = 0, sfacts = 0;
++	int mtotal = 0, stotal = 0;
++	Client *c;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (n < m->nmaster)
++			mtotal += msize * (c->cfact / mfacts);
++		else
++			stotal += ssize * (c->cfact / sfacts);
++
++	*mf = mfacts; // total factor of master area
++	*sf = sfacts; // total factor of stack area
++	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
++	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
++}
++
++/***
++ * Layouts
++ */
++
++/*
++ * Bottomstack layout + gaps
++ * https://dwm.suckless.org/patches/bottomstack/
++ */
++static void
++bstack(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sx = mx;
++		sy = my + mh + ih;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++	}
++}
++
++static void
++bstackhoriz(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh;
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
++	sw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sh = (mh - ih) * (1 - m->mfact);
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
++	}
++
++	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++	}
++}
++
++/*
++ * Centred master layout + gaps
++ * https://dwm.suckless.org/patches/centeredmaster/
++ */
++void
++centeredmaster(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int lx = 0, ly = 0, lw = 0, lh = 0;
++	int rx = 0, ry = 0, rw = 0, rh = 0;
++	float mfacts = 0, lfacts = 0, rfacts = 0;
++	int mtotal = 0, ltotal = 0, rtotal = 0;
++	int mrest = 0, lrest = 0, rrest = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* initialize areas */
++	mx = m->wx + ov;
++	my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
++	mw = m->ww - 2*ov;
++	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
++	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
++
++	if (m->nmaster && n > m->nmaster) {
++		/* go mfact box in the center if more than nmaster clients */
++		if (n - m->nmaster > 1) {
++			/* ||<-S->|<---M--->|<-S->|| */
++			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
++			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
++			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
++			mx += lw + iv;
++		} else {
++			/* ||<---M--->|<-S->|| */
++			mw = (mw - iv) * m->mfact;
++			lw = 0;
++			rw = m->ww - mw - iv - 2*ov;
++		}
++		lx = m->wx + ov;
++		ly = m->wy + oh;
++		rx = mx + mw + iv;
++		ry = m->wy + oh;
++	}
++
++	/* calculate facts */
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
++		if (!m->nmaster || n < m->nmaster)
++			mfacts += c->cfact;
++		else if ((n - m->nmaster) % 2)
++			lfacts += c->cfact; // total factor of left hand stack area
++		else
++			rfacts += c->cfact; // total factor of right hand stack area
++	}
++
++	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
++		if (!m->nmaster || n < m->nmaster)
++			mtotal += mh * (c->cfact / mfacts);
++		else if ((n - m->nmaster) % 2)
++			ltotal += lh * (c->cfact / lfacts);
++		else
++			rtotal += rh * (c->cfact / rfacts);
++
++	mrest = mh - mtotal;
++	lrest = lh - ltotal;
++	rrest = rh - rtotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		if (!m->nmaster || i < m->nmaster) {
++			/* nmaster clients are stacked vertically, in the center of the screen */
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			/* stack clients are stacked vertically */
++			if ((i - m->nmaster) % 2 ) {
++				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
++				ly += HEIGHT(c) + ih;
++			} else {
++				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
++				ry += HEIGHT(c) + ih;
++			}
++		}
++	}
++}
++
++void
++centeredfloatingmaster(Monitor *m)
++{
++	unsigned int i, n;
++	float mfacts, sfacts;
++	float mivf = 1.0; // master inner vertical gap factor
++	int oh, ov, ih, iv, mrest, srest;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	mw = m->ww - 2*ov - iv*(n - 1);
++	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
++
++	if (m->nmaster && n > m->nmaster) {
++		mivf = 0.8;
++		/* go mfact box in the center if more than nmaster clients */
++		if (m->ww > m->wh) {
++			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * 0.9;
++		} else {
++			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
++			mh = m->wh * m->mfact;
++		}
++		mx = m->wx + (m->ww - mw) / 2;
++		my = m->wy + (m->wh - mh - 2*oh) / 2;
++
++		sx = m->wx + ov;
++		sy = m->wy + oh;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			/* nmaster clients are stacked horizontally, in the center of the screen */
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv*mivf;
++		} else {
++			/* stack clients are stacked horizontally */
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * Deck layout + gaps
++ * https://dwm.suckless.org/patches/deck/
++ */
++void
++deck(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++		sh = m->wh - 2*oh;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	if (n - m->nmaster > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
++		}
++}
++
++/*
++ * Fibonacci layout + gaps
++ * https://dwm.suckless.org/patches/fibonacci/
++ */
++void
++fibonacci(Monitor *m, int s)
++{
++	unsigned int i, n;
++	int nx, ny, nw, nh;
++	int oh, ov, ih, iv;
++	int nv, hrest = 0, wrest = 0, r = 1;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	nx = m->wx + ov;
++	ny = m->wy + oh;
++	nw = m->ww - 2*ov;
++	nh = m->wh - 2*oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
++		if (r) {
++			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
++			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
++				r = 0;
++			}
++			if (r && i < n - 1) {
++				if (i % 2) {
++					nv = (nh - ih) / 2;
++					hrest = nh - 2*nv - ih;
++					nh = nv;
++				} else {
++					nv = (nw - iv) / 2;
++					wrest = nw - 2*nv - iv;
++					nw = nv;
++				}
++
++				if ((i % 4) == 2 && !s)
++					nx += nw + iv;
++				else if ((i % 4) == 3 && !s)
++					ny += nh + ih;
++			}
++
++			if ((i % 4) == 0) {
++				if (s) {
++					ny += nh + ih;
++					nh += hrest;
++				}
++				else {
++					nh -= hrest;
++					ny -= nh + ih;
++				}
++			}
++			else if ((i % 4) == 1) {
++				nx += nw + iv;
++				nw += wrest;
++			}
++			else if ((i % 4) == 2) {
++				ny += nh + ih;
++				nh += hrest;
++				if (i < n - 1)
++					nw += wrest;
++			}
++			else if ((i % 4) == 3) {
++				if (s) {
++					nx += nw + iv;
++					nw -= wrest;
++				} else {
++					nw -= wrest;
++					nx -= nw + iv;
++					nh += hrest;
++				}
++			}
++			if (i == 0)	{
++				if (n != 1) {
++					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
++					wrest = 0;
++				}
++				ny = m->wy + oh;
++			}
++			else if (i == 1)
++				nw = m->ww - nw - iv - 2*ov;
++			i++;
++		}
++
++		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
++	}
++}
++
++void
++dwindle(Monitor *m)
++{
++	fibonacci(m, 1);
++}
++
++void
++spiral(Monitor *m)
++{
++	fibonacci(m, 0);
++}
++
++/*
++ * Gappless grid layout + gaps (ironically)
++ * https://dwm.suckless.org/patches/gaplessgrid/
++ */
++void
++gaplessgrid(Monitor *m)
++{
++	unsigned int i, n;
++	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	/* grid dimensions */
++	for (cols = 0; cols <= n/2; cols++)
++		if (cols*cols >= n)
++			break;
++	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
++		cols = 2;
++	rows = n/cols;
++	cn = rn = 0; // reset column no, row no, client count
++
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
++	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	x = m->wx + ov;
++	y = m->wy + oh;
++
++	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
++		if (i/rows + 1 > cols - n%cols) {
++			rows = n/cols + 1;
++			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
++			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++		}
++		resize(c,
++			x,
++			y + rn*(ch + ih) + MIN(rn, rrest),
++			cw + (cn < crest ? 1 : 0) - 2*c->bw,
++			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
++			0);
++		rn++;
++		if (rn >= rows) {
++			rn = 0;
++			x += cw + ih + (cn < crest ? 1 : 0);
++			cn++;
++		}
++	}
++}
++
++/*
++ * Gridmode layout + gaps
++ * https://dwm.suckless.org/patches/gridmode/
++ */
++void
++grid(Monitor *m)
++{
++	unsigned int i, n;
++	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
++	int oh, ov, ih, iv;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* grid dimensions */
++	for (rows = 0; rows <= n/2; rows++)
++		if (rows*rows >= n)
++			break;
++	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
++
++	/* window geoms (cell height/width) */
++	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
++	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
++	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
++	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
++		cc = i / rows;
++		cr = i % rows;
++		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
++		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
++		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
++	}
++}
++
++/*
++ * Horizontal grid layout + gaps
++ * https://dwm.suckless.org/patches/horizgrid/
++ */
++void
++horizgrid(Monitor *m) {
++	Client *c;
++	unsigned int n, i;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	int ntop, nbottom = 1;
++	float mfacts = 0, sfacts = 0;
++	int mrest, srest, mtotal = 0, stotal = 0;
++
++	/* Count windows */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	if (n <= 2)
++		ntop = n;
++	else {
++		ntop = n / 2;
++		nbottom = n - ntop;
++	}
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	sh = mh = m->wh - 2*oh;
++	sw = mw = m->ww - 2*ov;
++
++	if (n > ntop) {
++		sh = (mh - ih) / 2;
++		mh = mh - ih - sh;
++		sy = my + mh + ih;
++		mw = m->ww - 2*ov - iv * (ntop - 1);
++		sw = m->ww - 2*ov - iv * (nbottom - 1);
++	}
++
++	/* calculate facts */
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mfacts += c->cfact;
++		else
++			sfacts += c->cfact;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop)
++			mtotal += mh * (c->cfact / mfacts);
++		else
++			stotal += sw * (c->cfact / sfacts);
++
++	mrest = mh - mtotal;
++	srest = sw - stotal;
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < ntop) {
++			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
++			mx += WIDTH(c) + iv;
++		} else {
++			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
++			sx += WIDTH(c) + iv;
++		}
++}
++
++/*
++ * nrowgrid layout + gaps
++ * https://dwm.suckless.org/patches/nrowgrid/
++ */
++void
++nrowgrid(Monitor *m)
++{
++	unsigned int n;
++	int ri = 0, ci = 0;  /* counters */
++	int oh, ov, ih, iv;                         /* vanitygap settings */
++	unsigned int cx, cy, cw, ch;                /* client geometry */
++	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
++	unsigned int cols, rows = m->nmaster + 1;
++	Client *c;
++
++	/* count clients */
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++
++	/* nothing to do here */
++	if (n == 0)
++		return;
++
++	/* force 2 clients to always split vertically */
++	if (FORCE_VSPLIT && n == 2)
++		rows = 1;
++
++	/* never allow empty rows */
++	if (n < rows)
++		rows = n;
++
++	/* define first row */
++	cols = n / rows;
++	uc = cols;
++	cy = m->wy + oh;
++	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
++	uh = ch;
++
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
++		if (ci == cols) {
++			uw = 0;
++			ci = 0;
++			ri++;
++
++			/* next row */
++			cols = (n - uc) / (rows - ri);
++			uc += cols;
++			cy = m->wy + oh + uh + ih;
++			uh += ch + ih;
++		}
++
++		cx = m->wx + ov + uw;
++		cw = (m->ww - 2*ov - uw) / (cols - ci);
++		uw += cw + iv;
++
++		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
++	}
++}
++
++/*
++ * Default tile layout + gaps
++ */
++static void
++tile(Monitor *m)
++{
++	unsigned int i, n;
++	int oh, ov, ih, iv;
++	int mx = 0, my = 0, mh = 0, mw = 0;
++	int sx = 0, sy = 0, sh = 0, sw = 0;
++	float mfacts, sfacts;
++	int mrest, srest;
++	Client *c;
++
++	getgaps(m, &oh, &ov, &ih, &iv, &n);
++	if (n == 0)
++		return;
++
++	sx = mx = m->wx + ov;
++	sy = my = m->wy + oh;
++	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
++	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
++	sw = mw = m->ww - 2*ov;
++
++	if (m->nmaster && n > m->nmaster) {
++		sw = (mw - iv) * (1 - m->mfact);
++		mw = mw - iv - sw;
++		sx = mx + mw + iv;
++	}
++
++	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
++
++	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		if (i < m->nmaster) {
++			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
++			my += HEIGHT(c) + ih;
++		} else {
++			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
++			sy += HEIGHT(c) + ih;
++		}
++}
+\ No newline at end of file
diff --git a/patches_git/dwm-xresources.diff b/patches_git/dwm-xresources.diff
new file mode 100644
index 0000000..220fdff
--- /dev/null
+++ b/patches_git/dwm-xresources.diff
@@ -0,0 +1,231 @@
+diff --git a/config.def.h b/config.def.h
+index 5a9f2d4..9ed2869 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -1,27 +1,29 @@
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+-static const unsigned int snap      = 32;       /* snap pixel */
++static unsigned int borderpx  = 1;        /* border pixel of windows */
++static unsigned int snap      = 32;       /* snap pixel */
+ static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const unsigned int gappih    = 20;       /* horiz inner gap between windows */
+ static const unsigned int gappiv    = 10;       /* vert inner gap between windows */
+ static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+ static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+ static       int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+-static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static int showbar            = 1;        /* 0 means no bar */
++static int topbar             = 1;        /* 0 means bottom bar */
++static char font[]            = "monospace:size=10";
++static char dmenufont[]       = "monospace:size=10";
++static const char *fonts[]          = { font };
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
+ /* tagging */
+@@ -40,9 +42,9 @@ static const Rule rules[] = {
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+-static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static int nmaster     = 1;    /* number of clients in master area */
++static int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ #define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+@@ -82,9 +84,30 @@ static const Layout layouts[] = {
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",               STRING,  &font },
++		{ "dmenufont",          STRING,  &dmenufont },
++		{ "normbgcolor",        STRING,  &normbgcolor },
++		{ "normbordercolor",    STRING,  &normbordercolor },
++		{ "normfgcolor",        STRING,  &normfgcolor },
++		{ "selbgcolor",         STRING,  &selbgcolor },
++		{ "selbordercolor",     STRING,  &selbordercolor },
++		{ "selfgcolor",         STRING,  &selfgcolor },
++		{ "borderpx",          	INTEGER, &borderpx },
++		{ "snap",          		INTEGER, &snap },
++		{ "showbar",          	INTEGER, &showbar },
++		{ "topbar",          	INTEGER, &topbar },
++		{ "nmaster",          	INTEGER, &nmaster },
++		{ "resizehints",       	INTEGER, &resizehints },
++		{ "mfact",      	 	FLOAT,   &mfact },
++};
++
+ static const Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+diff --git a/drw.c b/drw.c
+index c41e6af..6be5dee 100644
+--- a/drw.c
++++ b/drw.c
+@@ -181,7 +181,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 6471431..bdbf950 100644
+--- a/drw.h
++++ b/drw.h
+@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index a424e60..cb3067d 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -37,6 +37,7 @@
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
++#include <X11/Xresource.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+@@ -157,6 +158,19 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -258,6 +272,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
++static void load_xresources(void);
++static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
+ 
+ static pid_t getparentprocess(pid_t p);
+ static int isdescprocess(pid_t p, pid_t c);
+@@ -2717,6 +2733,60 @@ zoom(const Arg *arg)
+ 	pop(c);
+ }
+ 
++void
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char *sdst = NULL;
++	int *idst = NULL;
++	float *fdst = NULL;
++
++	sdst = dst;
++	idst = dst;
++	fdst = dst;
++
++	char fullname[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
++	fullname[sizeof(fullname) - 1] = '\0';
++
++	XrmGetResource(db, fullname, "*", &type, &ret);
++	if (!(ret.addr == NULL || strncmp("String", type, 64)))
++	{
++		switch (rtype) {
++		case STRING:
++			strcpy(sdst, ret.addr);
++			break;
++		case INTEGER:
++			*idst = strtoul(ret.addr, NULL, 10);
++			break;
++		case FLOAT:
++			*fdst = strtof(ret.addr, NULL);
++			break;
++		}
++	}
++}
++
++void
++load_xresources(void)
++{
++	Display *display;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	display = XOpenDisplay(NULL);
++	resm = XResourceManagerString(display);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LENGTH(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++	XCloseDisplay(display);
++}
++
+ int
+ main(int argc, char *argv[])
+ {
+@@ -2731,6 +2801,8 @@ main(int argc, char *argv[])
+ 	if (!(xcon = XGetXCBConnection(dpy)))
+ 		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
++	XrmInitialize();
++	load_xresources();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec ps", NULL) == -1)
diff --git a/vanitygaps.c b/vanitygaps.c
new file mode 100644
index 0000000..5acce38
--- /dev/null
+++ b/vanitygaps.c
@@ -0,0 +1,837 @@
+/* Key binding functions */
+static void defaultgaps(const Arg *arg);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void togglebgaps(const Arg *arg);
+/* Layouts (delete the ones you do not need) */
+static void bstack(Monitor *m);
+static void bstackhoriz(Monitor *m);
+static void centeredmaster(Monitor *m);
+static void centeredfloatingmaster(Monitor *m);
+static void deck(Monitor *m);
+static void dwindle(Monitor *m);
+static void fibonacci(Monitor *m, int s);
+static void grid(Monitor *m);
+static void nrowgrid(Monitor *m);
+static void spiral(Monitor *m);
+static void tile(Monitor *m);
+/* Internals */
+static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+static void setgaps(int oh, int ov, int ih, int iv);
+
+/* Settings */
+#if !PERTAG_PATCH
+static int enablegaps = 1;
+#endif // PERTAG_PATCH
+
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	#if PERTAG_PATCH
+	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	enablegaps = !enablegaps;
+	#endif // PERTAG_PATCH
+	arrange(NULL);
+}
+
+static void
+togglebgaps(const Arg *arg)
+{
+    browsergaps = !browsergaps;
+    arrange(NULL);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+{
+	unsigned int n, oe, ie;
+	#if PERTAG_PATCH
+	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	oe = ie = enablegaps;
+	#endif // PERTAG_PATCH
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (smartgaps && n == 1) {
+		oe = 0; // outer gaps disabled when only one client
+	}
+
+    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+        if (TAGMASK == (1 << 8)){
+            setgaps(gappoh, gappov, gappih, gappiv);
+        }
+    }
+
+	*oh = m->gappoh*oe; // outer horizontal gap
+	*ov = m->gappov*oe; // outer vertical gap
+	*ih = m->gappih*ie; // inner horizontal gap
+	*iv = m->gappiv*ie; // inner vertical gap
+	*nc = n;            // number of clients
+}
+
+void
+getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+{
+	unsigned int n;
+	float mfacts = 0, sfacts = 0;
+	int mtotal = 0, stotal = 0;
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mtotal += msize * (c->cfact / mfacts);
+		else
+			stotal += ssize * (c->cfact / sfacts);
+
+	*mf = mfacts; // total factor of master area
+	*sf = sfacts; // total factor of stack area
+	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
+}
+
+/***
+ * Layouts
+ */
+
+/*
+ * Bottomstack layout + gaps
+ * https://dwm.suckless.org/patches/bottomstack/
+ */
+static void
+bstack(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sx = mx;
+		sy = my + mh + ih;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+	}
+}
+
+static void
+bstackhoriz(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh;
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+	}
+
+	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+	}
+}
+
+/*
+ * Centred master layout + gaps
+ * https://dwm.suckless.org/patches/centeredmaster/
+ */
+void
+centeredmaster(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int lx = 0, ly = 0, lw = 0, lh = 0;
+	int rx = 0, ry = 0, rw = 0, rh = 0;
+	float mfacts = 0, lfacts = 0, rfacts = 0;
+	int mtotal = 0, ltotal = 0, rtotal = 0;
+	int mrest = 0, lrest = 0, rrest = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* initialize areas */
+	mx = m->wx + ov;
+	my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+	mw = m->ww - 2*ov;
+	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+
+	if (m->nmaster && n > m->nmaster) {
+		/* go mfact box in the center if more than nmaster clients */
+		if (n - m->nmaster > 1) {
+			/* ||<-S->|<---M--->|<-S->|| */
+			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+			mx += lw + iv;
+		} else {
+			/* ||<---M--->|<-S->|| */
+			mw = (mw - iv) * m->mfact;
+			lw = 0;
+			rw = m->ww - mw - iv - 2*ov;
+		}
+		lx = m->wx + ov;
+		ly = m->wy + oh;
+		rx = mx + mw + iv;
+		ry = m->wy + oh;
+	}
+
+	/* calculate facts */
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+		if (!m->nmaster || n < m->nmaster)
+			mfacts += c->cfact;
+		else if ((n - m->nmaster) % 2)
+			lfacts += c->cfact; // total factor of left hand stack area
+		else
+			rfacts += c->cfact; // total factor of right hand stack area
+	}
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (!m->nmaster || n < m->nmaster)
+			mtotal += mh * (c->cfact / mfacts);
+		else if ((n - m->nmaster) % 2)
+			ltotal += lh * (c->cfact / lfacts);
+		else
+			rtotal += rh * (c->cfact / rfacts);
+
+	mrest = mh - mtotal;
+	lrest = lh - ltotal;
+	rrest = rh - rtotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (!m->nmaster || i < m->nmaster) {
+			/* nmaster clients are stacked vertically, in the center of the screen */
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			/* stack clients are stacked vertically */
+			if ((i - m->nmaster) % 2 ) {
+				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+				ly += HEIGHT(c) + ih;
+			} else {
+				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+				ry += HEIGHT(c) + ih;
+			}
+		}
+	}
+}
+
+void
+centeredfloatingmaster(Monitor *m)
+{
+	unsigned int i, n;
+	float mfacts, sfacts;
+	float mivf = 1.0; // master inner vertical gap factor
+	int oh, ov, ih, iv, mrest, srest;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv*(n - 1);
+	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		mivf = 0.8;
+		/* go mfact box in the center if more than nmaster clients */
+		if (m->ww > m->wh) {
+			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * 0.9;
+		} else {
+			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * m->mfact;
+		}
+		mx = m->wx + (m->ww - mw) / 2;
+		my = m->wy + (m->wh - mh - 2*oh) / 2;
+
+		sx = m->wx + ov;
+		sy = m->wy + oh;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			/* nmaster clients are stacked horizontally, in the center of the screen */
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv*mivf;
+		} else {
+			/* stack clients are stacked horizontally */
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * Deck layout + gaps
+ * https://dwm.suckless.org/patches/deck/
+ */
+void
+deck(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	if (n - m->nmaster > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+		}
+}
+
+/*
+ * Fibonacci layout + gaps
+ * https://dwm.suckless.org/patches/fibonacci/
+ */
+void
+fibonacci(Monitor *m, int s)
+{
+	unsigned int i, n;
+	int nx, ny, nw, nh;
+	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	nx = m->wx + ov;
+	ny = m->wy + oh;
+	nw = m->ww - 2*ov;
+	nh = m->wh - 2*oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
+
+				if ((i % 4) == 2 && !s)
+					nx += nw + iv;
+				else if ((i % 4) == 3 && !s)
+					ny += nh + ih;
+			}
+
+			if ((i % 4) == 0) {
+				if (s) {
+					ny += nh + ih;
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
+					ny -= nh + ih;
+				}
+			}
+			else if ((i % 4) == 1) {
+				nx += nw + iv;
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
+				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
+			else if ((i % 4) == 3) {
+				if (s) {
+					nx += nw + iv;
+					nw -= wrest;
+				} else {
+					nw -= wrest;
+					nx -= nw + iv;
+					nh += hrest;
+				}
+			}
+			if (i == 0)	{
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
+				ny = m->wy + oh;
+			}
+			else if (i == 1)
+				nw = m->ww - nw - iv - 2*ov;
+			i++;
+		}
+
+		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+	}
+}
+
+void
+dwindle(Monitor *m)
+{
+	fibonacci(m, 1);
+}
+
+void
+spiral(Monitor *m)
+{
+	fibonacci(m, 0);
+}
+
+/*
+ * Gappless grid layout + gaps (ironically)
+ * https://dwm.suckless.org/patches/gaplessgrid/
+ */
+void
+gaplessgrid(Monitor *m)
+{
+	unsigned int i, n;
+	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* grid dimensions */
+	for (cols = 0; cols <= n/2; cols++)
+		if (cols*cols >= n)
+			break;
+	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+		cols = 2;
+	rows = n/cols;
+	cn = rn = 0; // reset column no, row no, client count
+
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	x = m->wx + ov;
+	y = m->wy + oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+		if (i/rows + 1 > cols - n%cols) {
+			rows = n/cols + 1;
+			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+		}
+		resize(c,
+			x,
+			y + rn*(ch + ih) + MIN(rn, rrest),
+			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+			0);
+		rn++;
+		if (rn >= rows) {
+			rn = 0;
+			x += cw + ih + (cn < crest ? 1 : 0);
+			cn++;
+		}
+	}
+}
+
+/*
+ * Gridmode layout + gaps
+ * https://dwm.suckless.org/patches/gridmode/
+ */
+void
+grid(Monitor *m)
+{
+	unsigned int i, n;
+	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* grid dimensions */
+	for (rows = 0; rows <= n/2; rows++)
+		if (rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		cc = i / rows;
+		cr = i % rows;
+		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+	}
+}
+
+/*
+ * Horizontal grid layout + gaps
+ * https://dwm.suckless.org/patches/horizgrid/
+ */
+void
+horizgrid(Monitor *m) {
+	Client *c;
+	unsigned int n, i;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	int ntop, nbottom = 1;
+	float mfacts = 0, sfacts = 0;
+	int mrest, srest, mtotal = 0, stotal = 0;
+
+	/* Count windows */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	if (n <= 2)
+		ntop = n;
+	else {
+		ntop = n / 2;
+		nbottom = n - ntop;
+	}
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	sw = mw = m->ww - 2*ov;
+
+	if (n > ntop) {
+		sh = (mh - ih) / 2;
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		mw = m->ww - 2*ov - iv * (ntop - 1);
+		sw = m->ww - 2*ov - iv * (nbottom - 1);
+	}
+
+	/* calculate facts */
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mtotal += mh * (c->cfact / mfacts);
+		else
+			stotal += sw * (c->cfact / sfacts);
+
+	mrest = mh - mtotal;
+	srest = sw - stotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * nrowgrid layout + gaps
+ * https://dwm.suckless.org/patches/nrowgrid/
+ */
+void
+nrowgrid(Monitor *m)
+{
+	unsigned int n;
+	int ri = 0, ci = 0;  /* counters */
+	int oh, ov, ih, iv;                         /* vanitygap settings */
+	unsigned int cx, cy, cw, ch;                /* client geometry */
+	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+	unsigned int cols, rows = m->nmaster + 1;
+	Client *c;
+
+	/* count clients */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* nothing to do here */
+	if (n == 0)
+		return;
+
+	/* force 2 clients to always split vertically */
+	if (FORCE_VSPLIT && n == 2)
+		rows = 1;
+
+	/* never allow empty rows */
+	if (n < rows)
+		rows = n;
+
+	/* define first row */
+	cols = n / rows;
+	uc = cols;
+	cy = m->wy + oh;
+	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+	uh = ch;
+
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+		if (ci == cols) {
+			uw = 0;
+			ci = 0;
+			ri++;
+
+			/* next row */
+			cols = (n - uc) / (rows - ri);
+			uc += cols;
+			cy = m->wy + oh + uh + ih;
+			uh += ch + ih;
+		}
+
+		cx = m->wx + ov + uw;
+		cw = (m->ww - 2*ov - uw) / (cols - ci);
+		uw += cw + iv;
+
+		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+	}
+}
+
+/*
+ * Default tile layout + gaps
+ */
+static void
+tile(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+}
