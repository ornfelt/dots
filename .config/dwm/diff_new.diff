diff --git a/README b/README
index 482b545..95d4fd0 100644
--- a/README
+++ b/README
@@ -1,13 +1,5 @@
-See patches in dir 'patches'.
-
-I also continously add fixes from suckless git log:
-https://git.suckless.org/
-https://dwm.suckless.org/
-
-============================
 dwm - dynamic window manager
 ============================
-
 dwm is an extremely fast, small, and dynamic window manager for X.
 
 
diff --git a/config.h b/config.h
index 3d14213..ec7de9e 100644
--- a/config.h
+++ b/config.h
@@ -28,6 +28,7 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
 static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
 static int showbar              = 1;        /* 0 means no bar */
 static int topbar               = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
 /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
 /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
 static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
@@ -163,7 +164,6 @@ ResourcePref resources[] = {
 };
 
 #include <X11/XF86keysym.h>
-#include "shiftview.c"
 
 static const Key keys[] = {
     /*  modifier                    key                 function            argument */
diff --git a/dwm.c b/dwm.c
index 1ce4a38..6232799 100644
--- a/dwm.c
+++ b/dwm.c
@@ -62,8 +62,8 @@
 #define ISINC(X)                ((X) > 1000 && (X) < 3000)
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
 #define PREVSEL                 3000
-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
@@ -248,6 +248,8 @@ static void setcfact(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shiftview(const Arg *arg);
+static void shifttag(const Arg *arg);
 static void showhide(Client *c);
 static void sigstatusbar(const Arg *arg);
 static void spawn(const Arg *arg);
@@ -545,9 +547,8 @@ buttonpress(XEvent *e)
 
 	click = ClkRootWin;
 	/* focus monitor if necessary */
-	//if ((m = wintomon(ev->window)) && m != selmon
-	//    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
-    if ((m = wintomon(ev->window)) && m != selmon) {
+	if ((m = wintomon(ev->window)) && m != selmon
+	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
 		unfocus(selmon->sel, 1);
 		selmon = m;
 		focus(NULL);
@@ -566,12 +567,12 @@ buttonpress(XEvent *e)
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
-		} //else if (ev->x < x + TEXTW(selmon->ltsymbol))
-			//click = ClkLtSymbol;
-		//else
-		else if (ev->x > selmon->ww - statusw) {
+		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+			click = ClkLtSymbol;
+        } else if (ev->x > selmon->ww - statusw) {
             x = selmon->ww - statusw;
             click = ClkStatusText;
+
 			char *text, *s, ch;
 			statussig = 0;
 			for (text = s = stext; *s && x <= ev->x; s++) {
@@ -595,10 +596,8 @@ buttonpress(XEvent *e)
 					s--;
 				}
 			}
-		}
 	} else if ((c = wintoclient(ev->window))) {
-		//if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
-		//	focus(c);
+		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
 			focus(c);
 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
 		click = ClkClientWin;
@@ -858,119 +857,6 @@ dirtomon(int dir)
 	return m;
 }
 
-//int
-//drawstatusbar(Monitor *m, int bh, char* stext) {
-//	int ret, i, j, w, x, len;
-//	short isCode = 0;
-//	char *text;
-//	char *p;
-//
-//	len = strlen(stext) + 1 ;
-//	if (!(text = (char*) malloc(sizeof(char)*len)))
-//		die("malloc");
-//	p = text;
-//
-//	i = -1, j = 0;
-//	while (stext[++i])
-//		if ((unsigned char)stext[i] >= ' ')
-//			text[j++] = stext[i];
-//	text[j] = '\0';
-//
-//	/* compute width of the status text */
-//	w = 0;
-//	i = -1;
-//	while (text[++i]) {
-//		if (text[i] == '^') {
-//			if (!isCode) {
-//				isCode = 1;
-//				text[i] = '\0';
-//				w += TEXTW(text) - lrpad;
-//				text[i] = '^';
-//				if (text[++i] == 'f')
-//					w += atoi(text + ++i);
-//			} else {
-//				isCode = 0;
-//				text = text + i + 1;
-//				i = -1;
-//			}
-//		}
-//	}
-//	if (!isCode)
-//		w += TEXTW(text) - lrpad;
-//	else
-//		isCode = 0;
-//	text = p;
-//
-//	w += 2; /* 1px padding on both sides */
-//	ret = x = m->ww - w;
-//
-//	drw_setscheme(drw, scheme[LENGTH(colors)]);
-//	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-//	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-//	drw_rect(drw, x, 0, w, bh, 1, 1);
-//	x++;
-//
-//	/* process status text */
-//	i = -1;
-//	while (text[++i]) {
-//		if (text[i] == '^' && !isCode) {
-//			isCode = 1;
-//
-//			text[i] = '\0';
-//			w = TEXTW(text) - lrpad;
-//			drw_text(drw, x, 0, w, bh, 0, text, 0);
-//
-//			x += w;
-//
-//			/* process code */
-//			while (text[++i] != '^') {
-//				if (text[i] == 'c') {
-//					char buf[8];
-//					memcpy(buf, (char*)text+i+1, 7);
-//					buf[7] = '\0';
-//					drw_clr_create(drw, &drw->scheme[ColFg], buf);
-//					i += 7;
-//				} else if (text[i] == 'b') {
-//					char buf[8];
-//					memcpy(buf, (char*)text+i+1, 7);
-//					buf[7] = '\0';
-//					drw_clr_create(drw, &drw->scheme[ColBg], buf);
-//					i += 7;
-//				} else if (text[i] == 'd') {
-//					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-//					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-//				} else if (text[i] == 'r') {
-//					int rx = atoi(text + ++i);
-//					while (text[++i] != ',');
-//					int ry = atoi(text + ++i);
-//					while (text[++i] != ',');
-//					int rw = atoi(text + ++i);
-//					while (text[++i] != ',');
-//					int rh = atoi(text + ++i);
-//
-//					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
-//				} else if (text[i] == 'f') {
-//					x += atoi(text + ++i);
-//				}
-//			}
-//
-//			text = text + i + 1;
-//			i=-1;
-//			isCode = 0;
-//		}
-//	}
-//
-//	if (!isCode) {
-//		w = TEXTW(text) - lrpad;
-//		drw_text(drw, x, 0, w, bh, 0, text, 0);
-//	}
-//
-//	drw_setscheme(drw, scheme[SchemeNorm]);
-//	free(p);
-//
-//	return ret;
-//}
-
 int
 drawstatusbar(Monitor *m, int bh, char* stext)
 {
@@ -1093,130 +979,6 @@ drawstatusbar(Monitor *m, int bh, char* stext)
     return ret;
 }
 
-//typedef struct {
-//    char key;
-//    const char *color;
-//} ColorMapping;
-//
-//int is_hot_weather(const char *filepath) {
-//    FILE *ptr = fopen(filepath, "r");
-//    if (!ptr) {
-//        printf("Failed to read weather report...\n");
-//        return 0;
-//    }
-//
-//    char ch;
-//    int hot = 0;
-//    while ((ch = fgetc(ptr)) != EOF) {
-//        if (ch == '+') {
-//            hot = 1;
-//        } else if (hot && (ch == '2' || ch == '3') && fgetc(ptr) <= '9') {
-//            fclose(ptr);
-//            return 1; // Hot weather
-//        } else if (ch == '-') {
-//            fclose(ptr);
-//            return -1; // Cold weather
-//        }
-//    }
-//    fclose(ptr);
-//    return 0; // Neutral or unknown weather
-//}
-//
-//void set_color(char key, const char *weather_path, Drw *drw) {
-//    static const ColorMapping color_map[] = {
-//        {'3', col3}, {'4', col4}, {'5', col5}, {'6', col6}
-//    };
-//
-//    if (key == '2') {
-//        int weather_status = is_hot_weather(weather_path);
-//        if (weather_status > 0) {
-//            drw_clr_create(drw, &drw->scheme[ColFg], col21); // Hot
-//        } else if (weather_status < 0) {
-//            drw_clr_create(drw, &drw->scheme[ColFg], col23); // Cold
-//        } else {
-//            drw_clr_create(drw, &drw->scheme[ColFg], col24); // Neutral
-//        }
-//    } else {
-//        for (size_t i = 0; i < sizeof(color_map) / sizeof(color_map[0]); i++) {
-//            if (color_map[i].key == key) {
-//                drw_clr_create(drw, &drw->scheme[ColFg], color_map[i].color);
-//                return;
-//            }
-//        }
-//    }
-//}
-//
-//int drawstatusbar(Monitor *m, int bh, char *stext) {
-//    int ret, i, w, x, len;
-//    short isCode = 0;
-//    char *text, *p;
-//    
-//    len = strlen(stext) + 1;
-//    if (!(text = malloc(len))) die("malloc");
-//    p = text;
-//    memcpy(text, stext, len);
-//
-//    // Compute the width of the status text
-//    w = 0;
-//    for (i = 0; text[i]; i++) {
-//        if (text[i] == '^') {
-//            if (!isCode) {
-//                isCode = 1;
-//                text[i] = '\0';
-//                w += TEXTW(text) - lrpad;
-//                text[i] = '^';
-//                if (text[++i] == 'f')
-//                    w += atoi(text + ++i);
-//            } else {
-//                isCode = 0;
-//                text += i + 1;
-//                i = -1;
-//            }
-//        }
-//    }
-//    if (!isCode) w += TEXTW(text) - lrpad;
-//
-//    w += 2; // Padding
-//    ret = x = m->ww - w;
-//
-//    drw_setscheme(drw, scheme[LENGTH(colors)]);
-//    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-//    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-//    drw_rect(drw, x, 0, w, bh, 1, 1);
-//    x++;
-//
-//    // Process status text
-//    text = p;
-//    for (i = 0; text[i]; i++) {
-//        if (text[i] == '^' && !isCode) {
-//            isCode = 1;
-//
-//            text[i] = '\0';
-//            w = TEXTW(text) - lrpad;
-//            drw_text(drw, x, 0, w, bh, 0, text, 0);
-//            x += w;
-//
-//            while (text[++i] != '^') {
-//                set_color(text[i], "/home/jonas/.local/share/weatherreport", drw);
-//            }
-//
-//            text += i + 1;
-//            i = -1;
-//            isCode = 0;
-//        }
-//    }
-//
-//    if (!isCode) {
-//        w = TEXTW(text) - lrpad;
-//        drw_text(drw, x, 0, w, bh, 0, text, 0);
-//    }
-//
-//    drw_setscheme(drw, scheme[SchemeNorm]);
-//    free(p);
-//
-//    return ret;
-//}
-
 void
 drawbar(Monitor *m)
 {
@@ -2166,6 +1928,40 @@ setlayout(const Arg *arg)
 		drawbar(selmon);
 }
 
+void
+shiftview(const Arg *arg) {
+	Arg shifted;
+
+	if(arg->i > 0) /* left circular shift */
+		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+
+	else /* right circular shift */
+		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+
+	view(&shifted);
+}
+
+void
+shifttag(const Arg *arg) {
+	Arg shifted;
+	Client *c;
+
+	if (!selmon->sel)
+		return;
+	c = selmon->sel;
+
+	if (arg->i > 0) /* left circular shift */
+		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+			^ (c->tags >> (LENGTH(tags) - arg->i));
+	else /* right circular shift */
+		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+			^ (c->tags << (LENGTH(tags) + arg->i));
+
+	toggletag(&shifted);
+}
+
 void
 setcfact(const Arg *arg) {
 	float f;
diff --git a/shiftview.c b/shiftview.c
deleted file mode 100644
index 7905a6d..0000000
--- a/shiftview.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/** Function to shift the current view to the left/right
- *
- * @param: "arg->i" stores the number of tags to shift right (positive value)
- *          or left (negative value)
- */
-void
-shiftview(const Arg *arg)
-{
-    Arg shifted;
-    Client *c;
-    unsigned int tagmask = 0;
-
-    for (c = selmon->clients; c; c = c->next)
-        if (!(c->tags & SPTAGMASK))
-            tagmask = tagmask | c->tags;
-
-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
-    if (arg->i > 0) /* left circular shift */
-        do {
-            shifted.ui = (shifted.ui << arg->i)
-                | (shifted.ui >> (LENGTH(tags) - arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-    else /* right circular shift */
-        do {
-            shifted.ui = (shifted.ui >> (- arg->i)
-                    | shifted.ui << (LENGTH(tags) + arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-
-    view(&shifted);
-}
-
-void
-shifttag(const Arg *arg)
-{
-    Arg a;
-    Client *c;
-    unsigned visible = 0;
-    int i = arg->i;
-    int count = 0;
-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
-
-    do {
-        if(i > 0) // left circular shift
-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
-
-        else // right circular shift
-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
-
-        // Check if tag is visible
-        for (c = selmon->clients; c && !visible; c = c->next)
-            if (nextseltags & c->tags) {
-                visible = 1;
-                break;
-            }
-        i += arg->i;
-    } while (!visible && ++count < 10);
-
-    if (count < 10) {
-        a.i = nextseltags;
-        tag(&a);
-    }
-}
diff --git a/vanitygaps.c b/vanitygaps.c
index 6f2407d..5acce38 100644
--- a/vanitygaps.c
+++ b/vanitygaps.c
@@ -162,6 +162,7 @@ getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
 	if (smartgaps && n == 1) {
 		oe = 0; // outer gaps disabled when only one client
 	}
+
     if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
         oe = 0; // outer gaps disabled when only one client (and it's Firefox)
         if (TAGMASK == (1 << 8)){
@@ -484,144 +485,82 @@ deck(Monitor *m)
  * Fibonacci layout + gaps
  * https://dwm.suckless.org/patches/fibonacci/
  */
-//void
-//fibonacci(Monitor *m, int s)
-//{
-//	unsigned int i, n;
-//	int nx, ny, nw, nh;
-//	int oh, ov, ih, iv;
-//	int nv, hrest = 0, wrest = 0, r = 1;
-//	Client *c;
-//
-//	getgaps(m, &oh, &ov, &ih, &iv, &n);
-//	if (n == 0)
-//		return;
-//
-//	nx = m->wx + ov;
-//	ny = m->wy + oh;
-//	nw = m->ww - 2*ov;
-//	nh = m->wh - 2*oh;
-//
-//	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
-//		if (r) {
-//			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
-//			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
-//				r = 0;
-//			}
-//			if (r && i < n - 1) {
-//				if (i % 2) {
-//					nv = (nh - ih) / 2;
-//					hrest = nh - 2*nv - ih;
-//					nh = nv;
-//				} else {
-//					nv = (nw - iv) / 2;
-//					wrest = nw - 2*nv - iv;
-//					nw = nv;
-//				}
-//
-//				if ((i % 4) == 2 && !s)
-//					nx += nw + iv;
-//				else if ((i % 4) == 3 && !s)
-//					ny += nh + ih;
-//			}
-//
-//			if ((i % 4) == 0) {
-//				if (s) {
-//					ny += nh + ih;
-//					nh += hrest;
-//				}
-//				else {
-//					nh -= hrest;
-//					ny -= nh + ih;
-//				}
-//			}
-//			else if ((i % 4) == 1) {
-//				nx += nw + iv;
-//				nw += wrest;
-//			}
-//			else if ((i % 4) == 2) {
-//				ny += nh + ih;
-//				nh += hrest;
-//				if (i < n - 1)
-//					nw += wrest;
-//			}
-//			else if ((i % 4) == 3) {
-//				if (s) {
-//					nx += nw + iv;
-//					nw -= wrest;
-//				} else {
-//					nw -= wrest;
-//					nx -= nw + iv;
-//					nh += hrest;
-//				}
-//			}
-//			if (i == 0)	{
-//				if (n != 1) {
-//					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
-//					wrest = 0;
-//				}
-//				ny = m->wy + oh;
-//			}
-//			else if (i == 1)
-//				nw = m->ww - nw - iv - 2*ov;
-//			i++;
-//		}
-//
-//		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
-//	}
-//}
-
-static void
+void
 fibonacci(Monitor *m, int s)
 {
 	unsigned int i, n;
 	int nx, ny, nw, nh;
 	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
 	Client *c;
 
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
 	nx = m->wx + ov;
-    ny = oh;
+	ny = m->wy + oh;
 	nw = m->ww - 2*ov;
 	nh = m->wh - 2*oh;
 
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
-        if ((i % 2 && nh / 2 > 2*c->bw)
-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
-            if (i < n - 1) {
-                if (i % 2)
-                    nh = (nh - ih) / 2;
-                else
-                    nw = (nw - iv) / 2;
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
 
 				if ((i % 4) == 2 && !s)
 					nx += nw + iv;
 				else if ((i % 4) == 3 && !s)
 					ny += nh + ih;
 			}
+
 			if ((i % 4) == 0) {
-                if (s)
+				if (s) {
 					ny += nh + ih;
-                else
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
 					ny -= nh + ih;
 				}
-            else if ((i % 4) == 1)
+			}
+			else if ((i % 4) == 1) {
 				nx += nw + iv;
-            else if ((i % 4) == 2)
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
 				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
 			else if ((i % 4) == 3) {
-                if (s)
+				if (s) {
 					nx += nw + iv;
-                else
+					nw -= wrest;
+				} else {
+					nw -= wrest;
 					nx -= nw + iv;
+					nh += hrest;
+				}
 			}
 			if (i == 0)	{
-                if (n != 1)
-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
 				ny = m->wy + oh;
 			}
 			else if (i == 1)
