diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..b099942
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,54 @@
+# Prerequisites
+*.d
+
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Linker output
+*.ilk
+*.map
+*.exp
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+*.idb
+*.pdb
+
+# Kernel Module Compile Results
+*.mod*
+*.cmd
+.tmp_versions/
+modules.order
+Module.symvers
+Mkfile.old
+dkms.conf
+a.out
+st
diff --git a/Makefile b/Makefile
index 15db421..dfcea0f 100644
--- a/Makefile
+++ b/Makefile
@@ -4,7 +4,7 @@
 
 include config.mk
 
-SRC = st.c x.c
+SRC = st.c x.c hb.c
 OBJ = $(SRC:.c=.o)
 
 all: st
@@ -16,7 +16,8 @@ config.h:
 	$(CC) $(STCFLAGS) -c $<
 
 st.o: config.h st.h win.h
-x.o: arg.h config.h st.h win.h
+x.o: arg.h config.h st.h win.h hb.h
+hb.o: st.h
 
 $(OBJ): config.h config.mk
 
diff --git a/config.def.h b/config.def.h
index 2cd740a..3ede079 100644
--- a/config.def.h
+++ b/config.def.h
@@ -6,6 +6,12 @@
  * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
  */
 static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
+/* Spare fonts */
+static char *font2[] = {
+/*	"Inconsolata for Powerline:pixelsize=12:antialias=true:autohint=true", */
+/*	"Hack Nerd Font Mono:pixelsize=11:antialias=true:autohint=true", */
+};
+
 static int borderpx = 2;
 
 /*
@@ -93,6 +99,12 @@ char *termname = "st-256color";
  */
 unsigned int tabspaces = 8;
 
+/* bg opacity */
+float alpha = 0.8;
+
+/* Background opacity */
+float alpha_def;
+
 /* Terminal colors (16 first used in escape sequence) */
 static const char *colorname[] = {
 	/* 8 normal colors */
@@ -170,6 +182,42 @@ static unsigned int defaultattr = 11;
  */
 static uint forcemousemod = ShiftMask;
 
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+		{ "font",         STRING,  &font },
+		{ "color0",       STRING,  &colorname[0] },
+		{ "color1",       STRING,  &colorname[1] },
+		{ "color2",       STRING,  &colorname[2] },
+		{ "color3",       STRING,  &colorname[3] },
+		{ "color4",       STRING,  &colorname[4] },
+		{ "color5",       STRING,  &colorname[5] },
+		{ "color6",       STRING,  &colorname[6] },
+		{ "color7",       STRING,  &colorname[7] },
+		{ "color8",       STRING,  &colorname[8] },
+		{ "color9",       STRING,  &colorname[9] },
+		{ "color10",      STRING,  &colorname[10] },
+		{ "color11",      STRING,  &colorname[11] },
+		{ "color12",      STRING,  &colorname[12] },
+		{ "color13",      STRING,  &colorname[13] },
+		{ "color14",      STRING,  &colorname[14] },
+		{ "color15",      STRING,  &colorname[15] },
+		{ "background",   STRING,  &colorname[256] },
+		{ "foreground",   STRING,  &colorname[257] },
+		{ "cursorColor",  STRING,  &colorname[258] },
+		{ "termname",     STRING,  &termname },
+		{ "shell",        STRING,  &shell },
+		{ "minlatency",   INTEGER, &minlatency },
+		{ "maxlatency",   INTEGER, &maxlatency },
+		{ "blinktimeout", INTEGER, &blinktimeout },
+		{ "bellvolume",   INTEGER, &bellvolume },
+		{ "tabspaces",    INTEGER, &tabspaces },
+		{ "borderpx",     INTEGER, &borderpx },
+		{ "cwscale",      FLOAT,   &cwscale },
+		{ "chscale",      FLOAT,   &chscale },
+};
+
 /*
  * Internal mouse shortcuts.
  * Beware that overloading Button1 will disable the selection.
@@ -201,6 +249,8 @@ static Shortcut shortcuts[] = {
 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
+    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
 };
 
 /*
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..b1a6cbb
--- /dev/null
+++ b/config.h
@@ -0,0 +1,560 @@
+/* See LICENSE file for copyright and license details. */
+
+/*
+ * appearance
+ *
+ * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
+ */
+/* static char *font = "mono:pixelsize=12:antialias=true:autohint=true"; */
+/* static char *font2[] = { "NotoColorEmoji:pixelsize=10:antialias=true:autohint=true" }; */
+static char *font = "JetBrainsMono Nerd Font:size=11:style=regular:antialias=true:autohint=true";
+/* static char *font2[] = { "JoyPixels:pixelsize=10:antialias=true:autohint=true" }; */
+static char *font2[] = { "JetBrainsMono Nerd Font:size=11:style=regular:antialias=true:autohint=true" };
+/* static int borderpx = 16; */
+static int borderpx = 18;
+
+/*
+ * What program is execed by st depends of these precedence rules:
+ * 1: program passed with -e
+ * 2: scroll and/or utmp
+ * 3: SHELL environment variable
+ * 4: value of shell in /etc/passwd
+ * 5: value of shell in config.h
+ */
+static char *shell = "/bin/sh";
+char *utmp = NULL;
+/* scroll program: to enable use a string like "scroll" */
+char *scroll = NULL;
+char *stty_args = "stty raw pass8 nl -echo -iexten -cstopb 38400";
+
+/* identification sequence returned in DA and DECID */
+char *vtiden = "\033[?6c";
+
+/* Kerning / character bounding-box multipliers */
+static float cwscale = 1.0;
+static float chscale = 1.0;
+
+/*
+ * word delimiter string
+ *
+ * More advanced example: L" `'\"()[]{}"
+ */
+wchar_t *worddelimiters = L" ";
+
+/* selection timeouts (in milliseconds) */
+static unsigned int doubleclicktimeout = 300;
+static unsigned int tripleclicktimeout = 600;
+
+/* alt screens */
+int allowaltscreen = 1;
+
+/* allow certain non-interactive (insecure) window operations such as:
+   setting the clipboard text */
+int allowwindowops = 0;
+
+/*
+ * draw latency range in ms - from new content/keypress/etc until drawing.
+ * within this range, st draws when content stops arriving (idle). mostly it's
+ * near minlatency, but it waits longer for slow updates to avoid partial draw.
+ * low minlatency will tear/flicker more, as it can "detect" idle too early.
+ */
+static double minlatency = 8;
+static double maxlatency = 33;
+
+/*
+ * blinking timeout (set to 0 to disable blinking) for the terminal blinking
+ * attribute.
+ */
+static unsigned int blinktimeout = 800;
+
+/*
+ * thickness of underline and bar cursors
+ */
+static unsigned int cursorthickness = 2;
+
+/*
+ * 1: render most of the lines/blocks characters without using the font for
+ *    perfect alignment between cells (U2500 - U259F except dashes/diagonals).
+ *    Bold affects lines thickness if boxdraw_bold is not 0. Italic is ignored.
+ * 0: disable (render all U25XX glyphs normally from the font).
+ */
+const int boxdraw = 1;
+const int boxdraw_bold = 0;
+
+/* braille (U28XX):  1: render as adjacent "pixels",  0: use font */
+const int boxdraw_braille = 0;
+
+/*
+ * bell volume. It must be a value between -100 and 100. Use 0 for disabling
+ * it
+ */
+static int bellvolume = 0;
+
+/* default TERM value */
+char *termname = "st-256color";
+
+/*
+ * spaces per tab
+ *
+ * When you are changing this value, don't forget to adapt the »it« value in
+ * the st.info and appropriately install the st.info in the environment where
+ * you use this st version.
+ *
+ *	it#$tabspaces,
+ *
+ * Secondly make sure your kernel is not expanding tabs. When running `stty
+ * -a` »tab0« should appear. You can tell the terminal to not expand tabs by
+ *  running following command:
+ *
+ *	stty tabs
+ */
+unsigned int tabspaces = 8;
+
+/* bg opacity */
+float alpha = 1.0;
+float alphaOffset = 0.0;
+float alphaUnfocus;
+
+/* Terminal colors (16 first used in escape sequence) */
+static const char *colorname[] = {
+    "#282828", /* hard contrast: #1d2021 / soft contrast: #32302f */
+    "#cc241d",
+    "#98971a",
+    "#d79921",
+    "#458588",
+    "#b16286",
+    "#689d6a",
+    "#a89984",
+    "#928374",
+    "#fb4934",
+    "#b8bb26",
+    "#fabd2f",
+    "#83a598",
+    "#d3869b",
+    "#8ec07c",
+    "#ebdbb2",
+    [255] = 0,
+    /* more colors can be added after 255 to use with DefaultXX */
+    "#add8e6", /* 256 -> cursor */
+    "#555555", /* 257 -> rev cursor*/
+    "#282828", /* 258 -> bg */
+    "#ebdbb2", /* 259 -> fg */
+    "black", /* 260 -> alphaBg */
+};
+
+/*
+ * Default colors (colorname index)
+ * foreground, background, cursor, reverse cursor
+ */
+unsigned int defaultfg = 259;
+unsigned int defaultbg = 258;
+unsigned int alphaBg = 260;
+unsigned int defaultAlphaBg = 258;
+unsigned int defaultcs = 256;
+unsigned int defaultrcs = 257;
+
+/*
+ * Default shape of cursor
+ * 2: Block ("█")
+ * 4: Underline ("_")
+ * 6: Bar ("|")
+ * 7: Snowman ("☃")
+ */
+static unsigned int cursorshape = 2;
+
+/*
+ * Default columns and rows numbers
+ */
+
+static unsigned int cols = 80;
+static unsigned int rows = 24;
+
+/*
+ * Default colour and shape of the mouse cursor
+ */
+static unsigned int mouseshape = XC_xterm;
+static unsigned int mousefg = 7;
+static unsigned int mousebg = 0;
+
+/*
+ * Color used to display font attributes when fontconfig selected a font which
+ * doesn't match the ones requested.
+ */
+static unsigned int defaultattr = 11;
+
+/*
+ * Force mouse select/shortcuts while mask is active (when MODE_MOUSE is set).
+ * Note that if you want to use ShiftMask with selmasks, set this to an other
+ * modifier, set to 0 to not use it.
+ */
+static uint forcemousemod = ShiftMask;
+
+/*
+ * Xresources preferences to load at startup
+ */
+ResourcePref resources[] = {
+    { "font",         STRING,  &font },
+    { "fontalt0",     STRING,  &font2[0] },
+    { "color0",       STRING,  &colorname[0] },
+    { "color1",       STRING,  &colorname[1] },
+    { "color2",       STRING,  &colorname[2] },
+    { "color3",       STRING,  &colorname[3] },
+    { "color4",       STRING,  &colorname[4] },
+    { "color5",       STRING,  &colorname[5] },
+    { "color6",       STRING,  &colorname[6] },
+    { "color7",       STRING,  &colorname[7] },
+    { "color8",       STRING,  &colorname[8] },
+    { "color9",       STRING,  &colorname[9] },
+    { "color10",      STRING,  &colorname[10] },
+    { "color11",      STRING,  &colorname[11] },
+    { "color12",      STRING,  &colorname[12] },
+    { "color13",      STRING,  &colorname[13] },
+    { "color14",      STRING,  &colorname[14] },
+    { "color15",      STRING,  &colorname[15] },
+    { "background",   STRING,  &colorname[258] },
+    { "foreground",   STRING,  &colorname[259] },
+    { "cursorColor",  STRING,  &colorname[256] },
+    { "termname",     STRING,  &termname },
+    { "shell",        STRING,  &shell },
+    { "minlatency",   INTEGER, &minlatency },
+    { "maxlatency",   INTEGER, &maxlatency },
+    { "blinktimeout", INTEGER, &blinktimeout },
+    { "bellvolume",   INTEGER, &bellvolume },
+    { "tabspaces",    INTEGER, &tabspaces },
+    { "borderpx",     INTEGER, &borderpx },
+    { "cwscale",      FLOAT,   &cwscale },
+    { "chscale",      FLOAT,   &chscale },
+    { "alpha",        FLOAT,   &alpha },
+    { "alphaOffset",  FLOAT,   &alphaOffset },
+};
+
+/*
+ * Internal mouse shortcuts.
+ * Beware that overloading Button1 will disable the selection.
+ */
+static MouseShortcut mshortcuts[] = {
+    /* mask                 button   function        argument       release */
+    { XK_NO_MOD,            Button4, kscrollup,      {.i = 1} },
+    { XK_NO_MOD,            Button5, kscrolldown,    {.i = 1} },
+    { XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
+    { ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
+    { XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
+    { ShiftMask,            Button5, ttysend,        {.s = "\033[6;2~"} },
+    { XK_ANY_MOD,           Button5, ttysend,        {.s = "\005"} },
+};
+
+/* Internal keyboard shortcuts. */
+#define MODKEY Mod1Mask
+#define TERMMOD (Mod1Mask|ShiftMask)
+
+static char *openurlcmd[] = { "/bin/sh", "-c", "st-urlhandler -o", "externalpipe", NULL };
+static char *copyurlcmd[] = { "/bin/sh", "-c", "st-urlhandler -c", "externalpipe", NULL };
+static char *copyoutput[] = { "/bin/sh", "-c", "st-copyout", "externalpipe", NULL };
+
+static Shortcut shortcuts[] = {
+    /* mask                 keysym          function        argument */
+    { XK_ANY_MOD,           XK_Break,       sendbreak,      {.i =  0} },
+    { ControlMask,          XK_Print,       toggleprinter,  {.i =  0} },
+    { ShiftMask,            XK_Print,       printscreen,    {.i =  0} },
+    { XK_ANY_MOD,           XK_Print,       printsel,       {.i =  0} },
+    { TERMMOD,              XK_Prior,       zoom,           {.f = +1} },
+    { TERMMOD,              XK_Next,        zoom,           {.f = -1} },
+    { TERMMOD,              XK_Home,        zoomreset,      {.f =  0} },
+    { TERMMOD,              XK_C,           clipcopy,       {.i =  0} },
+    { MODKEY|ControlMask,   XK_c,           clipcopy,       {.i =  0} },
+    { TERMMOD,              XK_V,           clippaste,      {.i =  0} },
+    { ShiftMask,            XK_Insert,      clippaste,      {.i =  0} },
+    { MODKEY,               XK_v,           clippaste,      {.i =  0} },
+    { ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
+    { TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+    { ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
+    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
+    { MODKEY,               XK_Page_Up,     kscrollup,      {.i = -1} },
+    { MODKEY,               XK_Page_Down,   kscrolldown,    {.i = -1} },
+    { MODKEY,               XK_Up,          kscrollup,      {.i =  1} },
+    { MODKEY,               XK_Down,        kscrolldown,    {.i =  1} },
+    { TERMMOD,				XK_K,           kscrollup,      {.i =  1} },
+    { TERMMOD,				XK_J,           kscrolldown,    {.i =  1} },
+    { TERMMOD,				XK_S,			changealpha,	{.f = -0.05} },
+    { TERMMOD,				XK_A,			changealpha,	{.f = +0.05} },
+    { TERMMOD,              XK_Up,          zoom,           {.f = +1} },
+    { TERMMOD,              XK_Down,        zoom,           {.f = -1} },
+    { ControlMask,			XK_plus,        zoom,           {.f = +1} },
+    { ControlMask,			XK_minus,       zoom,           {.f = -1} },
+    { MODKEY,				XK_plus,        zoom,           {.f = +2} },
+    { MODKEY,				XK_minus,       zoom,           {.f = -2} },
+    { TERMMOD,              XK_L,           externalpipe,   {.v = openurlcmd } },
+    { TERMMOD,              XK_Y,           externalpipe,   {.v = copyurlcmd } },
+    { TERMMOD,              XK_O,           externalpipe,   {.v = copyoutput } },
+};
+
+/*
+ * Special keys (change & recompile st.info accordingly)
+ *
+ * Mask value:
+ * * Use XK_ANY_MOD to match the key no matter modifiers state
+ * * Use XK_NO_MOD to match the key alone (no modifiers)
+ * appkey value:
+ * * 0: no value
+ * * > 0: keypad application mode enabled
+ * *   = 2: term.numlock = 1
+ * * < 0: keypad application mode disabled
+ * appcursor value:
+ * * 0: no value
+ * * > 0: cursor application mode enabled
+ * * < 0: cursor application mode disabled
+ *
+ * Be careful with the order of the definitions because st searches in
+ * this table sequentially, so any XK_ANY_MOD must be in the last
+ * position for a key.
+ */
+
+/*
+ * If you want keys other than the X11 function keys (0xFD00 - 0xFFFF)
+ * to be mapped below, add them to this array.
+ */
+static KeySym mappedkeys[] = { -1 };
+
+/*
+ * State bits to ignore when matching key or button events.  By default,
+ * numlock (Mod2Mask) and keyboard layout (XK_SWITCH_MOD) are ignored.
+ */
+static uint ignoremod = Mod2Mask|XK_SWITCH_MOD;
+
+/*
+ * This is the huge key array which defines all compatibility to the Linux
+ * world. Please decide about changes wisely.
+ */
+static Key key[] = {
+    /* keysym           mask            string      appkey appcursor */
+    { XK_KP_Home,       ShiftMask,      "\033[2J",       0,   -1},
+    { XK_KP_Home,       ShiftMask,      "\033[1;2H",     0,   +1},
+    { XK_KP_Home,       XK_ANY_MOD,     "\033[H",        0,   -1},
+    { XK_KP_Home,       XK_ANY_MOD,     "\033[1~",       0,   +1},
+    { XK_KP_Up,         XK_ANY_MOD,     "\033Ox",       +1,    0},
+    { XK_KP_Up,         XK_ANY_MOD,     "\033[A",        0,   -1},
+    { XK_KP_Up,         XK_ANY_MOD,     "\033OA",        0,   +1},
+    { XK_KP_Down,       XK_ANY_MOD,     "\033Or",       +1,    0},
+    { XK_KP_Down,       XK_ANY_MOD,     "\033[B",        0,   -1},
+    { XK_KP_Down,       XK_ANY_MOD,     "\033OB",        0,   +1},
+    { XK_KP_Left,       XK_ANY_MOD,     "\033Ot",       +1,    0},
+    { XK_KP_Left,       XK_ANY_MOD,     "\033[D",        0,   -1},
+    { XK_KP_Left,       XK_ANY_MOD,     "\033OD",        0,   +1},
+    { XK_KP_Right,      XK_ANY_MOD,     "\033Ov",       +1,    0},
+    { XK_KP_Right,      XK_ANY_MOD,     "\033[C",        0,   -1},
+    { XK_KP_Right,      XK_ANY_MOD,     "\033OC",        0,   +1},
+    { XK_KP_Prior,      ShiftMask,      "\033[5;2~",     0,    0},
+    { XK_KP_Prior,      XK_ANY_MOD,     "\033[5~",       0,    0},
+    { XK_KP_Begin,      XK_ANY_MOD,     "\033[E",        0,    0},
+    { XK_KP_End,        ControlMask,    "\033[J",       -1,    0},
+    { XK_KP_End,        ControlMask,    "\033[1;5F",    +1,    0},
+    { XK_KP_End,        ShiftMask,      "\033[K",       -1,    0},
+    { XK_KP_End,        ShiftMask,      "\033[1;2F",    +1,    0},
+    { XK_KP_End,        XK_ANY_MOD,     "\033[4~",       0,    0},
+    { XK_KP_Next,       ShiftMask,      "\033[6;2~",     0,    0},
+    { XK_KP_Next,       XK_ANY_MOD,     "\033[6~",       0,    0},
+    { XK_KP_Insert,     ShiftMask,      "\033[2;2~",    +1,    0},
+    { XK_KP_Insert,     ShiftMask,      "\033[4l",      -1,    0},
+    { XK_KP_Insert,     ControlMask,    "\033[L",       -1,    0},
+    { XK_KP_Insert,     ControlMask,    "\033[2;5~",    +1,    0},
+    { XK_KP_Insert,     XK_ANY_MOD,     "\033[4h",      -1,    0},
+    { XK_KP_Insert,     XK_ANY_MOD,     "\033[2~",      +1,    0},
+    { XK_KP_Delete,     ControlMask,    "\033[M",       -1,    0},
+    { XK_KP_Delete,     ControlMask,    "\033[3;5~",    +1,    0},
+    { XK_KP_Delete,     ShiftMask,      "\033[2K",      -1,    0},
+    { XK_KP_Delete,     ShiftMask,      "\033[3;2~",    +1,    0},
+    { XK_KP_Delete,     XK_ANY_MOD,     "\033[P",       -1,    0},
+    { XK_KP_Delete,     XK_ANY_MOD,     "\033[3~",      +1,    0},
+    { XK_KP_Multiply,   XK_ANY_MOD,     "\033Oj",       +2,    0},
+    { XK_KP_Add,        XK_ANY_MOD,     "\033Ok",       +2,    0},
+    { XK_KP_Enter,      XK_ANY_MOD,     "\033OM",       +2,    0},
+    { XK_KP_Enter,      XK_ANY_MOD,     "\r",           -1,    0},
+    { XK_KP_Subtract,   XK_ANY_MOD,     "\033Om",       +2,    0},
+    { XK_KP_Decimal,    XK_ANY_MOD,     "\033On",       +2,    0},
+    { XK_KP_Divide,     XK_ANY_MOD,     "\033Oo",       +2,    0},
+    { XK_KP_0,          XK_ANY_MOD,     "\033Op",       +2,    0},
+    { XK_KP_1,          XK_ANY_MOD,     "\033Oq",       +2,    0},
+    { XK_KP_2,          XK_ANY_MOD,     "\033Or",       +2,    0},
+    { XK_KP_3,          XK_ANY_MOD,     "\033Os",       +2,    0},
+    { XK_KP_4,          XK_ANY_MOD,     "\033Ot",       +2,    0},
+    { XK_KP_5,          XK_ANY_MOD,     "\033Ou",       +2,    0},
+    { XK_KP_6,          XK_ANY_MOD,     "\033Ov",       +2,    0},
+    { XK_KP_7,          XK_ANY_MOD,     "\033Ow",       +2,    0},
+    { XK_KP_8,          XK_ANY_MOD,     "\033Ox",       +2,    0},
+    { XK_KP_9,          XK_ANY_MOD,     "\033Oy",       +2,    0},
+    { XK_Up,            ShiftMask,      "\033[1;2A",     0,    0},
+    { XK_Up,            Mod1Mask,       "\033[1;3A",     0,    0},
+    { XK_Up,         ShiftMask|Mod1Mask,"\033[1;4A",     0,    0},
+    { XK_Up,            ControlMask,    "\033[1;5A",     0,    0},
+    { XK_Up,      ShiftMask|ControlMask,"\033[1;6A",     0,    0},
+    { XK_Up,       ControlMask|Mod1Mask,"\033[1;7A",     0,    0},
+    { XK_Up,ShiftMask|ControlMask|Mod1Mask,"\033[1;8A",  0,    0},
+    { XK_Up,            XK_ANY_MOD,     "\033[A",        0,   -1},
+    { XK_Up,            XK_ANY_MOD,     "\033OA",        0,   +1},
+    { XK_Down,          ShiftMask,      "\033[1;2B",     0,    0},
+    { XK_Down,          Mod1Mask,       "\033[1;3B",     0,    0},
+    { XK_Down,       ShiftMask|Mod1Mask,"\033[1;4B",     0,    0},
+    { XK_Down,          ControlMask,    "\033[1;5B",     0,    0},
+    { XK_Down,    ShiftMask|ControlMask,"\033[1;6B",     0,    0},
+    { XK_Down,     ControlMask|Mod1Mask,"\033[1;7B",     0,    0},
+    { XK_Down,ShiftMask|ControlMask|Mod1Mask,"\033[1;8B",0,    0},
+    { XK_Down,          XK_ANY_MOD,     "\033[B",        0,   -1},
+    { XK_Down,          XK_ANY_MOD,     "\033OB",        0,   +1},
+    { XK_Left,          ShiftMask,      "\033[1;2D",     0,    0},
+    { XK_Left,          Mod1Mask,       "\033[1;3D",     0,    0},
+    { XK_Left,       ShiftMask|Mod1Mask,"\033[1;4D",     0,    0},
+    { XK_Left,          ControlMask,    "\033[1;5D",     0,    0},
+    { XK_Left,    ShiftMask|ControlMask,"\033[1;6D",     0,    0},
+    { XK_Left,     ControlMask|Mod1Mask,"\033[1;7D",     0,    0},
+    { XK_Left,ShiftMask|ControlMask|Mod1Mask,"\033[1;8D",0,    0},
+    { XK_Left,          XK_ANY_MOD,     "\033[D",        0,   -1},
+    { XK_Left,          XK_ANY_MOD,     "\033OD",        0,   +1},
+    { XK_Right,         ShiftMask,      "\033[1;2C",     0,    0},
+    { XK_Right,         Mod1Mask,       "\033[1;3C",     0,    0},
+    { XK_Right,      ShiftMask|Mod1Mask,"\033[1;4C",     0,    0},
+    { XK_Right,         ControlMask,    "\033[1;5C",     0,    0},
+    { XK_Right,   ShiftMask|ControlMask,"\033[1;6C",     0,    0},
+    { XK_Right,    ControlMask|Mod1Mask,"\033[1;7C",     0,    0},
+    { XK_Right,ShiftMask|ControlMask|Mod1Mask,"\033[1;8C",0,   0},
+    { XK_Right,         XK_ANY_MOD,     "\033[C",        0,   -1},
+    { XK_Right,         XK_ANY_MOD,     "\033OC",        0,   +1},
+    { XK_ISO_Left_Tab,  ShiftMask,      "\033[Z",        0,    0},
+    { XK_Return,        Mod1Mask,       "\033\r",        0,    0},
+    { XK_Return,        XK_ANY_MOD,     "\r",            0,    0},
+    { XK_Insert,        ShiftMask,      "\033[4l",      -1,    0},
+    { XK_Insert,        ShiftMask,      "\033[2;2~",    +1,    0},
+    { XK_Insert,        ControlMask,    "\033[L",       -1,    0},
+    { XK_Insert,        ControlMask,    "\033[2;5~",    +1,    0},
+    { XK_Insert,        XK_ANY_MOD,     "\033[4h",      -1,    0},
+    { XK_Insert,        XK_ANY_MOD,     "\033[2~",      +1,    0},
+    { XK_Delete,        ControlMask,    "\033[M",       -1,    0},
+    { XK_Delete,        ControlMask,    "\033[3;5~",    +1,    0},
+    { XK_Delete,        ShiftMask,      "\033[2K",      -1,    0},
+    { XK_Delete,        ShiftMask,      "\033[3;2~",    +1,    0},
+    { XK_Delete,        XK_ANY_MOD,     "\033[P",       -1,    0},
+    { XK_Delete,        XK_ANY_MOD,     "\033[3~",      +1,    0},
+    { XK_BackSpace,     XK_NO_MOD,      "\177",          0,    0},
+    { XK_BackSpace,     Mod1Mask,       "\033\177",      0,    0},
+    { XK_Home,          ShiftMask,      "\033[2J",       0,   -1},
+    { XK_Home,          ShiftMask,      "\033[1;2H",     0,   +1},
+    { XK_Home,          XK_ANY_MOD,     "\033[H",        0,   -1},
+    { XK_Home,          XK_ANY_MOD,     "\033[1~",       0,   +1},
+    { XK_End,           ControlMask,    "\033[J",       -1,    0},
+    { XK_End,           ControlMask,    "\033[1;5F",    +1,    0},
+    { XK_End,           ShiftMask,      "\033[K",       -1,    0},
+    { XK_End,           ShiftMask,      "\033[1;2F",    +1,    0},
+    { XK_End,           XK_ANY_MOD,     "\033[4~",       0,    0},
+    { XK_Prior,         ControlMask,    "\033[5;5~",     0,    0},
+    { XK_Prior,         ShiftMask,      "\033[5;2~",     0,    0},
+    { XK_Prior,         XK_ANY_MOD,     "\033[5~",       0,    0},
+    { XK_Next,          ControlMask,    "\033[6;5~",     0,    0},
+    { XK_Next,          ShiftMask,      "\033[6;2~",     0,    0},
+    { XK_Next,          XK_ANY_MOD,     "\033[6~",       0,    0},
+    { XK_F1,            XK_NO_MOD,      "\033OP" ,       0,    0},
+    { XK_F1, /* F13 */  ShiftMask,      "\033[1;2P",     0,    0},
+    { XK_F1, /* F25 */  ControlMask,    "\033[1;5P",     0,    0},
+    { XK_F1, /* F37 */  Mod4Mask,       "\033[1;6P",     0,    0},
+    { XK_F1, /* F49 */  Mod1Mask,       "\033[1;3P",     0,    0},
+    { XK_F1, /* F61 */  Mod3Mask,       "\033[1;4P",     0,    0},
+    { XK_F2,            XK_NO_MOD,      "\033OQ" ,       0,    0},
+    { XK_F2, /* F14 */  ShiftMask,      "\033[1;2Q",     0,    0},
+    { XK_F2, /* F26 */  ControlMask,    "\033[1;5Q",     0,    0},
+    { XK_F2, /* F38 */  Mod4Mask,       "\033[1;6Q",     0,    0},
+    { XK_F2, /* F50 */  Mod1Mask,       "\033[1;3Q",     0,    0},
+    { XK_F2, /* F62 */  Mod3Mask,       "\033[1;4Q",     0,    0},
+    { XK_F3,            XK_NO_MOD,      "\033OR" ,       0,    0},
+    { XK_F3, /* F15 */  ShiftMask,      "\033[1;2R",     0,    0},
+    { XK_F3, /* F27 */  ControlMask,    "\033[1;5R",     0,    0},
+    { XK_F3, /* F39 */  Mod4Mask,       "\033[1;6R",     0,    0},
+    { XK_F3, /* F51 */  Mod1Mask,       "\033[1;3R",     0,    0},
+    { XK_F3, /* F63 */  Mod3Mask,       "\033[1;4R",     0,    0},
+    { XK_F4,            XK_NO_MOD,      "\033OS" ,       0,    0},
+    { XK_F4, /* F16 */  ShiftMask,      "\033[1;2S",     0,    0},
+    { XK_F4, /* F28 */  ControlMask,    "\033[1;5S",     0,    0},
+    { XK_F4, /* F40 */  Mod4Mask,       "\033[1;6S",     0,    0},
+    { XK_F4, /* F52 */  Mod1Mask,       "\033[1;3S",     0,    0},
+    { XK_F5,            XK_NO_MOD,      "\033[15~",      0,    0},
+    { XK_F5, /* F17 */  ShiftMask,      "\033[15;2~",    0,    0},
+    { XK_F5, /* F29 */  ControlMask,    "\033[15;5~",    0,    0},
+    { XK_F5, /* F41 */  Mod4Mask,       "\033[15;6~",    0,    0},
+    { XK_F5, /* F53 */  Mod1Mask,       "\033[15;3~",    0,    0},
+    { XK_F6,            XK_NO_MOD,      "\033[17~",      0,    0},
+    { XK_F6, /* F18 */  ShiftMask,      "\033[17;2~",    0,    0},
+    { XK_F6, /* F30 */  ControlMask,    "\033[17;5~",    0,    0},
+    { XK_F6, /* F42 */  Mod4Mask,       "\033[17;6~",    0,    0},
+    { XK_F6, /* F54 */  Mod1Mask,       "\033[17;3~",    0,    0},
+    { XK_F7,            XK_NO_MOD,      "\033[18~",      0,    0},
+    { XK_F7, /* F19 */  ShiftMask,      "\033[18;2~",    0,    0},
+    { XK_F7, /* F31 */  ControlMask,    "\033[18;5~",    0,    0},
+    { XK_F7, /* F43 */  Mod4Mask,       "\033[18;6~",    0,    0},
+    { XK_F7, /* F55 */  Mod1Mask,       "\033[18;3~",    0,    0},
+    { XK_F8,            XK_NO_MOD,      "\033[19~",      0,    0},
+    { XK_F8, /* F20 */  ShiftMask,      "\033[19;2~",    0,    0},
+    { XK_F8, /* F32 */  ControlMask,    "\033[19;5~",    0,    0},
+    { XK_F8, /* F44 */  Mod4Mask,       "\033[19;6~",    0,    0},
+    { XK_F8, /* F56 */  Mod1Mask,       "\033[19;3~",    0,    0},
+    { XK_F9,            XK_NO_MOD,      "\033[20~",      0,    0},
+    { XK_F9, /* F21 */  ShiftMask,      "\033[20;2~",    0,    0},
+    { XK_F9, /* F33 */  ControlMask,    "\033[20;5~",    0,    0},
+    { XK_F9, /* F45 */  Mod4Mask,       "\033[20;6~",    0,    0},
+    { XK_F9, /* F57 */  Mod1Mask,       "\033[20;3~",    0,    0},
+    { XK_F10,           XK_NO_MOD,      "\033[21~",      0,    0},
+    { XK_F10, /* F22 */ ShiftMask,      "\033[21;2~",    0,    0},
+    { XK_F10, /* F34 */ ControlMask,    "\033[21;5~",    0,    0},
+    { XK_F10, /* F46 */ Mod4Mask,       "\033[21;6~",    0,    0},
+    { XK_F10, /* F58 */ Mod1Mask,       "\033[21;3~",    0,    0},
+    { XK_F11,           XK_NO_MOD,      "\033[23~",      0,    0},
+    { XK_F11, /* F23 */ ShiftMask,      "\033[23;2~",    0,    0},
+    { XK_F11, /* F35 */ ControlMask,    "\033[23;5~",    0,    0},
+    { XK_F11, /* F47 */ Mod4Mask,       "\033[23;6~",    0,    0},
+    { XK_F11, /* F59 */ Mod1Mask,       "\033[23;3~",    0,    0},
+    { XK_F12,           XK_NO_MOD,      "\033[24~",      0,    0},
+    { XK_F12, /* F24 */ ShiftMask,      "\033[24;2~",    0,    0},
+    { XK_F12, /* F36 */ ControlMask,    "\033[24;5~",    0,    0},
+    { XK_F12, /* F48 */ Mod4Mask,       "\033[24;6~",    0,    0},
+    { XK_F12, /* F60 */ Mod1Mask,       "\033[24;3~",    0,    0},
+    { XK_F13,           XK_NO_MOD,      "\033[1;2P",     0,    0},
+    { XK_F14,           XK_NO_MOD,      "\033[1;2Q",     0,    0},
+    { XK_F15,           XK_NO_MOD,      "\033[1;2R",     0,    0},
+    { XK_F16,           XK_NO_MOD,      "\033[1;2S",     0,    0},
+    { XK_F17,           XK_NO_MOD,      "\033[15;2~",    0,    0},
+    { XK_F18,           XK_NO_MOD,      "\033[17;2~",    0,    0},
+    { XK_F19,           XK_NO_MOD,      "\033[18;2~",    0,    0},
+    { XK_F20,           XK_NO_MOD,      "\033[19;2~",    0,    0},
+    { XK_F21,           XK_NO_MOD,      "\033[20;2~",    0,    0},
+    { XK_F22,           XK_NO_MOD,      "\033[21;2~",    0,    0},
+    { XK_F23,           XK_NO_MOD,      "\033[23;2~",    0,    0},
+    { XK_F24,           XK_NO_MOD,      "\033[24;2~",    0,    0},
+    { XK_F25,           XK_NO_MOD,      "\033[1;5P",     0,    0},
+    { XK_F26,           XK_NO_MOD,      "\033[1;5Q",     0,    0},
+    { XK_F27,           XK_NO_MOD,      "\033[1;5R",     0,    0},
+    { XK_F28,           XK_NO_MOD,      "\033[1;5S",     0,    0},
+    { XK_F29,           XK_NO_MOD,      "\033[15;5~",    0,    0},
+    { XK_F30,           XK_NO_MOD,      "\033[17;5~",    0,    0},
+    { XK_F31,           XK_NO_MOD,      "\033[18;5~",    0,    0},
+    { XK_F32,           XK_NO_MOD,      "\033[19;5~",    0,    0},
+    { XK_F33,           XK_NO_MOD,      "\033[20;5~",    0,    0},
+    { XK_F34,           XK_NO_MOD,      "\033[21;5~",    0,    0},
+    { XK_F35,           XK_NO_MOD,      "\033[23;5~",    0,    0},
+};
+
+/*
+ * Selection types' masks.
+ * Use the same masks as usual.
+ * Button1Mask is always unset, to make masks match between ButtonPress.
+ * ButtonRelease and MotionNotify.
+ * If no match is found, regular selection is used.
+ */
+static uint selmasks[] = {
+    [SEL_RECTANGULAR] = Mod1Mask,
+};
+
+/*
+ * Printable characters in ASCII, used to estimate the advance width
+ * of single wide characters.
+ */
+static char ascii_printable[] =
+" !\"#$%&'()*+,-./0123456789:;<=>?"
+"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
+"`abcdefghijklmnopqrstuvwxyz{|}~";
+
diff --git a/config.mk b/config.mk
index fdc29a7..b6458af 100644
--- a/config.mk
+++ b/config.mk
@@ -15,10 +15,12 @@ PKG_CONFIG = pkg-config
 # includes and libs
 INCS = -I$(X11INC) \
        `$(PKG_CONFIG) --cflags fontconfig` \
-       `$(PKG_CONFIG) --cflags freetype2`
-LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft \
+       `$(PKG_CONFIG) --cflags freetype2` \
+       `$(PKG_CONFIG) --cflags harfbuzz`
+LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender \
        `$(PKG_CONFIG) --libs fontconfig` \
-       `$(PKG_CONFIG) --libs freetype2`
+       `$(PKG_CONFIG) --libs freetype2` \
+       `$(PKG_CONFIG) --libs harfbuzz`
 
 # flags
 STCPPFLAGS = -DVERSION=\"$(VERSION)\" -D_XOPEN_SOURCE=600
diff --git a/diff_bkp.diff b/diff_bkp.diff
new file mode 100644
index 0000000..b2cf7d5
--- /dev/null
+++ b/diff_bkp.diff
@@ -0,0 +1,10756 @@
+diff --git a/FAQ b/FAQ
+new file mode 100644
+index 0000000..6287a27
+--- /dev/null
++++ b/FAQ
+@@ -0,0 +1,253 @@
++## Why does st not handle utmp entries?
++
++Use the excellent tool of [utmp](https://git.suckless.org/utmp/) for this task.
++
++
++## Some _random program_ complains that st is unknown/not recognised/unsupported/whatever!
++
++It means that st doesn’t have any terminfo entry on your system. Chances are
++you did not `make install`. If you just want to test it without installing it,
++you can manually run `tic -sx st.info`.
++
++
++## Nothing works, and nothing is said about an unknown terminal!
++
++* Some programs just assume they’re running in xterm i.e. they don’t rely on
++  terminfo. What you see is the current state of the “xterm compliance”.
++* Some programs don’t complain about the lacking st description and default to
++  another terminal. In that case see the question about terminfo.
++
++
++## How do I scroll back up?
++
++* Using a terminal multiplexer.
++	* `st -e tmux` using C-b [
++	* `st -e screen` using C-a ESC
++* Using the excellent tool of [scroll](https://git.suckless.org/scroll/).
++* Using the scrollback [patch](https://st.suckless.org/patches/scrollback/).
++
++
++## I would like to have utmp and/or scroll functionality by default
++
++You can add the absolute path of both programs in your config.h file. You only
++have to modify the value of utmp and scroll variables.
++
++
++## Why doesn't the Del key work in some programs?
++
++Taken from the terminfo manpage:
++
++	If the terminal has a keypad that transmits codes when the keys
++	are pressed, this information can be given. Note that it is not
++	possible to handle terminals where the keypad only works in
++	local (this applies, for example, to the unshifted HP 2621 keys).
++	If the keypad can be set to transmit or not transmit, give these
++	codes as smkx and rmkx. Otherwise the keypad is assumed to
++	always transmit.
++
++In the st case smkx=E[?1hE= and rmkx=E[?1lE>, so it is mandatory that
++applications which want to test against keypad keys send these
++sequences.
++
++But buggy applications (like bash and irssi, for example) don't do this. A fast
++solution for them is to use the following command:
++
++	$ printf '\033[?1h\033=' >/dev/tty
++
++or
++	$ tput smkx
++
++In the case of bash, readline is used. Readline has a different note in its
++manpage about this issue:
++
++	enable-keypad (Off)
++		When set to On, readline will try to enable the
++		application keypad when it is called. Some systems
++		need this to enable arrow keys.
++
++Adding this option to your .inputrc will fix the keypad problem for all
++applications using readline.
++
++If you are using zsh, then read the zsh FAQ
++<http://zsh.sourceforge.net/FAQ/zshfaq03.html#l25>:
++
++	It should be noted that the O / [ confusion can occur with other keys
++	such as Home and End. Some systems let you query the key sequences
++	sent by these keys from the system's terminal database, terminfo.
++	Unfortunately, the key sequences given there typically apply to the
++	mode that is not the one zsh uses by default (it's the "application"
++	mode rather than the "raw" mode). Explaining the use of terminfo is
++	outside of the scope of this FAQ, but if you wish to use the key
++	sequences given there you can tell the line editor to turn on
++	"application" mode when it starts and turn it off when it stops:
++
++		function zle-line-init () { echoti smkx }
++		function zle-line-finish () { echoti rmkx }
++		zle -N zle-line-init
++		zle -N zle-line-finish
++
++Putting these lines into your .zshrc will fix the problems.
++
++
++## How can I use meta in 8bit mode?
++
++St supports meta in 8bit mode, but the default terminfo entry doesn't
++use this capability. If you want it, you have to use the 'st-meta' value
++in TERM.
++
++
++## I cannot compile st in OpenBSD
++
++OpenBSD lacks librt, despite it being mandatory in POSIX
++<http://pubs.opengroup.org/onlinepubs/9699919799/utilities/c99.html#tag_20_11_13>.
++If you want to compile st for OpenBSD you have to remove -lrt from config.mk, and
++st will compile without any loss of functionality, because all the functions are
++included in libc on this platform.
++
++
++## The Backspace Case
++
++St is emulating the Linux way of handling backspace being delete and delete being
++backspace.
++
++This is an issue that was discussed in suckless mailing list
++<https://lists.suckless.org/dev/1404/20697.html>. Here is why some old grumpy
++terminal users wants its backspace to be how he feels it:
++
++	Well, I am going to comment why I want to change the behaviour
++	of this key. When ASCII was defined in 1968, communication
++	with computers was done using punched cards, or hardcopy
++	terminals (basically a typewriter machine connected with the
++	computer using a serial port).  ASCII defines DELETE as 7F,
++	because, in punched-card terms, it means all the holes of the
++	card punched; it is thus a kind of 'physical delete'. In the
++	same way, the BACKSPACE key was a non-destructive backspace,
++	as on a typewriter.  So, if you wanted to delete a character,
++	you had to BACKSPACE and then DELETE.  Another use of BACKSPACE
++	was to type accented characters, for example 'a BACKSPACE `'.
++	The VT100 had no BACKSPACE key; it was generated using the
++	CONTROL key as another control character (CONTROL key sets to
++	0 b7 b6 b5, so it converts H (code 0x48) into BACKSPACE (code
++	0x08)), but it had a DELETE key in a similar position where
++	the BACKSPACE key is located today on common PC keyboards.
++	All the terminal emulators emulated the difference between
++	these keys correctly: the backspace key generated a BACKSPACE
++	(^H) and delete key generated a DELETE (^?).
++
++	But a problem arose when Linus Torvalds wrote Linux. Unlike
++	earlier terminals, the Linux virtual terminal (the terminal
++	emulator integrated in the kernel) returned a DELETE when
++	backspace was pressed, due to the VT100 having a DELETE key in
++	the same position.  This created a lot of problems (see [1]
++	and [2]). Since Linux has become the king, a lot of terminal
++	emulators today generate a DELETE when the backspace key is
++	pressed in order to avoid problems with Linux. The result is
++	that the only way of generating a BACKSPACE on these systems
++	is by using CONTROL + H. (I also think that emacs had an
++	important point here because the CONTROL + H prefix is used
++	in emacs in some commands (help commands).)
++
++	From point of view of the kernel, you can change the key
++	for deleting a previous character with stty erase. When you
++	connect a real terminal into a machine you describe the type
++	of terminal, so getty configures the correct value of stty
++	erase for this terminal. In the case of terminal emulators,
++	however, you don't have any getty that can set the correct
++	value of stty erase, so you always get the default value.
++	For this reason, it is necessary to add 'stty erase ^H' to your
++	profile if you have changed the value of the backspace key.
++	Of course, another solution is for st itself to modify the
++	value of stty erase.  I usually have the inverse problem:
++	when I connect to non-Unix machines, I have to press CONTROL +
++	h to get a BACKSPACE. The inverse problem occurs when a user
++	connects to my Unix machines from a different system with a
++	correct backspace key.
++
++	[1] http://www.ibb.net/~anne/keyboard.html
++	[2] http://www.tldp.org/HOWTO/Keyboard-and-Console-HOWTO-5.html
++
++
++## But I really want the old grumpy behaviour of my terminal
++
++Apply [1].
++
++[1] https://st.suckless.org/patches/delkey
++
++
++## Why do images not work in st using the w3m image hack?
++
++w3mimg uses a hack that draws an image on top of the terminal emulator Drawable
++window. The hack relies on the terminal to use a single buffer to draw its
++contents directly.
++
++st uses double-buffered drawing so the image is quickly replaced and may show a
++short flicker effect.
++
++Below is a patch example to change st double-buffering to a single Drawable
++buffer.
++
++diff --git a/x.c b/x.c
++--- a/x.c
+++++ b/x.c
++@@ -732,10 +732,6 @@ xresize(int col, int row)
++ 	win.tw = col * win.cw;
++ 	win.th = row * win.ch;
++ 
++-	XFreePixmap(xw.dpy, xw.buf);
++-	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++-			DefaultDepth(xw.dpy, xw.scr));
++-	XftDrawChange(xw.draw, xw.buf);
++ 	xclear(0, 0, win.w, win.h);
++ 
++ 	/* resize to new width */
++@@ -1148,8 +1144,7 @@ xinit(int cols, int rows)
++ 	gcvalues.graphics_exposures = False;
++ 	dc.gc = XCreateGC(xw.dpy, parent, GCGraphicsExposures,
++ 			&gcvalues);
++-	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++-			DefaultDepth(xw.dpy, xw.scr));
+++	xw.buf = xw.win;
++ 	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
++ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
++ 
++@@ -1632,8 +1627,6 @@ xdrawline(Line line, int x1, int y1, int x2)
++ void
++ xfinishdraw(void)
++ {
++-	XCopyArea(xw.dpy, xw.buf, xw.win, dc.gc, 0, 0, win.w,
++-			win.h, 0, 0);
++ 	XSetForeground(xw.dpy, dc.gc,
++ 			dc.col[IS_SET(MODE_REVERSE)?
++ 				defaultfg : defaultbg].pixel);
++
++
++## BadLength X error in Xft when trying to render emoji
++
++Xft makes st crash when rendering color emojis with the following error:
++
++"X Error of failed request:  BadLength (poly request too large or internal Xlib length error)"
++  Major opcode of failed request:  139 (RENDER)
++  Minor opcode of failed request:  20 (RenderAddGlyphs)
++  Serial number of failed request: 1595
++  Current serial number in output stream:  1818"
++
++This is a known bug in Xft (not st) which happens on some platforms and
++combination of particular fonts and fontconfig settings.
++
++See also:
++https://gitlab.freedesktop.org/xorg/lib/libxft/issues/6
++https://bugs.freedesktop.org/show_bug.cgi?id=107534
++https://bugzilla.redhat.com/show_bug.cgi?id=1498269
++
++The solution is to remove color emoji fonts or disable this in the fontconfig
++XML configuration.  As an ugly workaround (which may work only on newer
++fontconfig versions (FC_COLOR)), the following code can be used to mask color
++fonts:
++
++	FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
++
++Please don't bother reporting this bug to st, but notify the upstream Xft
++developers about fixing this bug.
++
++As of 2022-09-05 this now seems to be finally fixed in libXft 2.3.5:
++https://gitlab.freedesktop.org/xorg/lib/libxft/-/blob/libXft-2.3.5/NEWS
+diff --git a/LEGACY b/LEGACY
+new file mode 100644
+index 0000000..bf28b1e
+--- /dev/null
++++ b/LEGACY
+@@ -0,0 +1,17 @@
++A STATEMENT ON LEGACY SUPPORT
++
++In the terminal world there is much cruft that comes from old and unsup‐
++ported terminals that inherit incompatible modes  and  escape  sequences
++which noone is able to know, except when he/she comes from that time and
++developed a graphical vt100 emulator at that time.
++
++One  goal  of  st is to only support what is really needed. When you en‐
++counter a sequence which you really need, implement it.  But  while  you
++are  at it,  do not add the other cruft you might encounter while sneek‐
++ing at other terminal emulators. History has bloated them and  there  is
++no real evidence that most of the sequences are used today.
++
++
++Christoph Lohmann <20h@r-36.net>
++2012-09-13T07:00:36.081271045+02:00
++
+diff --git a/Makefile b/Makefile
+index 662ac6d..dfcea0f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -4,18 +4,20 @@
+ 
+ include config.mk
+ 
+-SRC = st.c x.c boxdraw.c hb.c
++SRC = st.c x.c hb.c
+ OBJ = $(SRC:.c=.o)
+ 
+ all: st
+ 
++config.h:
++	cp config.def.h config.h
++
+ .c.o:
+ 	$(CC) $(STCFLAGS) -c $<
+ 
+ st.o: config.h st.h win.h
+ x.o: arg.h config.h st.h win.h hb.h
+ hb.o: st.h
+-boxdraw.o: config.h st.h boxdraw_data.h
+ 
+ $(OBJ): config.h config.mk
+ 
+@@ -23,12 +25,12 @@ st: $(OBJ)
+ 	$(CC) -o $@ $(OBJ) $(STLDFLAGS)
+ 
+ clean:
+-	rm -f st $(OBJ) st-$(VERSION).tar.gz *.rej *.orig *.o
++	rm -f st $(OBJ) st-$(VERSION).tar.gz
+ 
+ dist: clean
+ 	mkdir -p st-$(VERSION)
+ 	cp -R FAQ LEGACY TODO LICENSE Makefile README config.mk\
+-		config.h st.info st.1 arg.h st.h win.h $(SRC)\
++		config.def.h st.info st.1 arg.h st.h win.h $(SRC)\
+ 		st-$(VERSION)
+ 	tar -cf - st-$(VERSION) | gzip > st-$(VERSION).tar.gz
+ 	rm -rf st-$(VERSION)
+@@ -36,11 +38,7 @@ dist: clean
+ install: st
+ 	mkdir -p $(DESTDIR)$(PREFIX)/bin
+ 	cp -f st $(DESTDIR)$(PREFIX)/bin
+-	cp -f st-copyout $(DESTDIR)$(PREFIX)/bin
+-	cp -f st-urlhandler $(DESTDIR)$(PREFIX)/bin
+ 	chmod 755 $(DESTDIR)$(PREFIX)/bin/st
+-	chmod 755 $(DESTDIR)$(PREFIX)/bin/st-copyout
+-	chmod 755 $(DESTDIR)$(PREFIX)/bin/st-urlhandler
+ 	mkdir -p $(DESTDIR)$(MANPREFIX)/man1
+ 	sed "s/VERSION/$(VERSION)/g" < st.1 > $(DESTDIR)$(MANPREFIX)/man1/st.1
+ 	chmod 644 $(DESTDIR)$(MANPREFIX)/man1/st.1
+@@ -49,8 +47,6 @@ install: st
+ 
+ uninstall:
+ 	rm -f $(DESTDIR)$(PREFIX)/bin/st
+-	rm -f $(DESTDIR)$(PREFIX)/bin/st-copyout
+-	rm -f $(DESTDIR)$(PREFIX)/bin/st-urlhandler
+ 	rm -f $(DESTDIR)$(MANPREFIX)/man1/st.1
+ 
+ .PHONY: all clean dist install uninstall
+diff --git a/PKGBUILD b/PKGBUILD
+deleted file mode 100644
+index 66dd05e..0000000
+--- a/PKGBUILD
++++ /dev/null
+@@ -1,45 +0,0 @@
+-# Maintainer:
+-
+-pkgname=st-luke-git
+-_pkgname=st
+-pkgver=0.8.2.r1062.2087ab9
+-pkgrel=1
+-epoch=1
+-pkgdesc="Luke's simple (suckless) terminal with vim-bindings, transparency, xresources, etc. "
+-url='https://github.com/LukeSmithxyz/st'
+-arch=('i686' 'x86_64')
+-license=('MIT')
+-options=('zipman')
+-depends=('libxft')
+-makedepends=('ncurses' 'libxext' 'git')
+-optdepends=('dmenu: feed urls to dmenu')
+-source=(git+https://github.com/LukeSmithxyz/st)
+-sha1sums=('SKIP')
+-
+-provides=("${_pkgname}")
+-conflicts=("${_pkgname}")
+-
+-pkgver() {
+-	cd "${_pkgname}"
+-	printf "%s.r%s.%s" "$(awk '/^VERSION =/ {print $3}' config.mk)" \
+-		"$(git rev-list --count HEAD)" "$(git rev-parse --short HEAD)"
+-}
+-
+-prepare() {
+-	cd $srcdir/${_pkgname}
+-	# skip terminfo which conflicts with ncurses
+-	sed -i '/tic /d' Makefile
+-}
+-
+-build() {
+-	cd "${_pkgname}"
+-	make X11INC=/usr/include/X11 X11LIB=/usr/lib/X11
+-}
+-
+-package() {
+-	cd "${_pkgname}"
+-	make PREFIX=/usr DESTDIR="${pkgdir}" install
+-	install -Dm644 LICENSE "${pkgdir}/usr/share/licenses/${pkgname}/LICENSE"
+-	install -Dm644 README.md "${pkgdir}/usr/share/doc/${pkgname}/README.md"
+-	install -Dm644 Xdefaults "${pkgdir}/usr/share/doc/${pkgname}/Xdefaults.example"
+-}
+diff --git a/README b/README
+new file mode 100644
+index 0000000..6a846ed
+--- /dev/null
++++ b/README
+@@ -0,0 +1,34 @@
++st - simple terminal
++--------------------
++st is a simple terminal emulator for X which sucks less.
++
++
++Requirements
++------------
++In order to build st you need the Xlib header files.
++
++
++Installation
++------------
++Edit config.mk to match your local setup (st is installed into
++the /usr/local namespace by default).
++
++Afterwards enter the following command to build and install st (if
++necessary as root):
++
++    make clean install
++
++
++Running st
++----------
++If you did not install st with make clean install, you must compile
++the st terminfo entry with the following command:
++
++    tic -sx st.info
++
++See the man page for additional details.
++
++Credits
++-------
++Based on Aurélien APTEL <aurelien dot aptel at gmail dot com> bt source code.
++
+diff --git a/README.md b/README.md
+deleted file mode 100644
+index 23d2373..0000000
+--- a/README.md
++++ /dev/null
+@@ -1,95 +0,0 @@
+-# My modification of Luke's build of st - the simple (suckless) terminal
+-I have added: https://st.suckless.org/patches/workingdir/
+-and some changes to transparency and keybinds.
+-
+-I've added the patches to patches dir (although im not 100% sure that those are the exact patches used, they are mostly based on the description below)
+-
+-I also continously add fixes from suckless git log.
+-
+-The [suckless terminal (st)](https://st.suckless.org/) with some additional
+-features that make it literally the best terminal emulator ever:
+-
+-## Unique features (using dmenu)
+-
+-+ **follow urls** by pressing `alt-l`
+-+ **copy urls** in the same way with `alt-y`
+-+ **copy the output of commands** with `alt-o`
+-
+-## Bindings for
+-
+-+ **scrollback** with `alt-↑/↓` or `alt-pageup/down` or `shift` while scrolling the
+-  mouse.
+-+ OR **vim-bindings**: scroll up/down in history with `alt-k` and `alt-j`.
+-  Faster with `alt-u`/`alt-d`.
+-+ **zoom/change font size**: same bindings as above, but holding down shift as
+-  well. `alt-home` returns to default
+-+ **copy text** with `alt-c`, **paste** is `alt-v` or `shift-insert`
+-
+-## Pretty stuff
+-
+-+ Compatibility with `Xresources` and `pywal` for dynamic colors.
+-+ Default [gruvbox](https://github.com/morhetz/gruvbox) colors otherwise.
+-+ Transparency/alpha, which is also adjustable from your `Xresources`.
+-+ Default font is system "mono" at 14pt, meaning the font will match your
+-  system font.
+-
+-## Other st patches
+-
+-+ Boxdraw
+-+ Ligatures
+-+ font2
+-+ updated to latest version 0.8.5
+-
+-## Installation for newbs
+-
+-You should have xlib header files and libharfbuzz build files installed.
+-
+-```
+-git clone https://github.com/LukeSmithxyz/st
+-cd st
+-sudo make install
+-```
+-
+-Obviously, `make` is required to build. `fontconfig` is required for the
+-default build, since it asks `fontconfig` for your system monospace font. It
+-might be obvious, but `libX11` and `libXft` are required as well. Chances are,
+-you have all of this installed already.
+-
+-On OpenBSD, be sure to edit `config.mk` first and remove `-lrt` from the
+-`$LIBS` before compiling.
+-
+-Be sure to have a composite manager (`xcompmgr`, `picom`, etc.) running if you
+-want transparency.
+-
+-## How to configure dynamically with Xresources
+-
+-For many key variables, this build of `st` will look for X settings set in
+-either `~/.Xdefaults` or `~/.Xresources`. You must run `xrdb` on one of these
+-files to load the settings.
+-
+-For example, you can define your desired fonts, transparency or colors:
+-
+-```
+-*.font:	Liberation Mono:pixelsize=12:antialias=true:autohint=true;
+-*.alpha: 0.9
+-*.color0: #111
+-...
+-```
+-
+-The `alpha` value (for transparency) goes from `0` (transparent) to `1`
+-(opaque). There is an example `Xdefaults` file in this respository.
+-
+-### Colors
+-
+-To be clear about the color settings:
+-
+-- This build will use gruvbox colors by default and as a fallback.
+-- If there are Xresources colors defined, those will take priority.
+-- But if `wal` has run in your session, its colors will take priority.
+-
+-Note that when you run `wal`, it will negate the transparency of existing windows, but new windows will continue with the previously defined transparency.
+-
+-## Contact
+-
+-- Luke Smith <luke@lukesmith.xyz>
+-- [https://lukesmith.xyz](https://lukesmith.xyz)
+diff --git a/TODO b/TODO
+new file mode 100644
+index 0000000..5f74cd5
+--- /dev/null
++++ b/TODO
+@@ -0,0 +1,28 @@
++vt emulation
++------------
++
++* double-height support
++
++code & interface
++----------------
++
++* add a simple way to do multiplexing
++
++drawing
++-------
++* add diacritics support to xdraws()
++	* switch to a suckless font drawing library
++* make the font cache simpler
++* add better support for brightening of the upper colors
++
++bugs
++----
++
++* fix shift up/down (shift selection in emacs)
++* remove DEC test sequence when appropriate
++
++misc
++----
++
++    $ grep -nE 'XXX|TODO' st.c
++
+diff --git a/Xdefaults b/Xdefaults
+deleted file mode 100644
+index 040c772..0000000
+--- a/Xdefaults
++++ /dev/null
+@@ -1,128 +0,0 @@
+-!! Transparency (0-1):
+-st.alpha: 0.92
+-st.alphaOffset: 0.3
+-
+-!! Set a default font and font size as below:
+-st.font: Monospace-11;
+-
+-! st.termname: st-256color
+-! st.borderpx: 2
+-
+-!! Set the background, foreground and cursor colors as below:
+-
+-!! gruvbox:
+-*.color0: #1d2021
+-*.color1: #cc241d
+-*.color2: #98971a
+-*.color3: #d79921
+-*.color4: #458588
+-*.color5: #b16286
+-*.color6: #689d6a
+-*.color7: #a89984
+-*.color8: #928374
+-*.color9: #fb4934
+-*.color10: #b8bb26
+-*.color11: #fabd2f
+-*.color12: #83a598
+-*.color13: #d3869b
+-*.color14: #8ec07c
+-*.color15: #ebdbb2
+-*.background: #282828
+-*.foreground: white
+-*.cursorColor: white
+-
+-/* /1* !! gruvbox light: *1/ */
+-/* *.color0: #fbf1c7 */
+-/* *.color1: #cc241d */
+-/* *.color2: #98971a */
+-/* *.color3: #d79921 */
+-/* *.color4: #458588 */
+-/* *.color5: #b16286 */
+-/* *.color6: #689d6a */
+-/* *.color7: #7c6f64 */
+-/* *.color8: #928374 */
+-/* *.color9: #9d0006 */
+-/* *.color10: #79740e */
+-/* *.color11: #b57614 */
+-/* *.color12: #076678 */
+-/* *.color13: #8f3f71 */
+-/* *.color14: #427b58 */
+-/* *.color15: #3c3836 */
+-/* *.background: #fbf1c7 */
+-/* *.foreground: #282828 */
+-/* *.cursorColor: #282828 */
+-
+-/* !! brogrammer: */
+-/* *.foreground:  #d6dbe5 */
+-/* *.background:  #131313 */
+-/* *.color0:      #1f1f1f */
+-/* *.color8:      #d6dbe5 */
+-/* *.color1:      #f81118 */
+-/* *.color9:      #de352e */
+-/* *.color2:      #2dc55e */
+-/* *.color10:     #1dd361 */
+-/* *.color3:      #ecba0f */
+-/* *.color11:     #f3bd09 */
+-/* *.color4:      #2a84d2 */
+-/* *.color12:     #1081d6 */
+-/* *.color5:      #4e5ab7 */
+-/* *.color13:     #5350b9 */
+-/* *.color6:      #1081d6 */
+-/* *.color14:     #0f7ddb */
+-/* *.color7:      #d6dbe5 */
+-/* *.color15:     #ffffff */
+-/* *.colorBD:     #d6dbe5 */
+-
+-/* ! base16 */
+-/* *.color0:       #181818 */
+-/* *.color1:       #ab4642 */
+-/* *.color2:       #a1b56c */
+-/* *.color3:       #f7ca88 */
+-/* *.color4:       #7cafc2 */
+-/* *.color5:       #ba8baf */
+-/* *.color6:       #86c1b9 */
+-/* *.color7:       #d8d8d8 */
+-/* *.color8:       #585858 */
+-/* *.color9:       #ab4642 */
+-/* *.color10:      #a1b56c */
+-/* *.color11:      #f7ca88 */
+-/* *.color12:      #7cafc2 */
+-/* *.color13:      #ba8baf */
+-/* *.color14:      #86c1b9 */
+-/* *.color15:      #f8f8f8 */
+-
+-/* !! solarized */
+-/* *.color0:	#073642 */
+-/* *.color1:	#dc322f */
+-/* *.color2:	#859900 */
+-/* *.color3:	#b58900 */
+-/* *.color4:	#268bd2 */
+-/* *.color5:	#d33682 */
+-/* *.color6:	#2aa198 */
+-/* *.color7:	#eee8d5 */
+-/* *.color9:	#cb4b16 */
+-/* *.color8:	#fdf6e3 */
+-/* *.color10:	#586e75 */
+-/* *.color11:	#657b83 */
+-/* *.color12:	#839496 */
+-/* *.color13:	#6c71c4 */
+-/* *.color14:	#93a1a1 */
+-/* *.color15:	#fdf6e3 */
+-
+-/* !! xterm */
+-/* *.color0:   #000000 */
+-/* *.color1:   #cd0000 */
+-/* *.color2:   #00cd00 */
+-/* *.color3:   #cdcd00 */
+-/* *.color4:   #0000cd */
+-/* *.color5:   #cd00cd */
+-/* *.color6:   #00cdcd */
+-/* *.color7:   #e5e5e5 */
+-/* *.color8:   #4d4d4d */
+-/* *.color9:   #ff0000 */
+-/* *.color10:  #00ff00 */
+-/* *.color11:  #ffff00 */
+-/* *.color12:  #0000ff */
+-/* *.color13:  #ff00ff */
+-/* *.color14:  #00ffff */
+-/* *.color15:  #aabac8 */
+diff --git a/arg.h b/arg.h
+index e2dd5b7..a22e019 100644
+--- a/arg.h
++++ b/arg.h
+@@ -10,41 +10,41 @@ extern char *argv0;
+ 
+ /* use main(int argc, char *argv[]) */
+ #define ARGBEGIN	for (argv0 = *argv, argv++, argc--;\
+-        argv[0] && argv[0][0] == '-'\
+-        && argv[0][1];\
+-        argc--, argv++) {\
+-    char argc_;\
+-    char **argv_;\
+-    int brk_;\
+-    if (argv[0][1] == '-' && argv[0][2] == '\0') {\
+-        argv++;\
+-        argc--;\
+-        break;\
+-    }\
+-    int i_;\
+-    for (i_ = 1, brk_ = 0, argv_ = argv;\
+-            argv[0][i_] && !brk_;\
+-            i_++) {\
+-        if (argv_ != argv)\
+-        break;\
+-        argc_ = argv[0][i_];\
+-        switch (argc_)
++					argv[0] && argv[0][0] == '-'\
++					&& argv[0][1];\
++					argc--, argv++) {\
++				char argc_;\
++				char **argv_;\
++				int brk_;\
++				if (argv[0][1] == '-' && argv[0][2] == '\0') {\
++					argv++;\
++					argc--;\
++					break;\
++				}\
++				int i_;\
++				for (i_ = 1, brk_ = 0, argv_ = argv;\
++						argv[0][i_] && !brk_;\
++						i_++) {\
++					if (argv_ != argv)\
++						break;\
++					argc_ = argv[0][i_];\
++					switch (argc_)
+ 
+ #define ARGEND			}\
+-}
++			}
+ 
+ #define ARGC()		argc_
+ 
+ #define EARGF(x)	((argv[0][i_+1] == '\0' && argv[1] == NULL)?\
+-        ((x), abort(), (char *)0) :\
+-        (brk_ = 1, (argv[0][i_+1] != '\0')?\
+-         (&argv[0][i_+1]) :\
+-         (argc--, argv++, argv[0])))
++				((x), abort(), (char *)0) :\
++				(brk_ = 1, (argv[0][i_+1] != '\0')?\
++					(&argv[0][i_+1]) :\
++					(argc--, argv++, argv[0])))
+ 
+ #define ARGF()		((argv[0][i_+1] == '\0' && argv[1] == NULL)?\
+-        (char *)0 :\
+-        (brk_ = 1, (argv[0][i_+1] != '\0')?\
+-         (&argv[0][i_+1]) :\
+-         (argc--, argv++, argv[0])))
++				(char *)0 :\
++				(brk_ = 1, (argv[0][i_+1] != '\0')?\
++					(&argv[0][i_+1]) :\
++					(argc--, argv++, argv[0])))
+ 
+ #endif
+diff --git a/boxdraw.c b/boxdraw.c
+deleted file mode 100644
+index ad05e0b..0000000
+--- a/boxdraw.c
++++ /dev/null
+@@ -1,193 +0,0 @@
+-/*
+- * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih
+- * MIT/X Consortium License
+- */
+-
+-#include <X11/Xft/Xft.h>
+-#include "st.h"
+-#include "boxdraw_data.h"
+-
+-/* Rounded non-negative integers division of n / d  */
+-#define DIV(n, d) (((n) + (d) / 2) / (d))
+-
+-static Display *xdpy;
+-static Colormap xcmap;
+-static XftDraw *xd;
+-static Visual *xvis;
+-
+-static void drawbox(int, int, int, int, XftColor *, XftColor *, ushort);
+-static void drawboxlines(int, int, int, int, XftColor *, ushort);
+-
+-/* public API */
+-
+-void
+-boxdraw_xinit(Display *dpy, Colormap cmap, XftDraw *draw, Visual *vis)
+-{
+-    xdpy = dpy; xcmap = cmap; xd = draw, xvis = vis;
+-}
+-
+-int
+-isboxdraw(Rune u)
+-{
+-    Rune block = u & ~0xff;
+-    return (boxdraw && block == 0x2500 && boxdata[(uint8_t)u]) ||
+-        (boxdraw_braille && block == 0x2800);
+-}
+-
+-/* the "index" is actually the entire shape data encoded as ushort */
+-ushort
+-boxdrawindex(const Glyph *g)
+-{
+-    if (boxdraw_braille && (g->u & ~0xff) == 0x2800)
+-        return BRL | (uint8_t)g->u;
+-    if (boxdraw_bold && (g->mode & ATTR_BOLD))
+-        return BDB | boxdata[(uint8_t)g->u];
+-    return boxdata[(uint8_t)g->u];
+-}
+-
+-void
+-drawboxes(int x, int y, int cw, int ch, XftColor *fg, XftColor *bg,
+-        const XftGlyphFontSpec *specs, int len)
+-{
+-    for ( ; len-- > 0; x += cw, specs++)
+-        drawbox(x, y, cw, ch, fg, bg, (ushort)specs->glyph);
+-}
+-
+-/* implementation */
+-
+-void
+-drawbox(int x, int y, int w, int h, XftColor *fg, XftColor *bg, ushort bd)
+-{
+-    ushort cat = bd & ~(BDB | 0xff);  /* mask out bold and data */
+-    if (bd & (BDL | BDA)) {
+-        /* lines (light/double/heavy/arcs) */
+-        drawboxlines(x, y, w, h, fg, bd);
+-
+-    } else if (cat == BBD) {
+-        /* lower (8-X)/8 block */
+-        int d = DIV((uint8_t)bd * h, 8);
+-        XftDrawRect(xd, fg, x, y + d, w, h - d);
+-
+-    } else if (cat == BBU) {
+-        /* upper X/8 block */
+-        XftDrawRect(xd, fg, x, y, w, DIV((uint8_t)bd * h, 8));
+-
+-    } else if (cat == BBL) {
+-        /* left X/8 block */
+-        XftDrawRect(xd, fg, x, y, DIV((uint8_t)bd * w, 8), h);
+-
+-    } else if (cat == BBR) {
+-        /* right (8-X)/8 block */
+-        int d = DIV((uint8_t)bd * w, 8);
+-        XftDrawRect(xd, fg, x + d, y, w - d, h);
+-
+-    } else if (cat == BBQ) {
+-        /* Quadrants */
+-        int w2 = DIV(w, 2), h2 = DIV(h, 2);
+-        if (bd & TL)
+-            XftDrawRect(xd, fg, x, y, w2, h2);
+-        if (bd & TR)
+-            XftDrawRect(xd, fg, x + w2, y, w - w2, h2);
+-        if (bd & BL)
+-            XftDrawRect(xd, fg, x, y + h2, w2, h - h2);
+-        if (bd & BR)
+-            XftDrawRect(xd, fg, x + w2, y + h2, w - w2, h - h2);
+-
+-    } else if (bd & BBS) {
+-        /* Shades - data is 1/2/3 for 25%/50%/75% alpha, respectively */
+-        int d = (uint8_t)bd;
+-        XftColor xfc;
+-        XRenderColor xrc = { .alpha = 0xffff };
+-
+-        xrc.red = DIV(fg->color.red * d + bg->color.red * (4 - d), 4);
+-        xrc.green = DIV(fg->color.green * d + bg->color.green * (4 - d), 4);
+-        xrc.blue = DIV(fg->color.blue * d + bg->color.blue * (4 - d), 4);
+-
+-        XftColorAllocValue(xdpy, xvis, xcmap, &xrc, &xfc);
+-        XftDrawRect(xd, &xfc, x, y, w, h);
+-        XftColorFree(xdpy, xvis, xcmap, &xfc);
+-
+-    } else if (cat == BRL) {
+-        /* braille, each data bit corresponds to one dot at 2x4 grid */
+-        int w1 = DIV(w, 2);
+-        int h1 = DIV(h, 4), h2 = DIV(h, 2), h3 = DIV(3 * h, 4);
+-
+-        if (bd & 1)   XftDrawRect(xd, fg, x, y, w1, h1);
+-        if (bd & 2)   XftDrawRect(xd, fg, x, y + h1, w1, h2 - h1);
+-        if (bd & 4)   XftDrawRect(xd, fg, x, y + h2, w1, h3 - h2);
+-        if (bd & 8)   XftDrawRect(xd, fg, x + w1, y, w - w1, h1);
+-        if (bd & 16)  XftDrawRect(xd, fg, x + w1, y + h1, w - w1, h2 - h1);
+-        if (bd & 32)  XftDrawRect(xd, fg, x + w1, y + h2, w - w1, h3 - h2);
+-        if (bd & 64)  XftDrawRect(xd, fg, x, y + h3, w1, h - h3);
+-        if (bd & 128) XftDrawRect(xd, fg, x + w1, y + h3, w - w1, h - h3);
+-    }
+-}
+-
+-void
+-drawboxlines(int x, int y, int w, int h, XftColor *fg, ushort bd)
+-{
+-    /* s: stem thickness. width/8 roughly matches underscore thickness. */
+-    /* We draw bold as 1.5 * normal-stem and at least 1px thicker.      */
+-    /* doubles draw at least 3px, even when w or h < 3. bold needs 6px. */
+-    int mwh = MIN(w, h);
+-    int base_s = MAX(1, DIV(mwh, 8));
+-    int bold = (bd & BDB) && mwh >= 6;  /* possibly ignore boldness */
+-    int s = bold ? MAX(base_s + 1, DIV(3 * base_s, 2)) : base_s;
+-    int w2 = DIV(w - s, 2), h2 = DIV(h - s, 2);
+-    /* the s-by-s square (x + w2, y + h2, s, s) is the center texel.    */
+-    /* The base length (per direction till edge) includes this square.  */
+-
+-    int light = bd & (LL | LU | LR | LD);
+-    int double_ = bd & (DL | DU | DR | DD);
+-
+-    if (light) {
+-        /* d: additional (negative) length to not-draw the center   */
+-        /* texel - at arcs and avoid drawing inside (some) doubles  */
+-        int arc = bd & BDA;
+-        int multi_light = light & (light - 1);
+-        int multi_double = double_ & (double_ - 1);
+-        /* light crosses double only at DH+LV, DV+LH (ref. shapes)  */
+-        int d = arc || (multi_double && !multi_light) ? -s : 0;
+-
+-        if (bd & LL)
+-            XftDrawRect(xd, fg, x, y + h2, w2 + s + d, s);
+-        if (bd & LU)
+-            XftDrawRect(xd, fg, x + w2, y, s, h2 + s + d);
+-        if (bd & LR)
+-            XftDrawRect(xd, fg, x + w2 - d, y + h2, w - w2 + d, s);
+-        if (bd & LD)
+-            XftDrawRect(xd, fg, x + w2, y + h2 - d, s, h - h2 + d);
+-    }
+-
+-    /* double lines - also align with light to form heavy when combined */
+-    if (double_) {
+-        /*
+-         * going clockwise, for each double-ray: p is additional length
+-         * to the single-ray nearer to the previous direction, and n to
+-         * the next. p and n adjust from the base length to lengths
+-         * which consider other doubles - shorter to avoid intersections
+-         * (p, n), or longer to draw the far-corner texel (n).
+-         */
+-        int dl = bd & DL, du = bd & DU, dr = bd & DR, dd = bd & DD;
+-        if (dl) {
+-            int p = dd ? -s : 0, n = du ? -s : dd ? s : 0;
+-            XftDrawRect(xd, fg, x, y + h2 + s, w2 + s + p, s);
+-            XftDrawRect(xd, fg, x, y + h2 - s, w2 + s + n, s);
+-        }
+-        if (du) {
+-            int p = dl ? -s : 0, n = dr ? -s : dl ? s : 0;
+-            XftDrawRect(xd, fg, x + w2 - s, y, s, h2 + s + p);
+-            XftDrawRect(xd, fg, x + w2 + s, y, s, h2 + s + n);
+-        }
+-        if (dr) {
+-            int p = du ? -s : 0, n = dd ? -s : du ? s : 0;
+-            XftDrawRect(xd, fg, x + w2 - p, y + h2 - s, w - w2 + p, s);
+-            XftDrawRect(xd, fg, x + w2 - n, y + h2 + s, w - w2 + n, s);
+-        }
+-        if (dd) {
+-            int p = dr ? -s : 0, n = dl ? -s : dr ? s : 0;
+-            XftDrawRect(xd, fg, x + w2 + s, y + h2 - p, s, h - h2 + p);
+-            XftDrawRect(xd, fg, x + w2 - s, y + h2 - n, s, h - h2 + n);
+-        }
+-    }
+-}
+diff --git a/boxdraw_data.h b/boxdraw_data.h
+deleted file mode 100644
+index 7dff860..0000000
+--- a/boxdraw_data.h
++++ /dev/null
+@@ -1,214 +0,0 @@
+-/*
+- * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih
+- * MIT/X Consortium License
+- */
+-
+-/*
+- * U+25XX codepoints data
+- *
+- * References:
+- *   http://www.unicode.org/charts/PDF/U2500.pdf
+- *   http://www.unicode.org/charts/PDF/U2580.pdf
+- *
+- * Test page:
+- *   https://github.com/GNOME/vte/blob/master/doc/boxes.txt
+- */
+-
+-/* Each shape is encoded as 16-bits. Higher bits are category, lower are data */
+-/* Categories (mutually exclusive except BDB): */
+-/* For convenience, BDL/BDA/BBS/BDB are 1 bit each, the rest are enums */
+-#define BDL (1<<8)   /* Box Draw Lines (light/double/heavy) */
+-#define BDA (1<<9)   /* Box Draw Arc (light) */
+-
+-#define BBD (1<<10)  /* Box Block Down (lower) X/8 */
+-#define BBL (2<<10)  /* Box Block Left X/8 */
+-#define BBU (3<<10)  /* Box Block Upper X/8 */
+-#define BBR (4<<10)  /* Box Block Right X/8 */
+-#define BBQ (5<<10)  /* Box Block Quadrants */
+-#define BRL (6<<10)  /* Box Braille (data is lower byte of U28XX) */
+-
+-#define BBS (1<<14)  /* Box Block Shades */
+-#define BDB (1<<15)  /* Box Draw is Bold */
+-
+-/* (BDL/BDA) Light/Double/Heavy x Left/Up/Right/Down/Horizontal/Vertical      */
+-/* Heavy is light+double (literally drawing light+double align to form heavy) */
+-#define LL (1<<0)
+-#define LU (1<<1)
+-#define LR (1<<2)
+-#define LD (1<<3)
+-#define LH (LL+LR)
+-#define LV (LU+LD)
+-
+-#define DL (1<<4)
+-#define DU (1<<5)
+-#define DR (1<<6)
+-#define DD (1<<7)
+-#define DH (DL+DR)
+-#define DV (DU+DD)
+-
+-#define HL (LL+DL)
+-#define HU (LU+DU)
+-#define HR (LR+DR)
+-#define HD (LD+DD)
+-#define HH (HL+HR)
+-#define HV (HU+HD)
+-
+-/* (BBQ) Quadrants Top/Bottom x Left/Right */
+-#define TL (1<<0)
+-#define TR (1<<1)
+-#define BL (1<<2)
+-#define BR (1<<3)
+-
+-/* Data for U+2500 - U+259F except dashes/diagonals */
+-static const unsigned short boxdata[256] = {
+-    /* light lines */
+-    [0x00] = BDL + LH,       /* light horizontal */
+-    [0x02] = BDL + LV,       /* light vertical */
+-    [0x0c] = BDL + LD + LR,  /* light down and right */
+-    [0x10] = BDL + LD + LL,  /* light down and left */
+-    [0x14] = BDL + LU + LR,  /* light up and right */
+-    [0x18] = BDL + LU + LL,  /* light up and left */
+-    [0x1c] = BDL + LV + LR,  /* light vertical and right */
+-    [0x24] = BDL + LV + LL,  /* light vertical and left */
+-    [0x2c] = BDL + LH + LD,  /* light horizontal and down */
+-    [0x34] = BDL + LH + LU,  /* light horizontal and up */
+-    [0x3c] = BDL + LV + LH,  /* light vertical and horizontal */
+-    [0x74] = BDL + LL,       /* light left */
+-    [0x75] = BDL + LU,       /* light up */
+-    [0x76] = BDL + LR,       /* light right */
+-    [0x77] = BDL + LD,       /* light down */
+-
+-    /* heavy [+light] lines */
+-    [0x01] = BDL + HH,
+-    [0x03] = BDL + HV,
+-    [0x0d] = BDL + HR + LD,
+-    [0x0e] = BDL + HD + LR,
+-    [0x0f] = BDL + HD + HR,
+-    [0x11] = BDL + HL + LD,
+-    [0x12] = BDL + HD + LL,
+-    [0x13] = BDL + HD + HL,
+-    [0x15] = BDL + HR + LU,
+-    [0x16] = BDL + HU + LR,
+-    [0x17] = BDL + HU + HR,
+-    [0x19] = BDL + HL + LU,
+-    [0x1a] = BDL + HU + LL,
+-    [0x1b] = BDL + HU + HL,
+-    [0x1d] = BDL + HR + LV,
+-    [0x1e] = BDL + HU + LD + LR,
+-    [0x1f] = BDL + HD + LR + LU,
+-    [0x20] = BDL + HV + LR,
+-    [0x21] = BDL + HU + HR + LD,
+-    [0x22] = BDL + HD + HR + LU,
+-    [0x23] = BDL + HV + HR,
+-    [0x25] = BDL + HL + LV,
+-    [0x26] = BDL + HU + LD + LL,
+-    [0x27] = BDL + HD + LU + LL,
+-    [0x28] = BDL + HV + LL,
+-    [0x29] = BDL + HU + HL + LD,
+-    [0x2a] = BDL + HD + HL + LU,
+-    [0x2b] = BDL + HV + HL,
+-    [0x2d] = BDL + HL + LD + LR,
+-    [0x2e] = BDL + HR + LL + LD,
+-    [0x2f] = BDL + HH + LD,
+-    [0x30] = BDL + HD + LH,
+-    [0x31] = BDL + HD + HL + LR,
+-    [0x32] = BDL + HR + HD + LL,
+-    [0x33] = BDL + HH + HD,
+-    [0x35] = BDL + HL + LU + LR,
+-    [0x36] = BDL + HR + LU + LL,
+-    [0x37] = BDL + HH + LU,
+-    [0x38] = BDL + HU + LH,
+-    [0x39] = BDL + HU + HL + LR,
+-    [0x3a] = BDL + HU + HR + LL,
+-    [0x3b] = BDL + HH + HU,
+-    [0x3d] = BDL + HL + LV + LR,
+-    [0x3e] = BDL + HR + LV + LL,
+-    [0x3f] = BDL + HH + LV,
+-    [0x40] = BDL + HU + LH + LD,
+-    [0x41] = BDL + HD + LH + LU,
+-    [0x42] = BDL + HV + LH,
+-    [0x43] = BDL + HU + HL + LD + LR,
+-    [0x44] = BDL + HU + HR + LD + LL,
+-    [0x45] = BDL + HD + HL + LU + LR,
+-    [0x46] = BDL + HD + HR + LU + LL,
+-    [0x47] = BDL + HH + HU + LD,
+-    [0x48] = BDL + HH + HD + LU,
+-    [0x49] = BDL + HV + HL + LR,
+-    [0x4a] = BDL + HV + HR + LL,
+-    [0x4b] = BDL + HV + HH,
+-    [0x78] = BDL + HL,
+-    [0x79] = BDL + HU,
+-    [0x7a] = BDL + HR,
+-    [0x7b] = BDL + HD,
+-    [0x7c] = BDL + HR + LL,
+-    [0x7d] = BDL + HD + LU,
+-    [0x7e] = BDL + HL + LR,
+-    [0x7f] = BDL + HU + LD,
+-
+-    /* double [+light] lines */
+-    [0x50] = BDL + DH,
+-    [0x51] = BDL + DV,
+-    [0x52] = BDL + DR + LD,
+-    [0x53] = BDL + DD + LR,
+-    [0x54] = BDL + DR + DD,
+-    [0x55] = BDL + DL + LD,
+-    [0x56] = BDL + DD + LL,
+-    [0x57] = BDL + DL + DD,
+-    [0x58] = BDL + DR + LU,
+-    [0x59] = BDL + DU + LR,
+-    [0x5a] = BDL + DU + DR,
+-    [0x5b] = BDL + DL + LU,
+-    [0x5c] = BDL + DU + LL,
+-    [0x5d] = BDL + DL + DU,
+-    [0x5e] = BDL + DR + LV,
+-    [0x5f] = BDL + DV + LR,
+-    [0x60] = BDL + DV + DR,
+-    [0x61] = BDL + DL + LV,
+-    [0x62] = BDL + DV + LL,
+-    [0x63] = BDL + DV + DL,
+-    [0x64] = BDL + DH + LD,
+-    [0x65] = BDL + DD + LH,
+-    [0x66] = BDL + DD + DH,
+-    [0x67] = BDL + DH + LU,
+-    [0x68] = BDL + DU + LH,
+-    [0x69] = BDL + DH + DU,
+-    [0x6a] = BDL + DH + LV,
+-    [0x6b] = BDL + DV + LH,
+-    [0x6c] = BDL + DH + DV,
+-
+-    /* (light) arcs */
+-    [0x6d] = BDA + LD + LR,
+-    [0x6e] = BDA + LD + LL,
+-    [0x6f] = BDA + LU + LL,
+-    [0x70] = BDA + LU + LR,
+-
+-    /* Lower (Down) X/8 block (data is 8 - X) */
+-    [0x81] = BBD + 7, [0x82] = BBD + 6, [0x83] = BBD + 5, [0x84] = BBD + 4,
+-    [0x85] = BBD + 3, [0x86] = BBD + 2, [0x87] = BBD + 1, [0x88] = BBD + 0,
+-
+-    /* Left X/8 block (data is X) */
+-    [0x89] = BBL + 7, [0x8a] = BBL + 6, [0x8b] = BBL + 5, [0x8c] = BBL + 4,
+-    [0x8d] = BBL + 3, [0x8e] = BBL + 2, [0x8f] = BBL + 1,
+-
+-    /* upper 1/2 (4/8), 1/8 block (X), right 1/2, 1/8 block (8-X) */
+-    [0x80] = BBU + 4, [0x94] = BBU + 1,
+-    [0x90] = BBR + 4, [0x95] = BBR + 7,
+-
+-    /* Quadrants */
+-    [0x96] = BBQ + BL,
+-    [0x97] = BBQ + BR,
+-    [0x98] = BBQ + TL,
+-    [0x99] = BBQ + TL + BL + BR,
+-    [0x9a] = BBQ + TL + BR,
+-    [0x9b] = BBQ + TL + TR + BL,
+-    [0x9c] = BBQ + TL + TR + BR,
+-    [0x9d] = BBQ + TR,
+-    [0x9e] = BBQ + BL + TR,
+-    [0x9f] = BBQ + BL + TR + BR,
+-
+-    /* Shades, data is an alpha value in 25% units (1/4, 1/2, 3/4) */
+-    [0x91] = BBS + 1, [0x92] = BBS + 2, [0x93] = BBS + 3,
+-
+-    /* U+2504 - U+250B, U+254C - U+254F: unsupported (dashes) */
+-    /* U+2571 - U+2573: unsupported (diagonals) */
+-};
+diff --git a/config.h b/config.h
+index bd018f9..b1a6cbb 100644
+--- a/config.h
++++ b/config.h
+@@ -152,7 +152,6 @@ unsigned int alphaBg = 260;
+ unsigned int defaultAlphaBg = 258;
+ unsigned int defaultcs = 256;
+ unsigned int defaultrcs = 257;
+-unsigned int background = 258;
+ 
+ /*
+  * Default shape of cursor
+diff --git a/config.mk b/config.mk
+index ef6de39..b6458af 100644
+--- a/config.mk
++++ b/config.mk
+@@ -1,5 +1,5 @@
+ # st version
+-VERSION = 0.8.5
++VERSION = 0.9.2
+ 
+ # Customize below to fit your system
+ 
+@@ -17,7 +17,7 @@ INCS = -I$(X11INC) \
+        `$(PKG_CONFIG) --cflags fontconfig` \
+        `$(PKG_CONFIG) --cflags freetype2` \
+        `$(PKG_CONFIG) --cflags harfbuzz`
+-LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender\
++LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender \
+        `$(PKG_CONFIG) --libs fontconfig` \
+        `$(PKG_CONFIG) --libs freetype2` \
+        `$(PKG_CONFIG) --libs harfbuzz`
+@@ -32,6 +32,7 @@ STLDFLAGS = $(LIBS) $(LDFLAGS)
+ #LIBS = -L$(X11LIB) -lm -lX11 -lutil -lXft \
+ #       `$(PKG_CONFIG) --libs fontconfig` \
+ #       `$(PKG_CONFIG) --libs freetype2`
++#MANPREFIX = ${PREFIX}/man
+ 
+ # compiler and linker
+ # CC = c99
+diff --git a/gruvbox-dark.rasi b/gruvbox-dark.rasi
+deleted file mode 100644
+index 5754c4a..0000000
+--- a/gruvbox-dark.rasi
++++ /dev/null
+@@ -1,62 +0,0 @@
+-/* ==========================================================================
+-   Rofi color theme
+-
+-   Based on the Gruvbox color scheme for Vim by morhetz
+-   https://github.com/morhetz/gruvbox
+-
+-   File: gruvbox-dark.rasi
+-   Desc: Gruvbox dark color theme for Rofi
+-   Author: bardisty <b@bah.im>
+-   Source: https://github.com/bardisty/gruvbox-rofi
+-   Modified: Mon Feb 12 2018 04:08:43 PST -0800
+-   ========================================================================== */
+-
+-* {
+-    /* Theme settings */
+-    highlight: bold italic;
+-    scrollbar: false;
+-
+-    /* Gruvbox dark colors */
+-    gruvbox-dark-bg0:          #282828;
+-    gruvbox-dark-bg0-soft:     #32302f;
+-    gruvbox-dark-bg3:          #665c54;
+-    gruvbox-dark-fg0:          #fbf1c7;
+-    gruvbox-dark-fg1:          #ebdbb2;
+-    gruvbox-dark-red-dark:     #cc241d;
+-    gruvbox-dark-red-light:    #fb4934;
+-    gruvbox-dark-yellow-dark:  #d79921;
+-    gruvbox-dark-yellow-light: #fabd2f;
+-    gruvbox-dark-gray:         #a89984;
+-
+-    /* Theme colors */
+-    background:                  @gruvbox-dark-bg0;
+-    background-color:            @background;
+-    foreground:                  @gruvbox-dark-fg1;
+-    border-color:                @gruvbox-dark-gray;
+-    separatorcolor:              @border-color;
+-    scrollbar-handle:            @border-color;
+-
+-    normal-background:           @background;
+-    normal-foreground:           @foreground;
+-    alternate-normal-background: @gruvbox-dark-bg0-soft;
+-    alternate-normal-foreground: @foreground;
+-    selected-normal-background:  @gruvbox-dark-bg3;
+-    selected-normal-foreground:  @gruvbox-dark-fg0;
+-
+-    active-background:           @gruvbox-dark-yellow-dark;
+-    active-foreground:           @background;
+-    alternate-active-background: @active-background;
+-    alternate-active-foreground: @active-foreground;
+-    selected-active-background:  @gruvbox-dark-yellow-light;
+-    selected-active-foreground:  @active-foreground;
+-
+-    urgent-background:           @gruvbox-dark-red-dark;
+-    urgent-foreground:           @background;
+-    alternate-urgent-background: @urgent-background;
+-    alternate-urgent-foreground: @urgent-foreground;
+-    selected-urgent-background:  @gruvbox-dark-red-light;
+-    selected-urgent-foreground:  @urgent-foreground;
+-}
+-
+-@import "gruvbox-common.rasi"
+-
+diff --git a/hb.c b/hb.c
+index 8000afa..99412c8 100644
+--- a/hb.c
++++ b/hb.c
+@@ -7,21 +7,11 @@
+ #include <hb-ft.h>
+ 
+ #include "st.h"
++#include "hb.h"
+ 
+ #define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
++#define BUFFER_STEP 256
+ 
+-/*
+- * Replace 0 with a list of font features, wrapped in FEATURE macro, e.g.
+- * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
+- * 
+- * Uncomment either one of the 2 lines below. Uncomment the prior to disable (any) font features. Uncomment the 
+- * latter to enable the (selected) font features.
+- */
+-
+-hb_feature_t features[] = { 0 };
+-//hb_feature_t features[] = { FEATURE('s','s','0','1'), FEATURE('s','s','0','2'), FEATURE('s','s','0','3'), FEATURE('s','s','0','5'), FEATURE('s','s','0','6'), FEATURE('s','s','0','7'), FEATURE('s','s','0','8'), FEATURE('z','e','r','o') };
+-
+-void hbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length);
+ hb_font_t *hbfindfont(XftFont *match);
+ 
+ typedef struct {
+@@ -29,126 +19,107 @@ typedef struct {
+ 	hb_font_t *font;
+ } HbFontMatch;
+ 
+-static int hbfontslen = 0;
+-static HbFontMatch *hbfontcache = NULL;
++typedef struct {
++	size_t capacity;
++	HbFontMatch *fonts;
++} HbFontCache;
++
++static HbFontCache hbfontcache = { 0, NULL };
++
++typedef struct {
++	size_t capacity;
++	Rune *runes;
++} RuneBuffer;
++
++static RuneBuffer hbrunebuffer = { 0, NULL };
++
++/*
++ * Poplulate the array with a list of font features, wrapped in FEATURE macro,
++ * e. g.
++ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
++ */
++hb_feature_t features[] = { };
+ 
+ void
+ hbunloadfonts()
+ {
+-	for (int i = 0; i < hbfontslen; i++) {
+-		hb_font_destroy(hbfontcache[i].font);
+-		XftUnlockFace(hbfontcache[i].match);
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		hb_font_destroy(hbfontcache.fonts[i].font);
++		XftUnlockFace(hbfontcache.fonts[i].match);
+ 	}
+ 
+-	if (hbfontcache != NULL) {
+-		free(hbfontcache);
+-		hbfontcache = NULL;
++	if (hbfontcache.fonts != NULL) {
++		free(hbfontcache.fonts);
++		hbfontcache.fonts = NULL;
+ 	}
+-	hbfontslen = 0;
++	hbfontcache.capacity = 0;
+ }
+ 
+ hb_font_t *
+ hbfindfont(XftFont *match)
+ {
+-	for (int i = 0; i < hbfontslen; i++) {
+-		if (hbfontcache[i].match == match)
+-			return hbfontcache[i].font;
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		if (hbfontcache.fonts[i].match == match)
++			return hbfontcache.fonts[i].font;
+ 	}
+ 
+ 	/* Font not found in cache, caching it now. */
+-	hbfontcache = realloc(hbfontcache, sizeof(HbFontMatch) * (hbfontslen + 1));
++	hbfontcache.fonts = realloc(hbfontcache.fonts, sizeof(HbFontMatch) * (hbfontcache.capacity + 1));
+ 	FT_Face face = XftLockFace(match);
+ 	hb_font_t *font = hb_ft_font_create(face, NULL);
+ 	if (font == NULL)
+ 		die("Failed to load Harfbuzz font.");
+ 
+-	hbfontcache[hbfontslen].match = match;
+-	hbfontcache[hbfontslen].font = font;
+-	hbfontslen += 1;
++	hbfontcache.fonts[hbfontcache.capacity].match = match;
++	hbfontcache.fonts[hbfontcache.capacity].font = font;
++	hbfontcache.capacity += 1;
+ 
+ 	return font;
+ }
+ 
+-void
+-hbtransform(XftGlyphFontSpec *specs, const Glyph *glyphs, size_t len, int x, int y)
+-{
+-	int start = 0, length = 1, gstart = 0;
+-	hb_codepoint_t *codepoints = calloc((unsigned int)len, sizeof(hb_codepoint_t));
+-
+-	for (int idx = 1, specidx = 1; idx < len; idx++) {
+-		if (glyphs[idx].mode & ATTR_WDUMMY) {
+-			length += 1;
+-			continue;
+-		}
+-
+-		if (specs[specidx].font != specs[start].font || ATTRCMP(glyphs[gstart], glyphs[idx]) || selected(x + idx, y) != selected(x + gstart, y)) {
+-			hbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);
+-
+-			/* Reset the sequence. */
+-			length = 1;
+-			start = specidx;
+-			gstart = idx;
+-		} else {
+-			length += 1;
+-		}
+-
+-		specidx++;
+-	}
+-
+-	/* EOL. */
+-	hbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);
+-
+-	/* Apply the transformation to glyph specs. */
+-	for (int i = 0, specidx = 0; i < len; i++) {
+-		if (glyphs[i].mode & ATTR_WDUMMY)
+-			continue;
+-		if (glyphs[i].mode & ATTR_BOXDRAW) {
+-			specidx++;
+-			continue;
+-		}
+-
+-		if (codepoints[i] != specs[specidx].glyph)
+-			((Glyph *)glyphs)[i].mode |= ATTR_LIGA;
+-
+-		specs[specidx++].glyph = codepoints[i];
+-	}
+-
+-	free(codepoints);
+-}
++void hbtransform(HbTransformData *data, XftFont *xfont, const Glyph *glyphs, int start, int length) {
++	ushort mode = USHRT_MAX;
++	unsigned int glyph_count;
++	int rune_idx, glyph_idx, end = start + length;
+ 
+-void
+-hbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length)
+-{
+ 	hb_font_t *font = hbfindfont(xfont);
+ 	if (font == NULL)
+ 		return;
+ 
+-	Rune rune;
+-	ushort mode = USHRT_MAX;
+ 	hb_buffer_t *buffer = hb_buffer_create();
+ 	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
++	hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
++
++	/* Resize the buffer if required length is larger. */
++	if (hbrunebuffer.capacity < length) {
++		hbrunebuffer.capacity = (length / BUFFER_STEP + 1) * BUFFER_STEP;
++		hbrunebuffer.runes = realloc(hbrunebuffer.runes, hbrunebuffer.capacity * sizeof(Rune));
++	}
+ 
+ 	/* Fill buffer with codepoints. */
+-	for (int i = start; i < (start+length); i++) {
+-		rune = string[i].u;
+-		mode = string[i].mode;
++	for (rune_idx = 0, glyph_idx = start; glyph_idx < end; glyph_idx++, rune_idx++) {
++		hbrunebuffer.runes[rune_idx] = glyphs[glyph_idx].u;
++		mode = glyphs[glyph_idx].mode;
+ 		if (mode & ATTR_WDUMMY)
+-			rune = 0x0020;
+-		hb_buffer_add_codepoints(buffer, &rune, 1, 0, 1);
++			hbrunebuffer.runes[rune_idx] = 0x0020;
+ 	}
++	hb_buffer_add_codepoints(buffer, hbrunebuffer.runes, length, 0, length);
+ 
+ 	/* Shape the segment. */
+-	hb_shape(font, buffer, features, sizeof(features));
++	hb_shape(font, buffer, features, sizeof(features)/sizeof(hb_feature_t));
+ 
+ 	/* Get new glyph info. */
+-	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, NULL);
+-
+-	/* Write new codepoints. */
+-	for (int i = 0; i < length; i++) {
+-		hb_codepoint_t gid = info[i].codepoint;
+-		codepoints[start+i] = gid;
+-	}
++	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
++	hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);
++
++	/* Fill the output. */
++	data->buffer = buffer;
++	data->glyphs = info;
++	data->positions = pos;
++	data->count = glyph_count;
++}
+ 
+-	/* Cleanup. */
+-	hb_buffer_destroy(buffer);
++void hbcleanup(HbTransformData *data) {
++	hb_buffer_destroy(data->buffer);
++	memset(data, 0, sizeof(HbTransformData));
+ }
+diff --git a/hb.h b/hb.h
+index 07888df..3b0ef44 100644
+--- a/hb.h
++++ b/hb.h
+@@ -2,5 +2,13 @@
+ #include <hb.h>
+ #include <hb-ft.h>
+ 
++typedef struct {
++	hb_buffer_t *buffer;
++	hb_glyph_info_t *glyphs;
++	hb_glyph_position_t *positions;
++	unsigned int count;
++} HbTransformData;
++
+ void hbunloadfonts();
+-void hbtransform(XftGlyphFontSpec *, const Glyph *, size_t, int, int);
++void hbtransform(HbTransformData *, XftFont *, const Glyph *, int, int);
++void hbcleanup(HbTransformData *);
+diff --git a/st.1 b/st.1
+index e2a0e16..b82beb3 100644
+--- a/st.1
++++ b/st.1
+@@ -133,41 +133,6 @@ and all the remaining arguments are used as a command
+ even without it.
+ .SH SHORTCUTS
+ .TP
+-.B Alt-j/k or Alt-Up/Down or Alt-Mouse Wheel
+-Scroll up/down one line at a time.
+-.TP
+-.B Alt-u/d or Alt-Page Up/Page Down
+-Scroll up/down one screen at a time.
+-.TP
+-.B Alt-Shift-k/j or Alt-Shift-Page Up/Page Down or Alt-Shift-Mouse Wheel
+-Increase or decrease font size.
+-.TP
+-.B Alt-Home
+-Reset to default font size.
+-.TP
+-.B Shift-Insert or Alt-v
+-Paste from clipboard.
+-.TP
+-.B Alt-c
+-Copy to clipboard.
+-.TP
+-.B Alt-p
+-Paste/input primary selection.
+-.TP
+-.B Alt-l
+-Show dmenu menu of all URLs on screen and choose one to open.
+-.TP
+-.B Alt-y
+-Show dmenu menu of all URLs on screen and choose one to copy.
+-.TP
+-.B Alt-o
+-Show dmenu menu of all recently run commands and copy the output of the chosen command to the clipboard.
+-.I xclip
+-required.
+-.TP
+-.B Alt-a/s
+-Increase or decrease opacity/alpha value (make window more or less transparent).
+-.TP
+ .B Break
+ Send a break in the serial line.
+ Break key is obtained in PC keyboards
+@@ -184,6 +149,24 @@ Print the full screen to the
+ .B Print Screen
+ Print the selection to the
+ .I iofile.
++.TP
++.B Ctrl-Shift-Page Up
++Increase font size.
++.TP
++.B Ctrl-Shift-Page Down
++Decrease font size.
++.TP
++.B Ctrl-Shift-Home
++Reset to default font size.
++.TP
++.B Ctrl-Shift-y
++Paste from primary selection (middle mouse button).
++.TP
++.B Ctrl-Shift-c
++Copy the selected text to the clipboard selection.
++.TP
++.B Ctrl-Shift-v
++Paste from the clipboard selection.
+ .SH CUSTOMIZATION
+ .B st
+ can be customized by creating a custom config.h and (re)compiling the source
+@@ -199,3 +182,4 @@ See the LICENSE file for the terms of redistribution.
+ .BR scroll (1)
+ .SH BUGS
+ See the TODO file in the distribution.
++
+diff --git a/st.c b/st.c
+index 0f35711..755d84e 100644
+--- a/st.c
++++ b/st.c
+@@ -21,11 +21,11 @@
+ #include "win.h"
+ 
+ #if   defined(__linux)
+-#include <pty.h>
++ #include <pty.h>
+ #elif defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
+-#include <util.h>
++ #include <util.h>
+ #elif defined(__FreeBSD__) || defined(__DragonFly__)
+-#include <libutil.h>
++ #include <libutil.h>
+ #endif
+ 
+ /* Arbitrary sizes */
+@@ -46,119 +46,117 @@
+ #define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
+             term.scr + HISTSIZE + 1) % HISTSIZE] : \
+             term.line[(y) - term.scr])
+-#define TLINE_HIST(y)           ((y) <= HISTSIZE-term.row+2 ? term.hist[(y)] : term.line[(y-HISTSIZE+term.row-3)])
+ 
+ enum term_mode {
+-    MODE_WRAP        = 1 << 0,
+-    MODE_INSERT      = 1 << 1,
+-    MODE_ALTSCREEN   = 1 << 2,
+-    MODE_CRLF        = 1 << 3,
+-    MODE_ECHO        = 1 << 4,
+-    MODE_PRINT       = 1 << 5,
+-    MODE_UTF8        = 1 << 6,
++	MODE_WRAP        = 1 << 0,
++	MODE_INSERT      = 1 << 1,
++	MODE_ALTSCREEN   = 1 << 2,
++	MODE_CRLF        = 1 << 3,
++	MODE_ECHO        = 1 << 4,
++	MODE_PRINT       = 1 << 5,
++	MODE_UTF8        = 1 << 6,
+ };
+ 
+ enum cursor_movement {
+-    CURSOR_SAVE,
+-    CURSOR_LOAD
++	CURSOR_SAVE,
++	CURSOR_LOAD
+ };
+ 
+ enum cursor_state {
+-    CURSOR_DEFAULT  = 0,
+-    CURSOR_WRAPNEXT = 1,
+-    CURSOR_ORIGIN   = 2
++	CURSOR_DEFAULT  = 0,
++	CURSOR_WRAPNEXT = 1,
++	CURSOR_ORIGIN   = 2
+ };
+ 
+ enum charset {
+-    CS_GRAPHIC0,
+-    CS_GRAPHIC1,
+-    CS_UK,
+-    CS_USA,
+-    CS_MULTI,
+-    CS_GER,
+-    CS_FIN
++	CS_GRAPHIC0,
++	CS_GRAPHIC1,
++	CS_UK,
++	CS_USA,
++	CS_MULTI,
++	CS_GER,
++	CS_FIN
+ };
+ 
+ enum escape_state {
+-    ESC_START      = 1,
+-    ESC_CSI        = 2,
+-    ESC_STR        = 4,  /* DCS, OSC, PM, APC */
+-    ESC_ALTCHARSET = 8,
+-    ESC_STR_END    = 16, /* a final string was encountered */
+-    ESC_TEST       = 32, /* Enter in test mode */
+-    ESC_UTF8       = 64,
++	ESC_START      = 1,
++	ESC_CSI        = 2,
++	ESC_STR        = 4,  /* DCS, OSC, PM, APC */
++	ESC_ALTCHARSET = 8,
++	ESC_STR_END    = 16, /* a final string was encountered */
++	ESC_TEST       = 32, /* Enter in test mode */
++	ESC_UTF8       = 64,
+ };
+ 
+ typedef struct {
+-    Glyph attr; /* current char attributes */
+-    int x;
+-    int y;
+-    char state;
++	Glyph attr; /* current char attributes */
++	int x;
++	int y;
++	char state;
+ } TCursor;
+ 
+ typedef struct {
+-    int mode;
+-    int type;
+-    int snap;
+-    /*
+-     * Selection variables:
+-     * nb – normalized coordinates of the beginning of the selection
+-     * ne – normalized coordinates of the end of the selection
+-     * ob – original coordinates of the beginning of the selection
+-     * oe – original coordinates of the end of the selection
+-     */
+-    struct {
+-        int x, y;
+-    } nb, ne, ob, oe;
+-
+-    int alt;
++	int mode;
++	int type;
++	int snap;
++	/*
++	 * Selection variables:
++	 * nb – normalized coordinates of the beginning of the selection
++	 * ne – normalized coordinates of the end of the selection
++	 * ob – original coordinates of the beginning of the selection
++	 * oe – original coordinates of the end of the selection
++	 */
++	struct {
++		int x, y;
++	} nb, ne, ob, oe;
++
++	int alt;
+ } Selection;
+ 
+ /* Internal representation of the screen */
+ typedef struct {
+-    int row;      /* nb row */
+-    int col;      /* nb col */
+-    int maxcol;
+-    Line *line;   /* screen */
+-    Line *alt;    /* alternate screen */
+-    Line hist[HISTSIZE]; /* history buffer */
+-    int histi;    /* history index */
+-    int scr;      /* scroll back */
+-    int *dirty;   /* dirtyness of lines */
+-    TCursor c;    /* cursor */
+-    int ocx;      /* old cursor col */
+-    int ocy;      /* old cursor row */
+-    int top;      /* top    scroll limit */
+-    int bot;      /* bottom scroll limit */
+-    int mode;     /* terminal mode flags */
+-    int esc;      /* escape state flags */
+-    char trantbl[4]; /* charset table translation */
+-    int charset;  /* current charset */
+-    int icharset; /* selected charset for sequence */
+-    int *tabs;
+-    Rune lastc;   /* last printed char outside of sequence, 0 if control */
++	int row;      /* nb row */
++	int col;      /* nb col */
++	Line *line;   /* screen */
++	Line *alt;    /* alternate screen */
++	Line hist[HISTSIZE]; /* history buffer */
++	int histi;    /* history index */
++	int scr;      /* scroll back */
++	int *dirty;   /* dirtyness of lines */
++	TCursor c;    /* cursor */
++	int ocx;      /* old cursor col */
++	int ocy;      /* old cursor row */
++	int top;      /* top    scroll limit */
++	int bot;      /* bottom scroll limit */
++	int mode;     /* terminal mode flags */
++	int esc;      /* escape state flags */
++	char trantbl[4]; /* charset table translation */
++	int charset;  /* current charset */
++	int icharset; /* selected charset for sequence */
++	int *tabs;
++	Rune lastc;   /* last printed char outside of sequence, 0 if control */
+ } Term;
+ 
+ /* CSI Escape sequence structs */
+ /* ESC '[' [[ [<priv>] <arg> [;]] <mode> [<mode>]] */
+ typedef struct {
+-    char buf[ESC_BUF_SIZ]; /* raw string */
+-    size_t len;            /* raw string length */
+-    char priv;
+-    int arg[ESC_ARG_SIZ];
+-    int narg;              /* nb of args */
+-    char mode[2];
++	char buf[ESC_BUF_SIZ]; /* raw string */
++	size_t len;            /* raw string length */
++	char priv;
++	int arg[ESC_ARG_SIZ];
++	int narg;              /* nb of args */
++	char mode[2];
+ } CSIEscape;
+ 
+ /* STR Escape sequence structs */
+ /* ESC type [[ [<priv>] <arg> [;]] <mode>] ESC '\' */
+ typedef struct {
+-    char type;             /* ESC type ... */
+-    char *buf;             /* allocated raw string */
+-    size_t siz;            /* allocation size */
+-    size_t len;            /* raw string length */
+-    char *args[STR_ARG_SIZ];
+-    int narg;              /* nb of args */
++	char type;             /* ESC type ... */
++	char *buf;             /* allocated raw string */
++	size_t siz;            /* allocation size */
++	size_t len;            /* raw string length */
++	char *args[STR_ARG_SIZ];
++	int narg;              /* nb of args */
+ } STREscape;
+ 
+ static void execsh(char *, char **);
+@@ -203,6 +201,7 @@ static void tsetscroll(int, int);
+ static void tswapscreen(void);
+ static void tsetmode(int, int, const int *, int);
+ static int twrite(const char *, int, int);
++static void tfulldirt(void);
+ static void tcontrolcode(uchar );
+ static void tdectest(char );
+ static void tdefutf8(char);
+@@ -243,2166 +242,2155 @@ static const Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF
+ ssize_t
+ xwrite(int fd, const char *s, size_t len)
+ {
+-    size_t aux = len;
+-    ssize_t r;
++	size_t aux = len;
++	ssize_t r;
+ 
+-    while (len > 0) {
+-        r = write(fd, s, len);
+-        if (r < 0)
+-            return r;
+-        len -= r;
+-        s += r;
+-    }
++	while (len > 0) {
++		r = write(fd, s, len);
++		if (r < 0)
++			return r;
++		len -= r;
++		s += r;
++	}
+ 
+-    return aux;
++	return aux;
+ }
+ 
+ void *
+ xmalloc(size_t len)
+ {
+-    void *p;
++	void *p;
+ 
+-    if (!(p = malloc(len)))
+-        die("malloc: %s\n", strerror(errno));
++	if (!(p = malloc(len)))
++		die("malloc: %s\n", strerror(errno));
+ 
+-    return p;
++	return p;
+ }
+ 
+ void *
+ xrealloc(void *p, size_t len)
+ {
+-    if ((p = realloc(p, len)) == NULL)
+-        die("realloc: %s\n", strerror(errno));
++	if ((p = realloc(p, len)) == NULL)
++		die("realloc: %s\n", strerror(errno));
+ 
+-    return p;
++	return p;
+ }
+ 
+ char *
+ xstrdup(const char *s)
+ {
+-    if ((s = strdup(s)) == NULL)
+-        die("strdup: %s\n", strerror(errno));
+-    char *p;
++	char *p;
+ 
+-    if ((p = strdup(s)) == NULL)
+-        die("strdup: %s\n", strerror(errno));
++	if ((p = strdup(s)) == NULL)
++		die("strdup: %s\n", strerror(errno));
+ 
+-    return p;
++	return p;
+ }
+ 
+ size_t
+ utf8decode(const char *c, Rune *u, size_t clen)
+ {
+-    size_t i, j, len, type;
+-    Rune udecoded;
++	size_t i, j, len, type;
++	Rune udecoded;
+ 
+-    *u = UTF_INVALID;
+-    if (!clen)
+-        return 0;
+-    udecoded = utf8decodebyte(c[0], &len);
+-    if (!BETWEEN(len, 1, UTF_SIZ))
+-        return 1;
+-    for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
+-        udecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);
+-        if (type != 0)
+-            return j;
+-    }
+-    if (j < len)
+-        return 0;
+-    *u = udecoded;
+-    utf8validate(u, len);
++	*u = UTF_INVALID;
++	if (!clen)
++		return 0;
++	udecoded = utf8decodebyte(c[0], &len);
++	if (!BETWEEN(len, 1, UTF_SIZ))
++		return 1;
++	for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
++		udecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);
++		if (type != 0)
++			return j;
++	}
++	if (j < len)
++		return 0;
++	*u = udecoded;
++	utf8validate(u, len);
+ 
+-    return len;
++	return len;
+ }
+ 
+ Rune
+ utf8decodebyte(char c, size_t *i)
+ {
+-    for (*i = 0; *i < LEN(utfmask); ++(*i))
+-        if (((uchar)c & utfmask[*i]) == utfbyte[*i])
+-            return (uchar)c & ~utfmask[*i];
++	for (*i = 0; *i < LEN(utfmask); ++(*i))
++		if (((uchar)c & utfmask[*i]) == utfbyte[*i])
++			return (uchar)c & ~utfmask[*i];
+ 
+-    return 0;
++	return 0;
+ }
+ 
+ size_t
+ utf8encode(Rune u, char *c)
+ {
+-    size_t len, i;
++	size_t len, i;
+ 
+-    len = utf8validate(&u, 0);
+-    if (len > UTF_SIZ)
+-        return 0;
++	len = utf8validate(&u, 0);
++	if (len > UTF_SIZ)
++		return 0;
+ 
+-    for (i = len - 1; i != 0; --i) {
+-        c[i] = utf8encodebyte(u, 0);
+-        u >>= 6;
+-    }
+-    c[0] = utf8encodebyte(u, len);
++	for (i = len - 1; i != 0; --i) {
++		c[i] = utf8encodebyte(u, 0);
++		u >>= 6;
++	}
++	c[0] = utf8encodebyte(u, len);
+ 
+-    return len;
++	return len;
+ }
+ 
+ char
+ utf8encodebyte(Rune u, size_t i)
+ {
+-    return utfbyte[i] | (u & ~utfmask[i]);
++	return utfbyte[i] | (u & ~utfmask[i]);
+ }
+ 
+ size_t
+ utf8validate(Rune *u, size_t i)
+ {
+-    if (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))
+-        *u = UTF_INVALID;
+-    for (i = 1; *u > utfmax[i]; ++i)
+-        ;
++	if (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))
++		*u = UTF_INVALID;
++	for (i = 1; *u > utfmax[i]; ++i)
++		;
+ 
+-    return i;
++	return i;
+ }
+ 
+ char
+ base64dec_getc(const char **src)
+ {
+-    while (**src && !isprint((unsigned char)**src))
+-        (*src)++;
+-    return **src ? *((*src)++) : '=';  /* emulate padding if string ends */
++	while (**src && !isprint((unsigned char)**src))
++		(*src)++;
++	return **src ? *((*src)++) : '=';  /* emulate padding if string ends */
+ }
+ 
+ char *
+ base64dec(const char *src)
+ {
+-    size_t in_len = strlen(src);
+-    char *result, *dst;
+-    static const char base64_digits[256] = {
+-        [43] = 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
+-        0, 0, 0, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+-        13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0,
+-        0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
+-        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
+-    };
+-
+-    if (in_len % 4)
+-        in_len += 4 - (in_len % 4);
+-    result = dst = xmalloc(in_len / 4 * 3 + 1);
+-    while (*src) {
+-        int a = base64_digits[(unsigned char) base64dec_getc(&src)];
+-        int b = base64_digits[(unsigned char) base64dec_getc(&src)];
+-        int c = base64_digits[(unsigned char) base64dec_getc(&src)];
+-        int d = base64_digits[(unsigned char) base64dec_getc(&src)];
+-
+-        /* invalid input. 'a' can be -1, e.g. if src is "\n" (c-str) */
+-        if (a == -1 || b == -1)
+-            break;
+-
+-        *dst++ = (a << 2) | ((b & 0x30) >> 4);
+-        if (c == -1)
+-            break;
+-        *dst++ = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);
+-        if (d == -1)
+-            break;
+-        *dst++ = ((c & 0x03) << 6) | d;
+-    }
+-    *dst = '\0';
+-    return result;
++	size_t in_len = strlen(src);
++	char *result, *dst;
++	static const char base64_digits[256] = {
++		[43] = 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
++		0, 0, 0, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
++		13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0,
++		0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
++		40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
++	};
++
++	if (in_len % 4)
++		in_len += 4 - (in_len % 4);
++	result = dst = xmalloc(in_len / 4 * 3 + 1);
++	while (*src) {
++		int a = base64_digits[(unsigned char) base64dec_getc(&src)];
++		int b = base64_digits[(unsigned char) base64dec_getc(&src)];
++		int c = base64_digits[(unsigned char) base64dec_getc(&src)];
++		int d = base64_digits[(unsigned char) base64dec_getc(&src)];
++
++		/* invalid input. 'a' can be -1, e.g. if src is "\n" (c-str) */
++		if (a == -1 || b == -1)
++			break;
++
++		*dst++ = (a << 2) | ((b & 0x30) >> 4);
++		if (c == -1)
++			break;
++		*dst++ = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);
++		if (d == -1)
++			break;
++		*dst++ = ((c & 0x03) << 6) | d;
++	}
++	*dst = '\0';
++	return result;
+ }
+ 
+ void
+ selinit(void)
+ {
+-    sel.mode = SEL_IDLE;
+-    sel.snap = 0;
+-    sel.ob.x = -1;
++	sel.mode = SEL_IDLE;
++	sel.snap = 0;
++	sel.ob.x = -1;
+ }
+ 
+ int
+ tlinelen(int y)
+ {
+-    int i = term.col;
++	int i = term.col;
+ 
+-    if (TLINE(y)[i - 1].mode & ATTR_WRAP)
+-        return i;
++	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
++		return i;
+ 
+-    while (i > 0 && TLINE(y)[i - 1].u == ' ')
+-        --i;
++	while (i > 0 && TLINE(y)[i - 1].u == ' ')
++		--i;
+ 
+-    return i;
+-}
+-
+-int
+-tlinehistlen(int y)
+-{
+-    int i = term.col;
+-
+-    if (TLINE_HIST(y)[i - 1].mode & ATTR_WRAP)
+-        return i;
+-
+-    while (i > 0 && TLINE_HIST(y)[i - 1].u == ' ')
+-        --i;
+-
+-    return i;
++	return i;
+ }
+ 
+ void
+ selstart(int col, int row, int snap)
+ {
+-    selclear();
+-    sel.mode = SEL_EMPTY;
+-    sel.type = SEL_REGULAR;
+-    sel.alt = IS_SET(MODE_ALTSCREEN);
+-    sel.snap = snap;
+-    sel.oe.x = sel.ob.x = col;
+-    sel.oe.y = sel.ob.y = row;
+-    selnormalize();
++	selclear();
++	sel.mode = SEL_EMPTY;
++	sel.type = SEL_REGULAR;
++	sel.alt = IS_SET(MODE_ALTSCREEN);
++	sel.snap = snap;
++	sel.oe.x = sel.ob.x = col;
++	sel.oe.y = sel.ob.y = row;
++	selnormalize();
+ 
+-    if (sel.snap != 0)
+-        sel.mode = SEL_READY;
+-    tsetdirt(sel.nb.y, sel.ne.y);
++	if (sel.snap != 0)
++		sel.mode = SEL_READY;
++	tsetdirt(sel.nb.y, sel.ne.y);
+ }
+ 
+ void
+ selextend(int col, int row, int type, int done)
+ {
+-    int oldey, oldex, oldsby, oldsey, oldtype;
++	int oldey, oldex, oldsby, oldsey, oldtype;
+ 
+-    if (sel.mode == SEL_IDLE)
+-        return;
+-    if (done && sel.mode == SEL_EMPTY) {
+-        selclear();
+-        return;
+-    }
++	if (sel.mode == SEL_IDLE)
++		return;
++	if (done && sel.mode == SEL_EMPTY) {
++		selclear();
++		return;
++	}
+ 
+-    oldey = sel.oe.y;
+-    oldex = sel.oe.x;
+-    oldsby = sel.nb.y;
+-    oldsey = sel.ne.y;
+-    oldtype = sel.type;
++	oldey = sel.oe.y;
++	oldex = sel.oe.x;
++	oldsby = sel.nb.y;
++	oldsey = sel.ne.y;
++	oldtype = sel.type;
+ 
+-    sel.oe.x = col;
+-    sel.oe.y = row;
+-    selnormalize();
+-    sel.type = type;
++	sel.oe.x = col;
++	sel.oe.y = row;
++	selnormalize();
++	sel.type = type;
+ 
+-    if (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)
+-        tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));
++	if (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)
++		tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));
+ 
+-    sel.mode = done ? SEL_IDLE : SEL_READY;
++	sel.mode = done ? SEL_IDLE : SEL_READY;
+ }
+ 
+ void
+ selnormalize(void)
+ {
+-    int i;
++	int i;
+ 
+-    if (sel.type == SEL_REGULAR && sel.ob.y != sel.oe.y) {
+-        sel.nb.x = sel.ob.y < sel.oe.y ? sel.ob.x : sel.oe.x;
+-        sel.ne.x = sel.ob.y < sel.oe.y ? sel.oe.x : sel.ob.x;
+-    } else {
+-        sel.nb.x = MIN(sel.ob.x, sel.oe.x);
+-        sel.ne.x = MAX(sel.ob.x, sel.oe.x);
+-    }
+-    sel.nb.y = MIN(sel.ob.y, sel.oe.y);
+-    sel.ne.y = MAX(sel.ob.y, sel.oe.y);
++	if (sel.type == SEL_REGULAR && sel.ob.y != sel.oe.y) {
++		sel.nb.x = sel.ob.y < sel.oe.y ? sel.ob.x : sel.oe.x;
++		sel.ne.x = sel.ob.y < sel.oe.y ? sel.oe.x : sel.ob.x;
++	} else {
++		sel.nb.x = MIN(sel.ob.x, sel.oe.x);
++		sel.ne.x = MAX(sel.ob.x, sel.oe.x);
++	}
++	sel.nb.y = MIN(sel.ob.y, sel.oe.y);
++	sel.ne.y = MAX(sel.ob.y, sel.oe.y);
+ 
+-    selsnap(&sel.nb.x, &sel.nb.y, -1);
+-    selsnap(&sel.ne.x, &sel.ne.y, +1);
++	selsnap(&sel.nb.x, &sel.nb.y, -1);
++	selsnap(&sel.ne.x, &sel.ne.y, +1);
+ 
+-    /* expand selection over line breaks */
+-    if (sel.type == SEL_RECTANGULAR)
+-        return;
+-    i = tlinelen(sel.nb.y);
+-    if (i < sel.nb.x)
+-        sel.nb.x = i;
+-    if (tlinelen(sel.ne.y) <= sel.ne.x)
+-        sel.ne.x = term.col - 1;
++	/* expand selection over line breaks */
++	if (sel.type == SEL_RECTANGULAR)
++		return;
++	i = tlinelen(sel.nb.y);
++	if (i < sel.nb.x)
++		sel.nb.x = i;
++	if (tlinelen(sel.ne.y) <= sel.ne.x)
++		sel.ne.x = term.col - 1;
+ }
+ 
+ int
+ selected(int x, int y)
+ {
+-    if (sel.mode == SEL_EMPTY || sel.ob.x == -1 ||
+-            sel.alt != IS_SET(MODE_ALTSCREEN))
+-        return 0;
++	if (sel.mode == SEL_EMPTY || sel.ob.x == -1 ||
++			sel.alt != IS_SET(MODE_ALTSCREEN))
++		return 0;
+ 
+-    if (sel.type == SEL_RECTANGULAR)
+-        return BETWEEN(y, sel.nb.y, sel.ne.y)
+-            && BETWEEN(x, sel.nb.x, sel.ne.x);
++	if (sel.type == SEL_RECTANGULAR)
++		return BETWEEN(y, sel.nb.y, sel.ne.y)
++		    && BETWEEN(x, sel.nb.x, sel.ne.x);
+ 
+-    return BETWEEN(y, sel.nb.y, sel.ne.y)
+-        && (y != sel.nb.y || x >= sel.nb.x)
+-        && (y != sel.ne.y || x <= sel.ne.x);
++	return BETWEEN(y, sel.nb.y, sel.ne.y)
++	    && (y != sel.nb.y || x >= sel.nb.x)
++	    && (y != sel.ne.y || x <= sel.ne.x);
+ }
+ 
+ void
+ selsnap(int *x, int *y, int direction)
+ {
+-    int newx, newy, xt, yt;
+-    int delim, prevdelim;
+-    const Glyph *gp, *prevgp;
+-
+-    switch (sel.snap) {
+-        case SNAP_WORD:
+-            /*
+-             * Snap around if the word wraps around at the end or
+-             * beginning of a line.
+-             */
+-            prevgp = &TLINE(*y)[*x];
+-            prevdelim = ISDELIM(prevgp->u);
+-            for (;;) {
+-                newx = *x + direction;
+-                newy = *y;
+-                if (!BETWEEN(newx, 0, term.col - 1)) {
+-                    newy += direction;
+-                    newx = (newx + term.col) % term.col;
+-                    if (!BETWEEN(newy, 0, term.row - 1))
+-                        break;
+-
+-                    if (direction > 0)
+-                        yt = *y, xt = *x;
+-                    else
+-                        yt = newy, xt = newx;
+-                    if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
+-                        break;
+-                }
+-
+-                if (newx >= tlinelen(newy))
+-                    break;
+-
+-                gp = &TLINE(newy)[newx];
+-                delim = ISDELIM(gp->u);
+-                if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
+-                            || (delim && gp->u != prevgp->u)))
+-                    break;
+-
+-                *x = newx;
+-                *y = newy;
+-                prevgp = gp;
+-                prevdelim = delim;
+-            }
+-            break;
+-        case SNAP_LINE:
+-            /*
+-             * Snap around if the the previous line or the current one
+-             * has set ATTR_WRAP at its end. Then the whole next or
+-             * previous line will be selected.
+-             */
+-            *x = (direction < 0) ? 0 : term.col - 1;
+-            if (direction < 0) {
+-                for (; *y > 0; *y += direction) {
+-                    if (!(TLINE(*y-1)[term.col-1].mode
+-                                & ATTR_WRAP)) {
+-                        break;
+-                    }
+-                }
+-            } else if (direction > 0) {
+-                for (; *y < term.row-1; *y += direction) {
+-                    if (!(TLINE(*y)[term.col-1].mode
+-                                & ATTR_WRAP)) {
+-                        break;
+-                    }
+-                }
+-            }
+-            break;
+-    }
++	int newx, newy, xt, yt;
++	int delim, prevdelim;
++	const Glyph *gp, *prevgp;
++
++	switch (sel.snap) {
++	case SNAP_WORD:
++		/*
++		 * Snap around if the word wraps around at the end or
++		 * beginning of a line.
++		 */
++		prevgp = &TLINE(*y)[*x];
++		prevdelim = ISDELIM(prevgp->u);
++		for (;;) {
++			newx = *x + direction;
++			newy = *y;
++			if (!BETWEEN(newx, 0, term.col - 1)) {
++				newy += direction;
++				newx = (newx + term.col) % term.col;
++				if (!BETWEEN(newy, 0, term.row - 1))
++					break;
++
++				if (direction > 0)
++					yt = *y, xt = *x;
++				else
++					yt = newy, xt = newx;
++				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
++					break;
++			}
++
++			if (newx >= tlinelen(newy))
++				break;
++
++			gp = &TLINE(newy)[newx];
++			delim = ISDELIM(gp->u);
++			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
++					|| (delim && gp->u != prevgp->u)))
++				break;
++
++			*x = newx;
++			*y = newy;
++			prevgp = gp;
++			prevdelim = delim;
++		}
++		break;
++	case SNAP_LINE:
++		/*
++		 * Snap around if the the previous line or the current one
++		 * has set ATTR_WRAP at its end. Then the whole next or
++		 * previous line will be selected.
++		 */
++		*x = (direction < 0) ? 0 : term.col - 1;
++		if (direction < 0) {
++			for (; *y > 0; *y += direction) {
++				if (!(TLINE(*y-1)[term.col-1].mode
++						& ATTR_WRAP)) {
++					break;
++				}
++			}
++		} else if (direction > 0) {
++			for (; *y < term.row-1; *y += direction) {
++				if (!(TLINE(*y)[term.col-1].mode
++						& ATTR_WRAP)) {
++					break;
++				}
++			}
++		}
++		break;
++	}
+ }
+ 
+ char *
+ getsel(void)
+ {
+-    char *str, *ptr;
+-    int y, bufsize, lastx, linelen;
+-    const Glyph *gp, *last;
+-
+-    if (sel.ob.x == -1)
+-        return NULL;
+-
+-    bufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;
+-    ptr = str = xmalloc(bufsize);
+-
+-    /* append every set & selected glyph to the selection */
+-    for (y = sel.nb.y; y <= sel.ne.y; y++) {
+-        if ((linelen = tlinelen(y)) == 0) {
+-            *ptr++ = '\n';
+-            continue;
+-        }
+-
+-        if (sel.type == SEL_RECTANGULAR) {
+-            gp = &TLINE(y)[sel.nb.x];
+-            lastx = sel.ne.x;
+-        } else {
+-            gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
+-            lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
+-        }
+-        last = &TLINE(y)[MIN(lastx, linelen-1)];
+-        while (last >= gp && last->u == ' ')
+-            --last;
+-
+-        for ( ; gp <= last; ++gp) {
+-            if (gp->mode & ATTR_WDUMMY)
+-                continue;
+-
+-            ptr += utf8encode(gp->u, ptr);
+-        }
+-
+-        /*
+-         * Copy and pasting of line endings is inconsistent
+-         * in the inconsistent terminal and GUI world.
+-         * The best solution seems like to produce '\n' when
+-         * something is copied from st and convert '\n' to
+-         * '\r', when something to be pasted is received by
+-         * st.
+-         * FIXME: Fix the computer world.
+-         */
+-        if ((y < sel.ne.y || lastx >= linelen) &&
+-                (!(last->mode & ATTR_WRAP) || sel.type == SEL_RECTANGULAR))
+-            *ptr++ = '\n';
+-    }
+-    *ptr = 0;
+-    return str;
++	char *str, *ptr;
++	int y, bufsize, lastx, linelen;
++	const Glyph *gp, *last;
++
++	if (sel.ob.x == -1)
++		return NULL;
++
++	bufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;
++	ptr = str = xmalloc(bufsize);
++
++	/* append every set & selected glyph to the selection */
++	for (y = sel.nb.y; y <= sel.ne.y; y++) {
++		if ((linelen = tlinelen(y)) == 0) {
++			*ptr++ = '\n';
++			continue;
++		}
++
++		if (sel.type == SEL_RECTANGULAR) {
++			gp = &TLINE(y)[sel.nb.x];
++			lastx = sel.ne.x;
++		} else {
++			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
++			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
++		}
++		last = &TLINE(y)[MIN(lastx, linelen-1)];
++		while (last >= gp && last->u == ' ')
++			--last;
++
++		for ( ; gp <= last; ++gp) {
++			if (gp->mode & ATTR_WDUMMY)
++				continue;
++
++			ptr += utf8encode(gp->u, ptr);
++		}
++
++		/*
++		 * Copy and pasting of line endings is inconsistent
++		 * in the inconsistent terminal and GUI world.
++		 * The best solution seems like to produce '\n' when
++		 * something is copied from st and convert '\n' to
++		 * '\r', when something to be pasted is received by
++		 * st.
++		 * FIXME: Fix the computer world.
++		 */
++		if ((y < sel.ne.y || lastx >= linelen) &&
++		    (!(last->mode & ATTR_WRAP) || sel.type == SEL_RECTANGULAR))
++			*ptr++ = '\n';
++	}
++	*ptr = 0;
++	return str;
+ }
+ 
+ void
+ selclear(void)
+ {
+-    if (sel.ob.x == -1)
+-        return;
+-    sel.mode = SEL_IDLE;
+-    sel.ob.x = -1;
+-    tsetdirt(sel.nb.y, sel.ne.y);
++	if (sel.ob.x == -1)
++		return;
++	sel.mode = SEL_IDLE;
++	sel.ob.x = -1;
++	tsetdirt(sel.nb.y, sel.ne.y);
+ }
+ 
+ void
+ die(const char *errstr, ...)
+ {
+-    va_list ap;
++	va_list ap;
+ 
+-    va_start(ap, errstr);
+-    vfprintf(stderr, errstr, ap);
+-    va_end(ap);
+-    exit(1);
++	va_start(ap, errstr);
++	vfprintf(stderr, errstr, ap);
++	va_end(ap);
++	exit(1);
+ }
+ 
+ void
+ execsh(char *cmd, char **args)
+ {
+-    char *sh, *prog, *arg;
+-    const struct passwd *pw;
+-
+-    errno = 0;
+-    if ((pw = getpwuid(getuid())) == NULL) {
+-        if (errno)
+-            die("getpwuid: %s\n", strerror(errno));
+-        else
+-            die("who are you?\n");
+-    }
+-
+-    if ((sh = getenv("SHELL")) == NULL)
+-        sh = (pw->pw_shell[0]) ? pw->pw_shell : cmd;
+-
+-    if (args) {
+-        prog = args[0];
+-        arg = NULL;
+-    } else if (scroll) {
+-        prog = scroll;
+-        arg = utmp ? utmp : sh;
+-    } else if (utmp) {
+-        prog = utmp;
+-        arg = NULL;
+-    } else {
+-        prog = sh;
+-        arg = NULL;
+-    }
+-    DEFAULT(args, ((char *[]) {prog, arg, NULL}));
+-
+-    unsetenv("COLUMNS");
+-    unsetenv("LINES");
+-    unsetenv("TERMCAP");
+-    setenv("LOGNAME", pw->pw_name, 1);
+-    setenv("USER", pw->pw_name, 1);
+-    setenv("SHELL", sh, 1);
+-    setenv("HOME", pw->pw_dir, 1);
+-    setenv("TERM", termname, 1);
+-
+-    signal(SIGCHLD, SIG_DFL);
+-    signal(SIGHUP, SIG_DFL);
+-    signal(SIGINT, SIG_DFL);
+-    signal(SIGQUIT, SIG_DFL);
+-    signal(SIGTERM, SIG_DFL);
+-    signal(SIGALRM, SIG_DFL);
+-
+-    execvp(prog, args);
+-    _exit(1);
++	char *sh, *prog, *arg;
++	const struct passwd *pw;
++
++	errno = 0;
++	if ((pw = getpwuid(getuid())) == NULL) {
++		if (errno)
++			die("getpwuid: %s\n", strerror(errno));
++		else
++			die("who are you?\n");
++	}
++
++	if ((sh = getenv("SHELL")) == NULL)
++		sh = (pw->pw_shell[0]) ? pw->pw_shell : cmd;
++
++	if (args) {
++		prog = args[0];
++		arg = NULL;
++	} else if (scroll) {
++		prog = scroll;
++		arg = utmp ? utmp : sh;
++	} else if (utmp) {
++		prog = utmp;
++		arg = NULL;
++	} else {
++		prog = sh;
++		arg = NULL;
++	}
++	DEFAULT(args, ((char *[]) {prog, arg, NULL}));
++
++	unsetenv("COLUMNS");
++	unsetenv("LINES");
++	unsetenv("TERMCAP");
++	setenv("LOGNAME", pw->pw_name, 1);
++	setenv("USER", pw->pw_name, 1);
++	setenv("SHELL", sh, 1);
++	setenv("HOME", pw->pw_dir, 1);
++	setenv("TERM", termname, 1);
++
++	signal(SIGCHLD, SIG_DFL);
++	signal(SIGHUP, SIG_DFL);
++	signal(SIGINT, SIG_DFL);
++	signal(SIGQUIT, SIG_DFL);
++	signal(SIGTERM, SIG_DFL);
++	signal(SIGALRM, SIG_DFL);
++
++	execvp(prog, args);
++	_exit(1);
+ }
+ 
+ void
+ sigchld(int a)
+ {
+-    int stat;
+-    pid_t p;
++	int stat;
++	pid_t p;
+ 
+-    if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
+-        die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
++	if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
++		die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
+ 
+-    if (pid != p)
+-        return;
++	if (pid != p) {
++		if (p == 0 && wait(&stat) < 0)
++			die("wait: %s\n", strerror(errno));
+ 
+-    if (WIFEXITED(stat) && WEXITSTATUS(stat))
+-        die("child exited with status %d\n", WEXITSTATUS(stat));
+-    else if (WIFSIGNALED(stat))
+-        die("child terminated due to signal %d\n", WTERMSIG(stat));
+-    _exit(0);
++		/* reinstall sigchld handler */
++		signal(SIGCHLD, sigchld);
++		return;
++	}
++
++	if (WIFEXITED(stat) && WEXITSTATUS(stat))
++		die("child exited with status %d\n", WEXITSTATUS(stat));
++	else if (WIFSIGNALED(stat))
++		die("child terminated due to signal %d\n", WTERMSIG(stat));
++	_exit(0);
+ }
+ 
+ void
+ stty(char **args)
+ {
+-    char cmd[_POSIX_ARG_MAX], **p, *q, *s;
+-    size_t n, siz;
+-
+-    if ((n = strlen(stty_args)) > sizeof(cmd)-1)
+-        die("incorrect stty parameters\n");
+-    memcpy(cmd, stty_args, n);
+-    q = cmd + n;
+-    siz = sizeof(cmd) - n;
+-    for (p = args; p && (s = *p); ++p) {
+-        if ((n = strlen(s)) > siz-1)
+-            die("stty parameter length too long\n");
+-        *q++ = ' ';
+-        memcpy(q, s, n);
+-        q += n;
+-        siz -= n + 1;
+-    }
+-    *q = '\0';
+-    if (system(cmd) != 0)
+-        perror("Couldn't call stty");
++	char cmd[_POSIX_ARG_MAX], **p, *q, *s;
++	size_t n, siz;
++
++	if ((n = strlen(stty_args)) > sizeof(cmd)-1)
++		die("incorrect stty parameters\n");
++	memcpy(cmd, stty_args, n);
++	q = cmd + n;
++	siz = sizeof(cmd) - n;
++	for (p = args; p && (s = *p); ++p) {
++		if ((n = strlen(s)) > siz-1)
++			die("stty parameter length too long\n");
++		*q++ = ' ';
++		memcpy(q, s, n);
++		q += n;
++		siz -= n + 1;
++	}
++	*q = '\0';
++	if (system(cmd) != 0)
++		perror("Couldn't call stty");
+ }
+ 
+ int
+ ttynew(const char *line, char *cmd, const char *out, char **args)
+ {
+-    int m, s;
+-
+-    if (out) {
+-        term.mode |= MODE_PRINT;
+-        iofd = (!strcmp(out, "-")) ?
+-            1 : open(out, O_WRONLY | O_CREAT, 0666);
+-        if (iofd < 0) {
+-            fprintf(stderr, "Error opening %s:%s\n",
+-                    out, strerror(errno));
+-        }
+-    }
+-
+-    if (line) {
+-        if ((cmdfd = open(line, O_RDWR)) < 0)
+-            die("open line '%s' failed: %s\n",
+-                    line, strerror(errno));
+-        dup2(cmdfd, 0);
+-        stty(args);
+-        return cmdfd;
+-    }
+-
+-    /* seems to work fine on linux, openbsd and freebsd */
+-    if (openpty(&m, &s, NULL, NULL, NULL) < 0)
+-        die("openpty failed: %s\n", strerror(errno));
+-
+-    switch (pid = fork()) {
+-        case -1:
+-            die("fork failed: %s\n", strerror(errno));
+-            break;
+-        case 0:
+-            close(iofd);
+-            close(m);
+-            setsid(); /* create a new process group */
+-            dup2(s, 0);
+-            dup2(s, 1);
+-            dup2(s, 2);
+-            if (ioctl(s, TIOCSCTTY, NULL) < 0)
+-                die("ioctl TIOCSCTTY failed: %s\n", strerror(errno));
+-            if (s > 2)
+-                close(s);
++	int m, s;
++
++	if (out) {
++		term.mode |= MODE_PRINT;
++		iofd = (!strcmp(out, "-")) ?
++			  1 : open(out, O_WRONLY | O_CREAT, 0666);
++		if (iofd < 0) {
++			fprintf(stderr, "Error opening %s:%s\n",
++				out, strerror(errno));
++		}
++	}
++
++	if (line) {
++		if ((cmdfd = open(line, O_RDWR)) < 0)
++			die("open line '%s' failed: %s\n",
++			    line, strerror(errno));
++		dup2(cmdfd, 0);
++		stty(args);
++		return cmdfd;
++	}
++
++	/* seems to work fine on linux, openbsd and freebsd */
++	if (openpty(&m, &s, NULL, NULL, NULL) < 0)
++		die("openpty failed: %s\n", strerror(errno));
++
++	switch (pid = fork()) {
++	case -1:
++		die("fork failed: %s\n", strerror(errno));
++		break;
++	case 0:
++		close(iofd);
++		close(m);
++		setsid(); /* create a new process group */
++		dup2(s, 0);
++		dup2(s, 1);
++		dup2(s, 2);
++		if (ioctl(s, TIOCSCTTY, NULL) < 0)
++			die("ioctl TIOCSCTTY failed: %s\n", strerror(errno));
++		if (s > 2)
++			close(s);
+ #ifdef __OpenBSD__
+-            if (pledge("stdio getpw proc exec", NULL) == -1)
+-                die("pledge\n");
++		if (pledge("stdio getpw proc exec", NULL) == -1)
++			die("pledge\n");
+ #endif
+-            execsh(cmd, args);
+-            break;
+-        default:
++		execsh(cmd, args);
++		break;
++	default:
+ #ifdef __OpenBSD__
+-            if (pledge("stdio rpath tty proc", NULL) == -1)
+-                die("pledge\n");
++		if (pledge("stdio rpath tty proc exec", NULL) == -1)
++			die("pledge\n");
+ #endif
+-            close(s);
+-            cmdfd = m;
+-            signal(SIGCHLD, sigchld);
+-            break;
+-    }
+-    return cmdfd;
++		close(s);
++		cmdfd = m;
++		signal(SIGCHLD, sigchld);
++		break;
++	}
++	return cmdfd;
+ }
+ 
+ size_t
+ ttyread(void)
+ {
+-    static char buf[BUFSIZ];
+-    static int buflen = 0;
+-    int ret, written;
++	static char buf[BUFSIZ];
++	static int buflen = 0;
++	int ret, written;
+ 
+-    /* append read bytes to unprocessed bytes */
+-    ret = read(cmdfd, buf+buflen, LEN(buf)-buflen);
++	/* append read bytes to unprocessed bytes */
++	ret = read(cmdfd, buf+buflen, LEN(buf)-buflen);
+ 
+-    switch (ret) {
+-        case 0:
+-            exit(0);
+-        case -1:
+-            die("couldn't read from shell: %s\n", strerror(errno));
+-        default:
+-            buflen += ret;
+-            written = twrite(buf, buflen, 0);
+-            buflen -= written;
+-            /* keep any incomplete UTF-8 byte sequence for the next call */
+-            if (buflen > 0)
+-                memmove(buf, buf + written, buflen);
+-            return ret;
+-    }
++	switch (ret) {
++	case 0:
++		exit(0);
++	case -1:
++		die("couldn't read from shell: %s\n", strerror(errno));
++	default:
++		buflen += ret;
++		written = twrite(buf, buflen, 0);
++		buflen -= written;
++		/* keep any incomplete UTF-8 byte sequence for the next call */
++		if (buflen > 0)
++			memmove(buf, buf + written, buflen);
++		return ret;
++	}
+ }
+ 
+ void
+ ttywrite(const char *s, size_t n, int may_echo)
+ {
+-    const char *next;
+-    Arg arg = (Arg) { .i = term.scr };
++	const char *next;
++	Arg arg = (Arg) { .i = term.scr };
+ 
+-    kscrolldown(&arg);
++	kscrolldown(&arg);
+ 
+-    if (may_echo && IS_SET(MODE_ECHO))
+-        twrite(s, n, 1);
++	if (may_echo && IS_SET(MODE_ECHO))
++		twrite(s, n, 1);
+ 
+-    if (!IS_SET(MODE_CRLF)) {
+-        ttywriteraw(s, n);
+-        return;
+-    }
++	if (!IS_SET(MODE_CRLF)) {
++		ttywriteraw(s, n);
++		return;
++	}
+ 
+-    /* This is similar to how the kernel handles ONLCR for ttys */
+-    while (n > 0) {
+-        if (*s == '\r') {
+-            next = s + 1;
+-            ttywriteraw("\r\n", 2);
+-        } else {
+-            next = memchr(s, '\r', n);
+-            DEFAULT(next, s + n);
+-            ttywriteraw(s, next - s);
+-        }
+-        n -= next - s;
+-        s = next;
+-    }
++	/* This is similar to how the kernel handles ONLCR for ttys */
++	while (n > 0) {
++		if (*s == '\r') {
++			next = s + 1;
++			ttywriteraw("\r\n", 2);
++		} else {
++			next = memchr(s, '\r', n);
++			DEFAULT(next, s + n);
++			ttywriteraw(s, next - s);
++		}
++		n -= next - s;
++		s = next;
++	}
+ }
+ 
+ void
+ ttywriteraw(const char *s, size_t n)
+ {
+-    fd_set wfd, rfd;
+-    ssize_t r;
+-    size_t lim = 256;
+-
+-    /*
+-     * Remember that we are using a pty, which might be a modem line.
+-     * Writing too much will clog the line. That's why we are doing this
+-     * dance.
+-     * FIXME: Migrate the world to Plan 9.
+-     */
+-    while (n > 0) {
+-        FD_ZERO(&wfd);
+-        FD_ZERO(&rfd);
+-        FD_SET(cmdfd, &wfd);
+-        FD_SET(cmdfd, &rfd);
+-
+-        /* Check if we can write. */
+-        if (pselect(cmdfd+1, &rfd, &wfd, NULL, NULL, NULL) < 0) {
+-            if (errno == EINTR)
+-                continue;
+-            die("select failed: %s\n", strerror(errno));
+-        }
+-        if (FD_ISSET(cmdfd, &wfd)) {
+-            /*
+-             * Only write the bytes written by ttywrite() or the
+-             * default of 256. This seems to be a reasonable value
+-             * for a serial line. Bigger values might clog the I/O.
+-             */
+-            if ((r = write(cmdfd, s, (n < lim)? n : lim)) < 0)
+-                goto write_error;
+-            if (r < n) {
+-                /*
+-                 * We weren't able to write out everything.
+-                 * This means the buffer is getting full
+-                 * again. Empty it.
+-                 */
+-                if (n < lim)
+-                    lim = ttyread();
+-                n -= r;
+-                s += r;
+-            } else {
+-                /* All bytes have been written. */
+-                break;
+-            }
+-        }
+-        if (FD_ISSET(cmdfd, &rfd))
+-            lim = ttyread();
+-    }
+-    return;
++	fd_set wfd, rfd;
++	ssize_t r;
++	size_t lim = 256;
++
++	/*
++	 * Remember that we are using a pty, which might be a modem line.
++	 * Writing too much will clog the line. That's why we are doing this
++	 * dance.
++	 * FIXME: Migrate the world to Plan 9.
++	 */
++	while (n > 0) {
++		FD_ZERO(&wfd);
++		FD_ZERO(&rfd);
++		FD_SET(cmdfd, &wfd);
++		FD_SET(cmdfd, &rfd);
++
++		/* Check if we can write. */
++		if (pselect(cmdfd+1, &rfd, &wfd, NULL, NULL, NULL) < 0) {
++			if (errno == EINTR)
++				continue;
++			die("select failed: %s\n", strerror(errno));
++		}
++		if (FD_ISSET(cmdfd, &wfd)) {
++			/*
++			 * Only write the bytes written by ttywrite() or the
++			 * default of 256. This seems to be a reasonable value
++			 * for a serial line. Bigger values might clog the I/O.
++			 */
++			if ((r = write(cmdfd, s, (n < lim)? n : lim)) < 0)
++				goto write_error;
++			if (r < n) {
++				/*
++				 * We weren't able to write out everything.
++				 * This means the buffer is getting full
++				 * again. Empty it.
++				 */
++				if (n < lim)
++					lim = ttyread();
++				n -= r;
++				s += r;
++			} else {
++				/* All bytes have been written. */
++				break;
++			}
++		}
++		if (FD_ISSET(cmdfd, &rfd))
++			lim = ttyread();
++	}
++	return;
+ 
+ write_error:
+-    die("write error on tty: %s\n", strerror(errno));
++	die("write error on tty: %s\n", strerror(errno));
+ }
+ 
+ void
+ ttyresize(int tw, int th)
+ {
+-    struct winsize w;
++	struct winsize w;
+ 
+-    w.ws_row = term.row;
+-    w.ws_col = term.col;
+-    w.ws_xpixel = tw;
+-    w.ws_ypixel = th;
+-    if (ioctl(cmdfd, TIOCSWINSZ, &w) < 0)
+-        fprintf(stderr, "Couldn't set window size: %s\n", strerror(errno));
++	w.ws_row = term.row;
++	w.ws_col = term.col;
++	w.ws_xpixel = tw;
++	w.ws_ypixel = th;
++	if (ioctl(cmdfd, TIOCSWINSZ, &w) < 0)
++		fprintf(stderr, "Couldn't set window size: %s\n", strerror(errno));
+ }
+ 
+ void
+ ttyhangup(void)
+ {
+-    /* Send SIGHUP to shell */
+-    kill(pid, SIGHUP);
++	/* Send SIGHUP to shell */
++	kill(pid, SIGHUP);
+ }
+ 
+ int
+ tattrset(int attr)
+ {
+-    int i, j;
++	int i, j;
+ 
+-    for (i = 0; i < term.row-1; i++) {
+-        for (j = 0; j < term.col-1; j++) {
+-            if (term.line[i][j].mode & attr)
+-                return 1;
+-        }
+-    }
++	for (i = 0; i < term.row-1; i++) {
++		for (j = 0; j < term.col-1; j++) {
++			if (term.line[i][j].mode & attr)
++				return 1;
++		}
++	}
+ 
+-    return 0;
++	return 0;
+ }
+ 
+ void
+ tsetdirt(int top, int bot)
+ {
+-    int i;
++	int i;
+ 
+-    LIMIT(top, 0, term.row-1);
+-    LIMIT(bot, 0, term.row-1);
++	LIMIT(top, 0, term.row-1);
++	LIMIT(bot, 0, term.row-1);
+ 
+-    for (i = top; i <= bot; i++)
+-        term.dirty[i] = 1;
++	for (i = top; i <= bot; i++)
++		term.dirty[i] = 1;
+ }
+ 
+ void
+ tsetdirtattr(int attr)
+ {
+-    int i, j;
++	int i, j;
+ 
+-    for (i = 0; i < term.row-1; i++) {
+-        for (j = 0; j < term.col-1; j++) {
+-            if (term.line[i][j].mode & attr) {
+-                tsetdirt(i, i);
+-                break;
+-            }
+-        }
+-    }
++	for (i = 0; i < term.row-1; i++) {
++		for (j = 0; j < term.col-1; j++) {
++			if (term.line[i][j].mode & attr) {
++				tsetdirt(i, i);
++				break;
++			}
++		}
++	}
+ }
+ 
+ void
+ tfulldirt(void)
+ {
+-    tsetdirt(0, term.row-1);
++	tsetdirt(0, term.row-1);
+ }
+ 
+ void
+ tcursor(int mode)
+ {
+-    static TCursor c[2];
+-    int alt = IS_SET(MODE_ALTSCREEN);
++	static TCursor c[2];
++	int alt = IS_SET(MODE_ALTSCREEN);
+ 
+-    if (mode == CURSOR_SAVE) {
+-        c[alt] = term.c;
+-    } else if (mode == CURSOR_LOAD) {
+-        term.c = c[alt];
+-        tmoveto(c[alt].x, c[alt].y);
+-    }
++	if (mode == CURSOR_SAVE) {
++		c[alt] = term.c;
++	} else if (mode == CURSOR_LOAD) {
++		term.c = c[alt];
++		tmoveto(c[alt].x, c[alt].y);
++	}
+ }
+ 
+ void
+ treset(void)
+ {
+-    uint i;
++	uint i;
+ 
+-    term.c = (TCursor){{
+-        .mode = ATTR_NULL,
+-            .fg = defaultfg,
+-            .bg = defaultbg
+-    }, .x = 0, .y = 0, .state = CURSOR_DEFAULT};
++	term.c = (TCursor){{
++		.mode = ATTR_NULL,
++		.fg = defaultfg,
++		.bg = defaultbg
++	}, .x = 0, .y = 0, .state = CURSOR_DEFAULT};
+ 
+-    memset(term.tabs, 0, term.col * sizeof(*term.tabs));
+-    for (i = tabspaces; i < term.col; i += tabspaces)
+-        term.tabs[i] = 1;
+-    term.top = 0;
+-    term.bot = term.row - 1;
+-    term.mode = MODE_WRAP|MODE_UTF8;
+-    memset(term.trantbl, CS_USA, sizeof(term.trantbl));
+-    term.charset = 0;
++	memset(term.tabs, 0, term.col * sizeof(*term.tabs));
++	for (i = tabspaces; i < term.col; i += tabspaces)
++		term.tabs[i] = 1;
++	term.top = 0;
++	term.bot = term.row - 1;
++	term.mode = MODE_WRAP|MODE_UTF8;
++	memset(term.trantbl, CS_USA, sizeof(term.trantbl));
++	term.charset = 0;
+ 
+-    for (i = 0; i < 2; i++) {
+-        tmoveto(0, 0);
+-        tcursor(CURSOR_SAVE);
+-        tclearregion(0, 0, term.col-1, term.row-1);
+-        tswapscreen();
+-    }
++	for (i = 0; i < 2; i++) {
++		tmoveto(0, 0);
++		tcursor(CURSOR_SAVE);
++		tclearregion(0, 0, term.col-1, term.row-1);
++		tswapscreen();
++	}
+ }
+ 
+ void
+ tnew(int col, int row)
+ {
+-    term = (Term){ .c = { .attr = { .fg = defaultfg, .bg = defaultbg } } };
+-    tresize(col, row);
+-    treset();
++	term = (Term){ .c = { .attr = { .fg = defaultfg, .bg = defaultbg } } };
++	tresize(col, row);
++	treset();
+ }
+ 
+ void
+ tswapscreen(void)
+ {
+-    Line *tmp = term.line;
++	Line *tmp = term.line;
+ 
+-    term.line = term.alt;
+-    term.alt = tmp;
+-    term.mode ^= MODE_ALTSCREEN;
+-    tfulldirt();
++	term.line = term.alt;
++	term.alt = tmp;
++	term.mode ^= MODE_ALTSCREEN;
++	tfulldirt();
+ }
+ 
+ void
+ kscrolldown(const Arg* a)
+ {
+-    int n = a->i;
++	int n = a->i;
+ 
+-    if (n < 0)
+-        n = term.row + n;
++	if (n < 0)
++		n = term.row + n;
+ 
+-    if (n > term.scr)
+-        n = term.scr;
++	if (n > term.scr)
++		n = term.scr;
+ 
+-    if (term.scr > 0) {
+-        term.scr -= n;
+-        selscroll(0, -n);
+-        tfulldirt();
+-    }
++	if (term.scr > 0) {
++		term.scr -= n;
++		selscroll(0, -n);
++		tfulldirt();
++	}
+ }
+ 
+ void
+ kscrollup(const Arg* a)
+ {
+-    int n = a->i;
++	int n = a->i;
+ 
+-    if (n < 0)
+-        n = term.row + n;
++	if (n < 0)
++		n = term.row + n;
+ 
+-    if (term.scr <= HISTSIZE-n) {
+-        term.scr += n;
+-        selscroll(0, n);
+-        tfulldirt();
+-    }
++	if (term.scr <= HISTSIZE-n) {
++		term.scr += n;
++		selscroll(0, n);
++		tfulldirt();
++	}
+ }
+ 
+ void
+ tscrolldown(int orig, int n, int copyhist)
+ {
+-    int i;
+-    Line temp;
++	int i;
++	Line temp;
+ 
+-    LIMIT(n, 0, term.bot-orig+1);
++	LIMIT(n, 0, term.bot-orig+1);
+ 
+-    if (copyhist) {
+-        term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+-        temp = term.hist[term.histi];
+-        term.hist[term.histi] = term.line[term.bot];
+-        term.line[term.bot] = temp;
+-    }
++	if (copyhist) {
++		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[term.bot];
++		term.line[term.bot] = temp;
++	}
+ 
+-    tsetdirt(orig, term.bot-n);
+-    tclearregion(0, term.bot-n+1, term.col-1, term.bot);
++	tsetdirt(orig, term.bot-n);
++	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
+ 
+-    for (i = term.bot; i >= orig+n; i--) {
+-        temp = term.line[i];
+-        term.line[i] = term.line[i-n];
+-        term.line[i-n] = temp;
+-    }
++	for (i = term.bot; i >= orig+n; i--) {
++		temp = term.line[i];
++		term.line[i] = term.line[i-n];
++		term.line[i-n] = temp;
++	}
+ 
+-    if (term.scr == 0)
+-        selscroll(orig, n);
++	if (term.scr == 0)
++		selscroll(orig, n);
+ }
+ 
+ void
+ tscrollup(int orig, int n, int copyhist)
+ {
+-    int i;
+-    Line temp;
++	int i;
++	Line temp;
+ 
+-    LIMIT(n, 0, term.bot-orig+1);
++	LIMIT(n, 0, term.bot-orig+1);
+ 
+-    if (copyhist) {
+-        term.histi = (term.histi + 1) % HISTSIZE;
+-        temp = term.hist[term.histi];
+-        term.hist[term.histi] = term.line[orig];
+-        term.line[orig] = temp;
+-    }
++	if (copyhist) {
++		term.histi = (term.histi + 1) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[orig];
++		term.line[orig] = temp;
++	}
+ 
+-    if (term.scr > 0 && term.scr < HISTSIZE)
+-        term.scr = MIN(term.scr + n, HISTSIZE-1);
++	if (term.scr > 0 && term.scr < HISTSIZE)
++		term.scr = MIN(term.scr + n, HISTSIZE-1);
+ 
+-    tclearregion(0, orig, term.col-1, orig+n-1);
+-    tsetdirt(orig+n, term.bot);
++	tclearregion(0, orig, term.col-1, orig+n-1);
++	tsetdirt(orig+n, term.bot);
+ 
+-    for (i = orig; i <= term.bot-n; i++) {
+-        temp = term.line[i];
+-        term.line[i] = term.line[i+n];
+-        term.line[i+n] = temp;
+-    }
++	for (i = orig; i <= term.bot-n; i++) {
++		temp = term.line[i];
++		term.line[i] = term.line[i+n];
++		term.line[i+n] = temp;
++	}
+ 
+-    if (term.scr == 0)
+-        selscroll(orig, -n);
++	if (term.scr == 0)
++		selscroll(orig, -n);
+ }
+ 
+ void
+ selscroll(int orig, int n)
+ {
+-    if (sel.ob.x == -1 || sel.alt != IS_SET(MODE_ALTSCREEN))
+-        return;
++	if (sel.ob.x == -1 || sel.alt != IS_SET(MODE_ALTSCREEN))
++		return;
+ 
+-    if (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {
+-        selclear();
+-    } else if (BETWEEN(sel.nb.y, orig, term.bot)) {
+-        sel.ob.y += n;
+-        sel.oe.y += n;
+-        if (sel.ob.y < term.top || sel.ob.y > term.bot ||
+-                sel.oe.y < term.top || sel.oe.y > term.bot) {
+-            selclear();
+-        } else {
+-            selnormalize();
+-        }
+-    }
++	if (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {
++		selclear();
++	} else if (BETWEEN(sel.nb.y, orig, term.bot)) {
++		sel.ob.y += n;
++		sel.oe.y += n;
++		if (sel.ob.y < term.top || sel.ob.y > term.bot ||
++		    sel.oe.y < term.top || sel.oe.y > term.bot) {
++			selclear();
++		} else {
++			selnormalize();
++		}
++	}
+ }
+ 
+ void
+ tnewline(int first_col)
+ {
+-    int y = term.c.y;
++	int y = term.c.y;
+ 
+-    if (y == term.bot) {
+-        tscrollup(term.top, 1, 1);
+-    } else {
+-        y++;
+-    }
+-    tmoveto(first_col ? 0 : term.c.x, y);
++	if (y == term.bot) {
++		tscrollup(term.top, 1, 1);
++	} else {
++		y++;
++	}
++	tmoveto(first_col ? 0 : term.c.x, y);
+ }
+ 
+ void
+ csiparse(void)
+ {
+-    char *p = csiescseq.buf, *np;
+-    long int v;
+-
+-    csiescseq.narg = 0;
+-    if (*p == '?') {
+-        csiescseq.priv = 1;
+-        p++;
+-    }
+-
+-    csiescseq.buf[csiescseq.len] = '\0';
+-    while (p < csiescseq.buf+csiescseq.len) {
+-        np = NULL;
+-        v = strtol(p, &np, 10);
+-        if (np == p)
+-            v = 0;
+-        if (v == LONG_MAX || v == LONG_MIN)
+-            v = -1;
+-        csiescseq.arg[csiescseq.narg++] = v;
+-        p = np;
+-        if (*p != ';' || csiescseq.narg == ESC_ARG_SIZ)
+-            break;
+-        p++;
+-    }
+-    csiescseq.mode[0] = *p++;
+-    csiescseq.mode[1] = (p < csiescseq.buf+csiescseq.len) ? *p : '\0';
++	char *p = csiescseq.buf, *np;
++	long int v;
++	int sep = ';'; /* colon or semi-colon, but not both */
++
++	csiescseq.narg = 0;
++	if (*p == '?') {
++		csiescseq.priv = 1;
++		p++;
++	}
++
++	csiescseq.buf[csiescseq.len] = '\0';
++	while (p < csiescseq.buf+csiescseq.len) {
++		np = NULL;
++		v = strtol(p, &np, 10);
++		if (np == p)
++			v = 0;
++		if (v == LONG_MAX || v == LONG_MIN)
++			v = -1;
++		csiescseq.arg[csiescseq.narg++] = v;
++		p = np;
++		if (sep == ';' && *p == ':')
++			sep = ':'; /* allow override to colon once */
++		if (*p != sep || csiescseq.narg == ESC_ARG_SIZ)
++			break;
++		p++;
++	}
++	csiescseq.mode[0] = *p++;
++	csiescseq.mode[1] = (p < csiescseq.buf+csiescseq.len) ? *p : '\0';
+ }
+ 
+ /* for absolute user moves, when decom is set */
+ void
+ tmoveato(int x, int y)
+ {
+-    tmoveto(x, y + ((term.c.state & CURSOR_ORIGIN) ? term.top: 0));
++	tmoveto(x, y + ((term.c.state & CURSOR_ORIGIN) ? term.top: 0));
+ }
+ 
+ void
+ tmoveto(int x, int y)
+ {
+-    int miny, maxy;
++	int miny, maxy;
+ 
+-    if (term.c.state & CURSOR_ORIGIN) {
+-        miny = term.top;
+-        maxy = term.bot;
+-    } else {
+-        miny = 0;
+-        maxy = term.row - 1;
+-    }
+-    term.c.state &= ~CURSOR_WRAPNEXT;
+-    term.c.x = LIMIT(x, 0, term.col-1);
+-    term.c.y = LIMIT(y, miny, maxy);
++	if (term.c.state & CURSOR_ORIGIN) {
++		miny = term.top;
++		maxy = term.bot;
++	} else {
++		miny = 0;
++		maxy = term.row - 1;
++	}
++	term.c.state &= ~CURSOR_WRAPNEXT;
++	term.c.x = LIMIT(x, 0, term.col-1);
++	term.c.y = LIMIT(y, miny, maxy);
+ }
+ 
+ void
+ tsetchar(Rune u, const Glyph *attr, int x, int y)
+ {
+-    static const char *vt100_0[62] = { /* 0x41 - 0x7e */
+-        "↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
+-        0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
+-        0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
+-        0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
+-        "◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
+-        "␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
+-        "⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
+-        "│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
+-    };
+-
+-    /*
+-     * The table is proudly stolen from rxvt.
+-     */
+-    if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
+-            BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
+-        utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
+-
+-    if (term.line[y][x].mode & ATTR_WIDE) {
+-        if (x+1 < term.col) {
+-            term.line[y][x+1].u = ' ';
+-            term.line[y][x+1].mode &= ~ATTR_WDUMMY;
+-        }
+-    } else if (term.line[y][x].mode & ATTR_WDUMMY) {
+-        term.line[y][x-1].u = ' ';
+-        term.line[y][x-1].mode &= ~ATTR_WIDE;
+-    }
+-
+-    term.dirty[y] = 1;
+-    term.line[y][x] = *attr;
+-    term.line[y][x].u = u;
+-
+-    if (isboxdraw(u))
+-        term.line[y][x].mode |= ATTR_BOXDRAW;
++	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
++		"↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
++		0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
++		0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
++		0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
++		"◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
++		"␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
++		"⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
++		"│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
++	};
++
++	/*
++	 * The table is proudly stolen from rxvt.
++	 */
++	if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
++	   BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
++		utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
++
++	if (term.line[y][x].mode & ATTR_WIDE) {
++		if (x+1 < term.col) {
++			term.line[y][x+1].u = ' ';
++			term.line[y][x+1].mode &= ~ATTR_WDUMMY;
++		}
++	} else if (term.line[y][x].mode & ATTR_WDUMMY) {
++		term.line[y][x-1].u = ' ';
++		term.line[y][x-1].mode &= ~ATTR_WIDE;
++	}
++
++	term.dirty[y] = 1;
++	term.line[y][x] = *attr;
++	term.line[y][x].u = u;
+ }
+ 
+ void
+ tclearregion(int x1, int y1, int x2, int y2)
+ {
+-    int x, y, temp;
+-    Glyph *gp;
++	int x, y, temp;
++	Glyph *gp;
+ 
+-    if (x1 > x2)
+-        temp = x1, x1 = x2, x2 = temp;
+-    if (y1 > y2)
+-        temp = y1, y1 = y2, y2 = temp;
++	if (x1 > x2)
++		temp = x1, x1 = x2, x2 = temp;
++	if (y1 > y2)
++		temp = y1, y1 = y2, y2 = temp;
+ 
+-    LIMIT(x1, 0, term.maxcol-1);
+-    LIMIT(x2, 0, term.maxcol-1);
+-    LIMIT(y1, 0, term.row-1);
+-    LIMIT(y2, 0, term.row-1);
++	LIMIT(x1, 0, term.col-1);
++	LIMIT(x2, 0, term.col-1);
++	LIMIT(y1, 0, term.row-1);
++	LIMIT(y2, 0, term.row-1);
+ 
+-    for (y = y1; y <= y2; y++) {
+-        term.dirty[y] = 1;
+-        for (x = x1; x <= x2; x++) {
+-            gp = &term.line[y][x];
+-            if (selected(x, y))
+-                selclear();
+-            gp->fg = term.c.attr.fg;
+-            gp->bg = term.c.attr.bg;
+-            gp->mode = 0;
+-            gp->u = ' ';
+-        }
+-    }
++	for (y = y1; y <= y2; y++) {
++		term.dirty[y] = 1;
++		for (x = x1; x <= x2; x++) {
++			gp = &term.line[y][x];
++			if (selected(x, y))
++				selclear();
++			gp->fg = term.c.attr.fg;
++			gp->bg = term.c.attr.bg;
++			gp->mode = 0;
++			gp->u = ' ';
++		}
++	}
+ }
+ 
+ void
+ tdeletechar(int n)
+ {
+-    int dst, src, size;
+-    Glyph *line;
++	int dst, src, size;
++	Glyph *line;
+ 
+-    LIMIT(n, 0, term.col - term.c.x);
++	LIMIT(n, 0, term.col - term.c.x);
+ 
+-    dst = term.c.x;
+-    src = term.c.x + n;
+-    size = term.col - src;
+-    line = term.line[term.c.y];
++	dst = term.c.x;
++	src = term.c.x + n;
++	size = term.col - src;
++	line = term.line[term.c.y];
+ 
+-    memmove(&line[dst], &line[src], size * sizeof(Glyph));
+-    tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
++	memmove(&line[dst], &line[src], size * sizeof(Glyph));
++	tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
+ }
+ 
+ void
+ tinsertblank(int n)
+ {
+-    int dst, src, size;
+-    Glyph *line;
++	int dst, src, size;
++	Glyph *line;
+ 
+-    LIMIT(n, 0, term.col - term.c.x);
++	LIMIT(n, 0, term.col - term.c.x);
+ 
+-    dst = term.c.x + n;
+-    src = term.c.x;
+-    size = term.col - dst;
+-    line = term.line[term.c.y];
++	dst = term.c.x + n;
++	src = term.c.x;
++	size = term.col - dst;
++	line = term.line[term.c.y];
+ 
+-    memmove(&line[dst], &line[src], size * sizeof(Glyph));
+-    tclearregion(src, term.c.y, dst - 1, term.c.y);
++	memmove(&line[dst], &line[src], size * sizeof(Glyph));
++	tclearregion(src, term.c.y, dst - 1, term.c.y);
+ }
+ 
+ void
+ tinsertblankline(int n)
+ {
+-    if (BETWEEN(term.c.y, term.top, term.bot))
+-        tscrolldown(term.c.y, n, 0);
++	if (BETWEEN(term.c.y, term.top, term.bot))
++		tscrolldown(term.c.y, n, 0);
+ }
+ 
+ void
+ tdeleteline(int n)
+ {
+-    if (BETWEEN(term.c.y, term.top, term.bot))
+-        tscrollup(term.c.y, n, 0);
++	if (BETWEEN(term.c.y, term.top, term.bot))
++		tscrollup(term.c.y, n, 0);
+ }
+ 
+ int32_t
+ tdefcolor(const int *attr, int *npar, int l)
+ {
+-    int32_t idx = -1;
+-    uint r, g, b;
+-
+-    switch (attr[*npar + 1]) {
+-        case 2: /* direct color in RGB space */
+-            if (*npar + 4 >= l) {
+-                fprintf(stderr,
+-                        "erresc(38): Incorrect number of parameters (%d)\n",
+-                        *npar);
+-                break;
+-            }
+-            r = attr[*npar + 2];
+-            g = attr[*npar + 3];
+-            b = attr[*npar + 4];
+-            *npar += 4;
+-            if (!BETWEEN(r, 0, 255) || !BETWEEN(g, 0, 255) || !BETWEEN(b, 0, 255))
+-                fprintf(stderr, "erresc: bad rgb color (%u,%u,%u)\n",
+-                        r, g, b);
+-            else
+-                idx = TRUECOLOR(r, g, b);
+-            break;
+-        case 5: /* indexed color */
+-            if (*npar + 2 >= l) {
+-                fprintf(stderr,
+-                        "erresc(38): Incorrect number of parameters (%d)\n",
+-                        *npar);
+-                break;
+-            }
+-            *npar += 2;
+-            if (!BETWEEN(attr[*npar], 0, 255))
+-                fprintf(stderr, "erresc: bad fgcolor %d\n", attr[*npar]);
+-            else
+-                idx = attr[*npar];
+-            break;
+-        case 0: /* implemented defined (only foreground) */
+-        case 1: /* transparent */
+-        case 3: /* direct color in CMY space */
+-        case 4: /* direct color in CMYK space */
+-        default:
+-            fprintf(stderr,
+-                    "erresc(38): gfx attr %d unknown\n", attr[*npar]);
+-            break;
+-    }
+-
+-    return idx;
++	int32_t idx = -1;
++	uint r, g, b;
++
++	switch (attr[*npar + 1]) {
++	case 2: /* direct color in RGB space */
++		if (*npar + 4 >= l) {
++			fprintf(stderr,
++				"erresc(38): Incorrect number of parameters (%d)\n",
++				*npar);
++			break;
++		}
++		r = attr[*npar + 2];
++		g = attr[*npar + 3];
++		b = attr[*npar + 4];
++		*npar += 4;
++		if (!BETWEEN(r, 0, 255) || !BETWEEN(g, 0, 255) || !BETWEEN(b, 0, 255))
++			fprintf(stderr, "erresc: bad rgb color (%u,%u,%u)\n",
++				r, g, b);
++		else
++			idx = TRUECOLOR(r, g, b);
++		break;
++	case 5: /* indexed color */
++		if (*npar + 2 >= l) {
++			fprintf(stderr,
++				"erresc(38): Incorrect number of parameters (%d)\n",
++				*npar);
++			break;
++		}
++		*npar += 2;
++		if (!BETWEEN(attr[*npar], 0, 255))
++			fprintf(stderr, "erresc: bad fgcolor %d\n", attr[*npar]);
++		else
++			idx = attr[*npar];
++		break;
++	case 0: /* implemented defined (only foreground) */
++	case 1: /* transparent */
++	case 3: /* direct color in CMY space */
++	case 4: /* direct color in CMYK space */
++	default:
++		fprintf(stderr,
++		        "erresc(38): gfx attr %d unknown\n", attr[*npar]);
++		break;
++	}
++
++	return idx;
+ }
+ 
+ void
+ tsetattr(const int *attr, int l)
+ {
+-    int i;
+-    int32_t idx;
+-
+-    for (i = 0; i < l; i++) {
+-        switch (attr[i]) {
+-            case 0:
+-                term.c.attr.mode &= ~(
+-                        ATTR_BOLD       |
+-                        ATTR_FAINT      |
+-                        ATTR_ITALIC     |
+-                        ATTR_UNDERLINE  |
+-                        ATTR_BLINK      |
+-                        ATTR_REVERSE    |
+-                        ATTR_INVISIBLE  |
+-                        ATTR_STRUCK     );
+-                term.c.attr.fg = defaultfg;
+-                term.c.attr.bg = defaultbg;
+-                break;
+-            case 1:
+-                term.c.attr.mode |= ATTR_BOLD;
+-                break;
+-            case 2:
+-                term.c.attr.mode |= ATTR_FAINT;
+-                break;
+-            case 3:
+-                term.c.attr.mode |= ATTR_ITALIC;
+-                break;
+-            case 4:
+-                term.c.attr.mode |= ATTR_UNDERLINE;
+-                break;
+-            case 5: /* slow blink */
+-                /* FALLTHROUGH */
+-            case 6: /* rapid blink */
+-                term.c.attr.mode |= ATTR_BLINK;
+-                break;
+-            case 7:
+-                term.c.attr.mode |= ATTR_REVERSE;
+-                break;
+-            case 8:
+-                term.c.attr.mode |= ATTR_INVISIBLE;
+-                break;
+-            case 9:
+-                term.c.attr.mode |= ATTR_STRUCK;
+-                break;
+-            case 22:
+-                term.c.attr.mode &= ~(ATTR_BOLD | ATTR_FAINT);
+-                break;
+-            case 23:
+-                term.c.attr.mode &= ~ATTR_ITALIC;
+-                break;
+-            case 24:
+-                term.c.attr.mode &= ~ATTR_UNDERLINE;
+-                break;
+-            case 25:
+-                term.c.attr.mode &= ~ATTR_BLINK;
+-                break;
+-            case 27:
+-                term.c.attr.mode &= ~ATTR_REVERSE;
+-                break;
+-            case 28:
+-                term.c.attr.mode &= ~ATTR_INVISIBLE;
+-                break;
+-            case 29:
+-                term.c.attr.mode &= ~ATTR_STRUCK;
+-                break;
+-            case 38:
+-                if ((idx = tdefcolor(attr, &i, l)) >= 0)
+-                    term.c.attr.fg = idx;
+-                break;
+-            case 39:
+-                term.c.attr.fg = defaultfg;
+-                break;
+-            case 48:
+-                if ((idx = tdefcolor(attr, &i, l)) >= 0)
+-                    term.c.attr.bg = idx;
+-                break;
+-            case 49:
+-                term.c.attr.bg = defaultbg;
+-                break;
+-            default:
+-                if (BETWEEN(attr[i], 30, 37)) {
+-                    term.c.attr.fg = attr[i] - 30;
+-                } else if (BETWEEN(attr[i], 40, 47)) {
+-                    term.c.attr.bg = attr[i] - 40;
+-                } else if (BETWEEN(attr[i], 90, 97)) {
+-                    term.c.attr.fg = attr[i] - 90 + 8;
+-                } else if (BETWEEN(attr[i], 100, 107)) {
+-                    term.c.attr.bg = attr[i] - 100 + 8;
+-                } else {
+-                    fprintf(stderr,
+-                            "erresc(default): gfx attr %d unknown\n",
+-                            attr[i]);
+-                    csidump();
+-                }
+-                break;
+-        }
+-    }
++	int i;
++	int32_t idx;
++
++	for (i = 0; i < l; i++) {
++		switch (attr[i]) {
++		case 0:
++			term.c.attr.mode &= ~(
++				ATTR_BOLD       |
++				ATTR_FAINT      |
++				ATTR_ITALIC     |
++				ATTR_UNDERLINE  |
++				ATTR_BLINK      |
++				ATTR_REVERSE    |
++				ATTR_INVISIBLE  |
++				ATTR_STRUCK     );
++			term.c.attr.fg = defaultfg;
++			term.c.attr.bg = defaultbg;
++			break;
++		case 1:
++			term.c.attr.mode |= ATTR_BOLD;
++			break;
++		case 2:
++			term.c.attr.mode |= ATTR_FAINT;
++			break;
++		case 3:
++			term.c.attr.mode |= ATTR_ITALIC;
++			break;
++		case 4:
++			term.c.attr.mode |= ATTR_UNDERLINE;
++			break;
++		case 5: /* slow blink */
++			/* FALLTHROUGH */
++		case 6: /* rapid blink */
++			term.c.attr.mode |= ATTR_BLINK;
++			break;
++		case 7:
++			term.c.attr.mode |= ATTR_REVERSE;
++			break;
++		case 8:
++			term.c.attr.mode |= ATTR_INVISIBLE;
++			break;
++		case 9:
++			term.c.attr.mode |= ATTR_STRUCK;
++			break;
++		case 22:
++			term.c.attr.mode &= ~(ATTR_BOLD | ATTR_FAINT);
++			break;
++		case 23:
++			term.c.attr.mode &= ~ATTR_ITALIC;
++			break;
++		case 24:
++			term.c.attr.mode &= ~ATTR_UNDERLINE;
++			break;
++		case 25:
++			term.c.attr.mode &= ~ATTR_BLINK;
++			break;
++		case 27:
++			term.c.attr.mode &= ~ATTR_REVERSE;
++			break;
++		case 28:
++			term.c.attr.mode &= ~ATTR_INVISIBLE;
++			break;
++		case 29:
++			term.c.attr.mode &= ~ATTR_STRUCK;
++			break;
++		case 38:
++			if ((idx = tdefcolor(attr, &i, l)) >= 0)
++				term.c.attr.fg = idx;
++			break;
++		case 39:
++			term.c.attr.fg = defaultfg;
++			break;
++		case 48:
++			if ((idx = tdefcolor(attr, &i, l)) >= 0)
++				term.c.attr.bg = idx;
++			break;
++		case 49:
++			term.c.attr.bg = defaultbg;
++			break;
++		default:
++			if (BETWEEN(attr[i], 30, 37)) {
++				term.c.attr.fg = attr[i] - 30;
++			} else if (BETWEEN(attr[i], 40, 47)) {
++				term.c.attr.bg = attr[i] - 40;
++			} else if (BETWEEN(attr[i], 90, 97)) {
++				term.c.attr.fg = attr[i] - 90 + 8;
++			} else if (BETWEEN(attr[i], 100, 107)) {
++				term.c.attr.bg = attr[i] - 100 + 8;
++			} else {
++				fprintf(stderr,
++					"erresc(default): gfx attr %d unknown\n",
++					attr[i]);
++				csidump();
++			}
++			break;
++		}
++	}
+ }
+ 
+ void
+ tsetscroll(int t, int b)
+ {
+-    int temp;
++	int temp;
+ 
+-    LIMIT(t, 0, term.row-1);
+-    LIMIT(b, 0, term.row-1);
+-    if (t > b) {
+-        temp = t;
+-        t = b;
+-        b = temp;
+-    }
+-    term.top = t;
+-    term.bot = b;
++	LIMIT(t, 0, term.row-1);
++	LIMIT(b, 0, term.row-1);
++	if (t > b) {
++		temp = t;
++		t = b;
++		b = temp;
++	}
++	term.top = t;
++	term.bot = b;
+ }
+ 
+ void
+ tsetmode(int priv, int set, const int *args, int narg)
+ {
+-    int alt; const int *lim;
+-
+-    for (lim = args + narg; args < lim; ++args) {
+-        if (priv) {
+-            switch (*args) {
+-                case 1: /* DECCKM -- Cursor key */
+-                    xsetmode(set, MODE_APPCURSOR);
+-                    break;
+-                case 5: /* DECSCNM -- Reverse video */
+-                    xsetmode(set, MODE_REVERSE);
+-                    break;
+-                case 6: /* DECOM -- Origin */
+-                    MODBIT(term.c.state, set, CURSOR_ORIGIN);
+-                    tmoveato(0, 0);
+-                    break;
+-                case 7: /* DECAWM -- Auto wrap */
+-                    MODBIT(term.mode, set, MODE_WRAP);
+-                    break;
+-                case 0:  /* Error (IGNORED) */
+-                case 2:  /* DECANM -- ANSI/VT52 (IGNORED) */
+-                case 3:  /* DECCOLM -- Column  (IGNORED) */
+-                case 4:  /* DECSCLM -- Scroll (IGNORED) */
+-                case 8:  /* DECARM -- Auto repeat (IGNORED) */
+-                case 18: /* DECPFF -- Printer feed (IGNORED) */
+-                case 19: /* DECPEX -- Printer extent (IGNORED) */
+-                case 42: /* DECNRCM -- National characters (IGNORED) */
+-                case 12: /* att610 -- Start blinking cursor (IGNORED) */
+-                    break;
+-                case 25: /* DECTCEM -- Text Cursor Enable Mode */
+-                    xsetmode(!set, MODE_HIDE);
+-                    break;
+-                case 9:    /* X10 mouse compatibility mode */
+-                    xsetpointermotion(0);
+-                    xsetmode(0, MODE_MOUSE);
+-                    xsetmode(set, MODE_MOUSEX10);
+-                    break;
+-                case 1000: /* 1000: report button press */
+-                    xsetpointermotion(0);
+-                    xsetmode(0, MODE_MOUSE);
+-                    xsetmode(set, MODE_MOUSEBTN);
+-                    break;
+-                case 1002: /* 1002: report motion on button press */
+-                    xsetpointermotion(0);
+-                    xsetmode(0, MODE_MOUSE);
+-                    xsetmode(set, MODE_MOUSEMOTION);
+-                    break;
+-                case 1003: /* 1003: enable all mouse motions */
+-                    xsetpointermotion(set);
+-                    xsetmode(0, MODE_MOUSE);
+-                    xsetmode(set, MODE_MOUSEMANY);
+-                    break;
+-                case 1004: /* 1004: send focus events to tty */
+-                    xsetmode(set, MODE_FOCUS);
+-                    break;
+-                case 1006: /* 1006: extended reporting mode */
+-                    xsetmode(set, MODE_MOUSESGR);
+-                    break;
+-                case 1034:
+-                    xsetmode(set, MODE_8BIT);
+-                    break;
+-                case 1049: /* swap screen & set/restore cursor as xterm */
+-                    if (!allowaltscreen)
+-                        break;
+-                    tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
+-                    /* FALLTHROUGH */
+-                case 47: /* swap screen */
+-                case 1047:
+-                    if (!allowaltscreen)
+-                        break;
+-                    alt = IS_SET(MODE_ALTSCREEN);
+-                    if (alt) {
+-                        tclearregion(0, 0, term.col-1,
+-                                term.row-1);
+-                    }
+-                    if (set ^ alt) /* set is always 1 or 0 */
+-                        tswapscreen();
+-                    if (*args != 1049)
+-                        break;
+-                    /* FALLTHROUGH */
+-                case 1048:
+-                    tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
+-                    break;
+-                case 2004: /* 2004: bracketed paste mode */
+-                    xsetmode(set, MODE_BRCKTPASTE);
+-                    break;
+-                    /* Not implemented mouse modes. See comments there. */
+-                case 1001: /* mouse highlight mode; can hang the
+-                              terminal by design when implemented. */
+-                case 1005: /* UTF-8 mouse mode; will confuse
+-                              applications not supporting UTF-8
+-                              and luit. */
+-                case 1015: /* urxvt mangled mouse mode; incompatible
+-                              and can be mistaken for other control
+-                              codes. */
+-                    break;
+-                default:
+-                    fprintf(stderr,
+-                            "erresc: unknown private set/reset mode %d\n",
+-                            *args);
+-                    break;
+-            }
+-        } else {
+-            switch (*args) {
+-                case 0:  /* Error (IGNORED) */
+-                    break;
+-                case 2:
+-                    xsetmode(set, MODE_KBDLOCK);
+-                    break;
+-                case 4:  /* IRM -- Insertion-replacement */
+-                    MODBIT(term.mode, set, MODE_INSERT);
+-                    break;
+-                case 12: /* SRM -- Send/Receive */
+-                    MODBIT(term.mode, !set, MODE_ECHO);
+-                    break;
+-                case 20: /* LNM -- Linefeed/new line */
+-                    MODBIT(term.mode, set, MODE_CRLF);
+-                    break;
+-                default:
+-                    fprintf(stderr,
+-                            "erresc: unknown set/reset mode %d\n",
+-                            *args);
+-                    break;
+-            }
+-        }
+-    }
++	int alt; const int *lim;
++
++	for (lim = args + narg; args < lim; ++args) {
++		if (priv) {
++			switch (*args) {
++			case 1: /* DECCKM -- Cursor key */
++				xsetmode(set, MODE_APPCURSOR);
++				break;
++			case 5: /* DECSCNM -- Reverse video */
++				xsetmode(set, MODE_REVERSE);
++				break;
++			case 6: /* DECOM -- Origin */
++				MODBIT(term.c.state, set, CURSOR_ORIGIN);
++				tmoveato(0, 0);
++				break;
++			case 7: /* DECAWM -- Auto wrap */
++				MODBIT(term.mode, set, MODE_WRAP);
++				break;
++			case 0:  /* Error (IGNORED) */
++			case 2:  /* DECANM -- ANSI/VT52 (IGNORED) */
++			case 3:  /* DECCOLM -- Column  (IGNORED) */
++			case 4:  /* DECSCLM -- Scroll (IGNORED) */
++			case 8:  /* DECARM -- Auto repeat (IGNORED) */
++			case 18: /* DECPFF -- Printer feed (IGNORED) */
++			case 19: /* DECPEX -- Printer extent (IGNORED) */
++			case 42: /* DECNRCM -- National characters (IGNORED) */
++			case 12: /* att610 -- Start blinking cursor (IGNORED) */
++				break;
++			case 25: /* DECTCEM -- Text Cursor Enable Mode */
++				xsetmode(!set, MODE_HIDE);
++				break;
++			case 9:    /* X10 mouse compatibility mode */
++				xsetpointermotion(0);
++				xsetmode(0, MODE_MOUSE);
++				xsetmode(set, MODE_MOUSEX10);
++				break;
++			case 1000: /* 1000: report button press */
++				xsetpointermotion(0);
++				xsetmode(0, MODE_MOUSE);
++				xsetmode(set, MODE_MOUSEBTN);
++				break;
++			case 1002: /* 1002: report motion on button press */
++				xsetpointermotion(0);
++				xsetmode(0, MODE_MOUSE);
++				xsetmode(set, MODE_MOUSEMOTION);
++				break;
++			case 1003: /* 1003: enable all mouse motions */
++				xsetpointermotion(set);
++				xsetmode(0, MODE_MOUSE);
++				xsetmode(set, MODE_MOUSEMANY);
++				break;
++			case 1004: /* 1004: send focus events to tty */
++				xsetmode(set, MODE_FOCUS);
++				break;
++			case 1006: /* 1006: extended reporting mode */
++				xsetmode(set, MODE_MOUSESGR);
++				break;
++			case 1034:
++				xsetmode(set, MODE_8BIT);
++				break;
++			case 1049: /* swap screen & set/restore cursor as xterm */
++				if (!allowaltscreen)
++					break;
++				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
++				/* FALLTHROUGH */
++			case 47: /* swap screen */
++			case 1047:
++				if (!allowaltscreen)
++					break;
++				alt = IS_SET(MODE_ALTSCREEN);
++				if (alt) {
++					tclearregion(0, 0, term.col-1,
++							term.row-1);
++				}
++				if (set ^ alt) /* set is always 1 or 0 */
++					tswapscreen();
++				if (*args != 1049)
++					break;
++				/* FALLTHROUGH */
++			case 1048:
++				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
++				break;
++			case 2004: /* 2004: bracketed paste mode */
++				xsetmode(set, MODE_BRCKTPASTE);
++				break;
++			/* Not implemented mouse modes. See comments there. */
++			case 1001: /* mouse highlight mode; can hang the
++				      terminal by design when implemented. */
++			case 1005: /* UTF-8 mouse mode; will confuse
++				      applications not supporting UTF-8
++				      and luit. */
++			case 1015: /* urxvt mangled mouse mode; incompatible
++				      and can be mistaken for other control
++				      codes. */
++				break;
++			default:
++				fprintf(stderr,
++					"erresc: unknown private set/reset mode %d\n",
++					*args);
++				break;
++			}
++		} else {
++			switch (*args) {
++			case 0:  /* Error (IGNORED) */
++				break;
++			case 2:
++				xsetmode(set, MODE_KBDLOCK);
++				break;
++			case 4:  /* IRM -- Insertion-replacement */
++				MODBIT(term.mode, set, MODE_INSERT);
++				break;
++			case 12: /* SRM -- Send/Receive */
++				MODBIT(term.mode, !set, MODE_ECHO);
++				break;
++			case 20: /* LNM -- Linefeed/new line */
++				MODBIT(term.mode, set, MODE_CRLF);
++				break;
++			default:
++				fprintf(stderr,
++					"erresc: unknown set/reset mode %d\n",
++					*args);
++				break;
++			}
++		}
++	}
+ }
+ 
+ void
+ csihandle(void)
+ {
+-    char buf[40];
+-    int len;
+-
+-    switch (csiescseq.mode[0]) {
+-        default:
+-unknown:
+-            fprintf(stderr, "erresc: unknown csi ");
+-            csidump();
+-            /* die(""); */
+-            break;
+-        case '@': /* ICH -- Insert <n> blank char */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tinsertblank(csiescseq.arg[0]);
+-            break;
+-        case 'A': /* CUU -- Cursor <n> Up */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(term.c.x, term.c.y-csiescseq.arg[0]);
+-            break;
+-        case 'B': /* CUD -- Cursor <n> Down */
+-        case 'e': /* VPR --Cursor <n> Down */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(term.c.x, term.c.y+csiescseq.arg[0]);
+-            break;
+-        case 'i': /* MC -- Media Copy */
+-            switch (csiescseq.arg[0]) {
+-                case 0:
+-                    tdump();
+-                    break;
+-                case 1:
+-                    tdumpline(term.c.y);
+-                    break;
+-                case 2:
+-                    tdumpsel();
+-                    break;
+-                case 4:
+-                    term.mode &= ~MODE_PRINT;
+-                    break;
+-                case 5:
+-                    term.mode |= MODE_PRINT;
+-                    break;
+-            }
+-            break;
+-        case 'c': /* DA -- Device Attributes */
+-            if (csiescseq.arg[0] == 0)
+-                ttywrite(vtiden, strlen(vtiden), 0);
+-            break;
+-        case 'b': /* REP -- if last char is printable print it <n> more times */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            if (term.lastc)
+-                while (csiescseq.arg[0]-- > 0)
+-                    tputc(term.lastc);
+-            break;
+-        case 'C': /* CUF -- Cursor <n> Forward */
+-        case 'a': /* HPR -- Cursor <n> Forward */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(term.c.x+csiescseq.arg[0], term.c.y);
+-            break;
+-        case 'D': /* CUB -- Cursor <n> Backward */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(term.c.x-csiescseq.arg[0], term.c.y);
+-            break;
+-        case 'E': /* CNL -- Cursor <n> Down and first col */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(0, term.c.y+csiescseq.arg[0]);
+-            break;
+-        case 'F': /* CPL -- Cursor <n> Up and first col */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(0, term.c.y-csiescseq.arg[0]);
+-            break;
+-        case 'g': /* TBC -- Tabulation clear */
+-            switch (csiescseq.arg[0]) {
+-                case 0: /* clear current tab stop */
+-                    term.tabs[term.c.x] = 0;
+-                    break;
+-                case 3: /* clear all the tabs */
+-                    memset(term.tabs, 0, term.col * sizeof(*term.tabs));
+-                    break;
+-                default:
+-                    goto unknown;
+-            }
+-            break;
+-        case 'G': /* CHA -- Move to <col> */
+-        case '`': /* HPA */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveto(csiescseq.arg[0]-1, term.c.y);
+-            break;
+-        case 'H': /* CUP -- Move to <row> <col> */
+-        case 'f': /* HVP */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            DEFAULT(csiescseq.arg[1], 1);
+-            tmoveato(csiescseq.arg[1]-1, csiescseq.arg[0]-1);
+-            break;
+-        case 'I': /* CHT -- Cursor Forward Tabulation <n> tab stops */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tputtab(csiescseq.arg[0]);
+-            break;
+-        case 'J': /* ED -- Clear screen */
+-            switch (csiescseq.arg[0]) {
+-                case 0: /* below */
+-                    tclearregion(term.c.x, term.c.y, term.col-1, term.c.y);
+-                    if (term.c.y < term.row-1) {
+-                        tclearregion(0, term.c.y+1, term.col-1,
+-                                term.row-1);
+-                    }
+-                    break;
+-                case 1: /* above */
+-                    if (term.c.y > 1)
+-                        tclearregion(0, 0, term.col-1, term.c.y-1);
+-                    tclearregion(0, term.c.y, term.c.x, term.c.y);
+-                    break;
+-                case 2: /* all */
+-                    tclearregion(0, 0, term.col-1, term.row-1);
+-                    break;
+-                default:
+-                    goto unknown;
+-            }
+-            break;
+-        case 'K': /* EL -- Clear line */
+-            switch (csiescseq.arg[0]) {
+-                case 0: /* right */
+-                    tclearregion(term.c.x, term.c.y, term.col-1,
+-                            term.c.y);
+-                    break;
+-                case 1: /* left */
+-                    tclearregion(0, term.c.y, term.c.x, term.c.y);
+-                    break;
+-                case 2: /* all */
+-                    tclearregion(0, term.c.y, term.col-1, term.c.y);
+-                    break;
+-            }
+-            break;
+-        case 'S': /* SU -- Scroll <n> line up */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tscrollup(term.top, csiescseq.arg[0], 0);
+-            break;
+-        case 'T': /* SD -- Scroll <n> line down */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tscrolldown(term.top, csiescseq.arg[0], 0);
+-            break;
+-        case 'L': /* IL -- Insert <n> blank lines */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tinsertblankline(csiescseq.arg[0]);
+-            break;
+-        case 'l': /* RM -- Reset Mode */
+-            tsetmode(csiescseq.priv, 0, csiescseq.arg, csiescseq.narg);
+-            break;
+-        case 'M': /* DL -- Delete <n> lines */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tdeleteline(csiescseq.arg[0]);
+-            break;
+-        case 'X': /* ECH -- Erase <n> char */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tclearregion(term.c.x, term.c.y,
+-                    term.c.x + csiescseq.arg[0] - 1, term.c.y);
+-            break;
+-        case 'P': /* DCH -- Delete <n> char */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tdeletechar(csiescseq.arg[0]);
+-            break;
+-        case 'Z': /* CBT -- Cursor Backward Tabulation <n> tab stops */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tputtab(-csiescseq.arg[0]);
+-            break;
+-        case 'd': /* VPA -- Move to <row> */
+-            DEFAULT(csiescseq.arg[0], 1);
+-            tmoveato(term.c.x, csiescseq.arg[0]-1);
+-            break;
+-        case 'h': /* SM -- Set terminal mode */
+-            tsetmode(csiescseq.priv, 1, csiescseq.arg, csiescseq.narg);
+-            break;
+-        case 'm': /* SGR -- Terminal attribute (color) */
+-            tsetattr(csiescseq.arg, csiescseq.narg);
+-            break;
+-        case 'n': /* DSR -- Device Status Report */
+-            switch (csiescseq.arg[0]) {
+-                case 5: /* Status Report "OK" `0n` */
+-                    ttywrite("\033[0n", sizeof("\033[0n") - 1, 0);
+-                    break;
+-                case 6: /* Report Cursor Position (CPR) "<row>;<column>R" */
+-                    len = snprintf(buf, sizeof(buf), "\033[%i;%iR",
+-                            term.c.y+1, term.c.x+1);
+-                    ttywrite(buf, len, 0);
+-                    break;
+-                default:
+-                    goto unknown;
+-            }
+-            break;
+-        case 'r': /* DECSTBM -- Set Scrolling Region */
+-            if (csiescseq.priv) {
+-                goto unknown;
+-            } else {
+-                DEFAULT(csiescseq.arg[0], 1);
+-                DEFAULT(csiescseq.arg[1], term.row);
+-                tsetscroll(csiescseq.arg[0]-1, csiescseq.arg[1]-1);
+-                tmoveato(0, 0);
+-            }
+-            break;
+-        case 's': /* DECSC -- Save cursor position (ANSI.SYS) */
+-            tcursor(CURSOR_SAVE);
+-            break;
+-        case 'u': /* DECRC -- Restore cursor position (ANSI.SYS) */
+-            tcursor(CURSOR_LOAD);
+-            break;
+-        case ' ':
+-            switch (csiescseq.mode[1]) {
+-                case 'q': /* DECSCUSR -- Set Cursor Style */
+-                    if (xsetcursor(csiescseq.arg[0]))
+-                        goto unknown;
+-                    break;
+-                default:
+-                    goto unknown;
+-            }
+-            break;
+-    }
++	char buf[40];
++	int len;
++
++	switch (csiescseq.mode[0]) {
++	default:
++	unknown:
++		fprintf(stderr, "erresc: unknown csi ");
++		csidump();
++		/* die(""); */
++		break;
++	case '@': /* ICH -- Insert <n> blank char */
++		DEFAULT(csiescseq.arg[0], 1);
++		tinsertblank(csiescseq.arg[0]);
++		break;
++	case 'A': /* CUU -- Cursor <n> Up */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(term.c.x, term.c.y-csiescseq.arg[0]);
++		break;
++	case 'B': /* CUD -- Cursor <n> Down */
++	case 'e': /* VPR --Cursor <n> Down */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(term.c.x, term.c.y+csiescseq.arg[0]);
++		break;
++	case 'i': /* MC -- Media Copy */
++		switch (csiescseq.arg[0]) {
++		case 0:
++			tdump();
++			break;
++		case 1:
++			tdumpline(term.c.y);
++			break;
++		case 2:
++			tdumpsel();
++			break;
++		case 4:
++			term.mode &= ~MODE_PRINT;
++			break;
++		case 5:
++			term.mode |= MODE_PRINT;
++			break;
++		}
++		break;
++	case 'c': /* DA -- Device Attributes */
++		if (csiescseq.arg[0] == 0)
++			ttywrite(vtiden, strlen(vtiden), 0);
++		break;
++	case 'b': /* REP -- if last char is printable print it <n> more times */
++		LIMIT(csiescseq.arg[0], 1, 65535);
++		if (term.lastc)
++			while (csiescseq.arg[0]-- > 0)
++				tputc(term.lastc);
++		break;
++	case 'C': /* CUF -- Cursor <n> Forward */
++	case 'a': /* HPR -- Cursor <n> Forward */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(term.c.x+csiescseq.arg[0], term.c.y);
++		break;
++	case 'D': /* CUB -- Cursor <n> Backward */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(term.c.x-csiescseq.arg[0], term.c.y);
++		break;
++	case 'E': /* CNL -- Cursor <n> Down and first col */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(0, term.c.y+csiescseq.arg[0]);
++		break;
++	case 'F': /* CPL -- Cursor <n> Up and first col */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(0, term.c.y-csiescseq.arg[0]);
++		break;
++	case 'g': /* TBC -- Tabulation clear */
++		switch (csiescseq.arg[0]) {
++		case 0: /* clear current tab stop */
++			term.tabs[term.c.x] = 0;
++			break;
++		case 3: /* clear all the tabs */
++			memset(term.tabs, 0, term.col * sizeof(*term.tabs));
++			break;
++		default:
++			goto unknown;
++		}
++		break;
++	case 'G': /* CHA -- Move to <col> */
++	case '`': /* HPA */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveto(csiescseq.arg[0]-1, term.c.y);
++		break;
++	case 'H': /* CUP -- Move to <row> <col> */
++	case 'f': /* HVP */
++		DEFAULT(csiescseq.arg[0], 1);
++		DEFAULT(csiescseq.arg[1], 1);
++		tmoveato(csiescseq.arg[1]-1, csiescseq.arg[0]-1);
++		break;
++	case 'I': /* CHT -- Cursor Forward Tabulation <n> tab stops */
++		DEFAULT(csiescseq.arg[0], 1);
++		tputtab(csiescseq.arg[0]);
++		break;
++	case 'J': /* ED -- Clear screen */
++		switch (csiescseq.arg[0]) {
++		case 0: /* below */
++			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y);
++			if (term.c.y < term.row-1) {
++				tclearregion(0, term.c.y+1, term.col-1,
++						term.row-1);
++			}
++			break;
++		case 1: /* above */
++			if (term.c.y > 0)
++				tclearregion(0, 0, term.col-1, term.c.y-1);
++			tclearregion(0, term.c.y, term.c.x, term.c.y);
++			break;
++		case 2: /* all */
++			tclearregion(0, 0, term.col-1, term.row-1);
++			break;
++		default:
++			goto unknown;
++		}
++		break;
++	case 'K': /* EL -- Clear line */
++		switch (csiescseq.arg[0]) {
++		case 0: /* right */
++			tclearregion(term.c.x, term.c.y, term.col-1,
++					term.c.y);
++			break;
++		case 1: /* left */
++			tclearregion(0, term.c.y, term.c.x, term.c.y);
++			break;
++		case 2: /* all */
++			tclearregion(0, term.c.y, term.col-1, term.c.y);
++			break;
++		}
++		break;
++	case 'S': /* SU -- Scroll <n> line up */
++		if (csiescseq.priv) break;
++		DEFAULT(csiescseq.arg[0], 1);
++		tscrollup(term.top, csiescseq.arg[0], 0);
++		break;
++	case 'T': /* SD -- Scroll <n> line down */
++		DEFAULT(csiescseq.arg[0], 1);
++		tscrolldown(term.top, csiescseq.arg[0], 0);
++		break;
++	case 'L': /* IL -- Insert <n> blank lines */
++		DEFAULT(csiescseq.arg[0], 1);
++		tinsertblankline(csiescseq.arg[0]);
++		break;
++	case 'l': /* RM -- Reset Mode */
++		tsetmode(csiescseq.priv, 0, csiescseq.arg, csiescseq.narg);
++		break;
++	case 'M': /* DL -- Delete <n> lines */
++		DEFAULT(csiescseq.arg[0], 1);
++		tdeleteline(csiescseq.arg[0]);
++		break;
++	case 'X': /* ECH -- Erase <n> char */
++		DEFAULT(csiescseq.arg[0], 1);
++		tclearregion(term.c.x, term.c.y,
++				term.c.x + csiescseq.arg[0] - 1, term.c.y);
++		break;
++	case 'P': /* DCH -- Delete <n> char */
++		DEFAULT(csiescseq.arg[0], 1);
++		tdeletechar(csiescseq.arg[0]);
++		break;
++	case 'Z': /* CBT -- Cursor Backward Tabulation <n> tab stops */
++		DEFAULT(csiescseq.arg[0], 1);
++		tputtab(-csiescseq.arg[0]);
++		break;
++	case 'd': /* VPA -- Move to <row> */
++		DEFAULT(csiescseq.arg[0], 1);
++		tmoveato(term.c.x, csiescseq.arg[0]-1);
++		break;
++	case 'h': /* SM -- Set terminal mode */
++		tsetmode(csiescseq.priv, 1, csiescseq.arg, csiescseq.narg);
++		break;
++	case 'm': /* SGR -- Terminal attribute (color) */
++		tsetattr(csiescseq.arg, csiescseq.narg);
++		break;
++	case 'n': /* DSR -- Device Status Report */
++		switch (csiescseq.arg[0]) {
++		case 5: /* Status Report "OK" `0n` */
++			ttywrite("\033[0n", sizeof("\033[0n") - 1, 0);
++			break;
++		case 6: /* Report Cursor Position (CPR) "<row>;<column>R" */
++			len = snprintf(buf, sizeof(buf), "\033[%i;%iR",
++			               term.c.y+1, term.c.x+1);
++			ttywrite(buf, len, 0);
++			break;
++		default:
++			goto unknown;
++		}
++		break;
++	case 'r': /* DECSTBM -- Set Scrolling Region */
++		if (csiescseq.priv) {
++			goto unknown;
++		} else {
++			DEFAULT(csiescseq.arg[0], 1);
++			DEFAULT(csiescseq.arg[1], term.row);
++			tsetscroll(csiescseq.arg[0]-1, csiescseq.arg[1]-1);
++			tmoveato(0, 0);
++		}
++		break;
++	case 's': /* DECSC -- Save cursor position (ANSI.SYS) */
++		tcursor(CURSOR_SAVE);
++		break;
++	case 'u': /* DECRC -- Restore cursor position (ANSI.SYS) */
++		tcursor(CURSOR_LOAD);
++		break;
++	case ' ':
++		switch (csiescseq.mode[1]) {
++		case 'q': /* DECSCUSR -- Set Cursor Style */
++			if (xsetcursor(csiescseq.arg[0]))
++				goto unknown;
++			break;
++		default:
++			goto unknown;
++		}
++		break;
++	}
+ }
+ 
+ void
+ csidump(void)
+ {
+-    size_t i;
+-    uint c;
++	size_t i;
++	uint c;
+ 
+-    fprintf(stderr, "ESC[");
+-    for (i = 0; i < csiescseq.len; i++) {
+-        c = csiescseq.buf[i] & 0xff;
+-        if (isprint(c)) {
+-            putc(c, stderr);
+-        } else if (c == '\n') {
+-            fprintf(stderr, "(\\n)");
+-        } else if (c == '\r') {
+-            fprintf(stderr, "(\\r)");
+-        } else if (c == 0x1b) {
+-            fprintf(stderr, "(\\e)");
+-        } else {
+-            fprintf(stderr, "(%02x)", c);
+-        }
+-    }
+-    putc('\n', stderr);
++	fprintf(stderr, "ESC[");
++	for (i = 0; i < csiescseq.len; i++) {
++		c = csiescseq.buf[i] & 0xff;
++		if (isprint(c)) {
++			putc(c, stderr);
++		} else if (c == '\n') {
++			fprintf(stderr, "(\\n)");
++		} else if (c == '\r') {
++			fprintf(stderr, "(\\r)");
++		} else if (c == 0x1b) {
++			fprintf(stderr, "(\\e)");
++		} else {
++			fprintf(stderr, "(%02x)", c);
++		}
++	}
++	putc('\n', stderr);
+ }
+ 
+ void
+ csireset(void)
+ {
+-    memset(&csiescseq, 0, sizeof(csiescseq));
++	memset(&csiescseq, 0, sizeof(csiescseq));
+ }
+ 
+ void
+ osc_color_response(int num, int index, int is_osc4)
+ {
+-    int n;
+-    char buf[32];
+-    unsigned char r, g, b;
++	int n;
++	char buf[32];
++	unsigned char r, g, b;
+ 
+-    if (xgetcolor(is_osc4 ? num : index, &r, &g, &b)) {
+-        fprintf(stderr, "erresc: failed to fetch %s color %d\n",
+-                is_osc4 ? "osc4" : "osc",
+-                is_osc4 ? num : index);
+-        return;
+-    }
++	if (xgetcolor(is_osc4 ? num : index, &r, &g, &b)) {
++		fprintf(stderr, "erresc: failed to fetch %s color %d\n",
++		        is_osc4 ? "osc4" : "osc",
++		        is_osc4 ? num : index);
++		return;
++	}
+ 
+-    n = snprintf(buf, sizeof buf, "\033]%s%d;rgb:%02x%02x/%02x%02x/%02x%02x\007",
+-            is_osc4 ? "4;" : "", num, r, r, g, g, b, b);
+-    if (n < 0 || n >= sizeof(buf)) {
+-        fprintf(stderr, "error: %s while printing %s response\n",
+-                n < 0 ? "snprintf failed" : "truncation occurred",
+-                is_osc4 ? "osc4" : "osc");
+-    } else {
+-        ttywrite(buf, n, 1);
+-    }
++	n = snprintf(buf, sizeof buf, "\033]%s%d;rgb:%02x%02x/%02x%02x/%02x%02x\007",
++	             is_osc4 ? "4;" : "", num, r, r, g, g, b, b);
++	if (n < 0 || n >= sizeof(buf)) {
++		fprintf(stderr, "error: %s while printing %s response\n",
++		        n < 0 ? "snprintf failed" : "truncation occurred",
++		        is_osc4 ? "osc4" : "osc");
++	} else {
++		ttywrite(buf, n, 1);
++	}
+ }
+ 
+ void
+ strhandle(void)
+ {
+-    char *p = NULL, *dec;
+-    int j, narg, par;
+-    const struct { int idx; char *str; } osc_table[] = {
+-        { defaultfg, "foreground" },
+-        { defaultbg, "background" },
+-        { defaultcs, "cursor" }
+-    };
+-
+-    term.esc &= ~(ESC_STR_END|ESC_STR);
+-    strparse();
+-    par = (narg = strescseq.narg) ? atoi(strescseq.args[0]) : 0;
+-
+-    switch (strescseq.type) {
+-        case ']': /* OSC -- Operating System Command */
+-            switch (par) {
+-                case 0:
+-                    if (narg > 1) {
+-                        xsettitle(strescseq.args[1]);
+-                        xseticontitle(strescseq.args[1]);
+-                    }
+-                    return;
+-                case 1:
+-                    if (narg > 1)
+-                        xseticontitle(strescseq.args[1]);
+-                    return;
+-                case 2:
+-                    if (narg > 1)
+-                        xsettitle(strescseq.args[1]);
+-                    return;
+-                case 52:
+-                    if (narg > 2 && allowwindowops) {
+-                        dec = base64dec(strescseq.args[2]);
+-                        if (dec) {
+-                            xsetsel(dec);
+-                            xclipcopy();
+-                        } else {
+-                            fprintf(stderr, "erresc: invalid base64\n");
+-                        }
+-                    }
+-                    return;
+-                case 10:
+-                case 11:
+-                case 12:
+-                    if (narg < 2)
+-                        break;
+-                    p = strescseq.args[1];
+-                    if ((j = par - 10) < 0 || j >= LEN(osc_table))
+-                        break; /* shouldn't be possible */
+-
+-                    if (!strcmp(p, "?")) {
+-                        osc_color_response(par, osc_table[j].idx, 0);
+-                    } else if (xsetcolorname(osc_table[j].idx, p)) {
+-                        fprintf(stderr, "erresc: invalid %s color: %s\n",
+-                                osc_table[j].str, p);
+-                    } else {
+-                        tfulldirt();
+-                    }
+-                    return;
+-                case 4: /* color set */
+-                    if (narg < 3)
+-                        break;
+-                    p = strescseq.args[2];
+-                    /* FALLTHROUGH */
+-                case 104: /* color reset */
+-                    j = (narg > 1) ? atoi(strescseq.args[1]) : -1;
+-
+-                    if (p && !strcmp(p, "?")) {
+-                        osc_color_response(j, 0, 1);
+-                    } else if (xsetcolorname(j, p)) {
+-                        if (par == 104 && narg <= 1) {
+-                            xloadcols();
+-                            return; /* color reset without parameter */
+-                        }
+-                        fprintf(stderr, "erresc: invalid color j=%d, p=%s\n",
+-                                j, p ? p : "(null)");
+-                    } else {
+-                        /*
+-                         * TODO if defaultbg color is changed, borders
+-                         * are dirty
+-                         */
+-                        tfulldirt();
+-                    }
+-                    return;
+-            }
+-            break;
+-        case 'k': /* old title set compatibility */
+-            xsettitle(strescseq.args[0]);
+-            return;
+-        case 'P': /* DCS -- Device Control String */
+-        case '_': /* APC -- Application Program Command */
+-        case '^': /* PM -- Privacy Message */
+-            return;
+-    }
+-
+-    fprintf(stderr, "erresc: unknown str ");
+-    strdump();
++	char *p = NULL, *dec;
++	int j, narg, par;
++	const struct { int idx; char *str; } osc_table[] = {
++		{ defaultfg, "foreground" },
++		{ defaultbg, "background" },
++		{ defaultcs, "cursor" }
++	};
++
++	term.esc &= ~(ESC_STR_END|ESC_STR);
++	strparse();
++	par = (narg = strescseq.narg) ? atoi(strescseq.args[0]) : 0;
++
++	switch (strescseq.type) {
++	case ']': /* OSC -- Operating System Command */
++		switch (par) {
++		case 0:
++			if (narg > 1) {
++				xsettitle(strescseq.args[1]);
++				xseticontitle(strescseq.args[1]);
++			}
++			return;
++		case 1:
++			if (narg > 1)
++				xseticontitle(strescseq.args[1]);
++			return;
++		case 2:
++			if (narg > 1)
++				xsettitle(strescseq.args[1]);
++			return;
++		case 52:
++			if (narg > 2 && allowwindowops) {
++				dec = base64dec(strescseq.args[2]);
++				if (dec) {
++					xsetsel(dec);
++					xclipcopy();
++				} else {
++					fprintf(stderr, "erresc: invalid base64\n");
++				}
++			}
++			return;
++		case 10:
++		case 11:
++		case 12:
++			if (narg < 2)
++				break;
++			p = strescseq.args[1];
++			if ((j = par - 10) < 0 || j >= LEN(osc_table))
++				break; /* shouldn't be possible */
++
++			if (!strcmp(p, "?")) {
++				osc_color_response(par, osc_table[j].idx, 0);
++			} else if (xsetcolorname(osc_table[j].idx, p)) {
++				fprintf(stderr, "erresc: invalid %s color: %s\n",
++				        osc_table[j].str, p);
++			} else {
++				tfulldirt();
++			}
++			return;
++		case 4: /* color set */
++			if (narg < 3)
++				break;
++			p = strescseq.args[2];
++			/* FALLTHROUGH */
++		case 104: /* color reset */
++			j = (narg > 1) ? atoi(strescseq.args[1]) : -1;
++
++			if (p && !strcmp(p, "?")) {
++				osc_color_response(j, 0, 1);
++			} else if (xsetcolorname(j, p)) {
++				if (par == 104 && narg <= 1) {
++					xloadcols();
++					return; /* color reset without parameter */
++				}
++				fprintf(stderr, "erresc: invalid color j=%d, p=%s\n",
++				        j, p ? p : "(null)");
++			} else {
++				/*
++				 * TODO if defaultbg color is changed, borders
++				 * are dirty
++				 */
++				tfulldirt();
++			}
++			return;
++		}
++		break;
++	case 'k': /* old title set compatibility */
++		xsettitle(strescseq.args[0]);
++		return;
++	case 'P': /* DCS -- Device Control String */
++	case '_': /* APC -- Application Program Command */
++	case '^': /* PM -- Privacy Message */
++		return;
++	}
++
++	fprintf(stderr, "erresc: unknown str ");
++	strdump();
+ }
+ 
+ void
+ strparse(void)
+ {
+-    int c;
+-    char *p = strescseq.buf;
++	int c;
++	char *p = strescseq.buf;
+ 
+-    strescseq.narg = 0;
+-    strescseq.buf[strescseq.len] = '\0';
++	strescseq.narg = 0;
++	strescseq.buf[strescseq.len] = '\0';
+ 
+-    if (*p == '\0')
+-        return;
++	if (*p == '\0')
++		return;
+ 
+-    while (strescseq.narg < STR_ARG_SIZ) {
+-        strescseq.args[strescseq.narg++] = p;
+-        while ((c = *p) != ';' && c != '\0')
+-            ++p;
+-        if (c == '\0')
+-            return;
+-        *p++ = '\0';
+-    }
++	while (strescseq.narg < STR_ARG_SIZ) {
++		strescseq.args[strescseq.narg++] = p;
++		while ((c = *p) != ';' && c != '\0')
++			++p;
++		if (c == '\0')
++			return;
++		*p++ = '\0';
++	}
+ }
+ 
+ void
+ externalpipe(const Arg *arg)
+ {
+-    int to[2];
+-    char buf[UTF_SIZ];
+-    void (*oldsigpipe)(int);
+-    Glyph *bp, *end;
+-    int lastpos, n, newline;
+-
+-    if (pipe(to) == -1)
+-        return;
+-
+-    switch (fork()) {
+-        case -1:
+-            close(to[0]);
+-            close(to[1]);
+-            return;
+-        case 0:
+-            dup2(to[0], STDIN_FILENO);
+-            close(to[0]);
+-            close(to[1]);
+-            execvp(((char **)arg->v)[0], (char **)arg->v);
+-            fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
+-            perror("failed");
+-            exit(0);
+-    }
+-
+-    close(to[0]);
+-    /* ignore sigpipe for now, in case child exists early */
+-    oldsigpipe = signal(SIGPIPE, SIG_IGN);
+-    newline = 0;
+-    for (n = 0; n <= HISTSIZE + 2; n++) {
+-        bp = TLINE_HIST(n);
+-        lastpos = MIN(tlinehistlen(n) + 1, term.col) - 1;
+-        if (lastpos < 0)
+-            break;
+-        if (lastpos == 0)
+-            continue;
+-        end = &bp[lastpos + 1];
+-        for (; bp < end; ++bp)
+-            if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
+-                break;
+-        if ((newline = TLINE_HIST(n)[lastpos].mode & ATTR_WRAP))
+-            continue;
+-        if (xwrite(to[1], "\n", 1) < 0)
+-            break;
+-        newline = 0;
+-    }
+-    if (newline)
+-        (void)xwrite(to[1], "\n", 1);
+-    close(to[1]);
+-    /* restore */
+-    signal(SIGPIPE, oldsigpipe);
++	int to[2];
++	char buf[UTF_SIZ];
++	void (*oldsigpipe)(int);
++	Glyph *bp, *end;
++	int lastpos, n, newline;
++
++	if (pipe(to) == -1)
++		return;
++
++	switch (fork()) {
++	case -1:
++		close(to[0]);
++		close(to[1]);
++		return;
++	case 0:
++		dup2(to[0], STDIN_FILENO);
++		close(to[0]);
++		close(to[1]);
++		execvp(((char **)arg->v)[0], (char **)arg->v);
++		fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
++		perror("failed");
++		exit(0);
++	}
++
++	close(to[0]);
++	/* ignore sigpipe for now, in case child exists early */
++	oldsigpipe = signal(SIGPIPE, SIG_IGN);
++	newline = 0;
++	for (n = 0; n < term.row; n++) {
++		bp = term.line[n];
++		lastpos = MIN(tlinelen(n) + 1, term.col) - 1;
++		if (lastpos < 0)
++			break;
++		end = &bp[lastpos + 1];
++		for (; bp < end; ++bp)
++			if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
++				break;
++		if ((newline = term.line[n][lastpos].mode & ATTR_WRAP))
++			continue;
++		if (xwrite(to[1], "\n", 1) < 0)
++			break;
++		newline = 0;
++	}
++	if (newline)
++		(void)xwrite(to[1], "\n", 1);
++	close(to[1]);
++	/* restore */
++	signal(SIGPIPE, oldsigpipe);
+ }
+ 
+ void
+ strdump(void)
+ {
+-    size_t i;
+-    uint c;
+-
+-    fprintf(stderr, "ESC%c", strescseq.type);
+-    for (i = 0; i < strescseq.len; i++) {
+-        c = strescseq.buf[i] & 0xff;
+-        if (c == '\0') {
+-            putc('\n', stderr);
+-            return;
+-        } else if (isprint(c)) {
+-            putc(c, stderr);
+-        } else if (c == '\n') {
+-            fprintf(stderr, "(\\n)");
+-        } else if (c == '\r') {
+-            fprintf(stderr, "(\\r)");
+-        } else if (c == 0x1b) {
+-            fprintf(stderr, "(\\e)");
+-        } else {
+-            fprintf(stderr, "(%02x)", c);
+-        }
+-    }
+-    fprintf(stderr, "ESC\\\n");
++	size_t i;
++	uint c;
++
++	fprintf(stderr, "ESC%c", strescseq.type);
++	for (i = 0; i < strescseq.len; i++) {
++		c = strescseq.buf[i] & 0xff;
++		if (c == '\0') {
++			putc('\n', stderr);
++			return;
++		} else if (isprint(c)) {
++			putc(c, stderr);
++		} else if (c == '\n') {
++			fprintf(stderr, "(\\n)");
++		} else if (c == '\r') {
++			fprintf(stderr, "(\\r)");
++		} else if (c == 0x1b) {
++			fprintf(stderr, "(\\e)");
++		} else {
++			fprintf(stderr, "(%02x)", c);
++		}
++	}
++	fprintf(stderr, "ESC\\\n");
+ }
+ 
+ void
+ strreset(void)
+ {
+-    strescseq = (STREscape){
+-        .buf = xrealloc(strescseq.buf, STR_BUF_SIZ),
+-            .siz = STR_BUF_SIZ,
+-    };
++	strescseq = (STREscape){
++		.buf = xrealloc(strescseq.buf, STR_BUF_SIZ),
++		.siz = STR_BUF_SIZ,
++	};
+ }
+ 
+ void
+ sendbreak(const Arg *arg)
+ {
+-    if (tcsendbreak(cmdfd, 0))
+-        perror("Error sending break");
++	if (tcsendbreak(cmdfd, 0))
++		perror("Error sending break");
+ }
+ 
+ void
+ tprinter(char *s, size_t len)
+ {
+-    if (iofd != -1 && xwrite(iofd, s, len) < 0) {
+-        perror("Error writing to output file");
+-        close(iofd);
+-        iofd = -1;
+-    }
++	if (iofd != -1 && xwrite(iofd, s, len) < 0) {
++		perror("Error writing to output file");
++		close(iofd);
++		iofd = -1;
++	}
+ }
+ 
+ void
+ toggleprinter(const Arg *arg)
+ {
+-    term.mode ^= MODE_PRINT;
++	term.mode ^= MODE_PRINT;
+ }
+ 
+ void
+ printscreen(const Arg *arg)
+ {
+-    tdump();
++	tdump();
+ }
+ 
+ void
+ printsel(const Arg *arg)
+ {
+-    tdumpsel();
++	tdumpsel();
+ }
+ 
+ void
+ tdumpsel(void)
+ {
+-    char *ptr;
++	char *ptr;
+ 
+-    if ((ptr = getsel())) {
+-        tprinter(ptr, strlen(ptr));
+-        free(ptr);
+-    }
++	if ((ptr = getsel())) {
++		tprinter(ptr, strlen(ptr));
++		free(ptr);
++	}
+ }
+ 
+ void
+ tdumpline(int n)
+ {
+-    char buf[UTF_SIZ];
+-    const Glyph *bp, *end;
++	char buf[UTF_SIZ];
++	const Glyph *bp, *end;
+ 
+-    bp = &term.line[n][0];
+-    end = &bp[MIN(tlinelen(n), term.col) - 1];
+-    if (bp != end || bp->u != ' ') {
+-        for ( ; bp <= end; ++bp)
+-            tprinter(buf, utf8encode(bp->u, buf));
+-    }
+-    tprinter("\n", 1);
++	bp = &term.line[n][0];
++	end = &bp[MIN(tlinelen(n), term.col) - 1];
++	if (bp != end || bp->u != ' ') {
++		for ( ; bp <= end; ++bp)
++			tprinter(buf, utf8encode(bp->u, buf));
++	}
++	tprinter("\n", 1);
+ }
+ 
+ void
+ tdump(void)
+ {
+-    int i;
++	int i;
+ 
+-    for (i = 0; i < term.row; ++i)
+-        tdumpline(i);
++	for (i = 0; i < term.row; ++i)
++		tdumpline(i);
+ }
+ 
+ void
+ tputtab(int n)
+ {
+-    uint x = term.c.x;
++	uint x = term.c.x;
+ 
+-    if (n > 0) {
+-        while (x < term.col && n--)
+-            for (++x; x < term.col && !term.tabs[x]; ++x)
+-                /* nothing */ ;
+-    } else if (n < 0) {
+-        while (x > 0 && n++)
+-            for (--x; x > 0 && !term.tabs[x]; --x)
+-                /* nothing */ ;
+-    }
+-    term.c.x = LIMIT(x, 0, term.col-1);
++	if (n > 0) {
++		while (x < term.col && n--)
++			for (++x; x < term.col && !term.tabs[x]; ++x)
++				/* nothing */ ;
++	} else if (n < 0) {
++		while (x > 0 && n++)
++			for (--x; x > 0 && !term.tabs[x]; --x)
++				/* nothing */ ;
++	}
++	term.c.x = LIMIT(x, 0, term.col-1);
+ }
+ 
+ void
+ tdefutf8(char ascii)
+ {
+-    if (ascii == 'G')
+-        term.mode |= MODE_UTF8;
+-    else if (ascii == '@')
+-        term.mode &= ~MODE_UTF8;
++	if (ascii == 'G')
++		term.mode |= MODE_UTF8;
++	else if (ascii == '@')
++		term.mode &= ~MODE_UTF8;
+ }
+ 
+ void
+ tdeftran(char ascii)
+ {
+-    static char cs[] = "0B";
+-    static int vcs[] = {CS_GRAPHIC0, CS_USA};
+-    char *p;
++	static char cs[] = "0B";
++	static int vcs[] = {CS_GRAPHIC0, CS_USA};
++	char *p;
+ 
+-    if ((p = strchr(cs, ascii)) == NULL) {
+-        fprintf(stderr, "esc unhandled charset: ESC ( %c\n", ascii);
+-    } else {
+-        term.trantbl[term.icharset] = vcs[p - cs];
+-    }
++	if ((p = strchr(cs, ascii)) == NULL) {
++		fprintf(stderr, "esc unhandled charset: ESC ( %c\n", ascii);
++	} else {
++		term.trantbl[term.icharset] = vcs[p - cs];
++	}
+ }
+ 
+ void
+ tdectest(char c)
+ {
+-    int x, y;
++	int x, y;
+ 
+-    if (c == '8') { /* DEC screen alignment test. */
+-        for (x = 0; x < term.col; ++x) {
+-            for (y = 0; y < term.row; ++y)
+-                tsetchar('E', &term.c.attr, x, y);
+-        }
+-    }
++	if (c == '8') { /* DEC screen alignment test. */
++		for (x = 0; x < term.col; ++x) {
++			for (y = 0; y < term.row; ++y)
++				tsetchar('E', &term.c.attr, x, y);
++		}
++	}
+ }
+ 
+ void
+ tstrsequence(uchar c)
+ {
+-    switch (c) {
+-        case 0x90:   /* DCS -- Device Control String */
+-            c = 'P';
+-            break;
+-        case 0x9f:   /* APC -- Application Program Command */
+-            c = '_';
+-            break;
+-        case 0x9e:   /* PM -- Privacy Message */
+-            c = '^';
+-            break;
+-        case 0x9d:   /* OSC -- Operating System Command */
+-            c = ']';
+-            break;
+-    }
+-    strreset();
+-    strescseq.type = c;
+-    term.esc |= ESC_STR;
++	switch (c) {
++	case 0x90:   /* DCS -- Device Control String */
++		c = 'P';
++		break;
++	case 0x9f:   /* APC -- Application Program Command */
++		c = '_';
++		break;
++	case 0x9e:   /* PM -- Privacy Message */
++		c = '^';
++		break;
++	case 0x9d:   /* OSC -- Operating System Command */
++		c = ']';
++		break;
++	}
++	strreset();
++	strescseq.type = c;
++	term.esc |= ESC_STR;
+ }
+ 
+ void
+ tcontrolcode(uchar ascii)
+ {
+-    switch (ascii) {
+-        case '\t':   /* HT */
+-            tputtab(1);
+-            return;
+-        case '\b':   /* BS */
+-            tmoveto(term.c.x-1, term.c.y);
+-            return;
+-        case '\r':   /* CR */
+-            tmoveto(0, term.c.y);
+-            return;
+-        case '\f':   /* LF */
+-        case '\v':   /* VT */
+-        case '\n':   /* LF */
+-            /* go to first col if the mode is set */
+-            tnewline(IS_SET(MODE_CRLF));
+-            return;
+-        case '\a':   /* BEL */
+-            if (term.esc & ESC_STR_END) {
+-                /* backwards compatibility to xterm */
+-                strhandle();
+-            } else {
+-                xbell();
+-            }
+-            break;
+-        case '\033': /* ESC */
+-            csireset();
+-            term.esc &= ~(ESC_CSI|ESC_ALTCHARSET|ESC_TEST);
+-            term.esc |= ESC_START;
+-            return;
+-        case '\016': /* SO (LS1 -- Locking shift 1) */
+-        case '\017': /* SI (LS0 -- Locking shift 0) */
+-            term.charset = 1 - (ascii - '\016');
+-            return;
+-        case '\032': /* SUB */
+-            tsetchar('?', &term.c.attr, term.c.x, term.c.y);
+-            /* FALLTHROUGH */
+-        case '\030': /* CAN */
+-            csireset();
+-            break;
+-        case '\005': /* ENQ (IGNORED) */
+-        case '\000': /* NUL (IGNORED) */
+-        case '\021': /* XON (IGNORED) */
+-        case '\023': /* XOFF (IGNORED) */
+-        case 0177:   /* DEL (IGNORED) */
+-            return;
+-        case 0x80:   /* TODO: PAD */
+-        case 0x81:   /* TODO: HOP */
+-        case 0x82:   /* TODO: BPH */
+-        case 0x83:   /* TODO: NBH */
+-        case 0x84:   /* TODO: IND */
+-            break;
+-        case 0x85:   /* NEL -- Next line */
+-            tnewline(1); /* always go to first col */
+-            break;
+-        case 0x86:   /* TODO: SSA */
+-        case 0x87:   /* TODO: ESA */
+-            break;
+-        case 0x88:   /* HTS -- Horizontal tab stop */
+-            term.tabs[term.c.x] = 1;
+-            break;
+-        case 0x89:   /* TODO: HTJ */
+-        case 0x8a:   /* TODO: VTS */
+-        case 0x8b:   /* TODO: PLD */
+-        case 0x8c:   /* TODO: PLU */
+-        case 0x8d:   /* TODO: RI */
+-        case 0x8e:   /* TODO: SS2 */
+-        case 0x8f:   /* TODO: SS3 */
+-        case 0x91:   /* TODO: PU1 */
+-        case 0x92:   /* TODO: PU2 */
+-        case 0x93:   /* TODO: STS */
+-        case 0x94:   /* TODO: CCH */
+-        case 0x95:   /* TODO: MW */
+-        case 0x96:   /* TODO: SPA */
+-        case 0x97:   /* TODO: EPA */
+-        case 0x98:   /* TODO: SOS */
+-        case 0x99:   /* TODO: SGCI */
+-            break;
+-        case 0x9a:   /* DECID -- Identify Terminal */
+-            ttywrite(vtiden, strlen(vtiden), 0);
+-            break;
+-        case 0x9b:   /* TODO: CSI */
+-        case 0x9c:   /* TODO: ST */
+-            break;
+-        case 0x90:   /* DCS -- Device Control String */
+-        case 0x9d:   /* OSC -- Operating System Command */
+-        case 0x9e:   /* PM -- Privacy Message */
+-        case 0x9f:   /* APC -- Application Program Command */
+-            tstrsequence(ascii);
+-            return;
+-    }
+-    /* only CAN, SUB, \a and C1 chars interrupt a sequence */
+-    term.esc &= ~(ESC_STR_END|ESC_STR);
++	switch (ascii) {
++	case '\t':   /* HT */
++		tputtab(1);
++		return;
++	case '\b':   /* BS */
++		tmoveto(term.c.x-1, term.c.y);
++		return;
++	case '\r':   /* CR */
++		tmoveto(0, term.c.y);
++		return;
++	case '\f':   /* LF */
++	case '\v':   /* VT */
++	case '\n':   /* LF */
++		/* go to first col if the mode is set */
++		tnewline(IS_SET(MODE_CRLF));
++		return;
++	case '\a':   /* BEL */
++		if (term.esc & ESC_STR_END) {
++			/* backwards compatibility to xterm */
++			strhandle();
++		} else {
++			xbell();
++		}
++		break;
++	case '\033': /* ESC */
++		csireset();
++		term.esc &= ~(ESC_CSI|ESC_ALTCHARSET|ESC_TEST);
++		term.esc |= ESC_START;
++		return;
++	case '\016': /* SO (LS1 -- Locking shift 1) */
++	case '\017': /* SI (LS0 -- Locking shift 0) */
++		term.charset = 1 - (ascii - '\016');
++		return;
++	case '\032': /* SUB */
++		tsetchar('?', &term.c.attr, term.c.x, term.c.y);
++		/* FALLTHROUGH */
++	case '\030': /* CAN */
++		csireset();
++		break;
++	case '\005': /* ENQ (IGNORED) */
++	case '\000': /* NUL (IGNORED) */
++	case '\021': /* XON (IGNORED) */
++	case '\023': /* XOFF (IGNORED) */
++	case 0177:   /* DEL (IGNORED) */
++		return;
++	case 0x80:   /* TODO: PAD */
++	case 0x81:   /* TODO: HOP */
++	case 0x82:   /* TODO: BPH */
++	case 0x83:   /* TODO: NBH */
++	case 0x84:   /* TODO: IND */
++		break;
++	case 0x85:   /* NEL -- Next line */
++		tnewline(1); /* always go to first col */
++		break;
++	case 0x86:   /* TODO: SSA */
++	case 0x87:   /* TODO: ESA */
++		break;
++	case 0x88:   /* HTS -- Horizontal tab stop */
++		term.tabs[term.c.x] = 1;
++		break;
++	case 0x89:   /* TODO: HTJ */
++	case 0x8a:   /* TODO: VTS */
++	case 0x8b:   /* TODO: PLD */
++	case 0x8c:   /* TODO: PLU */
++	case 0x8d:   /* TODO: RI */
++	case 0x8e:   /* TODO: SS2 */
++	case 0x8f:   /* TODO: SS3 */
++	case 0x91:   /* TODO: PU1 */
++	case 0x92:   /* TODO: PU2 */
++	case 0x93:   /* TODO: STS */
++	case 0x94:   /* TODO: CCH */
++	case 0x95:   /* TODO: MW */
++	case 0x96:   /* TODO: SPA */
++	case 0x97:   /* TODO: EPA */
++	case 0x98:   /* TODO: SOS */
++	case 0x99:   /* TODO: SGCI */
++		break;
++	case 0x9a:   /* DECID -- Identify Terminal */
++		ttywrite(vtiden, strlen(vtiden), 0);
++		break;
++	case 0x9b:   /* TODO: CSI */
++	case 0x9c:   /* TODO: ST */
++		break;
++	case 0x90:   /* DCS -- Device Control String */
++	case 0x9d:   /* OSC -- Operating System Command */
++	case 0x9e:   /* PM -- Privacy Message */
++	case 0x9f:   /* APC -- Application Program Command */
++		tstrsequence(ascii);
++		return;
++	}
++	/* only CAN, SUB, \a and C1 chars interrupt a sequence */
++	term.esc &= ~(ESC_STR_END|ESC_STR);
+ }
+ 
+ /*
+@@ -2412,421 +2400,411 @@ tcontrolcode(uchar ascii)
+ int
+ eschandle(uchar ascii)
+ {
+-    switch (ascii) {
+-        case '[':
+-            term.esc |= ESC_CSI;
+-            return 0;
+-        case '#':
+-            term.esc |= ESC_TEST;
+-            return 0;
+-        case '%':
+-            term.esc |= ESC_UTF8;
+-            return 0;
+-        case 'P': /* DCS -- Device Control String */
+-        case '_': /* APC -- Application Program Command */
+-        case '^': /* PM -- Privacy Message */
+-        case ']': /* OSC -- Operating System Command */
+-        case 'k': /* old title set compatibility */
+-            tstrsequence(ascii);
+-            return 0;
+-        case 'n': /* LS2 -- Locking shift 2 */
+-        case 'o': /* LS3 -- Locking shift 3 */
+-            term.charset = 2 + (ascii - 'n');
+-            break;
+-        case '(': /* GZD4 -- set primary charset G0 */
+-        case ')': /* G1D4 -- set secondary charset G1 */
+-        case '*': /* G2D4 -- set tertiary charset G2 */
+-        case '+': /* G3D4 -- set quaternary charset G3 */
+-            term.icharset = ascii - '(';
+-            term.esc |= ESC_ALTCHARSET;
+-            return 0;
+-        case 'D': /* IND -- Linefeed */
+-            if (term.c.y == term.bot) {
+-                tscrollup(term.top, 1, 1);
+-            } else {
+-                tmoveto(term.c.x, term.c.y+1);
+-            }
+-            break;
+-        case 'E': /* NEL -- Next line */
+-            tnewline(1); /* always go to first col */
+-            break;
+-        case 'H': /* HTS -- Horizontal tab stop */
+-            term.tabs[term.c.x] = 1;
+-            break;
+-        case 'M': /* RI -- Reverse index */
+-            if (term.c.y == term.top) {
+-                tscrolldown(term.top, 1, 1);
+-            } else {
+-                tmoveto(term.c.x, term.c.y-1);
+-            }
+-            break;
+-        case 'Z': /* DECID -- Identify Terminal */
+-            ttywrite(vtiden, strlen(vtiden), 0);
+-            break;
+-        case 'c': /* RIS -- Reset to initial state */
+-            treset();
+-            resettitle();
+-            xloadcols();
+-            xsetmode(0, MODE_HIDE);
+-            break;
+-        case '=': /* DECPAM -- Application keypad */
+-            xsetmode(1, MODE_APPKEYPAD);
+-            break;
+-        case '>': /* DECPNM -- Normal keypad */
+-            xsetmode(0, MODE_APPKEYPAD);
+-            break;
+-        case '7': /* DECSC -- Save Cursor */
+-            tcursor(CURSOR_SAVE);
+-            break;
+-        case '8': /* DECRC -- Restore Cursor */
+-            tcursor(CURSOR_LOAD);
+-            break;
+-        case '\\': /* ST -- String Terminator */
+-            if (term.esc & ESC_STR_END)
+-                strhandle();
+-            break;
+-        default:
+-            fprintf(stderr, "erresc: unknown sequence ESC 0x%02X '%c'\n",
+-                    (uchar) ascii, isprint(ascii)? ascii:'.');
+-            break;
+-    }
+-    return 1;
++	switch (ascii) {
++	case '[':
++		term.esc |= ESC_CSI;
++		return 0;
++	case '#':
++		term.esc |= ESC_TEST;
++		return 0;
++	case '%':
++		term.esc |= ESC_UTF8;
++		return 0;
++	case 'P': /* DCS -- Device Control String */
++	case '_': /* APC -- Application Program Command */
++	case '^': /* PM -- Privacy Message */
++	case ']': /* OSC -- Operating System Command */
++	case 'k': /* old title set compatibility */
++		tstrsequence(ascii);
++		return 0;
++	case 'n': /* LS2 -- Locking shift 2 */
++	case 'o': /* LS3 -- Locking shift 3 */
++		term.charset = 2 + (ascii - 'n');
++		break;
++	case '(': /* GZD4 -- set primary charset G0 */
++	case ')': /* G1D4 -- set secondary charset G1 */
++	case '*': /* G2D4 -- set tertiary charset G2 */
++	case '+': /* G3D4 -- set quaternary charset G3 */
++		term.icharset = ascii - '(';
++		term.esc |= ESC_ALTCHARSET;
++		return 0;
++	case 'D': /* IND -- Linefeed */
++		if (term.c.y == term.bot) {
++			tscrollup(term.top, 1, 1);
++		} else {
++			tmoveto(term.c.x, term.c.y+1);
++		}
++		break;
++	case 'E': /* NEL -- Next line */
++		tnewline(1); /* always go to first col */
++		break;
++	case 'H': /* HTS -- Horizontal tab stop */
++		term.tabs[term.c.x] = 1;
++		break;
++	case 'M': /* RI -- Reverse index */
++		if (term.c.y == term.top) {
++			tscrolldown(term.top, 1, 1);
++		} else {
++			tmoveto(term.c.x, term.c.y-1);
++		}
++		break;
++	case 'Z': /* DECID -- Identify Terminal */
++		ttywrite(vtiden, strlen(vtiden), 0);
++		break;
++	case 'c': /* RIS -- Reset to initial state */
++		treset();
++		resettitle();
++		xloadcols();
++		xsetmode(0, MODE_HIDE);
++		break;
++	case '=': /* DECPAM -- Application keypad */
++		xsetmode(1, MODE_APPKEYPAD);
++		break;
++	case '>': /* DECPNM -- Normal keypad */
++		xsetmode(0, MODE_APPKEYPAD);
++		break;
++	case '7': /* DECSC -- Save Cursor */
++		tcursor(CURSOR_SAVE);
++		break;
++	case '8': /* DECRC -- Restore Cursor */
++		tcursor(CURSOR_LOAD);
++		break;
++	case '\\': /* ST -- String Terminator */
++		if (term.esc & ESC_STR_END)
++			strhandle();
++		break;
++	default:
++		fprintf(stderr, "erresc: unknown sequence ESC 0x%02X '%c'\n",
++			(uchar) ascii, isprint(ascii)? ascii:'.');
++		break;
++	}
++	return 1;
+ }
+ 
+ void
+ tputc(Rune u)
+ {
+-    char c[UTF_SIZ];
+-    int control;
+-    int width, len;
+-    Glyph *gp;
+-
+-    control = ISCONTROL(u);
+-    if (u < 127 || !IS_SET(MODE_UTF8)) {
+-        c[0] = u;
+-        width = len = 1;
+-    } else {
+-        len = utf8encode(u, c);
+-        if (!control && (width = wcwidth(u)) == -1)
+-            width = 1;
+-    }
+-
+-    if (IS_SET(MODE_PRINT))
+-        tprinter(c, len);
+-
+-    /*
+-     * STR sequence must be checked before anything else
+-     * because it uses all following characters until it
+-     * receives a ESC, a SUB, a ST or any other C1 control
+-     * character.
+-     */
+-    if (term.esc & ESC_STR) {
+-        if (u == '\a' || u == 030 || u == 032 || u == 033 ||
+-                ISCONTROLC1(u)) {
+-            term.esc &= ~(ESC_START|ESC_STR);
+-            term.esc |= ESC_STR_END;
+-            goto check_control_code;
+-        }
+-
+-        if (strescseq.len+len >= strescseq.siz) {
+-            /*
+-             * Here is a bug in terminals. If the user never sends
+-             * some code to stop the str or esc command, then st
+-             * will stop responding. But this is better than
+-             * silently failing with unknown characters. At least
+-             * then users will report back.
+-             *
+-             * In the case users ever get fixed, here is the code:
+-             */
+-            /*
+-             * term.esc = 0;
+-             * strhandle();
+-             */
+-            if (strescseq.siz > (SIZE_MAX - UTF_SIZ) / 2)
+-                return;
+-            strescseq.siz *= 2;
+-            strescseq.buf = xrealloc(strescseq.buf, strescseq.siz);
+-        }
+-
+-        memmove(&strescseq.buf[strescseq.len], c, len);
+-        strescseq.len += len;
+-        return;
+-    }
++	char c[UTF_SIZ];
++	int control;
++	int width, len;
++	Glyph *gp;
++
++	control = ISCONTROL(u);
++	if (u < 127 || !IS_SET(MODE_UTF8)) {
++		c[0] = u;
++		width = len = 1;
++	} else {
++		len = utf8encode(u, c);
++		if (!control && (width = wcwidth(u)) == -1)
++			width = 1;
++	}
++
++	if (IS_SET(MODE_PRINT))
++		tprinter(c, len);
++
++	/*
++	 * STR sequence must be checked before anything else
++	 * because it uses all following characters until it
++	 * receives a ESC, a SUB, a ST or any other C1 control
++	 * character.
++	 */
++	if (term.esc & ESC_STR) {
++		if (u == '\a' || u == 030 || u == 032 || u == 033 ||
++		   ISCONTROLC1(u)) {
++			term.esc &= ~(ESC_START|ESC_STR);
++			term.esc |= ESC_STR_END;
++			goto check_control_code;
++		}
++
++		if (strescseq.len+len >= strescseq.siz) {
++			/*
++			 * Here is a bug in terminals. If the user never sends
++			 * some code to stop the str or esc command, then st
++			 * will stop responding. But this is better than
++			 * silently failing with unknown characters. At least
++			 * then users will report back.
++			 *
++			 * In the case users ever get fixed, here is the code:
++			 */
++			/*
++			 * term.esc = 0;
++			 * strhandle();
++			 */
++			if (strescseq.siz > (SIZE_MAX - UTF_SIZ) / 2)
++				return;
++			strescseq.siz *= 2;
++			strescseq.buf = xrealloc(strescseq.buf, strescseq.siz);
++		}
++
++		memmove(&strescseq.buf[strescseq.len], c, len);
++		strescseq.len += len;
++		return;
++	}
+ 
+ check_control_code:
+-    /*
+-     * Actions of control codes must be performed as soon they arrive
+-     * because they can be embedded inside a control sequence, and
+-     * they must not cause conflicts with sequences.
+-     */
+-    if (control) {
+-        /* in UTF-8 mode ignore handling C1 control characters */
+-        if (IS_SET(MODE_UTF8) && ISCONTROLC1(u))
+-            return;
+-        tcontrolcode(u);
+-        /*
+-         * control codes are not shown ever
+-         */
+-        if (!term.esc)
+-            term.lastc = 0;
+-        return;
+-    } else if (term.esc & ESC_START) {
+-        if (term.esc & ESC_CSI) {
+-            csiescseq.buf[csiescseq.len++] = u;
+-            if (BETWEEN(u, 0x40, 0x7E)
+-                    || csiescseq.len >= \
+-                    sizeof(csiescseq.buf)-1) {
+-                term.esc = 0;
+-                csiparse();
+-                csihandle();
+-            }
+-            return;
+-        } else if (term.esc & ESC_UTF8) {
+-            tdefutf8(u);
+-        } else if (term.esc & ESC_ALTCHARSET) {
+-            tdeftran(u);
+-        } else if (term.esc & ESC_TEST) {
+-            tdectest(u);
+-        } else {
+-            if (!eschandle(u))
+-                return;
+-            /* sequence already finished */
+-        }
+-        term.esc = 0;
+-        /*
+-         * All characters which form part of a sequence are not
+-         * printed
+-         */
+-        return;
+-    }
+-    if (selected(term.c.x, term.c.y))
+-        selclear();
+-
+-    gp = &term.line[term.c.y][term.c.x];
+-    if (IS_SET(MODE_WRAP) && (term.c.state & CURSOR_WRAPNEXT)) {
+-        gp->mode |= ATTR_WRAP;
+-        tnewline(1);
+-        gp = &term.line[term.c.y][term.c.x];
+-    }
+-
+-    if (IS_SET(MODE_INSERT) && term.c.x+width < term.col) {
+-        memmove(gp+width, gp, (term.col - term.c.x - width) * sizeof(Glyph));
+-        gp->mode &= ~ATTR_WIDE;
+-    }
+-
+-    if (term.c.x+width > term.col) {
++	/*
++	 * Actions of control codes must be performed as soon they arrive
++	 * because they can be embedded inside a control sequence, and
++	 * they must not cause conflicts with sequences.
++	 */
++	if (control) {
++		/* in UTF-8 mode ignore handling C1 control characters */
++		if (IS_SET(MODE_UTF8) && ISCONTROLC1(u))
++			return;
++		tcontrolcode(u);
++		/*
++		 * control codes are not shown ever
++		 */
++		if (!term.esc)
++			term.lastc = 0;
++		return;
++	} else if (term.esc & ESC_START) {
++		if (term.esc & ESC_CSI) {
++			csiescseq.buf[csiescseq.len++] = u;
++			if (BETWEEN(u, 0x40, 0x7E)
++					|| csiescseq.len >= \
++					sizeof(csiescseq.buf)-1) {
++				term.esc = 0;
++				csiparse();
++				csihandle();
++			}
++			return;
++		} else if (term.esc & ESC_UTF8) {
++			tdefutf8(u);
++		} else if (term.esc & ESC_ALTCHARSET) {
++			tdeftran(u);
++		} else if (term.esc & ESC_TEST) {
++			tdectest(u);
++		} else {
++			if (!eschandle(u))
++				return;
++			/* sequence already finished */
++		}
++		term.esc = 0;
++		/*
++		 * All characters which form part of a sequence are not
++		 * printed
++		 */
++		return;
++	}
++	if (selected(term.c.x, term.c.y))
++		selclear();
++
++	gp = &term.line[term.c.y][term.c.x];
++	if (IS_SET(MODE_WRAP) && (term.c.state & CURSOR_WRAPNEXT)) {
++		gp->mode |= ATTR_WRAP;
++		tnewline(1);
++		gp = &term.line[term.c.y][term.c.x];
++	}
++
++	if (IS_SET(MODE_INSERT) && term.c.x+width < term.col) {
++		memmove(gp+width, gp, (term.col - term.c.x - width) * sizeof(Glyph));
++		gp->mode &= ~ATTR_WIDE;
++	}
++
++	if (term.c.x+width > term.col) {
+ 		if (IS_SET(MODE_WRAP))
+ 			tnewline(1);
+ 		else
+ 			tmoveto(term.col - width, term.c.y);
+-        gp = &term.line[term.c.y][term.c.x];
+-    }
+-
+-    tsetchar(u, &term.c.attr, term.c.x, term.c.y);
+-    term.lastc = u;
+-
+-    if (width == 2) {
+-        gp->mode |= ATTR_WIDE;
+-        if (term.c.x+1 < term.col) {
+-            if (gp[1].mode == ATTR_WIDE && term.c.x+2 < term.col) {
+-                gp[2].u = ' ';
+-                gp[2].mode &= ~ATTR_WDUMMY;
+-            }
+-            gp[1].u = '\0';
+-            gp[1].mode = ATTR_WDUMMY;
+-        }
+-    }
+-    if (term.c.x+width < term.col) {
+-        tmoveto(term.c.x+width, term.c.y);
+-    } else {
+-        term.c.state |= CURSOR_WRAPNEXT;
+-    }
++		gp = &term.line[term.c.y][term.c.x];
++	}
++
++	tsetchar(u, &term.c.attr, term.c.x, term.c.y);
++	term.lastc = u;
++
++	if (width == 2) {
++		gp->mode |= ATTR_WIDE;
++		if (term.c.x+1 < term.col) {
++			if (gp[1].mode == ATTR_WIDE && term.c.x+2 < term.col) {
++				gp[2].u = ' ';
++				gp[2].mode &= ~ATTR_WDUMMY;
++			}
++			gp[1].u = '\0';
++			gp[1].mode = ATTR_WDUMMY;
++		}
++	}
++	if (term.c.x+width < term.col) {
++		tmoveto(term.c.x+width, term.c.y);
++	} else {
++		term.c.state |= CURSOR_WRAPNEXT;
++	}
+ }
+ 
+ int
+ twrite(const char *buf, int buflen, int show_ctrl)
+ {
+-    int charsize;
+-    Rune u;
+-    int n;
+-
+-    for (n = 0; n < buflen; n += charsize) {
+-        if (IS_SET(MODE_UTF8)) {
+-            /* process a complete utf8 char */
+-            charsize = utf8decode(buf + n, &u, buflen - n);
+-            if (charsize == 0)
+-                break;
+-        } else {
+-            u = buf[n] & 0xFF;
+-            charsize = 1;
+-        }
+-        if (show_ctrl && ISCONTROL(u)) {
+-            if (u & 0x80) {
+-                u &= 0x7f;
+-                tputc('^');
+-                tputc('[');
+-            } else if (u != '\n' && u != '\r' && u != '\t') {
+-                u ^= 0x40;
+-                tputc('^');
+-            }
+-        }
+-        tputc(u);
+-    }
+-    return n;
++	int charsize;
++	Rune u;
++	int n;
++
++	for (n = 0; n < buflen; n += charsize) {
++		if (IS_SET(MODE_UTF8)) {
++			/* process a complete utf8 char */
++			charsize = utf8decode(buf + n, &u, buflen - n);
++			if (charsize == 0)
++				break;
++		} else {
++			u = buf[n] & 0xFF;
++			charsize = 1;
++		}
++		if (show_ctrl && ISCONTROL(u)) {
++			if (u & 0x80) {
++				u &= 0x7f;
++				tputc('^');
++				tputc('[');
++			} else if (u != '\n' && u != '\r' && u != '\t') {
++				u ^= 0x40;
++				tputc('^');
++			}
++		}
++		tputc(u);
++	}
++	return n;
+ }
+ 
+ void
+ tresize(int col, int row)
+ {
+-    int i, j;
+-    int tmp;
+-    int minrow, mincol;
+-    int *bp;
+-    TCursor c;
+-
+-    tmp = col;
+-    if (!term.maxcol)
+-        term.maxcol = term.col;
+-    col = MAX(col, term.maxcol);
+-    minrow = MIN(row, term.row);
+-    mincol = MIN(col, term.maxcol);
+-
+-    if (col < 1 || row < 1) {
+-        fprintf(stderr,
+-                "tresize: error resizing to %dx%d\n", col, row);
+-        return;
+-    }
+-
+-    /*
+-     * slide screen to keep cursor where we expect it -
+-     * tscrollup would work here, but we can optimize to
+-     * memmove because we're freeing the earlier lines
+-     */
+-    for (i = 0; i <= term.c.y - row; i++) {
+-        free(term.line[i]);
+-        free(term.alt[i]);
+-    }
+-    /* ensure that both src and dst are not NULL */
+-    if (i > 0) {
+-        memmove(term.line, term.line + i, row * sizeof(Line));
+-        memmove(term.alt, term.alt + i, row * sizeof(Line));
+-    }
+-    for (i += row; i < term.row; i++) {
+-        free(term.line[i]);
+-        free(term.alt[i]);
+-    }
+-
+-    /* resize to new height */
+-    term.line = xrealloc(term.line, row * sizeof(Line));
+-    term.alt  = xrealloc(term.alt,  row * sizeof(Line));
+-    term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
+-    term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
+-
+-    for (i = 0; i < HISTSIZE; i++) {
+-        term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
+-        for (j = mincol; j < col; j++) {
+-            term.hist[i][j] = term.c.attr;
+-            term.hist[i][j].u = ' ';
+-        }
+-    }
+-
+-    /* resize each row to new width, zero-pad if needed */
+-    for (i = 0; i < minrow; i++) {
+-        term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
+-        term.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));
+-    }
+-
+-    /* allocate any new rows */
+-    for (/* i = minrow */; i < row; i++) {
+-        term.line[i] = xmalloc(col * sizeof(Glyph));
+-        term.alt[i] = xmalloc(col * sizeof(Glyph));
+-    }
+-    if (col > term.maxcol) {
+-        bp = term.tabs + term.maxcol;
+-
+-        memset(bp, 0, sizeof(*term.tabs) * (col - term.maxcol));
+-        while (--bp > term.tabs && !*bp)
+-            /* nothing */ ;
+-        for (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)
+-            *bp = 1;
+-    }
+-    /* update terminal size */
+-    term.col = tmp;
+-    term.maxcol = col;
+-    term.row = row;
+-    /* reset scrolling region */
+-    tsetscroll(0, row-1);
+-    /* make use of the LIMIT in tmoveto */
+-    tmoveto(term.c.x, term.c.y);
+-    /* Clearing both screens (it makes dirty all lines) */
+-    c = term.c;
+-    for (i = 0; i < 2; i++) {
+-        if (mincol < col && 0 < minrow) {
+-            tclearregion(mincol, 0, col - 1, minrow - 1);
+-        }
+-        if (0 < col && minrow < row) {
+-            tclearregion(0, minrow, col - 1, row - 1);
+-        }
+-        tswapscreen();
+-        tcursor(CURSOR_LOAD);
+-    }
+-    term.c = c;
++	int i, j;
++	int minrow = MIN(row, term.row);
++	int mincol = MIN(col, term.col);
++	int *bp;
++	TCursor c;
++
++	if (col < 1 || row < 1) {
++		fprintf(stderr,
++		        "tresize: error resizing to %dx%d\n", col, row);
++		return;
++	}
++
++	/*
++	 * slide screen to keep cursor where we expect it -
++	 * tscrollup would work here, but we can optimize to
++	 * memmove because we're freeing the earlier lines
++	 */
++	for (i = 0; i <= term.c.y - row; i++) {
++		free(term.line[i]);
++		free(term.alt[i]);
++	}
++	/* ensure that both src and dst are not NULL */
++	if (i > 0) {
++		memmove(term.line, term.line + i, row * sizeof(Line));
++		memmove(term.alt, term.alt + i, row * sizeof(Line));
++	}
++	for (i += row; i < term.row; i++) {
++		free(term.line[i]);
++		free(term.alt[i]);
++	}
++
++	/* resize to new height */
++	term.line = xrealloc(term.line, row * sizeof(Line));
++	term.alt  = xrealloc(term.alt,  row * sizeof(Line));
++	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
++	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
++
++	for (i = 0; i < HISTSIZE; i++) {
++		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
++		for (j = mincol; j < col; j++) {
++			term.hist[i][j] = term.c.attr;
++			term.hist[i][j].u = ' ';
++		}
++	}
++
++	/* resize each row to new width, zero-pad if needed */
++	for (i = 0; i < minrow; i++) {
++		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
++		term.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));
++	}
++
++	/* allocate any new rows */
++	for (/* i = minrow */; i < row; i++) {
++		term.line[i] = xmalloc(col * sizeof(Glyph));
++		term.alt[i] = xmalloc(col * sizeof(Glyph));
++	}
++	if (col > term.col) {
++		bp = term.tabs + term.col;
++
++		memset(bp, 0, sizeof(*term.tabs) * (col - term.col));
++		while (--bp > term.tabs && !*bp)
++			/* nothing */ ;
++		for (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)
++			*bp = 1;
++	}
++	/* update terminal size */
++	term.col = col;
++	term.row = row;
++	/* reset scrolling region */
++	tsetscroll(0, row-1);
++	/* make use of the LIMIT in tmoveto */
++	tmoveto(term.c.x, term.c.y);
++	/* Clearing both screens (it makes dirty all lines) */
++	c = term.c;
++	for (i = 0; i < 2; i++) {
++		if (mincol < col && 0 < minrow) {
++			tclearregion(mincol, 0, col - 1, minrow - 1);
++		}
++		if (0 < col && minrow < row) {
++			tclearregion(0, minrow, col - 1, row - 1);
++		}
++		tswapscreen();
++		tcursor(CURSOR_LOAD);
++	}
++	term.c = c;
+ }
+ 
+ void
+ resettitle(void)
+ {
+-    xsettitle(NULL);
++	xsettitle(NULL);
+ }
+ 
+ void
+ drawregion(int x1, int y1, int x2, int y2)
+ {
+-    int y;
++	int y;
+ 
+-    for (y = y1; y < y2; y++) {
+-        if (!term.dirty[y])
+-            continue;
++	for (y = y1; y < y2; y++) {
++		if (!term.dirty[y])
++			continue;
+ 
+-        term.dirty[y] = 0;
+-        xdrawline(TLINE(y), x1, y, x2);
+-    }
++		term.dirty[y] = 0;
++		xdrawline(TLINE(y), x1, y, x2);
++	}
+ }
+ 
+ void
+ draw(void)
+ {
+-    int cx = term.c.x, ocx = term.ocx, ocy = term.ocy;
++	int cx = term.c.x, ocx = term.ocx, ocy = term.ocy;
++
++	if (!xstartdraw())
++		return;
+ 
+-    if (!xstartdraw())
+-        return;
++	/* adjust cursor position */
++	LIMIT(term.ocx, 0, term.col-1);
++	LIMIT(term.ocy, 0, term.row-1);
++	if (term.line[term.ocy][term.ocx].mode & ATTR_WDUMMY)
++		term.ocx--;
++	if (term.line[term.c.y][cx].mode & ATTR_WDUMMY)
++		cx--;
+ 
+-    /* adjust cursor position */
+-    LIMIT(term.ocx, 0, term.col-1);
+-    LIMIT(term.ocy, 0, term.row-1);
+-    if (term.line[term.ocy][term.ocx].mode & ATTR_WDUMMY)
+-        term.ocx--;
+-    if (term.line[term.c.y][cx].mode & ATTR_WDUMMY)
+-        cx--;
++	drawregion(0, 0, term.col, term.row);
++	if (term.scr == 0)
++		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
++				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
++				term.line[term.ocy], term.col);
+ 
+-    drawregion(0, 0, term.col, term.row);
+-    if (term.scr == 0)
+-        xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+-                term.ocx, term.ocy, term.line[term.ocy][term.ocx],
+-                term.line[term.ocy], term.col);
+-    /* xdrawcursor(cx, term.c.y, term.line[term.c.y][cx], */
+-    /* 		term.ocx, term.ocy, term.line[term.ocy][term.ocx], */
+-    /* 		term.line[term.ocy], term.col); */
+-    term.ocx = cx;
+-    term.ocy = term.c.y;
+-    xfinishdraw();
+-    if (ocx != term.ocx || ocy != term.ocy)
+-        xximspot(term.ocx, term.ocy);
++	term.ocx = cx;
++	term.ocy = term.c.y;
++	xfinishdraw();
++	if (ocx != term.ocx || ocy != term.ocy)
++		xximspot(term.ocx, term.ocy);
+ }
+ 
+ void
+ redraw(void)
+ {
+-    tfulldirt();
+-    draw();
++	tfulldirt();
++	draw();
+ }
+diff --git a/st.h b/st.h
+index ca748f3..a6be61e 100644
+--- a/st.h
++++ b/st.h
+@@ -11,48 +11,46 @@
+ #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
+ #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
+ #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
+-#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) != ((b).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) || \
+-        (a).fg != (b).fg || \
+-        (a).bg != (b).bg)
++#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP)) != ((b).mode & (~ATTR_WRAP)) || \
++				(a).fg != (b).fg || \
++				(a).bg != (b).bg)
+ #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
+-        (t1.tv_nsec-t2.tv_nsec)/1E6)
++				(t1.tv_nsec-t2.tv_nsec)/1E6)
+ #define MODBIT(x, set, bit)	((set) ? ((x) |= (bit)) : ((x) &= ~(bit)))
+ 
+ #define TRUECOLOR(r,g,b)	(1 << 24 | (r) << 16 | (g) << 8 | (b))
+ #define IS_TRUECOL(x)		(1 << 24 & (x))
+ 
+ enum glyph_attribute {
+-    ATTR_NULL       = 0,
+-    ATTR_BOLD       = 1 << 0,
+-    ATTR_FAINT      = 1 << 1,
+-    ATTR_ITALIC     = 1 << 2,
+-    ATTR_UNDERLINE  = 1 << 3,
+-    ATTR_BLINK      = 1 << 4,
+-    ATTR_REVERSE    = 1 << 5,
+-    ATTR_INVISIBLE  = 1 << 6,
+-    ATTR_STRUCK     = 1 << 7,
+-    ATTR_WRAP       = 1 << 8,
+-    ATTR_WIDE       = 1 << 9,
+-    ATTR_WDUMMY     = 1 << 10,
+-    ATTR_BOXDRAW    = 1 << 11,
+-    ATTR_LIGA       = 1 << 12,
+-    ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
++	ATTR_NULL       = 0,
++	ATTR_BOLD       = 1 << 0,
++	ATTR_FAINT      = 1 << 1,
++	ATTR_ITALIC     = 1 << 2,
++	ATTR_UNDERLINE  = 1 << 3,
++	ATTR_BLINK      = 1 << 4,
++	ATTR_REVERSE    = 1 << 5,
++	ATTR_INVISIBLE  = 1 << 6,
++	ATTR_STRUCK     = 1 << 7,
++	ATTR_WRAP       = 1 << 8,
++	ATTR_WIDE       = 1 << 9,
++	ATTR_WDUMMY     = 1 << 10,
++	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
+ };
+ 
+ enum selection_mode {
+-    SEL_IDLE = 0,
+-    SEL_EMPTY = 1,
+-    SEL_READY = 2
++	SEL_IDLE = 0,
++	SEL_EMPTY = 1,
++	SEL_READY = 2
+ };
+ 
+ enum selection_type {
+-    SEL_REGULAR = 1,
+-    SEL_RECTANGULAR = 2
++	SEL_REGULAR = 1,
++	SEL_RECTANGULAR = 2
+ };
+ 
+ enum selection_snap {
+-    SNAP_WORD = 1,
+-    SNAP_LINE = 2
++	SNAP_WORD = 1,
++	SNAP_LINE = 2
+ };
+ 
+ typedef unsigned char uchar;
+@@ -64,31 +62,30 @@ typedef uint_least32_t Rune;
+ 
+ #define Glyph Glyph_
+ typedef struct {
+-    Rune u;           /* character code */
+-    ushort mode;      /* attribute flags */
+-    uint32_t fg;      /* foreground  */
+-    uint32_t bg;      /* background  */
++	Rune u;           /* character code */
++	ushort mode;      /* attribute flags */
++	uint32_t fg;      /* foreground  */
++	uint32_t bg;      /* background  */
+ } Glyph;
+ 
+ typedef Glyph *Line;
+ 
+ typedef union {
+-    int i;
+-    uint ui;
+-    float f;
+-    const void *v;
+-    const char *s;
++	int i;
++	uint ui;
++	float f;
++	const void *v;
++	const char *s;
+ } Arg;
+ 
+ void die(const char *, ...);
+ void redraw(void);
+-void tfulldirt(void);
+ void draw(void);
+ 
+ void externalpipe(const Arg *);
++
+ void kscrolldown(const Arg *);
+ void kscrollup(const Arg *);
+-
+ void printscreen(const Arg *);
+ void printsel(const Arg *);
+ void sendbreak(const Arg *);
+@@ -119,14 +116,6 @@ void *xmalloc(size_t);
+ void *xrealloc(void *, size_t);
+ char *xstrdup(const char *);
+ 
+-int isboxdraw(Rune);
+-ushort boxdrawindex(const Glyph *);
+-#ifdef XFT_VERSION
+-/* only exposed to x.c, otherwise we'll need Xft.h for the types */
+-void boxdraw_xinit(Display *, Colormap, XftDraw *, Visual *);
+-void drawboxes(int, int, int, int, XftColor *, XftColor *, const XftGlyphFontSpec *, int);
+-#endif
+-
+ /* config.h globals */
+ extern char *utmp;
+ extern char *scroll;
+@@ -139,8 +128,5 @@ extern char *termname;
+ extern unsigned int tabspaces;
+ extern unsigned int defaultfg;
+ extern unsigned int defaultbg;
+-extern float alpha;
+-extern float alphaUnfocus;
+-extern const int boxdraw, boxdraw_bold, boxdraw_braille;
+ extern unsigned int defaultcs;
+-
++extern float alpha_def;
+diff --git a/win.h b/win.h
+index ed8787d..94679e4 100644
+--- a/win.h
++++ b/win.h
+@@ -1,26 +1,26 @@
+ /* See LICENSE for license details. */
+ 
+ enum win_mode {
+-    MODE_VISIBLE     = 1 << 0,
+-    MODE_FOCUSED     = 1 << 1,
+-    MODE_APPKEYPAD   = 1 << 2,
+-    MODE_MOUSEBTN    = 1 << 3,
+-    MODE_MOUSEMOTION = 1 << 4,
+-    MODE_REVERSE     = 1 << 5,
+-    MODE_KBDLOCK     = 1 << 6,
+-    MODE_HIDE        = 1 << 7,
+-    MODE_APPCURSOR   = 1 << 8,
+-    MODE_MOUSESGR    = 1 << 9,
+-    MODE_8BIT        = 1 << 10,
+-    MODE_BLINK       = 1 << 11,
+-    MODE_FBLINK      = 1 << 12,
+-    MODE_FOCUS       = 1 << 13,
+-    MODE_MOUSEX10    = 1 << 14,
+-    MODE_MOUSEMANY   = 1 << 15,
+-    MODE_BRCKTPASTE  = 1 << 16,
+-    MODE_NUMLOCK     = 1 << 17,
+-    MODE_MOUSE       = MODE_MOUSEBTN|MODE_MOUSEMOTION|MODE_MOUSEX10\
+-                       |MODE_MOUSEMANY,
++	MODE_VISIBLE     = 1 << 0,
++	MODE_FOCUSED     = 1 << 1,
++	MODE_APPKEYPAD   = 1 << 2,
++	MODE_MOUSEBTN    = 1 << 3,
++	MODE_MOUSEMOTION = 1 << 4,
++	MODE_REVERSE     = 1 << 5,
++	MODE_KBDLOCK     = 1 << 6,
++	MODE_HIDE        = 1 << 7,
++	MODE_APPCURSOR   = 1 << 8,
++	MODE_MOUSESGR    = 1 << 9,
++	MODE_8BIT        = 1 << 10,
++	MODE_BLINK       = 1 << 11,
++	MODE_FBLINK      = 1 << 12,
++	MODE_FOCUS       = 1 << 13,
++	MODE_MOUSEX10    = 1 << 14,
++	MODE_MOUSEMANY   = 1 << 15,
++	MODE_BRCKTPASTE  = 1 << 16,
++	MODE_NUMLOCK     = 1 << 17,
++	MODE_MOUSE       = MODE_MOUSEBTN|MODE_MOUSEMOTION|MODE_MOUSEX10\
++	                  |MODE_MOUSEMANY,
+ };
+ 
+ void xbell(void);
+diff --git a/x.c b/x.c
+index 3cc3fa9..4615736 100644
+--- a/x.c
++++ b/x.c
+@@ -24,40 +24,40 @@ char *argv0;
+ 
+ /* types used in config.h */
+ typedef struct {
+-    uint mod;
+-    KeySym keysym;
+-    void (*func)(const Arg *);
+-    const Arg arg;
++	uint mod;
++	KeySym keysym;
++	void (*func)(const Arg *);
++	const Arg arg;
+ } Shortcut;
+ 
+ typedef struct {
+-    uint mod;
+-    uint button;
+-    void (*func)(const Arg *);
+-    const Arg arg;
+-    uint  release;
++	uint mod;
++	uint button;
++	void (*func)(const Arg *);
++	const Arg arg;
++	uint  release;
+ } MouseShortcut;
+ 
+ typedef struct {
+-    KeySym k;
+-    uint mask;
+-    char *s;
+-    /* three-valued logic variables: 0 indifferent, 1 on, -1 off */
+-    signed char appkey;    /* application keypad */
+-    signed char appcursor; /* application cursor */
++	KeySym k;
++	uint mask;
++	char *s;
++	/* three-valued logic variables: 0 indifferent, 1 on, -1 off */
++	signed char appkey;    /* application keypad */
++	signed char appcursor; /* application cursor */
+ } Key;
+ 
+ /* Xresources preferences */
+ enum resource_type {
+-    STRING = 0,
+-    INTEGER = 1,
+-    FLOAT = 2
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
+ };
+ 
+ typedef struct {
+-    char *name;
+-    enum resource_type type;
+-    void *dst;
++	char *name;
++	enum resource_type type;
++	void *dst;
+ } ResourcePref;
+ 
+ /* X modifiers */
+@@ -70,11 +70,12 @@ static void clipcopy(const Arg *);
+ static void clippaste(const Arg *);
+ static void numlock(const Arg *);
+ static void selpaste(const Arg *);
+-static void changealpha(const Arg *);
+ static void zoom(const Arg *);
+ static void zoomabs(const Arg *);
+ static void zoomreset(const Arg *);
+ static void ttysend(const Arg *);
++static void changealpha(const Arg *);
++static float clamp(float value, float lower, float upper);
+ 
+ /* config.h for applying patches and the configuration. */
+ #include "config.h"
+@@ -95,71 +96,72 @@ typedef XftGlyphFontSpec GlyphFontSpec;
+ 
+ /* Purely graphic info */
+ typedef struct {
+-    int tw, th; /* tty width and height */
+-    int w, h; /* window width and height */
+-    int ch; /* char height */
+-    int cw; /* char width  */
+-    int mode; /* window state/mode flags */
+-    int cursor; /* cursor style */
++	int tw, th; /* tty width and height */
++	int w, h; /* window width and height */
++	int ch; /* char height */
++	int cw; /* char width  */
++	int mode; /* window state/mode flags */
++	int cursor; /* cursor style */
+ } TermWindow;
+ 
+ typedef struct {
+-    Display *dpy;
+-    Colormap cmap;
+-    Window win;
+-    Drawable buf;
+-    GlyphFontSpec *specbuf; /* font spec buffer used for rendering */
+-    Atom xembed, wmdeletewin, netwmname, netwmiconname, netwmpid;
+-    struct {
+-        XIM xim;
+-        XIC xic;
+-        XPoint spot;
+-        XVaNestedList spotlist;
+-    } ime;
+-    Draw draw;
+-    Visual *vis;
+-    XSetWindowAttributes attrs;
+-    int scr;
+-    int isfixed; /* is fixed geometry? */
+-    int depth; /* bit depth */
+-    int l, t; /* left and top offset */
+-    int gm; /* geometry mask */
++	Display *dpy;
++	Colormap cmap;
++	Window win;
++	Drawable buf;
++	GlyphFontSpec *specbuf; /* font spec buffer used for rendering */
++	Atom xembed, wmdeletewin, netwmname, netwmiconname, netwmpid;
++	struct {
++		XIM xim;
++		XIC xic;
++		XPoint spot;
++		XVaNestedList spotlist;
++	} ime;
++	Draw draw;
++	Visual *vis;
++	XSetWindowAttributes attrs;
++	int scr;
++	int isfixed; /* is fixed geometry? */
++	int depth; /* bit depth */
++	int l, t; /* left and top offset */
++	int gm; /* geometry mask */
+ } XWindow;
+ 
+ typedef struct {
+-    Atom xtarget;
+-    char *primary, *clipboard;
+-    struct timespec tclick1;
+-    struct timespec tclick2;
++	Atom xtarget;
++	char *primary, *clipboard;
++	struct timespec tclick1;
++	struct timespec tclick2;
+ } XSelection;
+ 
+ /* Font structure */
+ #define Font Font_
+ typedef struct {
+-    int height;
+-    int width;
+-    int ascent;
+-    int descent;
+-    int badslant;
+-    int badweight;
+-    short lbearing;
+-    short rbearing;
+-    XftFont *match;
+-    FcFontSet *set;
+-    FcPattern *pattern;
++	int height;
++	int width;
++	int ascent;
++	int descent;
++	int badslant;
++	int badweight;
++	short lbearing;
++	short rbearing;
++	XftFont *match;
++	FcFontSet *set;
++	FcPattern *pattern;
+ } Font;
+ 
+ /* Drawing Context */
+ typedef struct {
+-    Color *col;
+-    size_t collen;
+-    Font font, bfont, ifont, ibfont;
+-    GC gc;
++	Color *col;
++	size_t collen;
++	Font font, bfont, ifont, ibfont;
++	GC gc;
+ } DC;
+ 
+ static inline ushort sixd_to_16bit(int);
++static void xresetfontsettings(ushort mode, Font **font, int *frcflags);
+ static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
+-static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
++static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int, int);
+ static void xdrawglyph(Glyph, int, int);
+ static void xclear(int, int, int, int);
+ static int xgeommasktogravity(int);
+@@ -173,16 +175,15 @@ static void xresize(int, int);
+ static void xhints(void);
+ static int xloadcolor(int, const char *, Color *);
+ static int xloadfont(Font *, FcPattern *);
++static void xloadfonts(const char *, double);
+ static int xloadsparefont(FcPattern *, int);
+ static void xloadsparefonts(void);
+-static void xloadfonts(const char *, double);
+ static void xunloadfont(Font *);
+ static void xunloadfonts(void);
+ static void xsetenv(void);
+ static void xseturgency(int);
+ static int evcol(XEvent *);
+ static int evrow(XEvent *);
+-static float clamp(float, float, float);
+ 
+ static void expose(XEvent *);
+ static void visibility(XEvent *);
+@@ -210,29 +211,29 @@ static void run(void);
+ static void usage(void);
+ 
+ static void (*handler[LASTEvent])(XEvent *) = {
+-    [KeyPress] = kpress,
+-    [ClientMessage] = cmessage,
+-    [ConfigureNotify] = resize,
+-    [VisibilityNotify] = visibility,
+-    [UnmapNotify] = unmap,
+-    [Expose] = expose,
+-    [FocusIn] = focus,
+-    [FocusOut] = focus,
+-    [MotionNotify] = bmotion,
+-    [ButtonPress] = bpress,
+-    [ButtonRelease] = brelease,
+-    /*
+-     * Uncomment if you want the selection to disappear when you select something
+-     * different in another window.
+-     */
+-    /*	[SelectionClear] = selclear_, */
+-    [SelectionNotify] = selnotify,
+-    /*
+-     * PropertyNotify is only turned on when there is some INCR transfer happening
+-     * for the selection retrieval.
+-     */
+-    [PropertyNotify] = propnotify,
+-    [SelectionRequest] = selrequest,
++	[KeyPress] = kpress,
++	[ClientMessage] = cmessage,
++	[ConfigureNotify] = resize,
++	[VisibilityNotify] = visibility,
++	[UnmapNotify] = unmap,
++	[Expose] = expose,
++	[FocusIn] = focus,
++	[FocusOut] = focus,
++	[MotionNotify] = bmotion,
++	[ButtonPress] = bpress,
++	[ButtonRelease] = brelease,
++/*
++ * Uncomment if you want the selection to disappear when you select something
++ * different in another window.
++ */
++/*	[SelectionClear] = selclear_, */
++	[SelectionNotify] = selnotify,
++/*
++ * PropertyNotify is only turned on when there is some INCR transfer happening
++ * for the selection retrieval.
++ */
++	[PropertyNotify] = propnotify,
++	[SelectionRequest] = selrequest,
+ };
+ 
+ /* Globals */
+@@ -243,16 +244,16 @@ static TermWindow win;
+ 
+ /* Font Ring Cache */
+ enum {
+-    FRC_NORMAL,
+-    FRC_ITALIC,
+-    FRC_BOLD,
+-    FRC_ITALICBOLD
++	FRC_NORMAL,
++	FRC_ITALIC,
++	FRC_BOLD,
++	FRC_ITALICBOLD
+ };
+ 
+ typedef struct {
+-    XftFont *font;
+-    int flags;
+-    Rune unicodep;
++	XftFont *font;
++	int flags;
++	Rune unicodep;
+ } Fontcache;
+ 
+ /* Fontcache is an array now. A new font will be appended to the array. */
+@@ -263,7 +264,6 @@ static char *usedfont = NULL;
+ static double usedfontsize = 0;
+ static double defaultfontsize = 0;
+ 
+-static char *opt_alpha = NULL;
+ static char *opt_class = NULL;
+ static char **opt_cmd  = NULL;
+ static char *opt_embed = NULL;
+@@ -274,632 +274,614 @@ static char *opt_name  = NULL;
+ static char *opt_title = NULL;
+ static char *opt_dir   = NULL;
+ 
+-static int focused = 0;
+-
+-static int oldbutton = 3; /* button event on startup: 3 = release */
+ static uint buttons; /* bit field of pressed buttons */
+ 
+ void
+ clipcopy(const Arg *dummy)
+ {
+-    Atom clipboard;
++	Atom clipboard;
+ 
+-    free(xsel.clipboard);
+-    xsel.clipboard = NULL;
++	free(xsel.clipboard);
++	xsel.clipboard = NULL;
+ 
+-    if (xsel.primary != NULL) {
+-        xsel.clipboard = xstrdup(xsel.primary);
+-        clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
+-        XSetSelectionOwner(xw.dpy, clipboard, xw.win, CurrentTime);
+-    }
++	if (xsel.primary != NULL) {
++		xsel.clipboard = xstrdup(xsel.primary);
++		clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
++		XSetSelectionOwner(xw.dpy, clipboard, xw.win, CurrentTime);
++	}
+ }
+ 
+ void
+ clippaste(const Arg *dummy)
+ {
+-    Atom clipboard;
++	Atom clipboard;
+ 
+-    clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
+-    XConvertSelection(xw.dpy, clipboard, xsel.xtarget, clipboard,
+-            xw.win, CurrentTime);
++	clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
++	XConvertSelection(xw.dpy, clipboard, xsel.xtarget, clipboard,
++			xw.win, CurrentTime);
+ }
+ 
+ void
+ selpaste(const Arg *dummy)
+ {
+-    XConvertSelection(xw.dpy, XA_PRIMARY, xsel.xtarget, XA_PRIMARY,
+-            xw.win, CurrentTime);
++	XConvertSelection(xw.dpy, XA_PRIMARY, xsel.xtarget, XA_PRIMARY,
++			xw.win, CurrentTime);
+ }
+ 
+ void
+ numlock(const Arg *dummy)
+ {
+-    win.mode ^= MODE_NUMLOCK;
+-}
+-
+-void
+-changealpha(const Arg *arg)
+-{
+-    if((alpha > 0 && arg->f < 0) || (alpha < 1 && arg->f > 0))
+-        alpha += arg->f;
+-
+-    if (alpha < 0.03){
+-        background = alphaBg;
+-    }else {
+-        background = defaultAlphaBg;
+-    }
+-
+-    alpha = clamp(alpha, 0.0, 1.0);
+-    alphaUnfocus = clamp(alpha-alphaOffset, 0.0, 1.0);
+-
+-    xloadcols();
+-    redraw();
++	win.mode ^= MODE_NUMLOCK;
+ }
+ 
+ void
+ zoom(const Arg *arg)
+ {
+-    Arg larg;
++	Arg larg;
+ 
+-    larg.f = usedfontsize + arg->f;
+-    zoomabs(&larg);
++	larg.f = usedfontsize + arg->f;
++	zoomabs(&larg);
+ }
+ 
+ void
+ zoomabs(const Arg *arg)
+ {
+-    xunloadfonts();
+-    xloadfonts(usedfont, arg->f);
+-    xloadsparefonts();
+-    cresize(0, 0);
+-    redraw();
+-    xhints();
++	xunloadfonts();
++	xloadfonts(usedfont, arg->f);
++	xloadsparefonts();
++	cresize(0, 0);
++	redraw();
++	xhints();
+ }
+ 
+ void
+ zoomreset(const Arg *arg)
+ {
+-    Arg larg;
++	Arg larg;
+ 
+-    if (defaultfontsize > 0) {
+-        larg.f = defaultfontsize;
+-        zoomabs(&larg);
+-    }
++	if (defaultfontsize > 0) {
++		larg.f = defaultfontsize;
++		zoomabs(&larg);
++	}
+ }
+ 
+ void
+ ttysend(const Arg *arg)
+ {
+-    ttywrite(arg->s, strlen(arg->s), 1);
++	ttywrite(arg->s, strlen(arg->s), 1);
+ }
+ 
+ int
+ evcol(XEvent *e)
+ {
+-    int x = e->xbutton.x - borderpx;
+-    LIMIT(x, 0, win.tw - 1);
+-    return x / win.cw;
++	int x = e->xbutton.x - borderpx;
++	LIMIT(x, 0, win.tw - 1);
++	return x / win.cw;
+ }
+ 
+ int
+ evrow(XEvent *e)
+ {
+-    int y = e->xbutton.y - borderpx;
+-    LIMIT(y, 0, win.th - 1);
+-    return y / win.ch;
+-}
+-
+-float clamp(float value, float lower, float upper)
+-{
+-    if(value < lower)
+-        return lower;
+-    if(value > upper)
+-        return upper;
+-    return value;
++	int y = e->xbutton.y - borderpx;
++	LIMIT(y, 0, win.th - 1);
++	return y / win.ch;
+ }
+ 
+ void
+ mousesel(XEvent *e, int done)
+ {
+-    int type, seltype = SEL_REGULAR;
+-    uint state = e->xbutton.state & ~(Button1Mask | forcemousemod);
++	int type, seltype = SEL_REGULAR;
++	uint state = e->xbutton.state & ~(Button1Mask | forcemousemod);
+ 
+-    for (type = 1; type < LEN(selmasks); ++type) {
+-        if (match(selmasks[type], state)) {
+-            seltype = type;
+-            break;
+-        }
+-    }
+-    selextend(evcol(e), evrow(e), seltype, done);
+-    if (done)
+-        setsel(getsel(), e->xbutton.time);
++	for (type = 1; type < LEN(selmasks); ++type) {
++		if (match(selmasks[type], state)) {
++			seltype = type;
++			break;
++		}
++	}
++	selextend(evcol(e), evrow(e), seltype, done);
++	if (done)
++		setsel(getsel(), e->xbutton.time);
+ }
+ 
+ void
+ mousereport(XEvent *e)
+ {
+-    int len, x = evcol(e), y = evrow(e),
+-        button = e->xbutton.button, state = e->xbutton.state;
+-    char buf[40];
+-    static int ox, oy;
+-
+-    /* from urxvt */
+-    if (e->xbutton.type == MotionNotify) {
+-        if (x == ox && y == oy)
+-            return;
+-        if (!IS_SET(MODE_MOUSEMOTION) && !IS_SET(MODE_MOUSEMANY))
+-            return;
+-        /* MOUSE_MOTION: no reporting if no button is pressed */
+-        if (IS_SET(MODE_MOUSEMOTION) && oldbutton == 3)
+-            return;
+-
+-        button = oldbutton + 32;
+-        ox = x;
+-        oy = y;
+-    } else {
+-        if (!IS_SET(MODE_MOUSESGR) && e->xbutton.type == ButtonRelease) {
+-            button = 3;
+-        } else {
+-            button -= Button1;
+-            if (button >= 3)
+-                button += 64 - 3;
+-        }
+-        if (e->xbutton.type == ButtonPress) {
+-            oldbutton = button;
+-            ox = x;
+-            oy = y;
+-        } else if (e->xbutton.type == ButtonRelease) {
+-            oldbutton = 3;
+-            /* MODE_MOUSEX10: no button release reporting */
+-            if (IS_SET(MODE_MOUSEX10))
+-                return;
+-            if (button == 64 || button == 65)
+-                return;
+-        }
+-    }
+-
+-    if (!IS_SET(MODE_MOUSEX10)) {
+-        button += ((state & ShiftMask  ) ? 4  : 0)
+-            + ((state & Mod4Mask   ) ? 8  : 0)
+-            + ((state & ControlMask) ? 16 : 0);
+-    }
+-
+-    if (IS_SET(MODE_MOUSESGR)) {
+-        len = snprintf(buf, sizeof(buf), "\033[<%d;%d;%d%c",
+-                button, x+1, y+1,
+-                e->type == ButtonRelease ? 'm' : 'M');
+-    } else if (x < 223 && y < 223) {
+-        len = snprintf(buf, sizeof(buf), "\033[M%c%c%c",
+-                32+button, 32+x+1, 32+y+1);
+-    } else {
+-        return;
+-    }
+-
+-    ttywrite(buf, len, 0);
++	int len, btn, code;
++	int x = evcol(e), y = evrow(e);
++	int state = e->xbutton.state;
++	char buf[40];
++	static int ox, oy;
++
++	if (e->type == MotionNotify) {
++		if (x == ox && y == oy)
++			return;
++		if (!IS_SET(MODE_MOUSEMOTION) && !IS_SET(MODE_MOUSEMANY))
++			return;
++		/* MODE_MOUSEMOTION: no reporting if no button is pressed */
++		if (IS_SET(MODE_MOUSEMOTION) && buttons == 0)
++			return;
++		/* Set btn to lowest-numbered pressed button, or 12 if no
++		 * buttons are pressed. */
++		for (btn = 1; btn <= 11 && !(buttons & (1<<(btn-1))); btn++)
++			;
++		code = 32;
++	} else {
++		btn = e->xbutton.button;
++		/* Only buttons 1 through 11 can be encoded */
++		if (btn < 1 || btn > 11)
++			return;
++		if (e->type == ButtonRelease) {
++			/* MODE_MOUSEX10: no button release reporting */
++			if (IS_SET(MODE_MOUSEX10))
++				return;
++			/* Don't send release events for the scroll wheel */
++			if (btn == 4 || btn == 5)
++				return;
++		}
++		code = 0;
++	}
++
++	ox = x;
++	oy = y;
++
++	/* Encode btn into code. If no button is pressed for a motion event in
++	 * MODE_MOUSEMANY, then encode it as a release. */
++	if ((!IS_SET(MODE_MOUSESGR) && e->type == ButtonRelease) || btn == 12)
++		code += 3;
++	else if (btn >= 8)
++		code += 128 + btn - 8;
++	else if (btn >= 4)
++		code += 64 + btn - 4;
++	else
++		code += btn - 1;
++
++	if (!IS_SET(MODE_MOUSEX10)) {
++		code += ((state & ShiftMask  ) ?  4 : 0)
++		      + ((state & Mod1Mask   ) ?  8 : 0) /* meta key: alt */
++		      + ((state & ControlMask) ? 16 : 0);
++	}
++
++	if (IS_SET(MODE_MOUSESGR)) {
++		len = snprintf(buf, sizeof(buf), "\033[<%d;%d;%d%c",
++				code, x+1, y+1,
++				e->type == ButtonRelease ? 'm' : 'M');
++	} else if (x < 223 && y < 223) {
++		len = snprintf(buf, sizeof(buf), "\033[M%c%c%c",
++				32+code, 32+x+1, 32+y+1);
++	} else {
++		return;
++	}
++
++	ttywrite(buf, len, 0);
+ }
+ 
+ uint
+ buttonmask(uint button)
+ {
+-    return button == Button1 ? Button1Mask
+-        : button == Button2 ? Button2Mask
+-        : button == Button3 ? Button3Mask
+-        : button == Button4 ? Button4Mask
+-        : button == Button5 ? Button5Mask
+-        : 0;
++	return button == Button1 ? Button1Mask
++	     : button == Button2 ? Button2Mask
++	     : button == Button3 ? Button3Mask
++	     : button == Button4 ? Button4Mask
++	     : button == Button5 ? Button5Mask
++	     : 0;
+ }
+ 
+ int
+ mouseaction(XEvent *e, uint release)
+ {
+-    MouseShortcut *ms;
++	MouseShortcut *ms;
+ 
+-    /* ignore Button<N>mask for Button<N> - it's set on release */
+-    uint state = e->xbutton.state & ~buttonmask(e->xbutton.button);
++	/* ignore Button<N>mask for Button<N> - it's set on release */
++	uint state = e->xbutton.state & ~buttonmask(e->xbutton.button);
+ 
+-    for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
+-        if (ms->release == release &&
+-                ms->button == e->xbutton.button &&
+-                (match(ms->mod, state) ||  /* exact or forced */
+-                 match(ms->mod, state & ~forcemousemod))) {
+-            ms->func(&(ms->arg));
+-            return 1;
+-        }
+-    }
++	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
++		if (ms->release == release &&
++		    ms->button == e->xbutton.button &&
++		    (match(ms->mod, state) ||  /* exact or forced */
++		     match(ms->mod, state & ~forcemousemod))) {
++			ms->func(&(ms->arg));
++			return 1;
++		}
++	}
+ 
+-    return 0;
++	return 0;
+ }
+ 
+ void
+ bpress(XEvent *e)
+ {
+-    int btn = e->xbutton.button;
+-    struct timespec now;
+-    int snap;
+-
+-    if (1 <= btn && btn <= 11)
+-        buttons |= 1 << (btn-1);
+-
+-    if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
+-        mousereport(e);
+-        return;
+-    }
+-
+-    if (mouseaction(e, 0))
+-        return;
+-
+-    if (btn == Button1) {
+-        /*
+-         * If the user clicks below predefined timeouts specific
+-         * snapping behaviour is exposed.
+-         */
+-        clock_gettime(CLOCK_MONOTONIC, &now);
+-        if (TIMEDIFF(now, xsel.tclick2) <= tripleclicktimeout) {
+-            snap = SNAP_LINE;
+-        } else if (TIMEDIFF(now, xsel.tclick1) <= doubleclicktimeout) {
+-            snap = SNAP_WORD;
+-        } else {
+-            snap = 0;
+-        }
+-        xsel.tclick2 = xsel.tclick1;
+-        xsel.tclick1 = now;
+-
+-        selstart(evcol(e), evrow(e), snap);
+-    }
++	int btn = e->xbutton.button;
++	struct timespec now;
++	int snap;
++
++	if (1 <= btn && btn <= 11)
++		buttons |= 1 << (btn-1);
++
++	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
++		mousereport(e);
++		return;
++	}
++
++	if (mouseaction(e, 0))
++		return;
++
++	if (btn == Button1) {
++		/*
++		 * If the user clicks below predefined timeouts specific
++		 * snapping behaviour is exposed.
++		 */
++		clock_gettime(CLOCK_MONOTONIC, &now);
++		if (TIMEDIFF(now, xsel.tclick2) <= tripleclicktimeout) {
++			snap = SNAP_LINE;
++		} else if (TIMEDIFF(now, xsel.tclick1) <= doubleclicktimeout) {
++			snap = SNAP_WORD;
++		} else {
++			snap = 0;
++		}
++		xsel.tclick2 = xsel.tclick1;
++		xsel.tclick1 = now;
++
++		selstart(evcol(e), evrow(e), snap);
++	}
+ }
+ 
+ void
+ propnotify(XEvent *e)
+ {
+-    XPropertyEvent *xpev;
+-    Atom clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
++	XPropertyEvent *xpev;
++	Atom clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
+ 
+-    xpev = &e->xproperty;
+-    if (xpev->state == PropertyNewValue &&
+-            (xpev->atom == XA_PRIMARY ||
+-             xpev->atom == clipboard)) {
+-        selnotify(e);
+-    }
++	xpev = &e->xproperty;
++	if (xpev->state == PropertyNewValue &&
++			(xpev->atom == XA_PRIMARY ||
++			 xpev->atom == clipboard)) {
++		selnotify(e);
++	}
+ }
+ 
+ void
+ selnotify(XEvent *e)
+ {
+-    ulong nitems, ofs, rem;
+-    int format;
+-    uchar *data, *last, *repl;
+-    Atom type, incratom, property = None;
+-
+-    incratom = XInternAtom(xw.dpy, "INCR", 0);
+-
+-    ofs = 0;
+-    if (e->type == SelectionNotify)
+-        property = e->xselection.property;
+-    else if (e->type == PropertyNotify)
+-        property = e->xproperty.atom;
+-
+-    if (property == None)
+-        return;
+-
+-    do {
+-        if (XGetWindowProperty(xw.dpy, xw.win, property, ofs,
+-                    BUFSIZ/4, False, AnyPropertyType,
+-                    &type, &format, &nitems, &rem,
+-                    &data)) {
+-            fprintf(stderr, "Clipboard allocation failed\n");
+-            return;
+-        }
+-
+-        if (e->type == PropertyNotify && nitems == 0 && rem == 0) {
+-            /*
+-             * If there is some PropertyNotify with no data, then
+-             * this is the signal of the selection owner that all
+-             * data has been transferred. We won't need to receive
+-             * PropertyNotify events anymore.
+-             */
+-            MODBIT(xw.attrs.event_mask, 0, PropertyChangeMask);
+-            XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,
+-                    &xw.attrs);
+-        }
+-
+-        if (type == incratom) {
+-            /*
+-             * Activate the PropertyNotify events so we receive
+-             * when the selection owner does send us the next
+-             * chunk of data.
+-             */
+-            MODBIT(xw.attrs.event_mask, 1, PropertyChangeMask);
+-            XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,
+-                    &xw.attrs);
+-
+-            /*
+-             * Deleting the property is the transfer start signal.
+-             */
+-            XDeleteProperty(xw.dpy, xw.win, (int)property);
+-            continue;
+-        }
+-
+-        /*
+-         * As seen in getsel:
+-         * Line endings are inconsistent in the terminal and GUI world
+-         * copy and pasting. When receiving some selection data,
+-         * replace all '\n' with '\r'.
+-         * FIXME: Fix the computer world.
+-         */
+-        repl = data;
+-        last = data + nitems * format / 8;
+-        while ((repl = memchr(repl, '\n', last - repl))) {
+-            *repl++ = '\r';
+-        }
+-
+-        if (IS_SET(MODE_BRCKTPASTE) && ofs == 0)
+-            ttywrite("\033[200~", 6, 0);
+-        ttywrite((char *)data, nitems * format / 8, 1);
+-        if (IS_SET(MODE_BRCKTPASTE) && rem == 0)
+-            ttywrite("\033[201~", 6, 0);
+-        XFree(data);
+-        /* number of 32-bit chunks returned */
+-        ofs += nitems * format / 32;
+-    } while (rem > 0);
+-
+-    /*
+-     * Deleting the property again tells the selection owner to send the
+-     * next data chunk in the property.
+-     */
+-    XDeleteProperty(xw.dpy, xw.win, (int)property);
++	ulong nitems, ofs, rem;
++	int format;
++	uchar *data, *last, *repl;
++	Atom type, incratom, property = None;
++
++	incratom = XInternAtom(xw.dpy, "INCR", 0);
++
++	ofs = 0;
++	if (e->type == SelectionNotify)
++		property = e->xselection.property;
++	else if (e->type == PropertyNotify)
++		property = e->xproperty.atom;
++
++	if (property == None)
++		return;
++
++	do {
++		if (XGetWindowProperty(xw.dpy, xw.win, property, ofs,
++					BUFSIZ/4, False, AnyPropertyType,
++					&type, &format, &nitems, &rem,
++					&data)) {
++			fprintf(stderr, "Clipboard allocation failed\n");
++			return;
++		}
++
++		if (e->type == PropertyNotify && nitems == 0 && rem == 0) {
++			/*
++			 * If there is some PropertyNotify with no data, then
++			 * this is the signal of the selection owner that all
++			 * data has been transferred. We won't need to receive
++			 * PropertyNotify events anymore.
++			 */
++			MODBIT(xw.attrs.event_mask, 0, PropertyChangeMask);
++			XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,
++					&xw.attrs);
++		}
++
++		if (type == incratom) {
++			/*
++			 * Activate the PropertyNotify events so we receive
++			 * when the selection owner does send us the next
++			 * chunk of data.
++			 */
++			MODBIT(xw.attrs.event_mask, 1, PropertyChangeMask);
++			XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,
++					&xw.attrs);
++
++			/*
++			 * Deleting the property is the transfer start signal.
++			 */
++			XDeleteProperty(xw.dpy, xw.win, (int)property);
++			continue;
++		}
++
++		/*
++		 * As seen in getsel:
++		 * Line endings are inconsistent in the terminal and GUI world
++		 * copy and pasting. When receiving some selection data,
++		 * replace all '\n' with '\r'.
++		 * FIXME: Fix the computer world.
++		 */
++		repl = data;
++		last = data + nitems * format / 8;
++		while ((repl = memchr(repl, '\n', last - repl))) {
++			*repl++ = '\r';
++		}
++
++		if (IS_SET(MODE_BRCKTPASTE) && ofs == 0)
++			ttywrite("\033[200~", 6, 0);
++		ttywrite((char *)data, nitems * format / 8, 1);
++		if (IS_SET(MODE_BRCKTPASTE) && rem == 0)
++			ttywrite("\033[201~", 6, 0);
++		XFree(data);
++		/* number of 32-bit chunks returned */
++		ofs += nitems * format / 32;
++	} while (rem > 0);
++
++	/*
++	 * Deleting the property again tells the selection owner to send the
++	 * next data chunk in the property.
++	 */
++	XDeleteProperty(xw.dpy, xw.win, (int)property);
+ }
+ 
+ void
+ xclipcopy(void)
+ {
+-    clipcopy(NULL);
++	clipcopy(NULL);
+ }
+ 
+ void
+ selclear_(XEvent *e)
+ {
+-    selclear();
++	selclear();
+ }
+ 
+ void
+ selrequest(XEvent *e)
+ {
+-    XSelectionRequestEvent *xsre;
+-    XSelectionEvent xev;
+-    Atom xa_targets, string, clipboard;
+-    char *seltext;
+-
+-    xsre = (XSelectionRequestEvent *) e;
+-    xev.type = SelectionNotify;
+-    xev.requestor = xsre->requestor;
+-    xev.selection = xsre->selection;
+-    xev.target = xsre->target;
+-    xev.time = xsre->time;
+-    if (xsre->property == None)
+-        xsre->property = xsre->target;
+-
+-    /* reject */
+-    xev.property = None;
+-
+-    xa_targets = XInternAtom(xw.dpy, "TARGETS", 0);
+-    if (xsre->target == xa_targets) {
+-        /* respond with the supported type */
+-        string = xsel.xtarget;
+-        XChangeProperty(xsre->display, xsre->requestor, xsre->property,
+-                XA_ATOM, 32, PropModeReplace,
+-                (uchar *) &string, 1);
+-        xev.property = xsre->property;
+-    } else if (xsre->target == xsel.xtarget || xsre->target == XA_STRING) {
+-        /*
+-         * xith XA_STRING non ascii characters may be incorrect in the
+-         * requestor. It is not our problem, use utf8.
+-         */
+-        clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
+-        if (xsre->selection == XA_PRIMARY) {
+-            seltext = xsel.primary;
+-        } else if (xsre->selection == clipboard) {
+-            seltext = xsel.clipboard;
+-        } else {
+-            fprintf(stderr,
+-                    "Unhandled clipboard selection 0x%lx\n",
+-                    xsre->selection);
+-            return;
+-        }
+-        if (seltext != NULL) {
+-            XChangeProperty(xsre->display, xsre->requestor,
+-                    xsre->property, xsre->target,
+-                    8, PropModeReplace,
+-                    (uchar *)seltext, strlen(seltext));
+-            xev.property = xsre->property;
+-        }
+-    }
+-
+-    /* all done, send a notification to the listener */
+-    if (!XSendEvent(xsre->display, xsre->requestor, 1, 0, (XEvent *) &xev))
+-        fprintf(stderr, "Error sending SelectionNotify event\n");
++	XSelectionRequestEvent *xsre;
++	XSelectionEvent xev;
++	Atom xa_targets, string, clipboard;
++	char *seltext;
++
++	xsre = (XSelectionRequestEvent *) e;
++	xev.type = SelectionNotify;
++	xev.requestor = xsre->requestor;
++	xev.selection = xsre->selection;
++	xev.target = xsre->target;
++	xev.time = xsre->time;
++	if (xsre->property == None)
++		xsre->property = xsre->target;
++
++	/* reject */
++	xev.property = None;
++
++	xa_targets = XInternAtom(xw.dpy, "TARGETS", 0);
++	if (xsre->target == xa_targets) {
++		/* respond with the supported type */
++		string = xsel.xtarget;
++		XChangeProperty(xsre->display, xsre->requestor, xsre->property,
++				XA_ATOM, 32, PropModeReplace,
++				(uchar *) &string, 1);
++		xev.property = xsre->property;
++	} else if (xsre->target == xsel.xtarget || xsre->target == XA_STRING) {
++		/*
++		 * xith XA_STRING non ascii characters may be incorrect in the
++		 * requestor. It is not our problem, use utf8.
++		 */
++		clipboard = XInternAtom(xw.dpy, "CLIPBOARD", 0);
++		if (xsre->selection == XA_PRIMARY) {
++			seltext = xsel.primary;
++		} else if (xsre->selection == clipboard) {
++			seltext = xsel.clipboard;
++		} else {
++			fprintf(stderr,
++				"Unhandled clipboard selection 0x%lx\n",
++				xsre->selection);
++			return;
++		}
++		if (seltext != NULL) {
++			XChangeProperty(xsre->display, xsre->requestor,
++					xsre->property, xsre->target,
++					8, PropModeReplace,
++					(uchar *)seltext, strlen(seltext));
++			xev.property = xsre->property;
++		}
++	}
++
++	/* all done, send a notification to the listener */
++	if (!XSendEvent(xsre->display, xsre->requestor, 1, 0, (XEvent *) &xev))
++		fprintf(stderr, "Error sending SelectionNotify event\n");
+ }
+ 
+ void
+ setsel(char *str, Time t)
+ {
+-    if (!str)
+-        return;
++	if (!str)
++		return;
+ 
+-    free(xsel.primary);
+-    xsel.primary = str;
++	free(xsel.primary);
++	xsel.primary = str;
+ 
+-    XSetSelectionOwner(xw.dpy, XA_PRIMARY, xw.win, t);
+-    if (XGetSelectionOwner(xw.dpy, XA_PRIMARY) != xw.win)
+-        selclear();
++	XSetSelectionOwner(xw.dpy, XA_PRIMARY, xw.win, t);
++	if (XGetSelectionOwner(xw.dpy, XA_PRIMARY) != xw.win)
++		selclear();
+ }
+ 
+ void
+ xsetsel(char *str)
+ {
+-    setsel(str, CurrentTime);
++	setsel(str, CurrentTime);
+ }
+ 
+ void
+ brelease(XEvent *e)
+ {
+-    int btn = e->xbutton.button;
++	int btn = e->xbutton.button;
+ 
+-    if (1 <= btn && btn <= 11)
+-        buttons &= ~(1 << (btn-1));
++	if (1 <= btn && btn <= 11)
++		buttons &= ~(1 << (btn-1));
+ 
+-    if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
+-        mousereport(e);
+-        return;
+-    }
++	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
++		mousereport(e);
++		return;
++	}
+ 
+-    if (mouseaction(e, 1))
+-        return;
+-    if (btn == Button1)
+-        mousesel(e, 1);
++	if (mouseaction(e, 1))
++		return;
++	if (btn == Button1)
++		mousesel(e, 1);
+ }
+ 
+ void
+ bmotion(XEvent *e)
+ {
+-    if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
+-        mousereport(e);
+-        return;
+-    }
++	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
++		mousereport(e);
++		return;
++	}
+ 
+-    mousesel(e, 0);
++	mousesel(e, 0);
+ }
+ 
+ void
+ cresize(int width, int height)
+ {
+-    int col, row;
++	int col, row;
+ 
+-    if (width != 0)
+-        win.w = width;
+-    if (height != 0)
+-        win.h = height;
++	if (width != 0)
++		win.w = width;
++	if (height != 0)
++		win.h = height;
+ 
+-    col = (win.w - 2 * borderpx) / win.cw;
+-    row = (win.h - 2 * borderpx) / win.ch;
+-    col = MAX(1, col);
+-    row = MAX(1, row);
++	col = (win.w - 2 * borderpx) / win.cw;
++	row = (win.h - 2 * borderpx) / win.ch;
++	col = MAX(1, col);
++	row = MAX(1, row);
+ 
+-    tresize(col, row);
+-    xresize(col, row);
+-    ttyresize(win.tw, win.th);
++	tresize(col, row);
++	xresize(col, row);
++	ttyresize(win.tw, win.th);
+ }
+ 
+ void
+ xresize(int col, int row)
+ {
+-    win.tw = col * win.cw;
+-    win.th = row * win.ch;
++	win.tw = col * win.cw;
++	win.th = row * win.ch;
+ 
+-    XFreePixmap(xw.dpy, xw.buf);
+-    xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
+-            xw.depth);
+-    XftDrawChange(xw.draw, xw.buf);
+-    xclear(0, 0, win.w, win.h);
++	XFreePixmap(xw.dpy, xw.buf);
++	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++			xw.depth);
++	XftDrawChange(xw.draw, xw.buf);
++	xclear(0, 0, win.w, win.h);
+ 
+-    /* resize to new width */
+-    xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));
++	/* resize to new width */
++	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec) * 4);
+ }
+ 
+ ushort
+ sixd_to_16bit(int x)
+ {
+-    return x == 0 ? 0 : 0x3737 + 0x2828 * x;
++	return x == 0 ? 0 : 0x3737 + 0x2828 * x;
+ }
+ 
+ int
+ xloadcolor(int i, const char *name, Color *ncolor)
+ {
+-    XRenderColor color = { .alpha = 0xffff };
+-
+-    if (!name) {
+-        if (BETWEEN(i, 16, 255)) { /* 256 color */
+-            if (i < 6*6*6+16) { /* same colors as xterm */
+-                color.red   = sixd_to_16bit( ((i-16)/36)%6 );
+-                color.green = sixd_to_16bit( ((i-16)/6) %6 );
+-                color.blue  = sixd_to_16bit( ((i-16)/1) %6 );
+-            } else { /* greyscale */
+-                color.red = 0x0808 + 0x0a0a * (i - (6*6*6+16));
+-                color.green = color.blue = color.red;
+-            }
+-            return XftColorAllocValue(xw.dpy, xw.vis,
+-                    xw.cmap, &color, ncolor);
+-        } else
+-            name = colorname[i];
+-    }
++	XRenderColor color = { .alpha = 0xffff };
+ 
+-    return XftColorAllocName(xw.dpy, xw.vis, xw.cmap, name, ncolor);
+-}
++	if (!name) {
++		if (BETWEEN(i, 16, 255)) { /* 256 color */
++			if (i < 6*6*6+16) { /* same colors as xterm */
++				color.red   = sixd_to_16bit( ((i-16)/36)%6 );
++				color.green = sixd_to_16bit( ((i-16)/6) %6 );
++				color.blue  = sixd_to_16bit( ((i-16)/1) %6 );
++			} else { /* greyscale */
++				color.red = 0x0808 + 0x0a0a * (i - (6*6*6+16));
++				color.green = color.blue = color.red;
++			}
++			return XftColorAllocValue(xw.dpy, xw.vis,
++			                          xw.cmap, &color, ncolor);
++		} else
++			name = colorname[i];
++	}
+ 
+-void
+-xloadalpha(void)
+-{
+-    float const usedAlpha = focused ? alpha : alphaUnfocus;
+-    if (opt_alpha) alpha = strtof(opt_alpha, NULL);
+-    dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * usedAlpha);
+-    dc.col[defaultbg].pixel &= 0x00FFFFFF;
+-    dc.col[defaultbg].pixel |= (unsigned char)(0xff * usedAlpha) << 24;
++	return XftColorAllocName(xw.dpy, xw.vis, xw.cmap, name, ncolor);
+ }
+ 
+ void
+ xloadcols(void)
+ {
+-    int i;
+-    static int loaded;
+-    Color *cp;
+-
+-    if (!loaded) {
+-        dc.collen = 1 + (defaultbg = MAX(LEN(colorname), 256));
+-        dc.col = xmalloc(dc.collen * sizeof(Color));
+-    }
+-
+-    for (i = 0; i+1 < dc.collen; i++)
+-        if (!xloadcolor(i, NULL, &dc.col[i])) {
+-            if (colorname[i])
+-                die("could not allocate color '%s'\n", colorname[i]);
+-            else
+-                die("could not allocate color %d\n", i);
+-        }
+-
+-    if (dc.collen) // cannot die, as the color is already loaded.
+-        xloadcolor(background, NULL, &dc.col[defaultbg]);
+-
+-    xloadalpha();
+-    loaded = 1;
++	int i;
++	static int loaded;
++	Color *cp;
++
++	if (loaded) {
++		for (cp = dc.col; cp < &dc.col[dc.collen]; ++cp)
++			XftColorFree(xw.dpy, xw.vis, xw.cmap, cp);
++	} else {
++		dc.collen = MAX(LEN(colorname), 256);
++		dc.col = xmalloc(dc.collen * sizeof(Color));
++	}
++
++	for (i = 0; i < dc.collen; i++)
++		if (!xloadcolor(i, NULL, &dc.col[i])) {
++			if (colorname[i])
++				die("could not allocate color '%s'\n", colorname[i]);
++			else
++				die("could not allocate color %d\n", i);
++		}
++
++	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++	dc.col[defaultbg].pixel &= 0x00FFFFFF;
++	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++    dc.col[defaultbg].color.red   *= alpha;
++    dc.col[defaultbg].color.green *= alpha;
++    dc.col[defaultbg].color.blue  *= alpha;
++	loaded = 1;
+ }
+ 
+ int
+ xgetcolor(int x, unsigned char *r, unsigned char *g, unsigned char *b)
+ {
+-    if (!BETWEEN(x, 0, dc.collen - 1))
+-        return 1;
++	if (!BETWEEN(x, 0, dc.collen - 1))
++		return 1;
+ 
+-    *r = dc.col[x].color.red >> 8;
+-    *g = dc.col[x].color.green >> 8;
+-    *b = dc.col[x].color.blue >> 8;
++	*r = dc.col[x].color.red >> 8;
++	*g = dc.col[x].color.green >> 8;
++	*b = dc.col[x].color.blue >> 8;
+ 
+-    return 0;
++	return 0;
+ }
+ 
+ int
+ xsetcolorname(int x, const char *name)
+ {
+-    Color ncolor;
++	Color ncolor;
+ 
+-    if (!BETWEEN(x, 0, dc.collen - 1))
+-        return 1;
++	if (!BETWEEN(x, 0, dc.collen - 1))
++		return 1;
+ 
+-    if (!xloadcolor(x, name, &ncolor))
+-        return 1;
++	if (!xloadcolor(x, name, &ncolor))
++		return 1;
+ 
+-    XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
+-    dc.col[x] = ncolor;
++	XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
++	dc.col[x] = ncolor;
+ 
+-    return 0;
++	if (x == defaultbg) {
++		dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++		dc.col[defaultbg].pixel &= 0x00FFFFFF;
++		dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++        dc.col[defaultbg].color.red   *= alpha;
++        dc.col[defaultbg].color.green *= alpha;
++        dc.col[defaultbg].color.blue  *= alpha;
++	}
++
++	return 0;
+ }
+ 
+ /*
+@@ -908,1471 +890,1552 @@ xsetcolorname(int x, const char *name)
+ void
+ xclear(int x1, int y1, int x2, int y2)
+ {
+-    XftDrawRect(xw.draw,
+-            &dc.col[IS_SET(MODE_REVERSE)? defaultfg : defaultbg],
+-            x1, y1, x2-x1, y2-y1);
++	XftDrawRect(xw.draw,
++			&dc.col[IS_SET(MODE_REVERSE)? defaultfg : defaultbg],
++			x1, y1, x2-x1, y2-y1);
+ }
+ 
+ void
+ xhints(void)
+ {
+-    XClassHint class = {opt_name ? opt_name : "st",
+-        opt_class ? opt_class : "St"};
+-    XWMHints wm = {.flags = InputHint, .input = 1};
+-    XSizeHints *sizeh;
+-
+-    sizeh = XAllocSizeHints();
+-
+-    sizeh->flags = PSize | PResizeInc | PBaseSize | PMinSize;
+-    sizeh->height = win.h;
+-    sizeh->width = win.w;
+-    sizeh->height_inc = win.ch;
+-    sizeh->width_inc = win.cw;
+-    sizeh->base_height = 2 * borderpx;
+-    sizeh->base_width = 2 * borderpx;
+-    sizeh->min_height = win.ch + 2 * borderpx;
+-    sizeh->min_width = win.cw + 2 * borderpx;
+-    if (xw.isfixed) {
+-        sizeh->flags |= PMaxSize;
+-        sizeh->min_width = sizeh->max_width = win.w;
+-        sizeh->min_height = sizeh->max_height = win.h;
+-    }
+-    if (xw.gm & (XValue|YValue)) {
+-        sizeh->flags |= USPosition | PWinGravity;
+-        sizeh->x = xw.l;
+-        sizeh->y = xw.t;
+-        sizeh->win_gravity = xgeommasktogravity(xw.gm);
+-    }
+-
+-    XSetWMProperties(xw.dpy, xw.win, NULL, NULL, NULL, 0, sizeh, &wm,
+-            &class);
+-    XFree(sizeh);
++	XClassHint class = {opt_name ? opt_name : "st",
++	                    opt_class ? opt_class : "St"};
++	XWMHints wm = {.flags = InputHint, .input = 1};
++	XSizeHints *sizeh;
++
++	sizeh = XAllocSizeHints();
++
++	sizeh->flags = PSize | PResizeInc | PBaseSize | PMinSize;
++	sizeh->height = win.h;
++	sizeh->width = win.w;
++	sizeh->height_inc = win.ch;
++	sizeh->width_inc = win.cw;
++	sizeh->base_height = 2 * borderpx;
++	sizeh->base_width = 2 * borderpx;
++	sizeh->min_height = win.ch + 2 * borderpx;
++	sizeh->min_width = win.cw + 2 * borderpx;
++	if (xw.isfixed) {
++		sizeh->flags |= PMaxSize;
++		sizeh->min_width = sizeh->max_width = win.w;
++		sizeh->min_height = sizeh->max_height = win.h;
++	}
++	if (xw.gm & (XValue|YValue)) {
++		sizeh->flags |= USPosition | PWinGravity;
++		sizeh->x = xw.l;
++		sizeh->y = xw.t;
++		sizeh->win_gravity = xgeommasktogravity(xw.gm);
++	}
++
++	XSetWMProperties(xw.dpy, xw.win, NULL, NULL, NULL, 0, sizeh, &wm,
++			&class);
++	XFree(sizeh);
+ }
+ 
+ int
+ xgeommasktogravity(int mask)
+ {
+-    switch (mask & (XNegative|YNegative)) {
+-        case 0:
+-            return NorthWestGravity;
+-        case XNegative:
+-            return NorthEastGravity;
+-        case YNegative:
+-            return SouthWestGravity;
+-    }
++	switch (mask & (XNegative|YNegative)) {
++	case 0:
++		return NorthWestGravity;
++	case XNegative:
++		return NorthEastGravity;
++	case YNegative:
++		return SouthWestGravity;
++	}
+ 
+-    return SouthEastGravity;
++	return SouthEastGravity;
+ }
+ 
+ int
+ xloadfont(Font *f, FcPattern *pattern)
+ {
+-    FcPattern *configured;
+-    FcPattern *match;
+-    FcResult result;
+-    XGlyphInfo extents;
+-    int wantattr, haveattr;
+-
+-    /*
+-     * Manually configure instead of calling XftMatchFont
+-     * so that we can use the configured pattern for
+-     * "missing glyph" lookups.
+-     */
+-    configured = FcPatternDuplicate(pattern);
+-    if (!configured)
+-        return 1;
+-
+-    FcConfigSubstitute(NULL, configured, FcMatchPattern);
+-    XftDefaultSubstitute(xw.dpy, xw.scr, configured);
+-
+-    match = FcFontMatch(NULL, configured, &result);
+-    if (!match) {
+-        FcPatternDestroy(configured);
+-        return 1;
+-    }
+-
+-    if (!(f->match = XftFontOpenPattern(xw.dpy, match))) {
+-        FcPatternDestroy(configured);
+-        FcPatternDestroy(match);
+-        return 1;
+-    }
+-
+-    if ((XftPatternGetInteger(pattern, "slant", 0, &wantattr) ==
+-                XftResultMatch)) {
+-        /*
+-         * Check if xft was unable to find a font with the appropriate
+-         * slant but gave us one anyway. Try to mitigate.
+-         */
+-        if ((XftPatternGetInteger(f->match->pattern, "slant", 0,
+-                        &haveattr) != XftResultMatch) || haveattr < wantattr) {
+-            f->badslant = 1;
+-            fputs("font slant does not match\n", stderr);
+-        }
+-    }
+-
+-    if ((XftPatternGetInteger(pattern, "weight", 0, &wantattr) ==
+-                XftResultMatch)) {
+-        if ((XftPatternGetInteger(f->match->pattern, "weight", 0,
+-                        &haveattr) != XftResultMatch) || haveattr != wantattr) {
+-            // Uncomment the following line for debian / if colors are off in terminal
+-            f->badweight = 1;
+-            fputs("font weight does not match\n", stderr);
+-        }
+-    }
+-
+-    XftTextExtentsUtf8(xw.dpy, f->match,
+-            (const FcChar8 *) ascii_printable,
+-            strlen(ascii_printable), &extents);
+-
+-    f->set = NULL;
+-    f->pattern = configured;
+-
+-    f->ascent = f->match->ascent;
+-    f->descent = f->match->descent;
+-    f->lbearing = 0;
+-    f->rbearing = f->match->max_advance_width;
+-
+-    f->height = f->ascent + f->descent;
+-    f->width = DIVCEIL(extents.xOff, strlen(ascii_printable));
+-
+-    return 0;
++	FcPattern *configured;
++	FcPattern *match;
++	FcResult result;
++	XGlyphInfo extents;
++	int wantattr, haveattr;
++
++	/*
++	 * Manually configure instead of calling XftMatchFont
++	 * so that we can use the configured pattern for
++	 * "missing glyph" lookups.
++	 */
++	configured = FcPatternDuplicate(pattern);
++	if (!configured)
++		return 1;
++
++	FcConfigSubstitute(NULL, configured, FcMatchPattern);
++	XftDefaultSubstitute(xw.dpy, xw.scr, configured);
++
++	match = FcFontMatch(NULL, configured, &result);
++	if (!match) {
++		FcPatternDestroy(configured);
++		return 1;
++	}
++
++	if (!(f->match = XftFontOpenPattern(xw.dpy, match))) {
++		FcPatternDestroy(configured);
++		FcPatternDestroy(match);
++		return 1;
++	}
++
++	if ((XftPatternGetInteger(pattern, "slant", 0, &wantattr) ==
++	    XftResultMatch)) {
++		/*
++		 * Check if xft was unable to find a font with the appropriate
++		 * slant but gave us one anyway. Try to mitigate.
++		 */
++		if ((XftPatternGetInteger(f->match->pattern, "slant", 0,
++		    &haveattr) != XftResultMatch) || haveattr < wantattr) {
++			f->badslant = 1;
++			fputs("font slant does not match\n", stderr);
++		}
++	}
++
++	if ((XftPatternGetInteger(pattern, "weight", 0, &wantattr) ==
++	    XftResultMatch)) {
++		if ((XftPatternGetInteger(f->match->pattern, "weight", 0,
++		    &haveattr) != XftResultMatch) || haveattr != wantattr) {
++			f->badweight = 1;
++			fputs("font weight does not match\n", stderr);
++		}
++	}
++
++	XftTextExtentsUtf8(xw.dpy, f->match,
++		(const FcChar8 *) ascii_printable,
++		strlen(ascii_printable), &extents);
++
++	f->set = NULL;
++	f->pattern = configured;
++
++	f->ascent = f->match->ascent;
++	f->descent = f->match->descent;
++	f->lbearing = 0;
++	f->rbearing = f->match->max_advance_width;
++
++	f->height = f->ascent + f->descent;
++	f->width = DIVCEIL(extents.xOff, strlen(ascii_printable));
++
++	return 0;
+ }
+ 
+ void
+ xloadfonts(const char *fontstr, double fontsize)
+ {
+-    FcPattern *pattern;
+-    double fontval;
+-
+-    if (fontstr[0] == '-')
+-        pattern = XftXlfdParse(fontstr, False, False);
+-    else
+-        pattern = FcNameParse((const FcChar8 *)fontstr);
+-
+-    if (!pattern)
+-        die("can't open font %s\n", fontstr);
+-
+-    if (fontsize > 1) {
+-        FcPatternDel(pattern, FC_PIXEL_SIZE);
+-        FcPatternDel(pattern, FC_SIZE);
+-        FcPatternAddDouble(pattern, FC_PIXEL_SIZE, (double)fontsize);
+-        usedfontsize = fontsize;
+-    } else {
+-        if (FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
+-                FcResultMatch) {
+-            usedfontsize = fontval;
+-        } else if (FcPatternGetDouble(pattern, FC_SIZE, 0, &fontval) ==
+-                FcResultMatch) {
+-            usedfontsize = -1;
+-        } else {
+-            /*
+-             * Default font size is 12, if none given. This is to
+-             * have a known usedfontsize value.
+-             */
+-            FcPatternAddDouble(pattern, FC_PIXEL_SIZE, 12);
+-            usedfontsize = 12;
+-        }
+-        defaultfontsize = usedfontsize;
+-    }
+-
+-    if (xloadfont(&dc.font, pattern))
+-        die("can't open font %s\n", fontstr);
+-
+-    if (usedfontsize < 0) {
+-        FcPatternGetDouble(dc.font.match->pattern,
+-                FC_PIXEL_SIZE, 0, &fontval);
+-        usedfontsize = fontval;
+-        if (fontsize == 0)
+-            defaultfontsize = fontval;
+-    }
+-
+-    /* Setting character width and height. */
+-    win.cw = ceilf(dc.font.width * cwscale);
+-    win.ch = ceilf(dc.font.height * chscale);
+-
+-    FcPatternDel(pattern, FC_SLANT);
+-    FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
+-    if (xloadfont(&dc.ifont, pattern))
+-        die("can't open font %s\n", fontstr);
+-
+-    FcPatternDel(pattern, FC_WEIGHT);
+-    FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+-    if (xloadfont(&dc.ibfont, pattern))
+-        die("can't open font %s\n", fontstr);
+-
+-    FcPatternDel(pattern, FC_SLANT);
+-    FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
+-    if (xloadfont(&dc.bfont, pattern))
+-        die("can't open font %s\n", fontstr);
+-
+-    FcPatternDestroy(pattern);
++	FcPattern *pattern;
++	double fontval;
++
++	if (fontstr[0] == '-')
++		pattern = XftXlfdParse(fontstr, False, False);
++	else
++		pattern = FcNameParse((const FcChar8 *)fontstr);
++
++	if (!pattern)
++		die("can't open font %s\n", fontstr);
++
++	if (fontsize > 1) {
++		FcPatternDel(pattern, FC_PIXEL_SIZE);
++		FcPatternDel(pattern, FC_SIZE);
++		FcPatternAddDouble(pattern, FC_PIXEL_SIZE, (double)fontsize);
++		usedfontsize = fontsize;
++	} else {
++		if (FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
++				FcResultMatch) {
++			usedfontsize = fontval;
++		} else if (FcPatternGetDouble(pattern, FC_SIZE, 0, &fontval) ==
++				FcResultMatch) {
++			usedfontsize = -1;
++		} else {
++			/*
++			 * Default font size is 12, if none given. This is to
++			 * have a known usedfontsize value.
++			 */
++			FcPatternAddDouble(pattern, FC_PIXEL_SIZE, 12);
++			usedfontsize = 12;
++		}
++		defaultfontsize = usedfontsize;
++	}
++
++	if (xloadfont(&dc.font, pattern))
++		die("can't open font %s\n", fontstr);
++
++	if (usedfontsize < 0) {
++		FcPatternGetDouble(dc.font.match->pattern,
++		                   FC_PIXEL_SIZE, 0, &fontval);
++		usedfontsize = fontval;
++		if (fontsize == 0)
++			defaultfontsize = fontval;
++	}
++
++	/* Setting character width and height. */
++	win.cw = ceilf(dc.font.width * cwscale);
++	win.ch = ceilf(dc.font.height * chscale);
++
++	FcPatternDel(pattern, FC_SLANT);
++	FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
++	if (xloadfont(&dc.ifont, pattern))
++		die("can't open font %s\n", fontstr);
++
++	FcPatternDel(pattern, FC_WEIGHT);
++	FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
++	if (xloadfont(&dc.ibfont, pattern))
++		die("can't open font %s\n", fontstr);
++
++	FcPatternDel(pattern, FC_SLANT);
++	FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
++	if (xloadfont(&dc.bfont, pattern))
++		die("can't open font %s\n", fontstr);
++
++	FcPatternDestroy(pattern);
+ }
+ 
+ int
+ xloadsparefont(FcPattern *pattern, int flags)
+ {
+-    FcPattern *match;
+-    FcResult result;
++	FcPattern *match;
++	FcResult result;
+ 
+-    match = FcFontMatch(NULL, pattern, &result);
+-    if (!match) {
+-        return 1;
+-    }
++	match = FcFontMatch(NULL, pattern, &result);
++	if (!match) {
++		return 1;
++	}
+ 
+-    if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
+-        FcPatternDestroy(match);
+-        return 1;
+-    }
++	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
++		FcPatternDestroy(match);
++		return 1;
++	}
+ 
+-    frc[frclen].flags = flags;
+-    /* Believe U+0000 glyph will present in each default font */
+-    frc[frclen].unicodep = 0;
+-    frclen++;
++	frc[frclen].flags = flags;
++	/* Believe U+0000 glyph will present in each default font */
++	frc[frclen].unicodep = 0;
++	frclen++;
+ 
+-    return 0;
++	return 0;
+ }
+ 
+ void
+ xloadsparefonts(void)
+ {
+-    FcPattern *pattern;
+-    double sizeshift, fontval;
+-    int fc;
+-    char **fp;
++	FcPattern *pattern;
++	double sizeshift, fontval;
++	int fc;
++	char **fp;
+ 
+-    if (frclen != 0)
+-        die("can't embed spare fonts. cache isn't empty");
++	if (frclen != 0)
++		die("can't embed spare fonts. cache isn't empty");
+ 
+-    /* Calculate count of spare fonts */
+-    fc = sizeof(font2) / sizeof(*font2);
+-    if (fc == 0)
+-        return;
++	/* Calculate count of spare fonts */
++	fc = sizeof(font2) / sizeof(*font2);
++	if (fc == 0)
++		return;
+ 
+-    /* Allocate memory for cache entries. */
+-    if (frccap < 4 * fc) {
+-        frccap += 4 * fc - frccap;
+-        frc = xrealloc(frc, frccap * sizeof(Fontcache));
+-    }
++	/* Allocate memory for cache entries. */
++	if (frccap < 4 * fc) {
++		frccap += 4 * fc - frccap;
++		frc = xrealloc(frc, frccap * sizeof(Fontcache));
++	}
+ 
+-    for (fp = font2; fp - font2 < fc; ++fp) {
++	for (fp = font2; fp - font2 < fc; ++fp) {
+ 
+-        if (**fp == '-')
+-            pattern = XftXlfdParse(*fp, False, False);
+-        else
+-            pattern = FcNameParse((FcChar8 *)*fp);
++		if (**fp == '-')
++			pattern = XftXlfdParse(*fp, False, False);
++		else
++			pattern = FcNameParse((FcChar8 *)*fp);
+ 
+-        if (!pattern)
+-            die("can't open spare font %s\n", *fp);
++		if (!pattern)
++			die("can't open spare font %s\n", *fp);
+ 
+-        if (defaultfontsize > 0) {
+-            sizeshift = usedfontsize - defaultfontsize;
+-            if (sizeshift != 0 &&
+-                    FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
+-                    FcResultMatch) {
+-                fontval += sizeshift;
+-                FcPatternDel(pattern, FC_PIXEL_SIZE);
+-                FcPatternDel(pattern, FC_SIZE);
+-                FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
+-            }
+-        }
++		if (defaultfontsize > 0) {
++			sizeshift = usedfontsize - defaultfontsize;
++			if (sizeshift != 0 &&
++					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
++					FcResultMatch) {
++				fontval += sizeshift;
++				FcPatternDel(pattern, FC_PIXEL_SIZE);
++				FcPatternDel(pattern, FC_SIZE);
++				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
++			}
++		}
+ 
+-        FcPatternAddBool(pattern, FC_SCALABLE, 1);
++		FcPatternAddBool(pattern, FC_SCALABLE, 1);
+ 
+-        FcConfigSubstitute(NULL, pattern, FcMatchPattern);
+-        XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
++		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
++		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
+ 
+-        if (xloadsparefont(pattern, FRC_NORMAL))
+-            die("can't open spare font %s\n", *fp);
++		if (xloadsparefont(pattern, FRC_NORMAL))
++			die("can't open spare font %s\n", *fp);
+ 
+-        FcPatternDel(pattern, FC_SLANT);
+-        FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
+-        if (xloadsparefont(pattern, FRC_ITALIC))
+-            die("can't open spare font %s\n", *fp);
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
++		if (xloadsparefont(pattern, FRC_ITALIC))
++			die("can't open spare font %s\n", *fp);
+ 
+-        FcPatternDel(pattern, FC_WEIGHT);
+-        FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+-        if (xloadsparefont(pattern, FRC_ITALICBOLD))
+-            die("can't open spare font %s\n", *fp);
++		FcPatternDel(pattern, FC_WEIGHT);
++		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
++		if (xloadsparefont(pattern, FRC_ITALICBOLD))
++			die("can't open spare font %s\n", *fp);
+ 
+-        FcPatternDel(pattern, FC_SLANT);
+-        FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
+-        if (xloadsparefont(pattern, FRC_BOLD))
+-            die("can't open spare font %s\n", *fp);
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
++		if (xloadsparefont(pattern, FRC_BOLD))
++			die("can't open spare font %s\n", *fp);
+ 
+-        FcPatternDestroy(pattern);
+-    }
++		FcPatternDestroy(pattern);
++	}
+ }
+ 
+ void
+ xunloadfont(Font *f)
+ {
+-    XftFontClose(xw.dpy, f->match);
+-    FcPatternDestroy(f->pattern);
+-    if (f->set)
+-        FcFontSetDestroy(f->set);
++	XftFontClose(xw.dpy, f->match);
++	FcPatternDestroy(f->pattern);
++	if (f->set)
++		FcFontSetDestroy(f->set);
+ }
+ 
+ void
+ xunloadfonts(void)
+ {
+-    /* Clear Harfbuzz font cache. */
+-    hbunloadfonts();
++	/* Clear Harfbuzz font cache. */
++	hbunloadfonts();
+ 
+-    /* Free the loaded fonts in the font cache.  */
+-    while (frclen > 0)
+-        XftFontClose(xw.dpy, frc[--frclen].font);
++	/* Free the loaded fonts in the font cache.  */
++	while (frclen > 0)
++		XftFontClose(xw.dpy, frc[--frclen].font);
+ 
+-    xunloadfont(&dc.font);
+-    xunloadfont(&dc.bfont);
+-    xunloadfont(&dc.ifont);
+-    xunloadfont(&dc.ibfont);
++	xunloadfont(&dc.font);
++	xunloadfont(&dc.bfont);
++	xunloadfont(&dc.ifont);
++	xunloadfont(&dc.ibfont);
+ }
+ 
+ int
+ ximopen(Display *dpy)
+ {
+-    XIMCallback imdestroy = { .client_data = NULL, .callback = ximdestroy };
+-    XICCallback icdestroy = { .client_data = NULL, .callback = xicdestroy };
++	XIMCallback imdestroy = { .client_data = NULL, .callback = ximdestroy };
++	XICCallback icdestroy = { .client_data = NULL, .callback = xicdestroy };
+ 
+-    xw.ime.xim = XOpenIM(xw.dpy, NULL, NULL, NULL);
+-    if (xw.ime.xim == NULL)
+-        return 0;
++	xw.ime.xim = XOpenIM(xw.dpy, NULL, NULL, NULL);
++	if (xw.ime.xim == NULL)
++		return 0;
+ 
+-    if (XSetIMValues(xw.ime.xim, XNDestroyCallback, &imdestroy, NULL))
+-        fprintf(stderr, "XSetIMValues: "
+-                "Could not set XNDestroyCallback.\n");
++	if (XSetIMValues(xw.ime.xim, XNDestroyCallback, &imdestroy, NULL))
++		fprintf(stderr, "XSetIMValues: "
++		                "Could not set XNDestroyCallback.\n");
+ 
+-    xw.ime.spotlist = XVaCreateNestedList(0, XNSpotLocation, &xw.ime.spot,
+-            NULL);
++	xw.ime.spotlist = XVaCreateNestedList(0, XNSpotLocation, &xw.ime.spot,
++	                                      NULL);
+ 
+-    if (xw.ime.xic == NULL) {
+-        xw.ime.xic = XCreateIC(xw.ime.xim, XNInputStyle,
+-                XIMPreeditNothing | XIMStatusNothing,
+-                XNClientWindow, xw.win,
+-                XNDestroyCallback, &icdestroy,
+-                NULL);
+-    }
+-    if (xw.ime.xic == NULL)
+-        fprintf(stderr, "XCreateIC: Could not create input context.\n");
++	if (xw.ime.xic == NULL) {
++		xw.ime.xic = XCreateIC(xw.ime.xim, XNInputStyle,
++		                       XIMPreeditNothing | XIMStatusNothing,
++		                       XNClientWindow, xw.win,
++		                       XNDestroyCallback, &icdestroy,
++		                       NULL);
++	}
++	if (xw.ime.xic == NULL)
++		fprintf(stderr, "XCreateIC: Could not create input context.\n");
+ 
+-    return 1;
++	return 1;
+ }
+ 
+ void
+ ximinstantiate(Display *dpy, XPointer client, XPointer call)
+ {
+-    if (ximopen(dpy))
+-        XUnregisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
+-                ximinstantiate, NULL);
++	if (ximopen(dpy))
++		XUnregisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
++		                                 ximinstantiate, NULL);
+ }
+ 
+ void
+ ximdestroy(XIM xim, XPointer client, XPointer call)
+ {
+-    xw.ime.xim = NULL;
+-    XRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
+-            ximinstantiate, NULL);
+-    XFree(xw.ime.spotlist);
++	xw.ime.xim = NULL;
++	XRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
++	                               ximinstantiate, NULL);
++	XFree(xw.ime.spotlist);
+ }
+ 
+ int
+ xicdestroy(XIC xim, XPointer client, XPointer call)
+ {
+-    xw.ime.xic = NULL;
+-    return 1;
++	xw.ime.xic = NULL;
++	return 1;
+ }
+ 
+ void
+ xinit(int cols, int rows)
+ {
+-    XGCValues gcvalues;
+-    Cursor cursor;
+-    Window parent;
+-    pid_t thispid = getpid();
+-    XColor xmousefg, xmousebg;
+-    XWindowAttributes attr;
+-    XVisualInfo vis;
+-
+-    xw.scr = XDefaultScreen(xw.dpy);
+-
+-    if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0)))) {
+-        parent = XRootWindow(xw.dpy, xw.scr);
+-        xw.depth = 32;
+-    } else {
+-        XGetWindowAttributes(xw.dpy, parent, &attr);
+-        xw.depth = attr.depth;
+-    }
+-
+-    XMatchVisualInfo(xw.dpy, xw.scr, xw.depth, TrueColor, &vis);
+-    xw.vis = vis.visual;
+-
+-    /* font */
+-    if (!FcInit())
+-        die("could not init fontconfig.\n");
+-
+-    usedfont = (opt_font == NULL)? font : opt_font;
+-    xloadfonts(usedfont, 0);
+-
+-    /* spare fonts */
+-    xloadsparefonts();
+-
+-    /* colors */
+-    xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
+-    xloadcols();
+-
+-    /* adjust fixed window geometry */
+-    win.w = 2 * borderpx + cols * win.cw;
+-    win.h = 2 * borderpx + rows * win.ch;
+-    if (xw.gm & XNegative)
+-        xw.l += DisplayWidth(xw.dpy, xw.scr) - win.w - 2;
+-    if (xw.gm & YNegative)
+-        xw.t += DisplayHeight(xw.dpy, xw.scr) - win.h - 2;
+-
+-    /* Events */
+-    xw.attrs.background_pixel = dc.col[defaultbg].pixel;
+-    xw.attrs.border_pixel = dc.col[defaultbg].pixel;
+-    xw.attrs.bit_gravity = NorthWestGravity;
+-    xw.attrs.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask
+-        | ExposureMask | VisibilityChangeMask | StructureNotifyMask
+-        | ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
+-    xw.attrs.colormap = xw.cmap;
+-
+-    xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
+-            win.w, win.h, 0, xw.depth, InputOutput,
+-            xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
+-            | CWEventMask | CWColormap, &xw.attrs);
+-
+-    memset(&gcvalues, 0, sizeof(gcvalues));
+-    gcvalues.graphics_exposures = False;
+-    xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h, xw.depth);
+-    dc.gc = XCreateGC(xw.dpy, xw.buf, GCGraphicsExposures, &gcvalues);
+-    XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
+-    XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
+-
+-    /* font spec buffer */
+-    xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));
+-
+-    /* Xft rendering context */
+-    xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
+-
+-    /* input methods */
+-    if (!ximopen(xw.dpy)) {
+-        XRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
+-                ximinstantiate, NULL);
+-    }
+-
+-    /* white cursor, black outline */
+-    cursor = XCreateFontCursor(xw.dpy, mouseshape);
+-    XDefineCursor(xw.dpy, xw.win, cursor);
+-
+-    if (XParseColor(xw.dpy, xw.cmap, colorname[mousefg], &xmousefg) == 0) {
+-        xmousefg.red   = 0xffff;
+-        xmousefg.green = 0xffff;
+-        xmousefg.blue  = 0xffff;
+-    }
+-
+-    if (XParseColor(xw.dpy, xw.cmap, colorname[mousebg], &xmousebg) == 0) {
+-        xmousebg.red   = 0x0000;
+-        xmousebg.green = 0x0000;
+-        xmousebg.blue  = 0x0000;
+-    }
+-
+-    XRecolorCursor(xw.dpy, cursor, &xmousefg, &xmousebg);
+-
+-    xw.xembed = XInternAtom(xw.dpy, "_XEMBED", False);
+-    xw.wmdeletewin = XInternAtom(xw.dpy, "WM_DELETE_WINDOW", False);
+-    xw.netwmname = XInternAtom(xw.dpy, "_NET_WM_NAME", False);
+-    xw.netwmiconname = XInternAtom(xw.dpy, "_NET_WM_ICON_NAME", False);
+-    XSetWMProtocols(xw.dpy, xw.win, &xw.wmdeletewin, 1);
+-
+-    xw.netwmpid = XInternAtom(xw.dpy, "_NET_WM_PID", False);
+-    XChangeProperty(xw.dpy, xw.win, xw.netwmpid, XA_CARDINAL, 32,
+-            PropModeReplace, (uchar *)&thispid, 1);
+-
+-    win.mode = MODE_NUMLOCK;
+-    resettitle();
+-    xhints();
+-    XMapWindow(xw.dpy, xw.win);
+-    XSync(xw.dpy, False);
+-
+-    clock_gettime(CLOCK_MONOTONIC, &xsel.tclick1);
+-    clock_gettime(CLOCK_MONOTONIC, &xsel.tclick2);
+-    xsel.primary = NULL;
+-    xsel.clipboard = NULL;
+-    xsel.xtarget = XInternAtom(xw.dpy, "UTF8_STRING", 0);
+-    if (xsel.xtarget == None)
+-        xsel.xtarget = XA_STRING;
++	XGCValues gcvalues;
++	Cursor cursor;
++	Window parent, root;
++	pid_t thispid = getpid();
++	XColor xmousefg, xmousebg;
++	XWindowAttributes attr;
++	XVisualInfo vis;
++
++	xw.scr = XDefaultScreen(xw.dpy);
++
++	root = XRootWindow(xw.dpy, xw.scr);
++	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
++		parent = root;
++
++	if (XMatchVisualInfo(xw.dpy, xw.scr, 32, TrueColor, &vis) != 0) {
++		xw.vis = vis.visual;
++		xw.depth = vis.depth;
++	} else {
++		XGetWindowAttributes(xw.dpy, parent, &attr);
++		xw.vis = attr.visual;
++		xw.depth = attr.depth;
++	}
++
++	/* font */
++	if (!FcInit())
++		die("could not init fontconfig.\n");
++
++	usedfont = (opt_font == NULL)? font : opt_font;
++	xloadfonts(usedfont, 0);
++
++	/* spare fonts */
++	xloadsparefonts();
++
++   /* Backup default alpha value */
++   //alpha_def = alpha;
++
++	/* colors */
++	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
++	xloadcols();
++
++	/* adjust fixed window geometry */
++	win.w = 2 * borderpx + cols * win.cw;
++	win.h = 2 * borderpx + rows * win.ch;
++	if (xw.gm & XNegative)
++		xw.l += DisplayWidth(xw.dpy, xw.scr) - win.w - 2;
++	if (xw.gm & YNegative)
++		xw.t += DisplayHeight(xw.dpy, xw.scr) - win.h - 2;
++
++	/* Events */
++	xw.attrs.background_pixel = dc.col[defaultbg].pixel;
++	xw.attrs.border_pixel = dc.col[defaultbg].pixel;
++	xw.attrs.bit_gravity = NorthWestGravity;
++	xw.attrs.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask
++		| ExposureMask | VisibilityChangeMask | StructureNotifyMask
++		| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
++	xw.attrs.colormap = xw.cmap;
++
++	xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
++			win.w, win.h, 0, xw.depth, InputOutput,
++			xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
++			| CWEventMask | CWColormap, &xw.attrs);
++	if (parent != root)
++		XReparentWindow(xw.dpy, xw.win, parent, xw.l, xw.t);
++
++	memset(&gcvalues, 0, sizeof(gcvalues));
++	gcvalues.graphics_exposures = False;
++	dc.gc = XCreateGC(xw.dpy, xw.win, GCGraphicsExposures,
++			&gcvalues);
++	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++			xw.depth);
++	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
++	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
++
++	/* font spec buffer */
++	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec) * 4);
++
++	/* Xft rendering context */
++	xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
++
++	/* input methods */
++	if (!ximopen(xw.dpy)) {
++		XRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,
++	                                       ximinstantiate, NULL);
++	}
++
++	/* white cursor, black outline */
++	cursor = XCreateFontCursor(xw.dpy, mouseshape);
++	XDefineCursor(xw.dpy, xw.win, cursor);
++
++	if (XParseColor(xw.dpy, xw.cmap, colorname[mousefg], &xmousefg) == 0) {
++		xmousefg.red   = 0xffff;
++		xmousefg.green = 0xffff;
++		xmousefg.blue  = 0xffff;
++	}
++
++	if (XParseColor(xw.dpy, xw.cmap, colorname[mousebg], &xmousebg) == 0) {
++		xmousebg.red   = 0x0000;
++		xmousebg.green = 0x0000;
++		xmousebg.blue  = 0x0000;
++	}
++
++	XRecolorCursor(xw.dpy, cursor, &xmousefg, &xmousebg);
++
++	xw.xembed = XInternAtom(xw.dpy, "_XEMBED", False);
++	xw.wmdeletewin = XInternAtom(xw.dpy, "WM_DELETE_WINDOW", False);
++	xw.netwmname = XInternAtom(xw.dpy, "_NET_WM_NAME", False);
++	xw.netwmiconname = XInternAtom(xw.dpy, "_NET_WM_ICON_NAME", False);
++	XSetWMProtocols(xw.dpy, xw.win, &xw.wmdeletewin, 1);
++
++	xw.netwmpid = XInternAtom(xw.dpy, "_NET_WM_PID", False);
++	XChangeProperty(xw.dpy, xw.win, xw.netwmpid, XA_CARDINAL, 32,
++			PropModeReplace, (uchar *)&thispid, 1);
++
++	win.mode = MODE_NUMLOCK;
++	resettitle();
++	xhints();
++	XMapWindow(xw.dpy, xw.win);
++	XSync(xw.dpy, False);
++
++	clock_gettime(CLOCK_MONOTONIC, &xsel.tclick1);
++	clock_gettime(CLOCK_MONOTONIC, &xsel.tclick2);
++	xsel.primary = NULL;
++	xsel.clipboard = NULL;
++	xsel.xtarget = XInternAtom(xw.dpy, "UTF8_STRING", 0);
++	if (xsel.xtarget == None)
++		xsel.xtarget = XA_STRING;
++}
+ 
+-    boxdraw_xinit(xw.dpy, xw.cmap, xw.draw, xw.vis);
++void
++xresetfontsettings(ushort mode, Font **font, int *frcflags)
++{
++	*font = &dc.font;
++	if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
++		*font = &dc.ibfont;
++		*frcflags = FRC_ITALICBOLD;
++	} else if (mode & ATTR_ITALIC) {
++		*font = &dc.ifont;
++		*frcflags = FRC_ITALIC;
++	} else if (mode & ATTR_BOLD) {
++		*font = &dc.bfont;
++		*frcflags = FRC_BOLD;
++	}
+ }
+ 
+ int
+ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
+ {
+-    float winx = borderpx + x * win.cw, winy = borderpx + y * win.ch, xp, yp;
+-    ushort mode, prevmode = USHRT_MAX;
+-    Font *font = &dc.font;
+-    int frcflags = FRC_NORMAL;
+-    float runewidth = win.cw;
+-    Rune rune;
+-    FT_UInt glyphidx;
+-    FcResult fcres;
+-    FcPattern *fcpattern, *fontpattern;
+-    FcFontSet *fcsets[] = { NULL };
+-    FcCharSet *fccharset;
+-    int i, f, numspecs = 0;
+-
+-    for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
+-        /* Fetch rune and mode for current glyph. */
+-        rune = glyphs[i].u;
+-        mode = glyphs[i].mode;
+-
+-        /* Skip dummy wide-character spacing. */
+-        if (mode & ATTR_WDUMMY)
+-            continue;
+-
+-        /* Determine font for glyph if different from previous glyph. */
+-        if (prevmode != mode) {
+-            prevmode = mode;
+-            font = &dc.font;
+-            frcflags = FRC_NORMAL;
+-            runewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);
+-            if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
+-                font = &dc.ibfont;
+-                frcflags = FRC_ITALICBOLD;
+-            } else if (mode & ATTR_ITALIC) {
+-                font = &dc.ifont;
+-                frcflags = FRC_ITALIC;
+-            } else if (mode & ATTR_BOLD) {
+-                font = &dc.bfont;
+-                frcflags = FRC_BOLD;
+-            }
+-            yp = winy + font->ascent;
+-        }
+-
+-        if (mode & ATTR_BOXDRAW) {
+-            /* minor shoehorning: boxdraw uses only this ushort */
+-            glyphidx = boxdrawindex(&glyphs[i]);
+-        } else {
+-            /* Lookup character index with default font. */
+-            glyphidx = XftCharIndex(xw.dpy, font->match, rune);
+-        }
+-        if (glyphidx) {
+-            specs[numspecs].font = font->match;
+-            specs[numspecs].glyph = glyphidx;
+-            specs[numspecs].x = (short)xp;
+-            specs[numspecs].y = (short)yp;
+-            xp += runewidth;
+-            numspecs++;
+-            continue;
+-        }
+-
+-        /* Fallback on font cache, search the font cache for match. */
+-        for (f = 0; f < frclen; f++) {
+-            glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
+-            /* Everything correct. */
+-            if (glyphidx && frc[f].flags == frcflags)
+-                break;
+-            /* We got a default font for a not found glyph. */
+-            if (!glyphidx && frc[f].flags == frcflags
+-                    && frc[f].unicodep == rune) {
+-                break;
+-            }
+-        }
+-
+-        /* Nothing was found. Use fontconfig to find matching font. */
+-        if (f >= frclen) {
+-            if (!font->set)
+-                font->set = FcFontSort(0, font->pattern,
+-                        1, 0, &fcres);
+-            fcsets[0] = font->set;
+-
+-            /*
+-             * Nothing was found in the cache. Now use
+-             * some dozen of Fontconfig calls to get the
+-             * font for one single character.
+-             *
+-             * Xft and fontconfig are design failures.
+-             */
+-            fcpattern = FcPatternDuplicate(font->pattern);
+-            fccharset = FcCharSetCreate();
+-
+-            FcCharSetAddChar(fccharset, rune);
+-            FcPatternAddCharSet(fcpattern, FC_CHARSET,
+-                    fccharset);
+-            FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
+-
+-            FcConfigSubstitute(0, fcpattern,
+-                    FcMatchPattern);
+-            FcDefaultSubstitute(fcpattern);
+-
+-            fontpattern = FcFontSetMatch(0, fcsets, 1,
+-                    fcpattern, &fcres);
+-
+-            /* Allocate memory for the new cache entry. */
+-            if (frclen >= frccap) {
+-                frccap += 16;
+-                frc = xrealloc(frc, frccap * sizeof(Fontcache));
+-            }
+-
+-            frc[frclen].font = XftFontOpenPattern(xw.dpy,
+-                    fontpattern);
+-            if (!frc[frclen].font)
+-                die("XftFontOpenPattern failed seeking fallback font: %s\n",
+-                        strerror(errno));
+-            frc[frclen].flags = frcflags;
+-            frc[frclen].unicodep = rune;
+-
+-            glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
+-
+-            f = frclen;
+-            frclen++;
+-
+-            FcPatternDestroy(fcpattern);
+-            FcCharSetDestroy(fccharset);
+-        }
+-
+-        specs[numspecs].font = frc[f].font;
+-        specs[numspecs].glyph = glyphidx;
+-        specs[numspecs].x = (short)xp;
+-        specs[numspecs].y = (short)yp;
+-        xp += runewidth;
+-        numspecs++;
++	float winx = borderpx + x * win.cw, winy = borderpx + y * win.ch, xp, yp;
++	ushort mode, prevmode = USHRT_MAX;
++	Font *font = &dc.font;
++	int frcflags = FRC_NORMAL;
++	float runewidth = win.cw;
++	Rune rune;
++	FT_UInt glyphidx;
++	FcResult fcres;
++	FcPattern *fcpattern, *fontpattern;
++	FcFontSet *fcsets[] = { NULL };
++	FcCharSet *fccharset;
++	int i, f, length = 0, start = 0, numspecs = 0;
++	float cluster_xp = xp, cluster_yp = yp;
++	HbTransformData shaped = { 0 };
++
++	/* Initial values. */
++	mode = prevmode = glyphs[0].mode & ~ATTR_WRAP;
++	xresetfontsettings(mode, &font, &frcflags);
++
++	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
++		mode = glyphs[i].mode & ~ATTR_WRAP;
++
++		/* Skip dummy wide-character spacing. */
++		if (mode & ATTR_WDUMMY && i < (len - 1))
++			continue;
++
++		if (
++			prevmode != mode
++			|| ATTRCMP(glyphs[start], glyphs[i])
++			|| selected(x + i, y) != selected(x + start, y)
++			|| i == (len - 1)
++		) {
++			/* Handle 1-character wide segments and end of line */
++			length = i - start;
++			if (i == start) {
++				length = 1;
++			} else if (i == (len - 1)) {
++				length = (i - start + 1);
++			}
++
++			/* Shape the segment. */
++			hbtransform(&shaped, font->match, glyphs, start, length);
++			runewidth = win.cw * ((glyphs[start].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++			cluster_xp = xp; cluster_yp = yp;
++			for (int code_idx = 0; code_idx < shaped.count; code_idx++) {
++				int idx = shaped.glyphs[code_idx].cluster;
++
++				if (glyphs[start + idx].mode & ATTR_WDUMMY)
++					continue;
++
++				/* Advance the drawing cursor if we've moved to a new cluster */
++				if (code_idx > 0 && idx != shaped.glyphs[code_idx - 1].cluster) {
++					xp += runewidth;
++					cluster_xp = xp;
++					cluster_yp = yp;
++					runewidth = win.cw * ((glyphs[start + idx].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++				}
++
++				if (shaped.glyphs[code_idx].codepoint != 0) {
++					/* If symbol is found, put it into the specs. */
++					specs[numspecs].font = font->match;
++					specs[numspecs].glyph = shaped.glyphs[code_idx].codepoint;
++					specs[numspecs].x = cluster_xp + (short)(shaped.positions[code_idx].x_offset / 64.);
++					specs[numspecs].y = cluster_yp - (short)(shaped.positions[code_idx].y_offset / 64.);
++					cluster_xp += shaped.positions[code_idx].x_advance / 64.;
++					cluster_yp += shaped.positions[code_idx].y_advance / 64.;
++					numspecs++;
++				} else {
++					/* If it's not found, try to fetch it through the font cache. */
++					rune = glyphs[start + idx].u;
++					for (f = 0; f < frclen; f++) {
++						glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
++						/* Everything correct. */
++						if (glyphidx && frc[f].flags == frcflags)
++							break;
++						/* We got a default font for a not found glyph. */
++						if (!glyphidx && frc[f].flags == frcflags
++								&& frc[f].unicodep == rune) {
++							break;
++						}
++					}
++
++					/* Nothing was found. Use fontconfig to find matching font. */
++					if (f >= frclen) {
++						if (!font->set)
++							font->set = FcFontSort(0, font->pattern,
++																		 1, 0, &fcres);
++						fcsets[0] = font->set;
++
++						/*
++						 * Nothing was found in the cache. Now use
++						 * some dozen of Fontconfig calls to get the
++						 * font for one single character.
++						 *
++						 * Xft and fontconfig are design failures.
++						 */
++						fcpattern = FcPatternDuplicate(font->pattern);
++						fccharset = FcCharSetCreate();
++
++						FcCharSetAddChar(fccharset, rune);
++						FcPatternAddCharSet(fcpattern, FC_CHARSET,
++								fccharset);
++						FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
++
++						FcConfigSubstitute(0, fcpattern,
++								FcMatchPattern);
++						FcDefaultSubstitute(fcpattern);
++
++						fontpattern = FcFontSetMatch(0, fcsets, 1,
++								fcpattern, &fcres);
++
++						/* Allocate memory for the new cache entry. */
++						if (frclen >= frccap) {
++							frccap += 16;
++							frc = xrealloc(frc, frccap * sizeof(Fontcache));
++						}
++
++						frc[frclen].font = XftFontOpenPattern(xw.dpy,
++								fontpattern);
++						if (!frc[frclen].font)
++							die("XftFontOpenPattern failed seeking fallback font: %s\n",
++								strerror(errno));
++						frc[frclen].flags = frcflags;
++						frc[frclen].unicodep = rune;
++
++						glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
++
++						f = frclen;
++						frclen++;
++
++						FcPatternDestroy(fcpattern);
++						FcCharSetDestroy(fccharset);
++					}
++
++					specs[numspecs].font = frc[f].font;
++					specs[numspecs].glyph = glyphidx;
++					specs[numspecs].x = (short)xp;
++					specs[numspecs].y = (short)yp;
++					numspecs++;
++				}
++			}
++
++			/* Cleanup and get ready for next segment. */
++			hbcleanup(&shaped);
++			start = i;
++
++			/* Determine font for glyph if different from previous glyph. */
++			if (prevmode != mode) {
++				prevmode = mode;
++				xresetfontsettings(mode, &font, &frcflags);
++				yp = winy + font->ascent;
++			}
++		}
++	}
++
++	return numspecs;
++}
++
++//void
++//changealpha(const Arg *arg)
++//{
++//   if (arg->f == -1.0f && alpha >= 0.1f)
++//      alpha -= 0.1f;
++//   else if (arg->f == 1.0f && alpha < 1.0f)
++//      alpha += 0.1f;
++//   else if (arg->f == 0.0f)
++//      alpha = alpha_def;
++//   else
++//      return;
++//
++//   dc.col[defaultbg].color.alpha = (unsigned short)(0xFFFF * alpha);
++//   /* Required to remove artifacting from borderpx */
++//   cresize(0, 0);
++//   redraw();
++//}
++
++#include <stdio.h>
++#include <stdlib.h>
++void log_to_file(const char *message) {
++    const char *log_file_path = getenv("HOME"); // Get the home directory
++    if (log_file_path == NULL) {
++        return; // If HOME is not set, don't log
+     }
+ 
+-    /* Harfbuzz transformation for ligatures. */
+-    hbtransform(specs, glyphs, len, x, y);
++    char file_path[256];
++    snprintf(file_path, sizeof(file_path), "%s/st_test.txt", log_file_path);
+ 
+-    return numspecs;
++    FILE *file = fopen(file_path, "a"); // Open the file in append mode
++    if (file != NULL) {
++        fprintf(file, "%s\n", message); // Write the message to the file
++        fclose(file);
++    }
+ }
+ 
++float clamp(float value, float lower, float upper)
++{
++    if(value < lower)
++        return lower;
++    if(value > upper)
++        return upper;
++    return value;
++}
+ void
+-xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
+-{
+-    int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
+-    int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
+-        width = charlen * win.cw;
+-    Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
+-    XRenderColor colfg, colbg;
+-    XRectangle r;
+-
+-    /* Fallback on color display for attributes not supported by the font */
+-    if (base.mode & ATTR_ITALIC && base.mode & ATTR_BOLD) {
+-        if (dc.ibfont.badslant || dc.ibfont.badweight)
+-            base.fg = defaultattr;
+-    } else if ((base.mode & ATTR_ITALIC && dc.ifont.badslant) ||
+-            (base.mode & ATTR_BOLD && dc.bfont.badweight)) {
+-        base.fg = defaultattr;
+-    }
+-
+-    if (IS_TRUECOL(base.fg)) {
+-        colfg.alpha = 0xffff;
+-        colfg.red = TRUERED(base.fg);
+-        colfg.green = TRUEGREEN(base.fg);
+-        colfg.blue = TRUEBLUE(base.fg);
+-        XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &truefg);
+-        fg = &truefg;
+-    } else {
+-        fg = &dc.col[base.fg];
+-    }
+-
+-    if (IS_TRUECOL(base.bg)) {
+-        colbg.alpha = 0xffff;
+-        colbg.green = TRUEGREEN(base.bg);
+-        colbg.red = TRUERED(base.bg);
+-        colbg.blue = TRUEBLUE(base.bg);
+-        XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg, &truebg);
+-        bg = &truebg;
+-    } else {
+-        bg = &dc.col[base.bg];
+-    }
+-
+-    /* Change basic system colors [0-7] to bright system colors [8-15] */
+-    if ((base.mode & ATTR_BOLD_FAINT) == ATTR_BOLD && BETWEEN(base.fg, 0, 7))
+-        fg = &dc.col[base.fg + 8];
+-
+-    if (IS_SET(MODE_REVERSE)) {
+-        if (fg == &dc.col[defaultfg]) {
+-            fg = &dc.col[defaultbg];
+-        } else {
+-            colfg.red = ~fg->color.red;
+-            colfg.green = ~fg->color.green;
+-            colfg.blue = ~fg->color.blue;
+-            colfg.alpha = fg->color.alpha;
+-            XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg,
+-                    &revfg);
+-            fg = &revfg;
+-        }
+-
+-        if (bg == &dc.col[defaultbg]) {
+-            bg = &dc.col[defaultfg];
+-        } else {
+-            colbg.red = ~bg->color.red;
+-            colbg.green = ~bg->color.green;
+-            colbg.blue = ~bg->color.blue;
+-            colbg.alpha = bg->color.alpha;
+-            XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg,
+-                    &revbg);
+-            bg = &revbg;
+-        }
+-    }
+-
+-    if ((base.mode & ATTR_BOLD_FAINT) == ATTR_FAINT) {
+-        colfg.red = fg->color.red / 2;
+-        colfg.green = fg->color.green / 2;
+-        colfg.blue = fg->color.blue / 2;
+-        colfg.alpha = fg->color.alpha;
+-        XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &revfg);
+-        fg = &revfg;
+-    }
+-
+-    if (base.mode & ATTR_REVERSE) {
+-        temp = fg;
+-        fg = bg;
+-        bg = temp;
+-    }
+-
+-    if (base.mode & ATTR_BLINK && win.mode & MODE_BLINK)
+-        fg = bg;
++changealpha(const Arg *arg)
++{
++    if((alpha > 0 && arg->f < 0) || (alpha < 1 && arg->f > 0))
++        alpha += arg->f;
+ 
+-    if (base.mode & ATTR_INVISIBLE)
+-        fg = bg;
++    //if (alpha < 0.03){
++    //    defaultbg = alphaBg;
++    //}else {
++    //    defaultbg = defaultAlphaBg;
++    //}
+ 
+-    /* Intelligent cleaning up of the borders. */
+-    if (x == 0) {
+-        xclear(0, (y == 0)? 0 : winy, borderpx,
+-                winy + win.ch +
+-                ((winy + win.ch >= borderpx + win.th)? win.h : 0));
+-    }
+-    if (winx + width >= borderpx + win.tw) {
+-        xclear(winx + width, (y == 0)? 0 : winy, win.w,
+-                ((winy + win.ch >= borderpx + win.th)? win.h : (winy + win.ch)));
+-    }
+-    if (y == 0)
+-        xclear(winx, 0, winx + width, borderpx);
+-    if (winy + win.ch >= borderpx + win.th)
+-        xclear(winx, winy + win.ch, winx + width, win.h);
+-
+-    /* Clean up the region we want to draw to. */
+-    XftDrawRect(xw.draw, bg, winx, winy, width, win.ch);
+-
+-    /* Set the clip region because Xft is sometimes dirty. */
+-    r.x = 0;
+-    r.y = 0;
+-    r.height = win.ch;
+-    r.width = width;
+-    XftDrawSetClipRectangles(xw.draw, winx, winy, &r, 1);
+-
+-    if (base.mode & ATTR_BOXDRAW) {
+-        drawboxes(winx, winy, width / len, win.ch, fg, bg, specs, len);
+-    } else {
+-        /* Render the glyphs. */
+-        XftDrawGlyphFontSpec(xw.draw, fg, specs, len);
+-    }
++    alpha = clamp(alpha, 0.0, 1.0);
++    alphaUnfocus = clamp(alpha-alphaOffset, 0.0, 1.0);
+ 
+-    /* Render underline and strikethrough. */
+-    if (base.mode & ATTR_UNDERLINE) {
+-        XftDrawRect(xw.draw, fg, winx, winy + dc.font.ascent + 1,
+-                width, 1);
+-    }
++    xloadcols();
++    redraw();
+ 
+-    if (base.mode & ATTR_STRUCK) {
+-        XftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent * chscale / 3,
+-                width, 1);
+-    }
++    // Debug
++    //char log_message[128];
++    //snprintf(log_message, sizeof(log_message), "changealpha called, alpha: %.2f", alpha);
++    //log_to_file(log_message);
++}
+ 
+-    /* Reset clip to none. */
+-    XftDrawSetClip(xw.draw, 0);
++void
++xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y, int charlen)
++{
++	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
++	    width = charlen * win.cw;
++	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
++	XRenderColor colfg, colbg;
++	XRectangle r;
++
++	/* Fallback on color display for attributes not supported by the font */
++	if (base.mode & ATTR_ITALIC && base.mode & ATTR_BOLD) {
++		if (dc.ibfont.badslant || dc.ibfont.badweight)
++			base.fg = defaultattr;
++	} else if ((base.mode & ATTR_ITALIC && dc.ifont.badslant) ||
++	    (base.mode & ATTR_BOLD && dc.bfont.badweight)) {
++		base.fg = defaultattr;
++	}
++
++	if (IS_TRUECOL(base.fg)) {
++		colfg.alpha = 0xffff;
++		colfg.red = TRUERED(base.fg);
++		colfg.green = TRUEGREEN(base.fg);
++		colfg.blue = TRUEBLUE(base.fg);
++		XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &truefg);
++		fg = &truefg;
++	} else {
++		fg = &dc.col[base.fg];
++	}
++
++	if (IS_TRUECOL(base.bg)) {
++		colbg.alpha = 0xffff;
++		colbg.green = TRUEGREEN(base.bg);
++		colbg.red = TRUERED(base.bg);
++		colbg.blue = TRUEBLUE(base.bg);
++		XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg, &truebg);
++		bg = &truebg;
++	} else {
++		bg = &dc.col[base.bg];
++	}
++
++	/* Change basic system colors [0-7] to bright system colors [8-15] */
++	if ((base.mode & ATTR_BOLD_FAINT) == ATTR_BOLD && BETWEEN(base.fg, 0, 7))
++		fg = &dc.col[base.fg + 8];
++
++	if (IS_SET(MODE_REVERSE)) {
++		if (fg == &dc.col[defaultfg]) {
++			fg = &dc.col[defaultbg];
++		} else {
++			colfg.red = ~fg->color.red;
++			colfg.green = ~fg->color.green;
++			colfg.blue = ~fg->color.blue;
++			colfg.alpha = fg->color.alpha;
++			XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg,
++					&revfg);
++			fg = &revfg;
++		}
++
++		if (bg == &dc.col[defaultbg]) {
++			bg = &dc.col[defaultfg];
++		} else {
++			colbg.red = ~bg->color.red;
++			colbg.green = ~bg->color.green;
++			colbg.blue = ~bg->color.blue;
++			colbg.alpha = bg->color.alpha;
++			XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg,
++					&revbg);
++			bg = &revbg;
++		}
++	}
++
++	if ((base.mode & ATTR_BOLD_FAINT) == ATTR_FAINT) {
++		colfg.red = fg->color.red / 2;
++		colfg.green = fg->color.green / 2;
++		colfg.blue = fg->color.blue / 2;
++		colfg.alpha = fg->color.alpha;
++		XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &revfg);
++		fg = &revfg;
++	}
++
++	if (base.mode & ATTR_REVERSE) {
++		temp = fg;
++		fg = bg;
++		bg = temp;
++	}
++
++	if (base.mode & ATTR_BLINK && win.mode & MODE_BLINK)
++		fg = bg;
++
++	if (base.mode & ATTR_INVISIBLE)
++		fg = bg;
++
++	/* Intelligent cleaning up of the borders. */
++	if (x == 0) {
++		xclear(0, (y == 0)? 0 : winy, borderpx,
++			winy + win.ch +
++			((winy + win.ch >= borderpx + win.th)? win.h : 0));
++	}
++	if (winx + width >= borderpx + win.tw) {
++		xclear(winx + width, (y == 0)? 0 : winy, win.w,
++			((winy + win.ch >= borderpx + win.th)? win.h : (winy + win.ch)));
++	}
++	if (y == 0)
++		xclear(winx, 0, winx + width, borderpx);
++	if (winy + win.ch >= borderpx + win.th)
++		xclear(winx, winy + win.ch, winx + width, win.h);
++
++	/* Clean up the region we want to draw to. */
++	XftDrawRect(xw.draw, bg, winx, winy, width, win.ch);
++
++	/* Set the clip region because Xft is sometimes dirty. */
++	r.x = 0;
++	r.y = 0;
++	r.height = win.ch;
++	r.width = width;
++	XftDrawSetClipRectangles(xw.draw, winx, winy, &r, 1);
++
++	/* Render the glyphs. */
++	XftDrawGlyphFontSpec(xw.draw, fg, specs, len);
++
++	/* Render underline and strikethrough. */
++	if (base.mode & ATTR_UNDERLINE) {
++		XftDrawRect(xw.draw, fg, winx, winy + dc.font.ascent * chscale + 1,
++				width, 1);
++	}
++
++	if (base.mode & ATTR_STRUCK) {
++		XftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent * chscale / 3,
++				width, 1);
++	}
++
++	/* Reset clip to none. */
++	XftDrawSetClip(xw.draw, 0);
+ }
+ 
+ void
+ xdrawglyph(Glyph g, int x, int y)
+ {
+-    int numspecs;
+-    XftGlyphFontSpec spec;
++	int numspecs;
++	XftGlyphFontSpec *specs = xw.specbuf;
+ 
+-    numspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);
+-    xdrawglyphfontspecs(&spec, g, numspecs, x, y);
++	numspecs = xmakeglyphfontspecs(specs, &g, 1, x, y);
++	xdrawglyphfontspecs(specs, g, numspecs, x, y, (g.mode & ATTR_WIDE) ? 2 : 1);
+ }
+ 
+ void
+ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
+ {
+-    Color drawcol;
+-
+-    /* remove the old cursor */
+-    if (selected(ox, oy))
+-        og.mode ^= ATTR_REVERSE;
+-
+-    /* Redraw the line where cursor was previously.
+-     * It will restore the ligatures broken by the cursor. */
+-    xdrawline(line, 0, oy, len);
+-
+-    if (IS_SET(MODE_HIDE))
+-        return;
+-
+-    /*
+-     * Select the right color for the right mode.
+-     */
+-    g.mode &= ATTR_BOLD|ATTR_ITALIC|ATTR_UNDERLINE|ATTR_STRUCK|ATTR_WIDE|ATTR_BOXDRAW;
+-
+-    if (IS_SET(MODE_REVERSE)) {
+-        g.mode |= ATTR_REVERSE;
+-        g.bg = defaultfg;
+-        if (selected(cx, cy)) {
+-            drawcol = dc.col[defaultcs];
+-            g.fg = defaultrcs;
+-        } else {
+-            drawcol = dc.col[defaultrcs];
+-            g.fg = defaultcs;
+-        }
+-    } else {
+-        if (selected(cx, cy)) {
+-            g.fg = defaultfg;
+-            g.bg = defaultrcs;
+-        } else {
+-            g.fg = defaultbg;
+-            g.bg = defaultcs;
+-        }
+-        drawcol = dc.col[g.bg];
+-    }
+-
+-    /* draw the new one */
+-    if (IS_SET(MODE_FOCUSED)) {
+-        switch (win.cursor) {
+-            case 7: /* st extension */
+-                g.u = 0x2603; /* snowman (U+2603) */
+-                /* FALLTHROUGH */
+-            case 0: /* Blinking Block */
+-            case 1: /* Blinking Block (Default) */
+-            case 2: /* Steady Block */
+-                xdrawglyph(g, cx, cy);
+-                break;
+-            case 3: /* Blinking Underline */
+-            case 4: /* Steady Underline */
+-                XftDrawRect(xw.draw, &drawcol,
+-                        borderpx + cx * win.cw,
+-                        borderpx + (cy + 1) * win.ch - \
+-                        cursorthickness,
+-                        win.cw, cursorthickness);
+-                break;
+-            case 5: /* Blinking bar */
+-            case 6: /* Steady bar */
+-                XftDrawRect(xw.draw, &drawcol,
+-                        borderpx + cx * win.cw,
+-                        borderpx + cy * win.ch,
+-                        cursorthickness, win.ch);
+-                break;
+-        }
+-    } else {
+-        XftDrawRect(xw.draw, &drawcol,
+-                borderpx + cx * win.cw,
+-                borderpx + cy * win.ch,
+-                win.cw - 1, 1);
+-        XftDrawRect(xw.draw, &drawcol,
+-                borderpx + cx * win.cw,
+-                borderpx + cy * win.ch,
+-                1, win.ch - 1);
+-        XftDrawRect(xw.draw, &drawcol,
+-                borderpx + (cx + 1) * win.cw - 1,
+-                borderpx + cy * win.ch,
+-                1, win.ch - 1);
+-        XftDrawRect(xw.draw, &drawcol,
+-                borderpx + cx * win.cw,
+-                borderpx + (cy + 1) * win.ch - 1,
+-                win.cw, 1);
+-    }
++	Color drawcol;
++
++	/* remove the old cursor */
++	if (selected(ox, oy))
++		og.mode ^= ATTR_REVERSE;
++
++	/* Redraw the line where cursor was previously.
++	 * It will restore the ligatures broken by the cursor. */
++	xdrawline(line, 0, oy, len);
++
++	if (IS_SET(MODE_HIDE))
++		return;
++
++	/*
++	 * Select the right color for the right mode.
++	 */
++	g.mode &= ATTR_BOLD|ATTR_ITALIC|ATTR_UNDERLINE|ATTR_STRUCK|ATTR_WIDE;
++
++	if (IS_SET(MODE_REVERSE)) {
++		g.mode |= ATTR_REVERSE;
++		g.bg = defaultfg;
++		if (selected(cx, cy)) {
++			drawcol = dc.col[defaultcs];
++			g.fg = defaultrcs;
++		} else {
++			drawcol = dc.col[defaultrcs];
++			g.fg = defaultcs;
++		}
++	} else {
++		if (selected(cx, cy)) {
++			g.fg = defaultfg;
++			g.bg = defaultrcs;
++		} else {
++			g.fg = defaultbg;
++			g.bg = defaultcs;
++		}
++		drawcol = dc.col[g.bg];
++	}
++
++	/* draw the new one */
++	if (IS_SET(MODE_FOCUSED)) {
++		switch (win.cursor) {
++		case 7: /* st extension */
++			g.u = 0x2603; /* snowman (U+2603) */
++			/* FALLTHROUGH */
++		case 0: /* Blinking Block */
++		case 1: /* Blinking Block (Default) */
++		case 2: /* Steady Block */
++			xdrawglyph(g, cx, cy);
++			break;
++		case 3: /* Blinking Underline */
++		case 4: /* Steady Underline */
++			XftDrawRect(xw.draw, &drawcol,
++					borderpx + cx * win.cw,
++					borderpx + (cy + 1) * win.ch - \
++						cursorthickness,
++					win.cw, cursorthickness);
++			break;
++		case 5: /* Blinking bar */
++		case 6: /* Steady bar */
++			XftDrawRect(xw.draw, &drawcol,
++					borderpx + cx * win.cw,
++					borderpx + cy * win.ch,
++					cursorthickness, win.ch);
++			break;
++		}
++	} else {
++		XftDrawRect(xw.draw, &drawcol,
++				borderpx + cx * win.cw,
++				borderpx + cy * win.ch,
++				win.cw - 1, 1);
++		XftDrawRect(xw.draw, &drawcol,
++				borderpx + cx * win.cw,
++				borderpx + cy * win.ch,
++				1, win.ch - 1);
++		XftDrawRect(xw.draw, &drawcol,
++				borderpx + (cx + 1) * win.cw - 1,
++				borderpx + cy * win.ch,
++				1, win.ch - 1);
++		XftDrawRect(xw.draw, &drawcol,
++				borderpx + cx * win.cw,
++				borderpx + (cy + 1) * win.ch - 1,
++				win.cw, 1);
++	}
+ }
+ 
+ void
+ xsetenv(void)
+ {
+-    char buf[sizeof(long) * 8 + 1];
++	char buf[sizeof(long) * 8 + 1];
+ 
+-    snprintf(buf, sizeof(buf), "%lu", xw.win);
+-    setenv("WINDOWID", buf, 1);
++	snprintf(buf, sizeof(buf), "%lu", xw.win);
++	setenv("WINDOWID", buf, 1);
+ }
+ 
+ void
+ xseticontitle(char *p)
+ {
+-    XTextProperty prop;
+-    DEFAULT(p, opt_title);
++	XTextProperty prop;
++	DEFAULT(p, opt_title);
+ 
+-    if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
+-                &prop) != Success)
+-        return;
+-    XSetWMIconName(xw.dpy, xw.win, &prop);
+-    XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmiconname);
+-    XFree(prop.value);
++	if (p[0] == '\0')
++		p = opt_title;
++
++	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
++	                                &prop) != Success)
++		return;
++	XSetWMIconName(xw.dpy, xw.win, &prop);
++	XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmiconname);
++	XFree(prop.value);
+ }
+ 
+ void
+ xsettitle(char *p)
+ {
+-    XTextProperty prop;
+-    DEFAULT(p, opt_title);
++	XTextProperty prop;
++	DEFAULT(p, opt_title);
++
++	if (p[0] == '\0')
++		p = opt_title;
+ 
+-    if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
+-                &prop) != Success)
+-        return;
+-    XSetWMName(xw.dpy, xw.win, &prop);
+-    XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmname);
+-    XFree(prop.value);
++	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
++	                                &prop) != Success)
++		return;
++	XSetWMName(xw.dpy, xw.win, &prop);
++	XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmname);
++	XFree(prop.value);
+ }
+ 
+ int
+ xstartdraw(void)
+ {
+-    return IS_SET(MODE_VISIBLE);
++	return IS_SET(MODE_VISIBLE);
+ }
+ 
+ void
+ xdrawline(Line line, int x1, int y1, int x2)
+ {
+-    int i, x, ox, numspecs;
+-    Glyph base, new;
+-    XftGlyphFontSpec *specs = xw.specbuf;
+-
+-    numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
+-    i = ox = 0;
+-    for (x = x1; x < x2 && i < numspecs; x++) {
+-        new = line[x];
+-        if (new.mode == ATTR_WDUMMY)
+-            continue;
+-        if (selected(x, y1))
+-            new.mode ^= ATTR_REVERSE;
+-        if (i > 0 && ATTRCMP(base, new)) {
+-            xdrawglyphfontspecs(specs, base, i, ox, y1);
+-            specs += i;
+-            numspecs -= i;
+-            i = 0;
+-        }
+-        if (i == 0) {
+-            ox = x;
+-            base = new;
+-        }
+-        i++;
+-    }
+-    if (i > 0)
+-        xdrawglyphfontspecs(specs, base, i, ox, y1);
++	int i, x, ox, numspecs;
++	Glyph base, new;
++	XftGlyphFontSpec *specs = xw.specbuf;
++
++	i = ox = 0;
++	for (x = x1; x < x2; x++) {
++		new = line[x];
++		if (new.mode == ATTR_WDUMMY)
++			continue;
++		if (selected(x, y1))
++			new.mode ^= ATTR_REVERSE;
++		if ((i > 0) && ATTRCMP(base, new)) {
++			numspecs = xmakeglyphfontspecs(specs, &line[ox], x - ox, ox, y1);
++			xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x - ox);
++			i = 0;
++		}
++		if (i == 0) {
++			ox = x;
++			base = new;
++		}
++		i++;
++	}
++	if (i > 0) {
++		numspecs = xmakeglyphfontspecs(specs, &line[ox], x2 - ox, ox, y1);
++		xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x2 - ox);
++	}
+ }
+ 
+ void
+ xfinishdraw(void)
+ {
+-    XCopyArea(xw.dpy, xw.buf, xw.win, dc.gc, 0, 0, win.w,
+-            win.h, 0, 0);
+-    XSetForeground(xw.dpy, dc.gc,
+-            dc.col[IS_SET(MODE_REVERSE)?
+-            defaultfg : defaultbg].pixel);
++	XCopyArea(xw.dpy, xw.buf, xw.win, dc.gc, 0, 0, win.w,
++			win.h, 0, 0);
++	XSetForeground(xw.dpy, dc.gc,
++			dc.col[IS_SET(MODE_REVERSE)?
++				defaultfg : defaultbg].pixel);
+ }
+ 
+ void
+ xximspot(int x, int y)
+ {
+-    if (xw.ime.xic == NULL)
+-        return;
++	if (xw.ime.xic == NULL)
++		return;
+ 
+-    xw.ime.spot.x = borderpx + x * win.cw;
+-    xw.ime.spot.y = borderpx + (y + 1) * win.ch;
++	xw.ime.spot.x = borderpx + x * win.cw;
++	xw.ime.spot.y = borderpx + (y + 1) * win.ch;
+ 
+-    XSetICValues(xw.ime.xic, XNPreeditAttributes, xw.ime.spotlist, NULL);
++	XSetICValues(xw.ime.xic, XNPreeditAttributes, xw.ime.spotlist, NULL);
+ }
+ 
+ void
+ expose(XEvent *ev)
+ {
+-    redraw();
++	redraw();
+ }
+ 
+ void
+ visibility(XEvent *ev)
+ {
+-    XVisibilityEvent *e = &ev->xvisibility;
++	XVisibilityEvent *e = &ev->xvisibility;
+ 
+-    MODBIT(win.mode, e->state != VisibilityFullyObscured, MODE_VISIBLE);
++	MODBIT(win.mode, e->state != VisibilityFullyObscured, MODE_VISIBLE);
+ }
+ 
+ void
+ unmap(XEvent *ev)
+ {
+-    win.mode &= ~MODE_VISIBLE;
++	win.mode &= ~MODE_VISIBLE;
+ }
+ 
+ void
+ xsetpointermotion(int set)
+ {
+-    MODBIT(xw.attrs.event_mask, set, PointerMotionMask);
+-    XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask, &xw.attrs);
++	MODBIT(xw.attrs.event_mask, set, PointerMotionMask);
++	XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask, &xw.attrs);
+ }
+ 
+ void
+ xsetmode(int set, unsigned int flags)
+ {
+-    int mode = win.mode;
+-    MODBIT(win.mode, set, flags);
+-    if ((win.mode & MODE_REVERSE) != (mode & MODE_REVERSE))
+-        redraw();
++	int mode = win.mode;
++	MODBIT(win.mode, set, flags);
++	if ((win.mode & MODE_REVERSE) != (mode & MODE_REVERSE))
++		redraw();
+ }
+ 
+ int
+ xsetcursor(int cursor)
+ {
+-    if (!BETWEEN(cursor, 0, 7)) /* 7: st extension */
+-        return 1;
+-    win.cursor = cursor;
+-    return 0;
++	if (!BETWEEN(cursor, 0, 7)) /* 7: st extension */
++		return 1;
++	win.cursor = cursor;
++	return 0;
+ }
+ 
+ void
+ xseturgency(int add)
+ {
+-    XWMHints *h = XGetWMHints(xw.dpy, xw.win);
++	XWMHints *h = XGetWMHints(xw.dpy, xw.win);
+ 
+-    MODBIT(h->flags, add, XUrgencyHint);
+-    XSetWMHints(xw.dpy, xw.win, h);
+-    XFree(h);
++	MODBIT(h->flags, add, XUrgencyHint);
++	XSetWMHints(xw.dpy, xw.win, h);
++	XFree(h);
+ }
+ 
+ void
+ xbell(void)
+ {
+-    if (!(IS_SET(MODE_FOCUSED)))
+-        xseturgency(1);
+-    if (bellvolume)
+-        XkbBell(xw.dpy, xw.win, bellvolume, (Atom)NULL);
++	if (!(IS_SET(MODE_FOCUSED)))
++		xseturgency(1);
++	if (bellvolume)
++		XkbBell(xw.dpy, xw.win, bellvolume, (Atom)NULL);
+ }
+ 
+ void
+ focus(XEvent *ev)
+ {
+-    XFocusChangeEvent *e = &ev->xfocus;
+-
+-    if (e->mode == NotifyGrab)
+-        return;
+-
+-    if (ev->type == FocusIn) {
+-        if (xw.ime.xic)
+-            XSetICFocus(xw.ime.xic);
+-        win.mode |= MODE_FOCUSED;
+-        xseturgency(0);
+-        if (IS_SET(MODE_FOCUS))
+-            ttywrite("\033[I", 3, 0);
+-        if (!focused) {
+-            focused = 1;
+-            xloadcols();
+-            tfulldirt();
+-        }
+-    } else {
+-        if (xw.ime.xic)
+-            XUnsetICFocus(xw.ime.xic);
+-        win.mode &= ~MODE_FOCUSED;
+-        if (IS_SET(MODE_FOCUS))
+-            ttywrite("\033[O", 3, 0);
+-        if (focused) {
+-            focused = 0;
+-            xloadcols();
+-            tfulldirt();
+-        }
+-    }
++	XFocusChangeEvent *e = &ev->xfocus;
++
++	if (e->mode == NotifyGrab)
++		return;
++
++	if (ev->type == FocusIn) {
++		if (xw.ime.xic)
++			XSetICFocus(xw.ime.xic);
++		win.mode |= MODE_FOCUSED;
++		xseturgency(0);
++		if (IS_SET(MODE_FOCUS))
++			ttywrite("\033[I", 3, 0);
++	} else {
++		if (xw.ime.xic)
++			XUnsetICFocus(xw.ime.xic);
++		win.mode &= ~MODE_FOCUSED;
++		if (IS_SET(MODE_FOCUS))
++			ttywrite("\033[O", 3, 0);
++	}
+ }
+ 
+ int
+ match(uint mask, uint state)
+ {
+-    return mask == XK_ANY_MOD || mask == (state & ~ignoremod);
++	return mask == XK_ANY_MOD || mask == (state & ~ignoremod);
+ }
+ 
+ char*
+ kmap(KeySym k, uint state)
+ {
+-    Key *kp;
+-    int i;
++	Key *kp;
++	int i;
+ 
+-    /* Check for mapped keys out of X11 function keys. */
+-    for (i = 0; i < LEN(mappedkeys); i++) {
+-        if (mappedkeys[i] == k)
+-            break;
+-    }
+-    if (i == LEN(mappedkeys)) {
+-        if ((k & 0xFFFF) < 0xFD00)
+-            return NULL;
+-    }
++	/* Check for mapped keys out of X11 function keys. */
++	for (i = 0; i < LEN(mappedkeys); i++) {
++		if (mappedkeys[i] == k)
++			break;
++	}
++	if (i == LEN(mappedkeys)) {
++		if ((k & 0xFFFF) < 0xFD00)
++			return NULL;
++	}
+ 
+-    for (kp = key; kp < key + LEN(key); kp++) {
+-        if (kp->k != k)
+-            continue;
++	for (kp = key; kp < key + LEN(key); kp++) {
++		if (kp->k != k)
++			continue;
+ 
+-        if (!match(kp->mask, state))
+-            continue;
++		if (!match(kp->mask, state))
++			continue;
+ 
+-        if (IS_SET(MODE_APPKEYPAD) ? kp->appkey < 0 : kp->appkey > 0)
+-            continue;
+-        if (IS_SET(MODE_NUMLOCK) && kp->appkey == 2)
+-            continue;
++		if (IS_SET(MODE_APPKEYPAD) ? kp->appkey < 0 : kp->appkey > 0)
++			continue;
++		if (IS_SET(MODE_NUMLOCK) && kp->appkey == 2)
++			continue;
+ 
+-        if (IS_SET(MODE_APPCURSOR) ? kp->appcursor < 0 : kp->appcursor > 0)
+-            continue;
++		if (IS_SET(MODE_APPCURSOR) ? kp->appcursor < 0 : kp->appcursor > 0)
++			continue;
+ 
+-        return kp->s;
+-    }
++		return kp->s;
++	}
+ 
+-    return NULL;
++	return NULL;
+ }
+ 
+ void
+ kpress(XEvent *ev)
+ {
+-    XKeyEvent *e = &ev->xkey;
+-    KeySym ksym;
+-    char *buf = NULL, *customkey;
+-    int len = 0;
+-    int buf_size = 64;
+-    int critical = - 1;
+-    Rune c;
+-    Status status;
+-    Shortcut *bp;
+-
+-    if (IS_SET(MODE_KBDLOCK))
+-        return;
+-
+-reallocbuf:
+-    if (critical > 0)
+-        goto cleanup;
+-    if (buf)
+-        free(buf);
+-
+-    buf = xmalloc((buf_size) * sizeof(char));
+-    critical += 1;
+-
+-    if (xw.ime.xic) {
+-        len = XmbLookupString(xw.ime.xic, e, buf, buf_size, &ksym, &status);
+-        if (status == XBufferOverflow) {
+-            buf_size = len;
+-            goto reallocbuf;
+-        }
+-    } else {
+-        // Not sure how to fix this and if it is fixable
+-        // but at least it does write something into the buffer
+-        // so it is not as critical
+-        len = XLookupString(e, buf, buf_size, &ksym, NULL);
+-    }
+-    /* 1. shortcuts */
+-    for (bp = shortcuts; bp < shortcuts + LEN(shortcuts); bp++) {
+-        if (ksym == bp->keysym && match(bp->mod, e->state)) {
+-            bp->func(&(bp->arg));
+-            goto cleanup;
+-        }
+-    }
+-
+-    /* 2. custom keys from config.h */
+-    if ((customkey = kmap(ksym, e->state))) {
+-        ttywrite(customkey, strlen(customkey), 1);
+-        goto cleanup;
+-    }
+-
+-    /* 3. composed string from input method */
+-    if (len == 0)
+-        goto cleanup;
+-    if (len == 1 && e->state & Mod1Mask) {
+-        if (IS_SET(MODE_8BIT)) {
+-            if (*buf < 0177) {
+-                c = *buf | 0x80;
+-                len = utf8encode(c, buf);
+-            }
+-        } else {
+-            buf[1] = buf[0];
+-            buf[0] = '\033';
+-            len = 2;
+-        }
+-    }
+-    if (len <= buf_size)
+-        ttywrite(buf, len, 1);
+-cleanup:
+-    if (buf)
+-        free(buf);
++	XKeyEvent *e = &ev->xkey;
++	KeySym ksym = NoSymbol;
++	char buf[64], *customkey;
++	int len;
++	Rune c;
++	Status status;
++	Shortcut *bp;
++
++	if (IS_SET(MODE_KBDLOCK))
++		return;
++
++	if (xw.ime.xic) {
++		len = XmbLookupString(xw.ime.xic, e, buf, sizeof buf, &ksym, &status);
++		if (status == XBufferOverflow)
++			return;
++	} else {
++		len = XLookupString(e, buf, sizeof buf, &ksym, NULL);
++	}
++	/* 1. shortcuts */
++	for (bp = shortcuts; bp < shortcuts + LEN(shortcuts); bp++) {
++		if (ksym == bp->keysym && match(bp->mod, e->state)) {
++			bp->func(&(bp->arg));
++			return;
++		}
++	}
++
++	/* 2. custom keys from config.h */
++	if ((customkey = kmap(ksym, e->state))) {
++		ttywrite(customkey, strlen(customkey), 1);
++		return;
++	}
++
++	/* 3. composed string from input method */
++	if (len == 0)
++		return;
++	if (len == 1 && e->state & Mod1Mask) {
++		if (IS_SET(MODE_8BIT)) {
++			if (*buf < 0177) {
++				c = *buf | 0x80;
++				len = utf8encode(c, buf);
++			}
++		} else {
++			buf[1] = buf[0];
++			buf[0] = '\033';
++			len = 2;
++		}
++	}
++	ttywrite(buf, len, 1);
+ }
+ 
+ void
+ cmessage(XEvent *e)
+ {
+-    /*
+-     * See xembed specs
+-     *  http://standards.freedesktop.org/xembed-spec/xembed-spec-latest.html
+-     */
+-    if (e->xclient.message_type == xw.xembed && e->xclient.format == 32) {
+-        if (e->xclient.data.l[1] == XEMBED_FOCUS_IN) {
+-            win.mode |= MODE_FOCUSED;
+-            xseturgency(0);
+-        } else if (e->xclient.data.l[1] == XEMBED_FOCUS_OUT) {
+-            win.mode &= ~MODE_FOCUSED;
+-        }
+-    } else if (e->xclient.data.l[0] == xw.wmdeletewin) {
+-        ttyhangup();
+-        exit(0);
+-    }
++	/*
++	 * See xembed specs
++	 *  http://standards.freedesktop.org/xembed-spec/xembed-spec-latest.html
++	 */
++	if (e->xclient.message_type == xw.xembed && e->xclient.format == 32) {
++		if (e->xclient.data.l[1] == XEMBED_FOCUS_IN) {
++			win.mode |= MODE_FOCUSED;
++			xseturgency(0);
++		} else if (e->xclient.data.l[1] == XEMBED_FOCUS_OUT) {
++			win.mode &= ~MODE_FOCUSED;
++		}
++	} else if (e->xclient.data.l[0] == xw.wmdeletewin) {
++		ttyhangup();
++		exit(0);
++	}
+ }
+ 
+ void
+ resize(XEvent *e)
+ {
+-    if (e->xconfigure.width == win.w && e->xconfigure.height == win.h)
+-        return;
++	if (e->xconfigure.width == win.w && e->xconfigure.height == win.h)
++		return;
+ 
+-    cresize(e->xconfigure.width, e->xconfigure.height);
++	cresize(e->xconfigure.width, e->xconfigure.height);
+ }
+ 
+ void
+ run(void)
+ {
+-    XEvent ev;
+-    int w = win.w, h = win.h;
+-    fd_set rfd;
+-    int xfd = XConnectionNumber(xw.dpy), ttyfd, xev, drawing;
+-    struct timespec seltv, *tv, now, lastblink, trigger;
+-    double timeout;
+-
+-    /* Waiting for window mapping */
+-    do {
+-        XNextEvent(xw.dpy, &ev);
+-        /*
+-         * This XFilterEvent call is required because of XOpenIM. It
+-         * does filter out the key event and some client message for
+-         * the input method too.
+-         */
+-        if (XFilterEvent(&ev, None))
+-            continue;
+-        if (ev.type == ConfigureNotify) {
+-            w = ev.xconfigure.width;
+-            h = ev.xconfigure.height;
+-        }
+-    } while (ev.type != MapNotify);
+-
+-    ttyfd = ttynew(opt_line, shell, opt_io, opt_cmd);
+-    cresize(w, h);
+-
+-    for (timeout = -1, drawing = 0, lastblink = (struct timespec){0};;) {
+-        FD_ZERO(&rfd);
+-        FD_SET(ttyfd, &rfd);
+-        FD_SET(xfd, &rfd);
+-
+-        if (XPending(xw.dpy))
+-            timeout = 0;  /* existing events might not set xfd */
+-
+-        seltv.tv_sec = timeout / 1E3;
+-        seltv.tv_nsec = 1E6 * (timeout - 1E3 * seltv.tv_sec);
+-        tv = timeout >= 0 ? &seltv : NULL;
+-
+-        if (pselect(MAX(xfd, ttyfd)+1, &rfd, NULL, NULL, tv, NULL) < 0) {
+-            if (errno == EINTR)
+-                continue;
+-            die("select failed: %s\n", strerror(errno));
+-        }
+-        clock_gettime(CLOCK_MONOTONIC, &now);
+-
+-        if (FD_ISSET(ttyfd, &rfd))
+-            ttyread();
+-
+-        xev = 0;
+-        while (XPending(xw.dpy)) {
+-            xev = 1;
+-            XNextEvent(xw.dpy, &ev);
+-            if (XFilterEvent(&ev, None))
+-                continue;
+-            if (handler[ev.type])
+-                (handler[ev.type])(&ev);
+-        }
+-
+-        /*
+-         * To reduce flicker and tearing, when new content or event
+-         * triggers drawing, we first wait a bit to ensure we got
+-         * everything, and if nothing new arrives - we draw.
+-         * We start with trying to wait minlatency ms. If more content
+-         * arrives sooner, we retry with shorter and shorter periods,
+-         * and eventually draw even without idle after maxlatency ms.
+-         * Typically this results in low latency while interacting,
+-         * maximum latency intervals during `cat huge.txt`, and perfect
+-         * sync with periodic updates from animations/key-repeats/etc.
+-         */
+-        if (FD_ISSET(ttyfd, &rfd) || xev) {
+-            if (!drawing) {
+-                trigger = now;
+-                drawing = 1;
+-            }
+-            timeout = (maxlatency - TIMEDIFF(now, trigger)) \
+-                      / maxlatency * minlatency;
+-            if (timeout > 0)
+-                continue;  /* we have time, try to find idle */
+-        }
+-
+-        /* idle detected or maxlatency exhausted -> draw */
+-        timeout = -1;
+-        if (blinktimeout && tattrset(ATTR_BLINK)) {
+-            timeout = blinktimeout - TIMEDIFF(now, lastblink);
+-            if (timeout <= 0) {
+-                if (-timeout > blinktimeout) /* start visible */
+-                    win.mode |= MODE_BLINK;
+-                win.mode ^= MODE_BLINK;
+-                tsetdirtattr(ATTR_BLINK);
+-                lastblink = now;
+-                timeout = blinktimeout;
+-            }
+-        }
+-
+-        draw();
+-        XFlush(xw.dpy);
+-        drawing = 0;
+-    }
++	XEvent ev;
++	int w = win.w, h = win.h;
++	fd_set rfd;
++	int xfd = XConnectionNumber(xw.dpy), ttyfd, xev, drawing;
++	struct timespec seltv, *tv, now, lastblink, trigger;
++	double timeout;
++
++	/* Waiting for window mapping */
++	do {
++		XNextEvent(xw.dpy, &ev);
++		/*
++		 * This XFilterEvent call is required because of XOpenIM. It
++		 * does filter out the key event and some client message for
++		 * the input method too.
++		 */
++		if (XFilterEvent(&ev, None))
++			continue;
++		if (ev.type == ConfigureNotify) {
++			w = ev.xconfigure.width;
++			h = ev.xconfigure.height;
++		}
++	} while (ev.type != MapNotify);
++
++	ttyfd = ttynew(opt_line, shell, opt_io, opt_cmd);
++	cresize(w, h);
++
++	for (timeout = -1, drawing = 0, lastblink = (struct timespec){0};;) {
++		FD_ZERO(&rfd);
++		FD_SET(ttyfd, &rfd);
++		FD_SET(xfd, &rfd);
++
++		if (XPending(xw.dpy))
++			timeout = 0;  /* existing events might not set xfd */
++
++		seltv.tv_sec = timeout / 1E3;
++		seltv.tv_nsec = 1E6 * (timeout - 1E3 * seltv.tv_sec);
++		tv = timeout >= 0 ? &seltv : NULL;
++
++		if (pselect(MAX(xfd, ttyfd)+1, &rfd, NULL, NULL, tv, NULL) < 0) {
++			if (errno == EINTR)
++				continue;
++			die("select failed: %s\n", strerror(errno));
++		}
++		clock_gettime(CLOCK_MONOTONIC, &now);
++
++		if (FD_ISSET(ttyfd, &rfd))
++			ttyread();
++
++		xev = 0;
++		while (XPending(xw.dpy)) {
++			xev = 1;
++			XNextEvent(xw.dpy, &ev);
++			if (XFilterEvent(&ev, None))
++				continue;
++			if (handler[ev.type])
++				(handler[ev.type])(&ev);
++		}
++
++		/*
++		 * To reduce flicker and tearing, when new content or event
++		 * triggers drawing, we first wait a bit to ensure we got
++		 * everything, and if nothing new arrives - we draw.
++		 * We start with trying to wait minlatency ms. If more content
++		 * arrives sooner, we retry with shorter and shorter periods,
++		 * and eventually draw even without idle after maxlatency ms.
++		 * Typically this results in low latency while interacting,
++		 * maximum latency intervals during `cat huge.txt`, and perfect
++		 * sync with periodic updates from animations/key-repeats/etc.
++		 */
++		if (FD_ISSET(ttyfd, &rfd) || xev) {
++			if (!drawing) {
++				trigger = now;
++				drawing = 1;
++			}
++			timeout = (maxlatency - TIMEDIFF(now, trigger)) \
++			          / maxlatency * minlatency;
++			if (timeout > 0)
++				continue;  /* we have time, try to find idle */
++		}
++
++		/* idle detected or maxlatency exhausted -> draw */
++		timeout = -1;
++		if (blinktimeout && tattrset(ATTR_BLINK)) {
++			timeout = blinktimeout - TIMEDIFF(now, lastblink);
++			if (timeout <= 0) {
++				if (-timeout > blinktimeout) /* start visible */
++					win.mode |= MODE_BLINK;
++				win.mode ^= MODE_BLINK;
++				tsetdirtattr(ATTR_BLINK);
++				lastblink = now;
++				timeout = blinktimeout;
++			}
++		}
++
++		draw();
++		XFlush(xw.dpy);
++		drawing = 0;
++	}
+ }
+ 
+ int
+ resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+ {
+-    char **sdst = dst;
+-    int *idst = dst;
+-    float *fdst = dst;
+-
+-    char fullname[256];
+-    char fullclass[256];
+-    char *type;
+-    XrmValue ret;
+-
+-    snprintf(fullname, sizeof(fullname), "%s.%s",
+-            opt_name ? opt_name : "st", name);
+-    snprintf(fullclass, sizeof(fullclass), "%s.%s",
+-            opt_class ? opt_class : "St", name);
+-    fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
+-
+-    XrmGetResource(db, fullname, fullclass, &type, &ret);
+-    if (ret.addr == NULL || strncmp("String", type, 64))
+-        return 1;
+-
+-    switch (rtype) {
+-        case STRING:
+-            *sdst = ret.addr;
+-            break;
+-        case INTEGER:
+-            *idst = strtoul(ret.addr, NULL, 10);
+-            break;
+-        case FLOAT:
+-            *fdst = strtof(ret.addr, NULL);
+-            break;
+-    }
+-    return 0;
++	char **sdst = dst;
++	int *idst = dst;
++	float *fdst = dst;
++
++	char fullname[256];
++	char fullclass[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s",
++			opt_name ? opt_name : "st", name);
++	snprintf(fullclass, sizeof(fullclass), "%s.%s",
++			opt_class ? opt_class : "St", name);
++	fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
++
++	XrmGetResource(db, fullname, fullclass, &type, &ret);
++	if (ret.addr == NULL || strncmp("String", type, 64))
++		return 1;
++
++	switch (rtype) {
++	case STRING:
++		*sdst = ret.addr;
++		break;
++	case INTEGER:
++		*idst = strtoul(ret.addr, NULL, 10);
++		break;
++	case FLOAT:
++		*fdst = strtof(ret.addr, NULL);
++		break;
++	}
++	return 0;
+ }
+ 
+ void
+ config_init(void)
+ {
+-    char *resm;
+-    XrmDatabase db;
+-    ResourcePref *p;
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
+ 
+-    XrmInitialize();
+-    resm = XResourceManagerString(xw.dpy);
+-    if (!resm)
+-        return;
++	XrmInitialize();
++	resm = XResourceManagerString(xw.dpy);
++	if (!resm)
++		return;
+ 
+-    db = XrmGetStringDatabase(resm);
+-    for (p = resources; p < resources + LEN(resources); p++)
+-        resource_load(db, p->name, p->type, p->dst);
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LEN(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
+ }
+ 
+ void
+ usage(void)
+ {
+-    die("usage: %s [-aiv] [-c class] [-d path] [-f font] [-g geometry]"
+-            " [-n name] [-o file]\n"
+-            "          [-T title] [-t title] [-w windowid]"
+-            " [[-e] command [args ...]]\n"
+-            "       %s [-aiv] [-c class] [-d path] [-f font] [-g geometry]"
+-            " [-n name] [-o file]\n"
+-            "          [-T title] [-t title] [-w windowid] -l line"
+-            " [stty_args ...]\n", argv0, argv0);
++	die("usage: %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
++	    "          [-T title] [-t title] [-w windowid]"
++	    " [[-e] command [args ...]]\n"
++	    "       %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
++	    "          [-T title] [-t title] [-w windowid] -l line"
++	    " [stty_args ...]\n", argv0, argv0);
+ }
+ 
+ int
+ main(int argc, char *argv[])
+ {
+-    xw.l = xw.t = 0;
+-    xw.isfixed = False;
+-    xsetcursor(cursorshape);
+-
+-    ARGBEGIN {
+-        case 'a':
+-            allowaltscreen = 0;
+-            break;
+-        case 'A':
+-            opt_alpha = EARGF(usage());
+-            break;
+-        case 'c':
+-            opt_class = EARGF(usage());
+-            break;
+-        case 'e':
+-            if (argc > 0)
+-                --argc, ++argv;
+-            goto run;
+-        case 'f':
+-            opt_font = EARGF(usage());
+-            break;
+-        case 'g':
+-            xw.gm = XParseGeometry(EARGF(usage()),
+-                    &xw.l, &xw.t, &cols, &rows);
+-            break;
+-        case 'i':
+-            xw.isfixed = 1;
+-            break;
+-        case 'o':
+-            opt_io = EARGF(usage());
+-            break;
+-        case 'l':
+-            opt_line = EARGF(usage());
+-            break;
+-        case 'n':
+-            opt_name = EARGF(usage());
+-            break;
+-        case 't':
+-        case 'T':
+-            opt_title = EARGF(usage());
+-            break;
+-        case 'w':
+-            opt_embed = EARGF(usage());
+-            break;
+-        case 'v':
+-            die("%s " VERSION "\n", argv0);
+-            break;
+-        case 'd':
+-            opt_dir = EARGF(usage());
+-            break;
+-        default:
+-            usage();
+-    } ARGEND;
++	xw.l = xw.t = 0;
++	xw.isfixed = False;
++	xsetcursor(cursorshape);
++
++	ARGBEGIN {
++	case 'a':
++		allowaltscreen = 0;
++		break;
++	case 'A':
++		alpha = strtof(EARGF(usage()), NULL);
++		LIMIT(alpha, 0.0, 1.0);
++		break;
++	case 'c':
++		opt_class = EARGF(usage());
++		break;
++	case 'e':
++		if (argc > 0)
++			--argc, ++argv;
++		goto run;
++	case 'f':
++		opt_font = EARGF(usage());
++		break;
++	case 'g':
++		xw.gm = XParseGeometry(EARGF(usage()),
++				&xw.l, &xw.t, &cols, &rows);
++		break;
++	case 'i':
++		xw.isfixed = 1;
++		break;
++	case 'o':
++		opt_io = EARGF(usage());
++		break;
++	case 'l':
++		opt_line = EARGF(usage());
++		break;
++	case 'n':
++		opt_name = EARGF(usage());
++		break;
++	case 't':
++	case 'T':
++		opt_title = EARGF(usage());
++		break;
++	case 'w':
++		opt_embed = EARGF(usage());
++		break;
++	case 'v':
++		die("%s " VERSION "\n", argv0);
++		break;
++	case 'd':
++		opt_dir = EARGF(usage());
++		break;
++	default:
++		usage();
++	} ARGEND;
+ 
+ run:
+-    if (argc > 0) /* eat all remaining arguments */
+-        opt_cmd = argv;
+-
+-    if (!opt_title)
+-        opt_title = (opt_line || !opt_cmd) ? "st" : opt_cmd[0];
+-
+-    setlocale(LC_CTYPE, "");
+-    XSetLocaleModifiers("");
+-
+-    if(!(xw.dpy = XOpenDisplay(NULL)))
+-        die("Can't open display\n");
+-
+-    config_init();
+-    cols = MAX(cols, 1);
+-    rows = MAX(rows, 1);
+-    defaultbg = MAX(LEN(colorname), 256);
+-    alphaUnfocus = alpha-alphaOffset;
+-    tnew(cols, rows);
+-    xinit(cols, rows);
+-    xsetenv();
+-    selinit();
+-    chdir(opt_dir);
+-    run();
+-
+-    return 0;
++	if (argc > 0) /* eat all remaining arguments */
++		opt_cmd = argv;
++
++	if (!opt_title)
++		opt_title = (opt_line || !opt_cmd) ? "st" : opt_cmd[0];
++
++	setlocale(LC_CTYPE, "");
++	XSetLocaleModifiers("");
++
++	if(!(xw.dpy = XOpenDisplay(NULL)))
++		die("Can't open display\n");
++
++	config_init();
++	cols = MAX(cols, 1);
++	rows = MAX(rows, 1);
++	tnew(cols, rows);
++	xinit(cols, rows);
++	xsetenv();
++	selinit();
++	chdir(opt_dir);
++	run();
++
++	return 0;
+ }
diff --git a/diff_upstream.diff b/diff_upstream.diff
new file mode 100644
index 0000000..1a716cf
--- /dev/null
+++ b/diff_upstream.diff
@@ -0,0 +1,4184 @@
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..b099942
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1,54 @@
++# Prerequisites
++*.d
++
++# Object files
++*.o
++*.ko
++*.obj
++*.elf
++
++# Linker output
++*.ilk
++*.map
++*.exp
++
++# Precompiled Headers
++*.gch
++*.pch
++
++# Libraries
++*.lib
++*.a
++*.la
++*.lo
++
++# Shared objects (inc. Windows DLLs)
++*.dll
++*.so
++*.so.*
++*.dylib
++
++# Executables
++*.exe
++*.out
++*.app
++*.i*86
++*.x86_64
++*.hex
++
++# Debug files
++*.dSYM/
++*.su
++*.idb
++*.pdb
++
++# Kernel Module Compile Results
++*.mod*
++*.cmd
++.tmp_versions/
++modules.order
++Module.symvers
++Mkfile.old
++dkms.conf
++a.out
++st
+diff --git a/Makefile b/Makefile
+index 15db421..dfcea0f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -4,7 +4,7 @@
+ 
+ include config.mk
+ 
+-SRC = st.c x.c
++SRC = st.c x.c hb.c
+ OBJ = $(SRC:.c=.o)
+ 
+ all: st
+@@ -16,7 +16,8 @@ config.h:
+ 	$(CC) $(STCFLAGS) -c $<
+ 
+ st.o: config.h st.h win.h
+-x.o: arg.h config.h st.h win.h
++x.o: arg.h config.h st.h win.h hb.h
++hb.o: st.h
+ 
+ $(OBJ): config.h config.mk
+ 
+diff --git a/config.def.h b/config.def.h
+index 2cd740a..3ede079 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -6,6 +6,12 @@
+  * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
+  */
+ static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
++/* Spare fonts */
++static char *font2[] = {
++/*	"Inconsolata for Powerline:pixelsize=12:antialias=true:autohint=true", */
++/*	"Hack Nerd Font Mono:pixelsize=11:antialias=true:autohint=true", */
++};
++
+ static int borderpx = 2;
+ 
+ /*
+@@ -93,6 +99,12 @@ char *termname = "st-256color";
+  */
+ unsigned int tabspaces = 8;
+ 
++/* bg opacity */
++float alpha = 0.8;
++
++/* Background opacity */
++float alpha_def;
++
+ /* Terminal colors (16 first used in escape sequence) */
+ static const char *colorname[] = {
+ 	/* 8 normal colors */
+@@ -170,6 +182,42 @@ static unsigned int defaultattr = 11;
+  */
+ static uint forcemousemod = ShiftMask;
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",         STRING,  &font },
++		{ "color0",       STRING,  &colorname[0] },
++		{ "color1",       STRING,  &colorname[1] },
++		{ "color2",       STRING,  &colorname[2] },
++		{ "color3",       STRING,  &colorname[3] },
++		{ "color4",       STRING,  &colorname[4] },
++		{ "color5",       STRING,  &colorname[5] },
++		{ "color6",       STRING,  &colorname[6] },
++		{ "color7",       STRING,  &colorname[7] },
++		{ "color8",       STRING,  &colorname[8] },
++		{ "color9",       STRING,  &colorname[9] },
++		{ "color10",      STRING,  &colorname[10] },
++		{ "color11",      STRING,  &colorname[11] },
++		{ "color12",      STRING,  &colorname[12] },
++		{ "color13",      STRING,  &colorname[13] },
++		{ "color14",      STRING,  &colorname[14] },
++		{ "color15",      STRING,  &colorname[15] },
++		{ "background",   STRING,  &colorname[256] },
++		{ "foreground",   STRING,  &colorname[257] },
++		{ "cursorColor",  STRING,  &colorname[258] },
++		{ "termname",     STRING,  &termname },
++		{ "shell",        STRING,  &shell },
++		{ "minlatency",   INTEGER, &minlatency },
++		{ "maxlatency",   INTEGER, &maxlatency },
++		{ "blinktimeout", INTEGER, &blinktimeout },
++		{ "bellvolume",   INTEGER, &bellvolume },
++		{ "tabspaces",    INTEGER, &tabspaces },
++		{ "borderpx",     INTEGER, &borderpx },
++		{ "cwscale",      FLOAT,   &cwscale },
++		{ "chscale",      FLOAT,   &chscale },
++};
++
+ /*
+  * Internal mouse shortcuts.
+  * Beware that overloading Button1 will disable the selection.
+@@ -201,6 +249,8 @@ static Shortcut shortcuts[] = {
+ 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
+ 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
+ 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
++	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
++    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
+ };
+ 
+ /*
+diff --git a/config.h b/config.h
+new file mode 100644
+index 0000000..b1a6cbb
+--- /dev/null
++++ b/config.h
+@@ -0,0 +1,560 @@
++/* See LICENSE file for copyright and license details. */
++
++/*
++ * appearance
++ *
++ * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
++ */
++/* static char *font = "mono:pixelsize=12:antialias=true:autohint=true"; */
++/* static char *font2[] = { "NotoColorEmoji:pixelsize=10:antialias=true:autohint=true" }; */
++static char *font = "JetBrainsMono Nerd Font:size=11:style=regular:antialias=true:autohint=true";
++/* static char *font2[] = { "JoyPixels:pixelsize=10:antialias=true:autohint=true" }; */
++static char *font2[] = { "JetBrainsMono Nerd Font:size=11:style=regular:antialias=true:autohint=true" };
++/* static int borderpx = 16; */
++static int borderpx = 18;
++
++/*
++ * What program is execed by st depends of these precedence rules:
++ * 1: program passed with -e
++ * 2: scroll and/or utmp
++ * 3: SHELL environment variable
++ * 4: value of shell in /etc/passwd
++ * 5: value of shell in config.h
++ */
++static char *shell = "/bin/sh";
++char *utmp = NULL;
++/* scroll program: to enable use a string like "scroll" */
++char *scroll = NULL;
++char *stty_args = "stty raw pass8 nl -echo -iexten -cstopb 38400";
++
++/* identification sequence returned in DA and DECID */
++char *vtiden = "\033[?6c";
++
++/* Kerning / character bounding-box multipliers */
++static float cwscale = 1.0;
++static float chscale = 1.0;
++
++/*
++ * word delimiter string
++ *
++ * More advanced example: L" `'\"()[]{}"
++ */
++wchar_t *worddelimiters = L" ";
++
++/* selection timeouts (in milliseconds) */
++static unsigned int doubleclicktimeout = 300;
++static unsigned int tripleclicktimeout = 600;
++
++/* alt screens */
++int allowaltscreen = 1;
++
++/* allow certain non-interactive (insecure) window operations such as:
++   setting the clipboard text */
++int allowwindowops = 0;
++
++/*
++ * draw latency range in ms - from new content/keypress/etc until drawing.
++ * within this range, st draws when content stops arriving (idle). mostly it's
++ * near minlatency, but it waits longer for slow updates to avoid partial draw.
++ * low minlatency will tear/flicker more, as it can "detect" idle too early.
++ */
++static double minlatency = 8;
++static double maxlatency = 33;
++
++/*
++ * blinking timeout (set to 0 to disable blinking) for the terminal blinking
++ * attribute.
++ */
++static unsigned int blinktimeout = 800;
++
++/*
++ * thickness of underline and bar cursors
++ */
++static unsigned int cursorthickness = 2;
++
++/*
++ * 1: render most of the lines/blocks characters without using the font for
++ *    perfect alignment between cells (U2500 - U259F except dashes/diagonals).
++ *    Bold affects lines thickness if boxdraw_bold is not 0. Italic is ignored.
++ * 0: disable (render all U25XX glyphs normally from the font).
++ */
++const int boxdraw = 1;
++const int boxdraw_bold = 0;
++
++/* braille (U28XX):  1: render as adjacent "pixels",  0: use font */
++const int boxdraw_braille = 0;
++
++/*
++ * bell volume. It must be a value between -100 and 100. Use 0 for disabling
++ * it
++ */
++static int bellvolume = 0;
++
++/* default TERM value */
++char *termname = "st-256color";
++
++/*
++ * spaces per tab
++ *
++ * When you are changing this value, don't forget to adapt the »it« value in
++ * the st.info and appropriately install the st.info in the environment where
++ * you use this st version.
++ *
++ *	it#$tabspaces,
++ *
++ * Secondly make sure your kernel is not expanding tabs. When running `stty
++ * -a` »tab0« should appear. You can tell the terminal to not expand tabs by
++ *  running following command:
++ *
++ *	stty tabs
++ */
++unsigned int tabspaces = 8;
++
++/* bg opacity */
++float alpha = 1.0;
++float alphaOffset = 0.0;
++float alphaUnfocus;
++
++/* Terminal colors (16 first used in escape sequence) */
++static const char *colorname[] = {
++    "#282828", /* hard contrast: #1d2021 / soft contrast: #32302f */
++    "#cc241d",
++    "#98971a",
++    "#d79921",
++    "#458588",
++    "#b16286",
++    "#689d6a",
++    "#a89984",
++    "#928374",
++    "#fb4934",
++    "#b8bb26",
++    "#fabd2f",
++    "#83a598",
++    "#d3869b",
++    "#8ec07c",
++    "#ebdbb2",
++    [255] = 0,
++    /* more colors can be added after 255 to use with DefaultXX */
++    "#add8e6", /* 256 -> cursor */
++    "#555555", /* 257 -> rev cursor*/
++    "#282828", /* 258 -> bg */
++    "#ebdbb2", /* 259 -> fg */
++    "black", /* 260 -> alphaBg */
++};
++
++/*
++ * Default colors (colorname index)
++ * foreground, background, cursor, reverse cursor
++ */
++unsigned int defaultfg = 259;
++unsigned int defaultbg = 258;
++unsigned int alphaBg = 260;
++unsigned int defaultAlphaBg = 258;
++unsigned int defaultcs = 256;
++unsigned int defaultrcs = 257;
++
++/*
++ * Default shape of cursor
++ * 2: Block ("█")
++ * 4: Underline ("_")
++ * 6: Bar ("|")
++ * 7: Snowman ("☃")
++ */
++static unsigned int cursorshape = 2;
++
++/*
++ * Default columns and rows numbers
++ */
++
++static unsigned int cols = 80;
++static unsigned int rows = 24;
++
++/*
++ * Default colour and shape of the mouse cursor
++ */
++static unsigned int mouseshape = XC_xterm;
++static unsigned int mousefg = 7;
++static unsigned int mousebg = 0;
++
++/*
++ * Color used to display font attributes when fontconfig selected a font which
++ * doesn't match the ones requested.
++ */
++static unsigned int defaultattr = 11;
++
++/*
++ * Force mouse select/shortcuts while mask is active (when MODE_MOUSE is set).
++ * Note that if you want to use ShiftMask with selmasks, set this to an other
++ * modifier, set to 0 to not use it.
++ */
++static uint forcemousemod = ShiftMask;
++
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++    { "font",         STRING,  &font },
++    { "fontalt0",     STRING,  &font2[0] },
++    { "color0",       STRING,  &colorname[0] },
++    { "color1",       STRING,  &colorname[1] },
++    { "color2",       STRING,  &colorname[2] },
++    { "color3",       STRING,  &colorname[3] },
++    { "color4",       STRING,  &colorname[4] },
++    { "color5",       STRING,  &colorname[5] },
++    { "color6",       STRING,  &colorname[6] },
++    { "color7",       STRING,  &colorname[7] },
++    { "color8",       STRING,  &colorname[8] },
++    { "color9",       STRING,  &colorname[9] },
++    { "color10",      STRING,  &colorname[10] },
++    { "color11",      STRING,  &colorname[11] },
++    { "color12",      STRING,  &colorname[12] },
++    { "color13",      STRING,  &colorname[13] },
++    { "color14",      STRING,  &colorname[14] },
++    { "color15",      STRING,  &colorname[15] },
++    { "background",   STRING,  &colorname[258] },
++    { "foreground",   STRING,  &colorname[259] },
++    { "cursorColor",  STRING,  &colorname[256] },
++    { "termname",     STRING,  &termname },
++    { "shell",        STRING,  &shell },
++    { "minlatency",   INTEGER, &minlatency },
++    { "maxlatency",   INTEGER, &maxlatency },
++    { "blinktimeout", INTEGER, &blinktimeout },
++    { "bellvolume",   INTEGER, &bellvolume },
++    { "tabspaces",    INTEGER, &tabspaces },
++    { "borderpx",     INTEGER, &borderpx },
++    { "cwscale",      FLOAT,   &cwscale },
++    { "chscale",      FLOAT,   &chscale },
++    { "alpha",        FLOAT,   &alpha },
++    { "alphaOffset",  FLOAT,   &alphaOffset },
++};
++
++/*
++ * Internal mouse shortcuts.
++ * Beware that overloading Button1 will disable the selection.
++ */
++static MouseShortcut mshortcuts[] = {
++    /* mask                 button   function        argument       release */
++    { XK_NO_MOD,            Button4, kscrollup,      {.i = 1} },
++    { XK_NO_MOD,            Button5, kscrolldown,    {.i = 1} },
++    { XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
++    { ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
++    { XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
++    { ShiftMask,            Button5, ttysend,        {.s = "\033[6;2~"} },
++    { XK_ANY_MOD,           Button5, ttysend,        {.s = "\005"} },
++};
++
++/* Internal keyboard shortcuts. */
++#define MODKEY Mod1Mask
++#define TERMMOD (Mod1Mask|ShiftMask)
++
++static char *openurlcmd[] = { "/bin/sh", "-c", "st-urlhandler -o", "externalpipe", NULL };
++static char *copyurlcmd[] = { "/bin/sh", "-c", "st-urlhandler -c", "externalpipe", NULL };
++static char *copyoutput[] = { "/bin/sh", "-c", "st-copyout", "externalpipe", NULL };
++
++static Shortcut shortcuts[] = {
++    /* mask                 keysym          function        argument */
++    { XK_ANY_MOD,           XK_Break,       sendbreak,      {.i =  0} },
++    { ControlMask,          XK_Print,       toggleprinter,  {.i =  0} },
++    { ShiftMask,            XK_Print,       printscreen,    {.i =  0} },
++    { XK_ANY_MOD,           XK_Print,       printsel,       {.i =  0} },
++    { TERMMOD,              XK_Prior,       zoom,           {.f = +1} },
++    { TERMMOD,              XK_Next,        zoom,           {.f = -1} },
++    { TERMMOD,              XK_Home,        zoomreset,      {.f =  0} },
++    { TERMMOD,              XK_C,           clipcopy,       {.i =  0} },
++    { MODKEY|ControlMask,   XK_c,           clipcopy,       {.i =  0} },
++    { TERMMOD,              XK_V,           clippaste,      {.i =  0} },
++    { ShiftMask,            XK_Insert,      clippaste,      {.i =  0} },
++    { MODKEY,               XK_v,           clippaste,      {.i =  0} },
++    { ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
++    { TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
++    { ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
++    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
++    { MODKEY,               XK_Page_Up,     kscrollup,      {.i = -1} },
++    { MODKEY,               XK_Page_Down,   kscrolldown,    {.i = -1} },
++    { MODKEY,               XK_Up,          kscrollup,      {.i =  1} },
++    { MODKEY,               XK_Down,        kscrolldown,    {.i =  1} },
++    { TERMMOD,				XK_K,           kscrollup,      {.i =  1} },
++    { TERMMOD,				XK_J,           kscrolldown,    {.i =  1} },
++    { TERMMOD,				XK_S,			changealpha,	{.f = -0.05} },
++    { TERMMOD,				XK_A,			changealpha,	{.f = +0.05} },
++    { TERMMOD,              XK_Up,          zoom,           {.f = +1} },
++    { TERMMOD,              XK_Down,        zoom,           {.f = -1} },
++    { ControlMask,			XK_plus,        zoom,           {.f = +1} },
++    { ControlMask,			XK_minus,       zoom,           {.f = -1} },
++    { MODKEY,				XK_plus,        zoom,           {.f = +2} },
++    { MODKEY,				XK_minus,       zoom,           {.f = -2} },
++    { TERMMOD,              XK_L,           externalpipe,   {.v = openurlcmd } },
++    { TERMMOD,              XK_Y,           externalpipe,   {.v = copyurlcmd } },
++    { TERMMOD,              XK_O,           externalpipe,   {.v = copyoutput } },
++};
++
++/*
++ * Special keys (change & recompile st.info accordingly)
++ *
++ * Mask value:
++ * * Use XK_ANY_MOD to match the key no matter modifiers state
++ * * Use XK_NO_MOD to match the key alone (no modifiers)
++ * appkey value:
++ * * 0: no value
++ * * > 0: keypad application mode enabled
++ * *   = 2: term.numlock = 1
++ * * < 0: keypad application mode disabled
++ * appcursor value:
++ * * 0: no value
++ * * > 0: cursor application mode enabled
++ * * < 0: cursor application mode disabled
++ *
++ * Be careful with the order of the definitions because st searches in
++ * this table sequentially, so any XK_ANY_MOD must be in the last
++ * position for a key.
++ */
++
++/*
++ * If you want keys other than the X11 function keys (0xFD00 - 0xFFFF)
++ * to be mapped below, add them to this array.
++ */
++static KeySym mappedkeys[] = { -1 };
++
++/*
++ * State bits to ignore when matching key or button events.  By default,
++ * numlock (Mod2Mask) and keyboard layout (XK_SWITCH_MOD) are ignored.
++ */
++static uint ignoremod = Mod2Mask|XK_SWITCH_MOD;
++
++/*
++ * This is the huge key array which defines all compatibility to the Linux
++ * world. Please decide about changes wisely.
++ */
++static Key key[] = {
++    /* keysym           mask            string      appkey appcursor */
++    { XK_KP_Home,       ShiftMask,      "\033[2J",       0,   -1},
++    { XK_KP_Home,       ShiftMask,      "\033[1;2H",     0,   +1},
++    { XK_KP_Home,       XK_ANY_MOD,     "\033[H",        0,   -1},
++    { XK_KP_Home,       XK_ANY_MOD,     "\033[1~",       0,   +1},
++    { XK_KP_Up,         XK_ANY_MOD,     "\033Ox",       +1,    0},
++    { XK_KP_Up,         XK_ANY_MOD,     "\033[A",        0,   -1},
++    { XK_KP_Up,         XK_ANY_MOD,     "\033OA",        0,   +1},
++    { XK_KP_Down,       XK_ANY_MOD,     "\033Or",       +1,    0},
++    { XK_KP_Down,       XK_ANY_MOD,     "\033[B",        0,   -1},
++    { XK_KP_Down,       XK_ANY_MOD,     "\033OB",        0,   +1},
++    { XK_KP_Left,       XK_ANY_MOD,     "\033Ot",       +1,    0},
++    { XK_KP_Left,       XK_ANY_MOD,     "\033[D",        0,   -1},
++    { XK_KP_Left,       XK_ANY_MOD,     "\033OD",        0,   +1},
++    { XK_KP_Right,      XK_ANY_MOD,     "\033Ov",       +1,    0},
++    { XK_KP_Right,      XK_ANY_MOD,     "\033[C",        0,   -1},
++    { XK_KP_Right,      XK_ANY_MOD,     "\033OC",        0,   +1},
++    { XK_KP_Prior,      ShiftMask,      "\033[5;2~",     0,    0},
++    { XK_KP_Prior,      XK_ANY_MOD,     "\033[5~",       0,    0},
++    { XK_KP_Begin,      XK_ANY_MOD,     "\033[E",        0,    0},
++    { XK_KP_End,        ControlMask,    "\033[J",       -1,    0},
++    { XK_KP_End,        ControlMask,    "\033[1;5F",    +1,    0},
++    { XK_KP_End,        ShiftMask,      "\033[K",       -1,    0},
++    { XK_KP_End,        ShiftMask,      "\033[1;2F",    +1,    0},
++    { XK_KP_End,        XK_ANY_MOD,     "\033[4~",       0,    0},
++    { XK_KP_Next,       ShiftMask,      "\033[6;2~",     0,    0},
++    { XK_KP_Next,       XK_ANY_MOD,     "\033[6~",       0,    0},
++    { XK_KP_Insert,     ShiftMask,      "\033[2;2~",    +1,    0},
++    { XK_KP_Insert,     ShiftMask,      "\033[4l",      -1,    0},
++    { XK_KP_Insert,     ControlMask,    "\033[L",       -1,    0},
++    { XK_KP_Insert,     ControlMask,    "\033[2;5~",    +1,    0},
++    { XK_KP_Insert,     XK_ANY_MOD,     "\033[4h",      -1,    0},
++    { XK_KP_Insert,     XK_ANY_MOD,     "\033[2~",      +1,    0},
++    { XK_KP_Delete,     ControlMask,    "\033[M",       -1,    0},
++    { XK_KP_Delete,     ControlMask,    "\033[3;5~",    +1,    0},
++    { XK_KP_Delete,     ShiftMask,      "\033[2K",      -1,    0},
++    { XK_KP_Delete,     ShiftMask,      "\033[3;2~",    +1,    0},
++    { XK_KP_Delete,     XK_ANY_MOD,     "\033[P",       -1,    0},
++    { XK_KP_Delete,     XK_ANY_MOD,     "\033[3~",      +1,    0},
++    { XK_KP_Multiply,   XK_ANY_MOD,     "\033Oj",       +2,    0},
++    { XK_KP_Add,        XK_ANY_MOD,     "\033Ok",       +2,    0},
++    { XK_KP_Enter,      XK_ANY_MOD,     "\033OM",       +2,    0},
++    { XK_KP_Enter,      XK_ANY_MOD,     "\r",           -1,    0},
++    { XK_KP_Subtract,   XK_ANY_MOD,     "\033Om",       +2,    0},
++    { XK_KP_Decimal,    XK_ANY_MOD,     "\033On",       +2,    0},
++    { XK_KP_Divide,     XK_ANY_MOD,     "\033Oo",       +2,    0},
++    { XK_KP_0,          XK_ANY_MOD,     "\033Op",       +2,    0},
++    { XK_KP_1,          XK_ANY_MOD,     "\033Oq",       +2,    0},
++    { XK_KP_2,          XK_ANY_MOD,     "\033Or",       +2,    0},
++    { XK_KP_3,          XK_ANY_MOD,     "\033Os",       +2,    0},
++    { XK_KP_4,          XK_ANY_MOD,     "\033Ot",       +2,    0},
++    { XK_KP_5,          XK_ANY_MOD,     "\033Ou",       +2,    0},
++    { XK_KP_6,          XK_ANY_MOD,     "\033Ov",       +2,    0},
++    { XK_KP_7,          XK_ANY_MOD,     "\033Ow",       +2,    0},
++    { XK_KP_8,          XK_ANY_MOD,     "\033Ox",       +2,    0},
++    { XK_KP_9,          XK_ANY_MOD,     "\033Oy",       +2,    0},
++    { XK_Up,            ShiftMask,      "\033[1;2A",     0,    0},
++    { XK_Up,            Mod1Mask,       "\033[1;3A",     0,    0},
++    { XK_Up,         ShiftMask|Mod1Mask,"\033[1;4A",     0,    0},
++    { XK_Up,            ControlMask,    "\033[1;5A",     0,    0},
++    { XK_Up,      ShiftMask|ControlMask,"\033[1;6A",     0,    0},
++    { XK_Up,       ControlMask|Mod1Mask,"\033[1;7A",     0,    0},
++    { XK_Up,ShiftMask|ControlMask|Mod1Mask,"\033[1;8A",  0,    0},
++    { XK_Up,            XK_ANY_MOD,     "\033[A",        0,   -1},
++    { XK_Up,            XK_ANY_MOD,     "\033OA",        0,   +1},
++    { XK_Down,          ShiftMask,      "\033[1;2B",     0,    0},
++    { XK_Down,          Mod1Mask,       "\033[1;3B",     0,    0},
++    { XK_Down,       ShiftMask|Mod1Mask,"\033[1;4B",     0,    0},
++    { XK_Down,          ControlMask,    "\033[1;5B",     0,    0},
++    { XK_Down,    ShiftMask|ControlMask,"\033[1;6B",     0,    0},
++    { XK_Down,     ControlMask|Mod1Mask,"\033[1;7B",     0,    0},
++    { XK_Down,ShiftMask|ControlMask|Mod1Mask,"\033[1;8B",0,    0},
++    { XK_Down,          XK_ANY_MOD,     "\033[B",        0,   -1},
++    { XK_Down,          XK_ANY_MOD,     "\033OB",        0,   +1},
++    { XK_Left,          ShiftMask,      "\033[1;2D",     0,    0},
++    { XK_Left,          Mod1Mask,       "\033[1;3D",     0,    0},
++    { XK_Left,       ShiftMask|Mod1Mask,"\033[1;4D",     0,    0},
++    { XK_Left,          ControlMask,    "\033[1;5D",     0,    0},
++    { XK_Left,    ShiftMask|ControlMask,"\033[1;6D",     0,    0},
++    { XK_Left,     ControlMask|Mod1Mask,"\033[1;7D",     0,    0},
++    { XK_Left,ShiftMask|ControlMask|Mod1Mask,"\033[1;8D",0,    0},
++    { XK_Left,          XK_ANY_MOD,     "\033[D",        0,   -1},
++    { XK_Left,          XK_ANY_MOD,     "\033OD",        0,   +1},
++    { XK_Right,         ShiftMask,      "\033[1;2C",     0,    0},
++    { XK_Right,         Mod1Mask,       "\033[1;3C",     0,    0},
++    { XK_Right,      ShiftMask|Mod1Mask,"\033[1;4C",     0,    0},
++    { XK_Right,         ControlMask,    "\033[1;5C",     0,    0},
++    { XK_Right,   ShiftMask|ControlMask,"\033[1;6C",     0,    0},
++    { XK_Right,    ControlMask|Mod1Mask,"\033[1;7C",     0,    0},
++    { XK_Right,ShiftMask|ControlMask|Mod1Mask,"\033[1;8C",0,   0},
++    { XK_Right,         XK_ANY_MOD,     "\033[C",        0,   -1},
++    { XK_Right,         XK_ANY_MOD,     "\033OC",        0,   +1},
++    { XK_ISO_Left_Tab,  ShiftMask,      "\033[Z",        0,    0},
++    { XK_Return,        Mod1Mask,       "\033\r",        0,    0},
++    { XK_Return,        XK_ANY_MOD,     "\r",            0,    0},
++    { XK_Insert,        ShiftMask,      "\033[4l",      -1,    0},
++    { XK_Insert,        ShiftMask,      "\033[2;2~",    +1,    0},
++    { XK_Insert,        ControlMask,    "\033[L",       -1,    0},
++    { XK_Insert,        ControlMask,    "\033[2;5~",    +1,    0},
++    { XK_Insert,        XK_ANY_MOD,     "\033[4h",      -1,    0},
++    { XK_Insert,        XK_ANY_MOD,     "\033[2~",      +1,    0},
++    { XK_Delete,        ControlMask,    "\033[M",       -1,    0},
++    { XK_Delete,        ControlMask,    "\033[3;5~",    +1,    0},
++    { XK_Delete,        ShiftMask,      "\033[2K",      -1,    0},
++    { XK_Delete,        ShiftMask,      "\033[3;2~",    +1,    0},
++    { XK_Delete,        XK_ANY_MOD,     "\033[P",       -1,    0},
++    { XK_Delete,        XK_ANY_MOD,     "\033[3~",      +1,    0},
++    { XK_BackSpace,     XK_NO_MOD,      "\177",          0,    0},
++    { XK_BackSpace,     Mod1Mask,       "\033\177",      0,    0},
++    { XK_Home,          ShiftMask,      "\033[2J",       0,   -1},
++    { XK_Home,          ShiftMask,      "\033[1;2H",     0,   +1},
++    { XK_Home,          XK_ANY_MOD,     "\033[H",        0,   -1},
++    { XK_Home,          XK_ANY_MOD,     "\033[1~",       0,   +1},
++    { XK_End,           ControlMask,    "\033[J",       -1,    0},
++    { XK_End,           ControlMask,    "\033[1;5F",    +1,    0},
++    { XK_End,           ShiftMask,      "\033[K",       -1,    0},
++    { XK_End,           ShiftMask,      "\033[1;2F",    +1,    0},
++    { XK_End,           XK_ANY_MOD,     "\033[4~",       0,    0},
++    { XK_Prior,         ControlMask,    "\033[5;5~",     0,    0},
++    { XK_Prior,         ShiftMask,      "\033[5;2~",     0,    0},
++    { XK_Prior,         XK_ANY_MOD,     "\033[5~",       0,    0},
++    { XK_Next,          ControlMask,    "\033[6;5~",     0,    0},
++    { XK_Next,          ShiftMask,      "\033[6;2~",     0,    0},
++    { XK_Next,          XK_ANY_MOD,     "\033[6~",       0,    0},
++    { XK_F1,            XK_NO_MOD,      "\033OP" ,       0,    0},
++    { XK_F1, /* F13 */  ShiftMask,      "\033[1;2P",     0,    0},
++    { XK_F1, /* F25 */  ControlMask,    "\033[1;5P",     0,    0},
++    { XK_F1, /* F37 */  Mod4Mask,       "\033[1;6P",     0,    0},
++    { XK_F1, /* F49 */  Mod1Mask,       "\033[1;3P",     0,    0},
++    { XK_F1, /* F61 */  Mod3Mask,       "\033[1;4P",     0,    0},
++    { XK_F2,            XK_NO_MOD,      "\033OQ" ,       0,    0},
++    { XK_F2, /* F14 */  ShiftMask,      "\033[1;2Q",     0,    0},
++    { XK_F2, /* F26 */  ControlMask,    "\033[1;5Q",     0,    0},
++    { XK_F2, /* F38 */  Mod4Mask,       "\033[1;6Q",     0,    0},
++    { XK_F2, /* F50 */  Mod1Mask,       "\033[1;3Q",     0,    0},
++    { XK_F2, /* F62 */  Mod3Mask,       "\033[1;4Q",     0,    0},
++    { XK_F3,            XK_NO_MOD,      "\033OR" ,       0,    0},
++    { XK_F3, /* F15 */  ShiftMask,      "\033[1;2R",     0,    0},
++    { XK_F3, /* F27 */  ControlMask,    "\033[1;5R",     0,    0},
++    { XK_F3, /* F39 */  Mod4Mask,       "\033[1;6R",     0,    0},
++    { XK_F3, /* F51 */  Mod1Mask,       "\033[1;3R",     0,    0},
++    { XK_F3, /* F63 */  Mod3Mask,       "\033[1;4R",     0,    0},
++    { XK_F4,            XK_NO_MOD,      "\033OS" ,       0,    0},
++    { XK_F4, /* F16 */  ShiftMask,      "\033[1;2S",     0,    0},
++    { XK_F4, /* F28 */  ControlMask,    "\033[1;5S",     0,    0},
++    { XK_F4, /* F40 */  Mod4Mask,       "\033[1;6S",     0,    0},
++    { XK_F4, /* F52 */  Mod1Mask,       "\033[1;3S",     0,    0},
++    { XK_F5,            XK_NO_MOD,      "\033[15~",      0,    0},
++    { XK_F5, /* F17 */  ShiftMask,      "\033[15;2~",    0,    0},
++    { XK_F5, /* F29 */  ControlMask,    "\033[15;5~",    0,    0},
++    { XK_F5, /* F41 */  Mod4Mask,       "\033[15;6~",    0,    0},
++    { XK_F5, /* F53 */  Mod1Mask,       "\033[15;3~",    0,    0},
++    { XK_F6,            XK_NO_MOD,      "\033[17~",      0,    0},
++    { XK_F6, /* F18 */  ShiftMask,      "\033[17;2~",    0,    0},
++    { XK_F6, /* F30 */  ControlMask,    "\033[17;5~",    0,    0},
++    { XK_F6, /* F42 */  Mod4Mask,       "\033[17;6~",    0,    0},
++    { XK_F6, /* F54 */  Mod1Mask,       "\033[17;3~",    0,    0},
++    { XK_F7,            XK_NO_MOD,      "\033[18~",      0,    0},
++    { XK_F7, /* F19 */  ShiftMask,      "\033[18;2~",    0,    0},
++    { XK_F7, /* F31 */  ControlMask,    "\033[18;5~",    0,    0},
++    { XK_F7, /* F43 */  Mod4Mask,       "\033[18;6~",    0,    0},
++    { XK_F7, /* F55 */  Mod1Mask,       "\033[18;3~",    0,    0},
++    { XK_F8,            XK_NO_MOD,      "\033[19~",      0,    0},
++    { XK_F8, /* F20 */  ShiftMask,      "\033[19;2~",    0,    0},
++    { XK_F8, /* F32 */  ControlMask,    "\033[19;5~",    0,    0},
++    { XK_F8, /* F44 */  Mod4Mask,       "\033[19;6~",    0,    0},
++    { XK_F8, /* F56 */  Mod1Mask,       "\033[19;3~",    0,    0},
++    { XK_F9,            XK_NO_MOD,      "\033[20~",      0,    0},
++    { XK_F9, /* F21 */  ShiftMask,      "\033[20;2~",    0,    0},
++    { XK_F9, /* F33 */  ControlMask,    "\033[20;5~",    0,    0},
++    { XK_F9, /* F45 */  Mod4Mask,       "\033[20;6~",    0,    0},
++    { XK_F9, /* F57 */  Mod1Mask,       "\033[20;3~",    0,    0},
++    { XK_F10,           XK_NO_MOD,      "\033[21~",      0,    0},
++    { XK_F10, /* F22 */ ShiftMask,      "\033[21;2~",    0,    0},
++    { XK_F10, /* F34 */ ControlMask,    "\033[21;5~",    0,    0},
++    { XK_F10, /* F46 */ Mod4Mask,       "\033[21;6~",    0,    0},
++    { XK_F10, /* F58 */ Mod1Mask,       "\033[21;3~",    0,    0},
++    { XK_F11,           XK_NO_MOD,      "\033[23~",      0,    0},
++    { XK_F11, /* F23 */ ShiftMask,      "\033[23;2~",    0,    0},
++    { XK_F11, /* F35 */ ControlMask,    "\033[23;5~",    0,    0},
++    { XK_F11, /* F47 */ Mod4Mask,       "\033[23;6~",    0,    0},
++    { XK_F11, /* F59 */ Mod1Mask,       "\033[23;3~",    0,    0},
++    { XK_F12,           XK_NO_MOD,      "\033[24~",      0,    0},
++    { XK_F12, /* F24 */ ShiftMask,      "\033[24;2~",    0,    0},
++    { XK_F12, /* F36 */ ControlMask,    "\033[24;5~",    0,    0},
++    { XK_F12, /* F48 */ Mod4Mask,       "\033[24;6~",    0,    0},
++    { XK_F12, /* F60 */ Mod1Mask,       "\033[24;3~",    0,    0},
++    { XK_F13,           XK_NO_MOD,      "\033[1;2P",     0,    0},
++    { XK_F14,           XK_NO_MOD,      "\033[1;2Q",     0,    0},
++    { XK_F15,           XK_NO_MOD,      "\033[1;2R",     0,    0},
++    { XK_F16,           XK_NO_MOD,      "\033[1;2S",     0,    0},
++    { XK_F17,           XK_NO_MOD,      "\033[15;2~",    0,    0},
++    { XK_F18,           XK_NO_MOD,      "\033[17;2~",    0,    0},
++    { XK_F19,           XK_NO_MOD,      "\033[18;2~",    0,    0},
++    { XK_F20,           XK_NO_MOD,      "\033[19;2~",    0,    0},
++    { XK_F21,           XK_NO_MOD,      "\033[20;2~",    0,    0},
++    { XK_F22,           XK_NO_MOD,      "\033[21;2~",    0,    0},
++    { XK_F23,           XK_NO_MOD,      "\033[23;2~",    0,    0},
++    { XK_F24,           XK_NO_MOD,      "\033[24;2~",    0,    0},
++    { XK_F25,           XK_NO_MOD,      "\033[1;5P",     0,    0},
++    { XK_F26,           XK_NO_MOD,      "\033[1;5Q",     0,    0},
++    { XK_F27,           XK_NO_MOD,      "\033[1;5R",     0,    0},
++    { XK_F28,           XK_NO_MOD,      "\033[1;5S",     0,    0},
++    { XK_F29,           XK_NO_MOD,      "\033[15;5~",    0,    0},
++    { XK_F30,           XK_NO_MOD,      "\033[17;5~",    0,    0},
++    { XK_F31,           XK_NO_MOD,      "\033[18;5~",    0,    0},
++    { XK_F32,           XK_NO_MOD,      "\033[19;5~",    0,    0},
++    { XK_F33,           XK_NO_MOD,      "\033[20;5~",    0,    0},
++    { XK_F34,           XK_NO_MOD,      "\033[21;5~",    0,    0},
++    { XK_F35,           XK_NO_MOD,      "\033[23;5~",    0,    0},
++};
++
++/*
++ * Selection types' masks.
++ * Use the same masks as usual.
++ * Button1Mask is always unset, to make masks match between ButtonPress.
++ * ButtonRelease and MotionNotify.
++ * If no match is found, regular selection is used.
++ */
++static uint selmasks[] = {
++    [SEL_RECTANGULAR] = Mod1Mask,
++};
++
++/*
++ * Printable characters in ASCII, used to estimate the advance width
++ * of single wide characters.
++ */
++static char ascii_printable[] =
++" !\"#$%&'()*+,-./0123456789:;<=>?"
++"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
++"`abcdefghijklmnopqrstuvwxyz{|}~";
++
+diff --git a/config.mk b/config.mk
+index fdc29a7..b6458af 100644
+--- a/config.mk
++++ b/config.mk
+@@ -15,10 +15,12 @@ PKG_CONFIG = pkg-config
+ # includes and libs
+ INCS = -I$(X11INC) \
+        `$(PKG_CONFIG) --cflags fontconfig` \
+-       `$(PKG_CONFIG) --cflags freetype2`
+-LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft \
++       `$(PKG_CONFIG) --cflags freetype2` \
++       `$(PKG_CONFIG) --cflags harfbuzz`
++LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender \
+        `$(PKG_CONFIG) --libs fontconfig` \
+-       `$(PKG_CONFIG) --libs freetype2`
++       `$(PKG_CONFIG) --libs freetype2` \
++       `$(PKG_CONFIG) --libs harfbuzz`
+ 
+ # flags
+ STCPPFLAGS = -DVERSION=\"$(VERSION)\" -D_XOPEN_SOURCE=600
+diff --git a/hb.c b/hb.c
+new file mode 100644
+index 0000000..99412c8
+--- /dev/null
++++ b/hb.c
+@@ -0,0 +1,125 @@
++#include <stdlib.h>
++#include <stdio.h>
++#include <math.h>
++#include <X11/Xft/Xft.h>
++#include <X11/cursorfont.h>
++#include <hb.h>
++#include <hb-ft.h>
++
++#include "st.h"
++#include "hb.h"
++
++#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
++#define BUFFER_STEP 256
++
++hb_font_t *hbfindfont(XftFont *match);
++
++typedef struct {
++	XftFont *match;
++	hb_font_t *font;
++} HbFontMatch;
++
++typedef struct {
++	size_t capacity;
++	HbFontMatch *fonts;
++} HbFontCache;
++
++static HbFontCache hbfontcache = { 0, NULL };
++
++typedef struct {
++	size_t capacity;
++	Rune *runes;
++} RuneBuffer;
++
++static RuneBuffer hbrunebuffer = { 0, NULL };
++
++/*
++ * Poplulate the array with a list of font features, wrapped in FEATURE macro,
++ * e. g.
++ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
++ */
++hb_feature_t features[] = { };
++
++void
++hbunloadfonts()
++{
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		hb_font_destroy(hbfontcache.fonts[i].font);
++		XftUnlockFace(hbfontcache.fonts[i].match);
++	}
++
++	if (hbfontcache.fonts != NULL) {
++		free(hbfontcache.fonts);
++		hbfontcache.fonts = NULL;
++	}
++	hbfontcache.capacity = 0;
++}
++
++hb_font_t *
++hbfindfont(XftFont *match)
++{
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		if (hbfontcache.fonts[i].match == match)
++			return hbfontcache.fonts[i].font;
++	}
++
++	/* Font not found in cache, caching it now. */
++	hbfontcache.fonts = realloc(hbfontcache.fonts, sizeof(HbFontMatch) * (hbfontcache.capacity + 1));
++	FT_Face face = XftLockFace(match);
++	hb_font_t *font = hb_ft_font_create(face, NULL);
++	if (font == NULL)
++		die("Failed to load Harfbuzz font.");
++
++	hbfontcache.fonts[hbfontcache.capacity].match = match;
++	hbfontcache.fonts[hbfontcache.capacity].font = font;
++	hbfontcache.capacity += 1;
++
++	return font;
++}
++
++void hbtransform(HbTransformData *data, XftFont *xfont, const Glyph *glyphs, int start, int length) {
++	ushort mode = USHRT_MAX;
++	unsigned int glyph_count;
++	int rune_idx, glyph_idx, end = start + length;
++
++	hb_font_t *font = hbfindfont(xfont);
++	if (font == NULL)
++		return;
++
++	hb_buffer_t *buffer = hb_buffer_create();
++	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
++	hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
++
++	/* Resize the buffer if required length is larger. */
++	if (hbrunebuffer.capacity < length) {
++		hbrunebuffer.capacity = (length / BUFFER_STEP + 1) * BUFFER_STEP;
++		hbrunebuffer.runes = realloc(hbrunebuffer.runes, hbrunebuffer.capacity * sizeof(Rune));
++	}
++
++	/* Fill buffer with codepoints. */
++	for (rune_idx = 0, glyph_idx = start; glyph_idx < end; glyph_idx++, rune_idx++) {
++		hbrunebuffer.runes[rune_idx] = glyphs[glyph_idx].u;
++		mode = glyphs[glyph_idx].mode;
++		if (mode & ATTR_WDUMMY)
++			hbrunebuffer.runes[rune_idx] = 0x0020;
++	}
++	hb_buffer_add_codepoints(buffer, hbrunebuffer.runes, length, 0, length);
++
++	/* Shape the segment. */
++	hb_shape(font, buffer, features, sizeof(features)/sizeof(hb_feature_t));
++
++	/* Get new glyph info. */
++	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
++	hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);
++
++	/* Fill the output. */
++	data->buffer = buffer;
++	data->glyphs = info;
++	data->positions = pos;
++	data->count = glyph_count;
++}
++
++void hbcleanup(HbTransformData *data) {
++	hb_buffer_destroy(data->buffer);
++	memset(data, 0, sizeof(HbTransformData));
++}
+diff --git a/hb.h b/hb.h
+new file mode 100644
+index 0000000..3b0ef44
+--- /dev/null
++++ b/hb.h
+@@ -0,0 +1,14 @@
++#include <X11/Xft/Xft.h>
++#include <hb.h>
++#include <hb-ft.h>
++
++typedef struct {
++	hb_buffer_t *buffer;
++	hb_glyph_info_t *glyphs;
++	hb_glyph_position_t *positions;
++	unsigned int count;
++} HbTransformData;
++
++void hbunloadfonts();
++void hbtransform(HbTransformData *, XftFont *, const Glyph *, int, int);
++void hbcleanup(HbTransformData *);
+diff --git a/patches/get.sh b/patches/get.sh
+new file mode 100755
+index 0000000..6569b6b
+--- /dev/null
++++ b/patches/get.sh
+@@ -0,0 +1,57 @@
++# Example
++# https://dwm.suckless.org/patches/alpha/
++# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
++# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
++# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
++# exit 0
++
++download_if_not_exists() {
++  local url="$1"
++  local filename=$(basename "$url") # Extract the file name from the URL
++
++  # Check if the file already exists
++  if [[ -f "$filename" ]]; then
++    echo "File '$filename' already exists. Skipping download."
++  else
++    echo "Downloading '$filename'..."
++    curl -O "$url"
++    if [[ $? -eq 0 ]]; then
++      echo "Downloaded '$filename' successfully."
++    else
++      echo "Failed to download '$filename'."
++    fi
++  fi
++}
++
++# https://st.suckless.org/patches/font2/
++download_if_not_exists https://st.suckless.org/patches/font2/st-font2-0.8.5.diff
++
++# https://st.suckless.org/patches/scrollback/
++download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-0.9.2.diff
++download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-mouse-0.9.2.diff
++# More efficient scrolling
++#download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-ringbuffer-0.9.2.diff
++
++# https://st.suckless.org/patches/xresources/
++download_if_not_exists https://st.suckless.org/patches/xresources/st-xresources-20200604-9ba7ecf.diff
++
++# https://st.suckless.org/patches/alpha/
++download_if_not_exists https://st.suckless.org/patches/alpha/st-alpha-20240814-a0274bc.diff
++
++# https://st.suckless.org/patches/ligatures/
++download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
++#download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-alpha-scrollback-ringbuffer-20240427-0.9.2.diff
++#download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-boxdraw-20240427-0.9.2.diff
++
++# https://st.suckless.org/patches/boxdraw/
++#download_if_not_exists https://st.suckless.org/patches/boxdraw/st-boxdraw_v2-0.8.5.diff
++
++# https://st.suckless.org/patches/workingdir/
++download_if_not_exists https://st.suckless.org/patches/workingdir/st-workingdir-20200317-51e19ea.diff
++
++# https://st.suckless.org/patches/changealpha/
++download_if_not_exists https://st.suckless.org/patches/changealpha/st-changealpha-20230519-b44f2ad.diff
++
++# https://st.suckless.org/patches/externalpipe/
++download_if_not_exists https://st.suckless.org/patches/externalpipe/st-externalpipe-0.8.5.diff
++
+diff --git a/patches/st-alpha-20240814-a0274bc.diff b/patches/st-alpha-20240814-a0274bc.diff
+new file mode 100644
+index 0000000..6913d19
+--- /dev/null
++++ b/patches/st-alpha-20240814-a0274bc.diff
+@@ -0,0 +1,129 @@
++diff --git a/config.def.h b/config.def.h
++index 2cd740a..019a4e1 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -93,6 +93,9 @@ char *termname = "st-256color";
++  */
++ unsigned int tabspaces = 8;
++ 
+++/* bg opacity */
+++float alpha = 0.8;
+++
++ /* Terminal colors (16 first used in escape sequence) */
++ static const char *colorname[] = {
++ 	/* 8 normal colors */
++diff --git a/x.c b/x.c
++index d73152b..f32fd6c 100644
++--- a/x.c
+++++ b/x.c
++@@ -105,6 +105,7 @@ typedef struct {
++ 	XSetWindowAttributes attrs;
++ 	int scr;
++ 	int isfixed; /* is fixed geometry? */
+++	int depth; /* bit depth */
++ 	int l, t; /* left and top offset */
++ 	int gm; /* geometry mask */
++ } XWindow;
++@@ -752,7 +753,7 @@ xresize(int col, int row)
++ 
++ 	XFreePixmap(xw.dpy, xw.buf);
++ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++-			DefaultDepth(xw.dpy, xw.scr));
+++			xw.depth);
++ 	XftDrawChange(xw.draw, xw.buf);
++ 	xclear(0, 0, win.w, win.h);
++ 
++@@ -812,6 +813,10 @@ xloadcols(void)
++ 			else
++ 				die("could not allocate color %d\n", i);
++ 		}
+++
+++	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
+++	dc.col[defaultbg].pixel &= 0x00FFFFFF;
+++	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++ 	loaded = 1;
++ }
++ 
++@@ -842,6 +847,12 @@ xsetcolorname(int x, const char *name)
++ 	XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
++ 	dc.col[x] = ncolor;
++ 
+++	if (x == defaultbg) {
+++		dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
+++		dc.col[defaultbg].pixel &= 0x00FFFFFF;
+++		dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
+++	}
+++
++ 	return 0;
++ }
++ 
++@@ -1134,11 +1145,25 @@ xinit(int cols, int rows)
++ 	Window parent, root;
++ 	pid_t thispid = getpid();
++ 	XColor xmousefg, xmousebg;
+++	XWindowAttributes attr;
+++	XVisualInfo vis;
++ 
++ 	if (!(xw.dpy = XOpenDisplay(NULL)))
++ 		die("can't open display\n");
++ 	xw.scr = XDefaultScreen(xw.dpy);
++-	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
+++
+++	root = XRootWindow(xw.dpy, xw.scr);
+++	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
+++		parent = root;
+++
+++	if (XMatchVisualInfo(xw.dpy, xw.scr, 32, TrueColor, &vis) != 0) {
+++		xw.vis = vis.visual;
+++		xw.depth = vis.depth;
+++	} else {
+++		XGetWindowAttributes(xw.dpy, parent, &attr);
+++		xw.vis = attr.visual;
+++		xw.depth = attr.depth;
+++	}
++ 
++ 	/* font */
++ 	if (!FcInit())
++@@ -1148,7 +1173,7 @@ xinit(int cols, int rows)
++ 	xloadfonts(usedfont, 0);
++ 
++ 	/* colors */
++-	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
+++	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
++ 	xloadcols();
++ 
++ 	/* adjust fixed window geometry */
++@@ -1168,11 +1193,8 @@ xinit(int cols, int rows)
++ 		| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
++ 	xw.attrs.colormap = xw.cmap;
++ 
++-	root = XRootWindow(xw.dpy, xw.scr);
++-	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
++-		parent = root;
++-	xw.win = XCreateWindow(xw.dpy, root, xw.l, xw.t,
++-			win.w, win.h, 0, XDefaultDepth(xw.dpy, xw.scr), InputOutput,
+++	xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
+++			win.w, win.h, 0, xw.depth, InputOutput,
++ 			xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
++ 			| CWEventMask | CWColormap, &xw.attrs);
++ 	if (parent != root)
++@@ -1183,7 +1205,7 @@ xinit(int cols, int rows)
++ 	dc.gc = XCreateGC(xw.dpy, xw.win, GCGraphicsExposures,
++ 			&gcvalues);
++ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
++-			DefaultDepth(xw.dpy, xw.scr));
+++			xw.depth);
++ 	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
++ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
++ 
++@@ -2047,6 +2069,10 @@ main(int argc, char *argv[])
++ 	case 'a':
++ 		allowaltscreen = 0;
++ 		break;
+++	case 'A':
+++		alpha = strtof(EARGF(usage()), NULL);
+++		LIMIT(alpha, 0.0, 1.0);
+++		break;
++ 	case 'c':
++ 		opt_class = EARGF(usage());
++ 		break;
+diff --git a/patches/st-changealpha-20230519-b44f2ad.diff b/patches/st-changealpha-20230519-b44f2ad.diff
+new file mode 100644
+index 0000000..172969f
+--- /dev/null
++++ b/patches/st-changealpha-20230519-b44f2ad.diff
+@@ -0,0 +1,80 @@
++diff --git a/config.def.h b/config.def.h
++index 91ab8ca..8a06176 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -93,6 +93,9 @@ char *termname = "st-256color";
++  */
++ unsigned int tabspaces = 8;
++ 
+++/* Background opacity */
+++float alpha_def;
+++
++ /* Terminal colors (16 first used in escape sequence) */
++ static const char *colorname[] = {
++ 	/* 8 normal colors */
++@@ -201,6 +204,9 @@ static Shortcut shortcuts[] = {
++ 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
++ 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
++ 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+++	{ MODKEY,               XK_bracketleft, chgalpha,       {.f = -1} }, /* Decrease opacity */
+++	{ MODKEY|ShiftMask,     XK_braceright,  chgalpha,       {.f = +1} }, /* Increase opacity */
+++	{ MODKEY,               XK_bracketright,chgalpha,       {.f =  0} }, /* Reset opacity */
++ };
++ 
++ /*
++diff --git a/st.h b/st.h
++index fd3b0d8..3bb587e 100644
++--- a/st.h
+++++ b/st.h
++@@ -124,3 +124,4 @@ extern unsigned int tabspaces;
++ extern unsigned int defaultfg;
++ extern unsigned int defaultbg;
++ extern unsigned int defaultcs;
+++extern float alpha_def;
++diff --git a/x.c b/x.c
++index aa09997..f8c8c1a 100644
++--- a/x.c
+++++ b/x.c
++@@ -59,6 +59,7 @@ static void zoom(const Arg *);
++ static void zoomabs(const Arg *);
++ static void zoomreset(const Arg *);
++ static void ttysend(const Arg *);
+++static void chgalpha(const Arg *);
++ 
++ /* config.h for applying patches and the configuration. */
++ #include "config.h"
++@@ -1147,6 +1148,9 @@ xinit(int cols, int rows)
++ 	usedfont = (opt_font == NULL)? font : opt_font;
++ 	xloadfonts(usedfont, 0);
++ 
+++   /* Backup default alpha value */
+++   alpha_def = alpha;
+++
++ 	/* colors */
++ 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
++ 	xloadcols();
++@@ -1371,6 +1375,24 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
++ 	return numspecs;
++ }
++ 
+++void
+++chgalpha(const Arg *arg)
+++{
+++   if (arg->f == -1.0f && alpha >= 0.1f)
+++      alpha -= 0.1f;
+++   else if (arg->f == 1.0f && alpha < 1.0f)
+++      alpha += 0.1f;
+++   else if (arg->f == 0.0f)
+++      alpha = alpha_def;
+++   else
+++      return;
+++
+++   dc.col[defaultbg].color.alpha = (unsigned short)(0xFFFF * alpha);
+++   /* Required to remove artifacting from borderpx */
+++   cresize(0, 0);
+++   redraw();
+++}
+++
++ void
++ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
++ {
+diff --git a/patches/st-externalpipe-0.8.5.diff b/patches/st-externalpipe-0.8.5.diff
+new file mode 100644
+index 0000000..daf91d3
+--- /dev/null
++++ b/patches/st-externalpipe-0.8.5.diff
+@@ -0,0 +1,104 @@
++diff --git a/st.c b/st.c
++index 034954d..98f2589 100644
++--- a/st.c
+++++ b/st.c
++@@ -718,8 +718,14 @@ sigchld(int a)
++ 	if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
++ 		die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
++ 
++-	if (pid != p)
+++	if (pid != p) {
+++		if (p == 0 && wait(&stat) < 0)
+++			die("wait: %s\n", strerror(errno));
+++
+++		/* reinstall sigchld handler */
+++		signal(SIGCHLD, sigchld);
++ 		return;
+++	}
++ 
++ 	if (WIFEXITED(stat) && WEXITSTATUS(stat))
++ 		die("child exited with status %d\n", WEXITSTATUS(stat));
++@@ -803,7 +809,7 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
++ 		break;
++ 	default:
++ #ifdef __OpenBSD__
++-		if (pledge("stdio rpath tty proc", NULL) == -1)
+++		if (pledge("stdio rpath tty proc exec", NULL) == -1)
++ 			die("pledge\n");
++ #endif
++ 		close(s);
++@@ -1991,6 +1997,59 @@ strparse(void)
++ 	}
++ }
++ 
+++void
+++externalpipe(const Arg *arg)
+++{
+++	int to[2];
+++	char buf[UTF_SIZ];
+++	void (*oldsigpipe)(int);
+++	Glyph *bp, *end;
+++	int lastpos, n, newline;
+++
+++	if (pipe(to) == -1)
+++		return;
+++
+++	switch (fork()) {
+++	case -1:
+++		close(to[0]);
+++		close(to[1]);
+++		return;
+++	case 0:
+++		dup2(to[0], STDIN_FILENO);
+++		close(to[0]);
+++		close(to[1]);
+++		execvp(((char **)arg->v)[0], (char **)arg->v);
+++		fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
+++		perror("failed");
+++		exit(0);
+++	}
+++
+++	close(to[0]);
+++	/* ignore sigpipe for now, in case child exists early */
+++	oldsigpipe = signal(SIGPIPE, SIG_IGN);
+++	newline = 0;
+++	for (n = 0; n < term.row; n++) {
+++		bp = term.line[n];
+++		lastpos = MIN(tlinelen(n) + 1, term.col) - 1;
+++		if (lastpos < 0)
+++			break;
+++		end = &bp[lastpos + 1];
+++		for (; bp < end; ++bp)
+++			if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
+++				break;
+++		if ((newline = term.line[n][lastpos].mode & ATTR_WRAP))
+++			continue;
+++		if (xwrite(to[1], "\n", 1) < 0)
+++			break;
+++		newline = 0;
+++	}
+++	if (newline)
+++		(void)xwrite(to[1], "\n", 1);
+++	close(to[1]);
+++	/* restore */
+++	signal(SIGPIPE, oldsigpipe);
+++}
+++
++ void
++ strdump(void)
++ {
++diff --git a/st.h b/st.h
++index fd3b0d8..754cd08 100644
++--- a/st.h
+++++ b/st.h
++@@ -81,6 +81,7 @@ void die(const char *, ...);
++ void redraw(void);
++ void draw(void);
++ 
+++void externalpipe(const Arg *);
++ void printscreen(const Arg *);
++ void printsel(const Arg *);
++ void sendbreak(const Arg *);
++-- 
++2.42.0
++
+diff --git a/patches/st-font2-0.8.5.diff b/patches/st-font2-0.8.5.diff
+new file mode 100644
+index 0000000..9b22b8a
+--- /dev/null
++++ b/patches/st-font2-0.8.5.diff
+@@ -0,0 +1,163 @@
++From 1635e04d3643dd4caa0c7c2043b585c6d7e4705f Mon Sep 17 00:00:00 2001
++From: Rizqi Nur Assyaufi <bandithijo@gmail.com>
++Date: Mon, 18 Jul 2022 01:15:45 +0800
++Subject: [PATCH] [st][patch][font2] Add patch for st-0.8.5
++
++---
++ config.def.h |   6 +++
++ x.c          | 101 +++++++++++++++++++++++++++++++++++++++++++++++++++
++ 2 files changed, 107 insertions(+)
++
++diff --git a/config.def.h b/config.def.h
++index 91ab8ca..717b2f0 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -6,6 +6,12 @@
++  * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
++  */
++ static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
+++/* Spare fonts */
+++static char *font2[] = {
+++/*	"Inconsolata for Powerline:pixelsize=12:antialias=true:autohint=true", */
+++/*	"Hack Nerd Font Mono:pixelsize=11:antialias=true:autohint=true", */
+++};
+++
++ static int borderpx = 2;
++
++ /*
++diff --git a/x.c b/x.c
++index 8a16faa..220fc4f 100644
++--- a/x.c
+++++ b/x.c
++@@ -157,6 +157,8 @@ static void xhints(void);
++ static int xloadcolor(int, const char *, Color *);
++ static int xloadfont(Font *, FcPattern *);
++ static void xloadfonts(const char *, double);
+++static int xloadsparefont(FcPattern *, int);
+++static void xloadsparefonts(void);
++ static void xunloadfont(Font *);
++ static void xunloadfonts(void);
++ static void xsetenv(void);
++@@ -306,6 +308,7 @@ zoomabs(const Arg *arg)
++ {
++ 	xunloadfonts();
++ 	xloadfonts(usedfont, arg->f);
+++	xloadsparefonts();
++ 	cresize(0, 0);
++ 	redraw();
++ 	xhints();
++@@ -1034,6 +1037,101 @@ xloadfonts(const char *fontstr, double fontsize)
++ 	FcPatternDestroy(pattern);
++ }
++
+++int
+++xloadsparefont(FcPattern *pattern, int flags)
+++{
+++	FcPattern *match;
+++	FcResult result;
+++
+++	match = FcFontMatch(NULL, pattern, &result);
+++	if (!match) {
+++		return 1;
+++	}
+++
+++	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
+++		FcPatternDestroy(match);
+++		return 1;
+++	}
+++
+++	frc[frclen].flags = flags;
+++	/* Believe U+0000 glyph will present in each default font */
+++	frc[frclen].unicodep = 0;
+++	frclen++;
+++
+++	return 0;
+++}
+++
+++void
+++xloadsparefonts(void)
+++{
+++	FcPattern *pattern;
+++	double sizeshift, fontval;
+++	int fc;
+++	char **fp;
+++
+++	if (frclen != 0)
+++		die("can't embed spare fonts. cache isn't empty");
+++
+++	/* Calculate count of spare fonts */
+++	fc = sizeof(font2) / sizeof(*font2);
+++	if (fc == 0)
+++		return;
+++
+++	/* Allocate memory for cache entries. */
+++	if (frccap < 4 * fc) {
+++		frccap += 4 * fc - frccap;
+++		frc = xrealloc(frc, frccap * sizeof(Fontcache));
+++	}
+++
+++	for (fp = font2; fp - font2 < fc; ++fp) {
+++
+++		if (**fp == '-')
+++			pattern = XftXlfdParse(*fp, False, False);
+++		else
+++			pattern = FcNameParse((FcChar8 *)*fp);
+++
+++		if (!pattern)
+++			die("can't open spare font %s\n", *fp);
+++
+++		if (defaultfontsize > 0) {
+++			sizeshift = usedfontsize - defaultfontsize;
+++			if (sizeshift != 0 &&
+++					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
+++					FcResultMatch) {
+++				fontval += sizeshift;
+++				FcPatternDel(pattern, FC_PIXEL_SIZE);
+++				FcPatternDel(pattern, FC_SIZE);
+++				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
+++			}
+++		}
+++
+++		FcPatternAddBool(pattern, FC_SCALABLE, 1);
+++
+++		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
+++		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
+++
+++		if (xloadsparefont(pattern, FRC_NORMAL))
+++			die("can't open spare font %s\n", *fp);
+++
+++		FcPatternDel(pattern, FC_SLANT);
+++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
+++		if (xloadsparefont(pattern, FRC_ITALIC))
+++			die("can't open spare font %s\n", *fp);
+++
+++		FcPatternDel(pattern, FC_WEIGHT);
+++		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+++		if (xloadsparefont(pattern, FRC_ITALICBOLD))
+++			die("can't open spare font %s\n", *fp);
+++
+++		FcPatternDel(pattern, FC_SLANT);
+++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
+++		if (xloadsparefont(pattern, FRC_BOLD))
+++			die("can't open spare font %s\n", *fp);
+++
+++		FcPatternDestroy(pattern);
+++	}
+++}
+++
++ void
++ xunloadfont(Font *f)
++ {
++@@ -1131,6 +1229,9 @@ xinit(int cols, int rows)
++ 	usedfont = (opt_font == NULL)? font : opt_font;
++ 	xloadfonts(usedfont, 0);
++
+++	/* spare fonts */
+++	xloadsparefonts();
+++
++ 	/* colors */
++ 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
++ 	xloadcols();
++--
++2.37.1
++
+diff --git a/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff b/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
+new file mode 100644
+index 0000000..3e9d675
+--- /dev/null
++++ b/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
+@@ -0,0 +1,635 @@
++diff --git a/Makefile b/Makefile
++index 470ac86..38240da 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -4,7 +4,7 @@
++ 
++ include config.mk
++ 
++-SRC = st.c x.c
+++SRC = st.c x.c hb.c
++ OBJ = $(SRC:.c=.o)
++ 
++ all: st
++@@ -22,7 +22,8 @@ config.h:
++ 	$(CC) $(STCFLAGS) -c $<
++ 
++ st.o: config.h st.h win.h
++-x.o: arg.h config.h st.h win.h
+++x.o: arg.h config.h st.h win.h hb.h
+++hb.o: st.h
++ 
++ $(OBJ): config.h config.mk
++ 
++diff --git a/config.mk b/config.mk
++index 47c615e..d7439a3 100644
++--- a/config.mk
+++++ b/config.mk
++@@ -15,10 +15,12 @@ PKG_CONFIG = pkg-config
++ # includes and libs
++ INCS = -I$(X11INC) \
++        `$(PKG_CONFIG) --cflags fontconfig` \
++-       `$(PKG_CONFIG) --cflags freetype2`
++-LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender\
+++       `$(PKG_CONFIG) --cflags freetype2` \
+++       `$(PKG_CONFIG) --cflags harfbuzz`
+++LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender \
++        `$(PKG_CONFIG) --libs fontconfig` \
++-       `$(PKG_CONFIG) --libs freetype2`
+++       `$(PKG_CONFIG) --libs freetype2` \
+++       `$(PKG_CONFIG) --libs harfbuzz`
++ 
++ # flags
++ STCPPFLAGS = -DVERSION=\"$(VERSION)\" -D_XOPEN_SOURCE=600
++diff --git a/hb.c b/hb.c
++new file mode 100644
++index 0000000..99412c8
++--- /dev/null
+++++ b/hb.c
++@@ -0,0 +1,125 @@
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <math.h>
+++#include <X11/Xft/Xft.h>
+++#include <X11/cursorfont.h>
+++#include <hb.h>
+++#include <hb-ft.h>
+++
+++#include "st.h"
+++#include "hb.h"
+++
+++#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
+++#define BUFFER_STEP 256
+++
+++hb_font_t *hbfindfont(XftFont *match);
+++
+++typedef struct {
+++	XftFont *match;
+++	hb_font_t *font;
+++} HbFontMatch;
+++
+++typedef struct {
+++	size_t capacity;
+++	HbFontMatch *fonts;
+++} HbFontCache;
+++
+++static HbFontCache hbfontcache = { 0, NULL };
+++
+++typedef struct {
+++	size_t capacity;
+++	Rune *runes;
+++} RuneBuffer;
+++
+++static RuneBuffer hbrunebuffer = { 0, NULL };
+++
+++/*
+++ * Poplulate the array with a list of font features, wrapped in FEATURE macro,
+++ * e. g.
+++ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
+++ */
+++hb_feature_t features[] = { };
+++
+++void
+++hbunloadfonts()
+++{
+++	for (int i = 0; i < hbfontcache.capacity; i++) {
+++		hb_font_destroy(hbfontcache.fonts[i].font);
+++		XftUnlockFace(hbfontcache.fonts[i].match);
+++	}
+++
+++	if (hbfontcache.fonts != NULL) {
+++		free(hbfontcache.fonts);
+++		hbfontcache.fonts = NULL;
+++	}
+++	hbfontcache.capacity = 0;
+++}
+++
+++hb_font_t *
+++hbfindfont(XftFont *match)
+++{
+++	for (int i = 0; i < hbfontcache.capacity; i++) {
+++		if (hbfontcache.fonts[i].match == match)
+++			return hbfontcache.fonts[i].font;
+++	}
+++
+++	/* Font not found in cache, caching it now. */
+++	hbfontcache.fonts = realloc(hbfontcache.fonts, sizeof(HbFontMatch) * (hbfontcache.capacity + 1));
+++	FT_Face face = XftLockFace(match);
+++	hb_font_t *font = hb_ft_font_create(face, NULL);
+++	if (font == NULL)
+++		die("Failed to load Harfbuzz font.");
+++
+++	hbfontcache.fonts[hbfontcache.capacity].match = match;
+++	hbfontcache.fonts[hbfontcache.capacity].font = font;
+++	hbfontcache.capacity += 1;
+++
+++	return font;
+++}
+++
+++void hbtransform(HbTransformData *data, XftFont *xfont, const Glyph *glyphs, int start, int length) {
+++	ushort mode = USHRT_MAX;
+++	unsigned int glyph_count;
+++	int rune_idx, glyph_idx, end = start + length;
+++
+++	hb_font_t *font = hbfindfont(xfont);
+++	if (font == NULL)
+++		return;
+++
+++	hb_buffer_t *buffer = hb_buffer_create();
+++	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
+++	hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
+++
+++	/* Resize the buffer if required length is larger. */
+++	if (hbrunebuffer.capacity < length) {
+++		hbrunebuffer.capacity = (length / BUFFER_STEP + 1) * BUFFER_STEP;
+++		hbrunebuffer.runes = realloc(hbrunebuffer.runes, hbrunebuffer.capacity * sizeof(Rune));
+++	}
+++
+++	/* Fill buffer with codepoints. */
+++	for (rune_idx = 0, glyph_idx = start; glyph_idx < end; glyph_idx++, rune_idx++) {
+++		hbrunebuffer.runes[rune_idx] = glyphs[glyph_idx].u;
+++		mode = glyphs[glyph_idx].mode;
+++		if (mode & ATTR_WDUMMY)
+++			hbrunebuffer.runes[rune_idx] = 0x0020;
+++	}
+++	hb_buffer_add_codepoints(buffer, hbrunebuffer.runes, length, 0, length);
+++
+++	/* Shape the segment. */
+++	hb_shape(font, buffer, features, sizeof(features)/sizeof(hb_feature_t));
+++
+++	/* Get new glyph info. */
+++	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
+++	hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);
+++
+++	/* Fill the output. */
+++	data->buffer = buffer;
+++	data->glyphs = info;
+++	data->positions = pos;
+++	data->count = glyph_count;
+++}
+++
+++void hbcleanup(HbTransformData *data) {
+++	hb_buffer_destroy(data->buffer);
+++	memset(data, 0, sizeof(HbTransformData));
+++}
++diff --git a/hb.h b/hb.h
++new file mode 100644
++index 0000000..3b0ef44
++--- /dev/null
+++++ b/hb.h
++@@ -0,0 +1,14 @@
+++#include <X11/Xft/Xft.h>
+++#include <hb.h>
+++#include <hb-ft.h>
+++
+++typedef struct {
+++	hb_buffer_t *buffer;
+++	hb_glyph_info_t *glyphs;
+++	hb_glyph_position_t *positions;
+++	unsigned int count;
+++} HbTransformData;
+++
+++void hbunloadfonts();
+++void hbtransform(HbTransformData *, XftFont *, const Glyph *, int, int);
+++void hbcleanup(HbTransformData *);
++diff --git a/st.c b/st.c
++index 79ee9ba..454771d 100644
++--- a/st.c
+++++ b/st.c
++@@ -2711,7 +2711,9 @@ draw(void)
++ 	drawregion(0, 0, term.col, term.row);
++ 	if (term.scr == 0)
++ 		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
++-				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+++				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
+++				term.line[term.ocy], term.col);
+++
++ 	term.ocx = cx;
++ 	term.ocy = term.c.y;
++ 	xfinishdraw();
++diff --git a/st.h b/st.h
++index 78762a2..01eea49 100644
++--- a/st.h
+++++ b/st.h
++@@ -11,7 +11,8 @@
++ #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
++ #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
++ #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
++-#define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
+++#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP)) != ((b).mode & (~ATTR_WRAP)) || \
+++				(a).fg != (b).fg || \
++ 				(a).bg != (b).bg)
++ #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
++ 				(t1.tv_nsec-t2.tv_nsec)/1E6)
++diff --git a/win.h b/win.h
++index 6de960d..94679e4 100644
++--- a/win.h
+++++ b/win.h
++@@ -25,7 +25,7 @@ enum win_mode {
++ 
++ void xbell(void);
++ void xclipcopy(void);
++-void xdrawcursor(int, int, Glyph, int, int, Glyph);
+++void xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);
++ void xdrawline(Line, int, int, int);
++ void xfinishdraw(void);
++ void xloadcols(void);
++diff --git a/x.c b/x.c
++index 27e81d1..5e11c1f 100644
++--- a/x.c
+++++ b/x.c
++@@ -19,6 +19,7 @@ char *argv0;
++ #include "arg.h"
++ #include "st.h"
++ #include "win.h"
+++#include "hb.h"
++ 
++ /* types used in config.h */
++ typedef struct {
++@@ -142,8 +143,9 @@ typedef struct {
++ } DC;
++ 
++ static inline ushort sixd_to_16bit(int);
+++static void xresetfontsettings(ushort mode, Font **font, int *frcflags);
++ static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
++-static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
+++static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int, int);
++ static void xdrawglyph(Glyph, int, int);
++ static void xclear(int, int, int, int);
++ static int xgeommasktogravity(int);
++@@ -759,7 +761,7 @@ xresize(int col, int row)
++ 	xclear(0, 0, win.w, win.h);
++ 
++ 	/* resize to new width */
++-	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));
+++	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec) * 4);
++ }
++ 
++ ushort
++@@ -1071,6 +1073,9 @@ xunloadfont(Font *f)
++ void
++ xunloadfonts(void)
++ {
+++	/* Clear Harfbuzz font cache. */
+++	hbunloadfonts();
+++
++ 	/* Free the loaded fonts in the font cache.  */
++ 	while (frclen > 0)
++ 		XftFontClose(xw.dpy, frc[--frclen].font);
++@@ -1202,7 +1207,7 @@ xinit(int cols, int rows)
++ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
++ 
++ 	/* font spec buffer */
++-	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));
+++	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec) * 4);
++ 
++ 	/* Xft rendering context */
++ 	xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
++@@ -1256,6 +1261,22 @@ xinit(int cols, int rows)
++ 		xsel.xtarget = XA_STRING;
++ }
++ 
+++void
+++xresetfontsettings(ushort mode, Font **font, int *frcflags)
+++{
+++	*font = &dc.font;
+++	if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
+++		*font = &dc.ibfont;
+++		*frcflags = FRC_ITALICBOLD;
+++	} else if (mode & ATTR_ITALIC) {
+++		*font = &dc.ifont;
+++		*frcflags = FRC_ITALIC;
+++	} else if (mode & ATTR_BOLD) {
+++		*font = &dc.bfont;
+++		*frcflags = FRC_BOLD;
+++	}
+++}
+++
++ int
++ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
++ {
++@@ -1270,128 +1291,156 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
++ 	FcPattern *fcpattern, *fontpattern;
++ 	FcFontSet *fcsets[] = { NULL };
++ 	FcCharSet *fccharset;
++-	int i, f, numspecs = 0;
+++	int i, f, length = 0, start = 0, numspecs = 0;
+++	float cluster_xp = xp, cluster_yp = yp;
+++	HbTransformData shaped = { 0 };
+++
+++	/* Initial values. */
+++	mode = prevmode = glyphs[0].mode & ~ATTR_WRAP;
+++	xresetfontsettings(mode, &font, &frcflags);
++ 
++ 	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
++-		/* Fetch rune and mode for current glyph. */
++-		rune = glyphs[i].u;
++-		mode = glyphs[i].mode;
+++		mode = glyphs[i].mode & ~ATTR_WRAP;
++ 
++ 		/* Skip dummy wide-character spacing. */
++-		if (mode == ATTR_WDUMMY)
+++		if (mode & ATTR_WDUMMY && i < (len - 1))
++ 			continue;
++ 
++-		/* Determine font for glyph if different from previous glyph. */
++-		if (prevmode != mode) {
++-			prevmode = mode;
++-			font = &dc.font;
++-			frcflags = FRC_NORMAL;
++-			runewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);
++-			if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
++-				font = &dc.ibfont;
++-				frcflags = FRC_ITALICBOLD;
++-			} else if (mode & ATTR_ITALIC) {
++-				font = &dc.ifont;
++-				frcflags = FRC_ITALIC;
++-			} else if (mode & ATTR_BOLD) {
++-				font = &dc.bfont;
++-				frcflags = FRC_BOLD;
+++		if (
+++			prevmode != mode
+++			|| ATTRCMP(glyphs[start], glyphs[i])
+++			|| selected(x + i, y) != selected(x + start, y)
+++			|| i == (len - 1)
+++		) {
+++			/* Handle 1-character wide segments and end of line */
+++			length = i - start;
+++			if (i == start) {
+++				length = 1;
+++			} else if (i == (len - 1)) {
+++				length = (i - start + 1);
++ 			}
++-			yp = winy + font->ascent;
++-		}
++ 
++-		/* Lookup character index with default font. */
++-		glyphidx = XftCharIndex(xw.dpy, font->match, rune);
++-		if (glyphidx) {
++-			specs[numspecs].font = font->match;
++-			specs[numspecs].glyph = glyphidx;
++-			specs[numspecs].x = (short)xp;
++-			specs[numspecs].y = (short)yp;
++-			xp += runewidth;
++-			numspecs++;
++-			continue;
++-		}
++-
++-		/* Fallback on font cache, search the font cache for match. */
++-		for (f = 0; f < frclen; f++) {
++-			glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
++-			/* Everything correct. */
++-			if (glyphidx && frc[f].flags == frcflags)
++-				break;
++-			/* We got a default font for a not found glyph. */
++-			if (!glyphidx && frc[f].flags == frcflags
++-					&& frc[f].unicodep == rune) {
++-				break;
+++			/* Shape the segment. */
+++			hbtransform(&shaped, font->match, glyphs, start, length);
+++			runewidth = win.cw * ((glyphs[start].mode & ATTR_WIDE) ? 2.0f : 1.0f);
+++			cluster_xp = xp; cluster_yp = yp;
+++			for (int code_idx = 0; code_idx < shaped.count; code_idx++) {
+++				int idx = shaped.glyphs[code_idx].cluster;
+++
+++				if (glyphs[start + idx].mode & ATTR_WDUMMY)
+++					continue;
+++
+++				/* Advance the drawing cursor if we've moved to a new cluster */
+++				if (code_idx > 0 && idx != shaped.glyphs[code_idx - 1].cluster) {
+++					xp += runewidth;
+++					cluster_xp = xp;
+++					cluster_yp = yp;
+++					runewidth = win.cw * ((glyphs[start + idx].mode & ATTR_WIDE) ? 2.0f : 1.0f);
+++				}
+++
+++				if (shaped.glyphs[code_idx].codepoint != 0) {
+++					/* If symbol is found, put it into the specs. */
+++					specs[numspecs].font = font->match;
+++					specs[numspecs].glyph = shaped.glyphs[code_idx].codepoint;
+++					specs[numspecs].x = cluster_xp + (short)(shaped.positions[code_idx].x_offset / 64.);
+++					specs[numspecs].y = cluster_yp - (short)(shaped.positions[code_idx].y_offset / 64.);
+++					cluster_xp += shaped.positions[code_idx].x_advance / 64.;
+++					cluster_yp += shaped.positions[code_idx].y_advance / 64.;
+++					numspecs++;
+++				} else {
+++					/* If it's not found, try to fetch it through the font cache. */
+++					rune = glyphs[start + idx].u;
+++					for (f = 0; f < frclen; f++) {
+++						glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
+++						/* Everything correct. */
+++						if (glyphidx && frc[f].flags == frcflags)
+++							break;
+++						/* We got a default font for a not found glyph. */
+++						if (!glyphidx && frc[f].flags == frcflags
+++								&& frc[f].unicodep == rune) {
+++							break;
+++						}
+++					}
+++
+++					/* Nothing was found. Use fontconfig to find matching font. */
+++					if (f >= frclen) {
+++						if (!font->set)
+++							font->set = FcFontSort(0, font->pattern,
+++																		 1, 0, &fcres);
+++						fcsets[0] = font->set;
+++
+++						/*
+++						 * Nothing was found in the cache. Now use
+++						 * some dozen of Fontconfig calls to get the
+++						 * font for one single character.
+++						 *
+++						 * Xft and fontconfig are design failures.
+++						 */
+++						fcpattern = FcPatternDuplicate(font->pattern);
+++						fccharset = FcCharSetCreate();
+++
+++						FcCharSetAddChar(fccharset, rune);
+++						FcPatternAddCharSet(fcpattern, FC_CHARSET,
+++								fccharset);
+++						FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
+++
+++						FcConfigSubstitute(0, fcpattern,
+++								FcMatchPattern);
+++						FcDefaultSubstitute(fcpattern);
+++
+++						fontpattern = FcFontSetMatch(0, fcsets, 1,
+++								fcpattern, &fcres);
+++
+++						/* Allocate memory for the new cache entry. */
+++						if (frclen >= frccap) {
+++							frccap += 16;
+++							frc = xrealloc(frc, frccap * sizeof(Fontcache));
+++						}
+++
+++						frc[frclen].font = XftFontOpenPattern(xw.dpy,
+++								fontpattern);
+++						if (!frc[frclen].font)
+++							die("XftFontOpenPattern failed seeking fallback font: %s\n",
+++								strerror(errno));
+++						frc[frclen].flags = frcflags;
+++						frc[frclen].unicodep = rune;
+++
+++						glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
+++
+++						f = frclen;
+++						frclen++;
+++
+++						FcPatternDestroy(fcpattern);
+++						FcCharSetDestroy(fccharset);
+++					}
+++
+++					specs[numspecs].font = frc[f].font;
+++					specs[numspecs].glyph = glyphidx;
+++					specs[numspecs].x = (short)xp;
+++					specs[numspecs].y = (short)yp;
+++					numspecs++;
+++				}
++ 			}
++-		}
++ 
++-		/* Nothing was found. Use fontconfig to find matching font. */
++-		if (f >= frclen) {
++-			if (!font->set)
++-				font->set = FcFontSort(0, font->pattern,
++-				                       1, 0, &fcres);
++-			fcsets[0] = font->set;
+++			/* Cleanup and get ready for next segment. */
+++			hbcleanup(&shaped);
+++			start = i;
++ 
++-			/*
++-			 * Nothing was found in the cache. Now use
++-			 * some dozen of Fontconfig calls to get the
++-			 * font for one single character.
++-			 *
++-			 * Xft and fontconfig are design failures.
++-			 */
++-			fcpattern = FcPatternDuplicate(font->pattern);
++-			fccharset = FcCharSetCreate();
++-
++-			FcCharSetAddChar(fccharset, rune);
++-			FcPatternAddCharSet(fcpattern, FC_CHARSET,
++-					fccharset);
++-			FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
++-
++-			FcConfigSubstitute(0, fcpattern,
++-					FcMatchPattern);
++-			FcDefaultSubstitute(fcpattern);
++-
++-			fontpattern = FcFontSetMatch(0, fcsets, 1,
++-					fcpattern, &fcres);
++-
++-			/* Allocate memory for the new cache entry. */
++-			if (frclen >= frccap) {
++-				frccap += 16;
++-				frc = xrealloc(frc, frccap * sizeof(Fontcache));
+++			/* Determine font for glyph if different from previous glyph. */
+++			if (prevmode != mode) {
+++				prevmode = mode;
+++				xresetfontsettings(mode, &font, &frcflags);
+++				yp = winy + font->ascent;
++ 			}
++-
++-			frc[frclen].font = XftFontOpenPattern(xw.dpy,
++-					fontpattern);
++-			if (!frc[frclen].font)
++-				die("XftFontOpenPattern failed seeking fallback font: %s\n",
++-					strerror(errno));
++-			frc[frclen].flags = frcflags;
++-			frc[frclen].unicodep = rune;
++-
++-			glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
++-
++-			f = frclen;
++-			frclen++;
++-
++-			FcPatternDestroy(fcpattern);
++-			FcCharSetDestroy(fccharset);
++ 		}
++-
++-		specs[numspecs].font = frc[f].font;
++-		specs[numspecs].glyph = glyphidx;
++-		specs[numspecs].x = (short)xp;
++-		specs[numspecs].y = (short)yp;
++-		xp += runewidth;
++-		numspecs++;
++ 	}
++ 
++ 	return numspecs;
++ }
++ 
++ void
++-xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
+++xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y, int charlen)
++ {
++-	int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
++ 	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
++ 	    width = charlen * win.cw;
++ 	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
++@@ -1527,21 +1576,24 @@ void
++ xdrawglyph(Glyph g, int x, int y)
++ {
++ 	int numspecs;
++-	XftGlyphFontSpec spec;
+++	XftGlyphFontSpec *specs = xw.specbuf;
++ 
++-	numspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);
++-	xdrawglyphfontspecs(&spec, g, numspecs, x, y);
+++	numspecs = xmakeglyphfontspecs(specs, &g, 1, x, y);
+++	xdrawglyphfontspecs(specs, g, numspecs, x, y, (g.mode & ATTR_WIDE) ? 2 : 1);
++ }
++ 
++ void
++-xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
+++xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
++ {
++ 	Color drawcol;
++ 
++ 	/* remove the old cursor */
++ 	if (selected(ox, oy))
++ 		og.mode ^= ATTR_REVERSE;
++-	xdrawglyph(og, ox, oy);
+++
+++	/* Redraw the line where cursor was previously.
+++	 * It will restore the ligatures broken by the cursor. */
+++	xdrawline(line, 0, oy, len);
++ 
++ 	if (IS_SET(MODE_HIDE))
++ 		return;
++@@ -1669,18 +1721,16 @@ xdrawline(Line line, int x1, int y1, int x2)
++ 	Glyph base, new;
++ 	XftGlyphFontSpec *specs = xw.specbuf;
++ 
++-	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
++ 	i = ox = 0;
++-	for (x = x1; x < x2 && i < numspecs; x++) {
+++	for (x = x1; x < x2; x++) {
++ 		new = line[x];
++ 		if (new.mode == ATTR_WDUMMY)
++ 			continue;
++ 		if (selected(x, y1))
++ 			new.mode ^= ATTR_REVERSE;
++-		if (i > 0 && ATTRCMP(base, new)) {
++-			xdrawglyphfontspecs(specs, base, i, ox, y1);
++-			specs += i;
++-			numspecs -= i;
+++		if ((i > 0) && ATTRCMP(base, new)) {
+++			numspecs = xmakeglyphfontspecs(specs, &line[ox], x - ox, ox, y1);
+++			xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x - ox);
++ 			i = 0;
++ 		}
++ 		if (i == 0) {
++@@ -1689,8 +1739,10 @@ xdrawline(Line line, int x1, int y1, int x2)
++ 		}
++ 		i++;
++ 	}
++-	if (i > 0)
++-		xdrawglyphfontspecs(specs, base, i, ox, y1);
+++	if (i > 0) {
+++		numspecs = xmakeglyphfontspecs(specs, &line[ox], x2 - ox, ox, y1);
+++		xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x2 - ox);
+++	}
++ }
++ 
++ void
+diff --git a/patches/st-scrollback-0.9.2.diff b/patches/st-scrollback-0.9.2.diff
+new file mode 100644
+index 0000000..f9782e8
+--- /dev/null
++++ b/patches/st-scrollback-0.9.2.diff
+@@ -0,0 +1,351 @@
++diff --git a/config.def.h b/config.def.h
++index 2cd740a..40b7d93 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -201,6 +201,8 @@ static Shortcut shortcuts[] = {
++ 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
++ 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
++ 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+++	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
+++    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
++ };
++ 
++ /*
++diff --git a/st.c b/st.c
++index b9f66e7..2478942 100644
++--- a/st.c
+++++ b/st.c
++@@ -35,6 +35,7 @@
++ #define ESC_ARG_SIZ   16
++ #define STR_BUF_SIZ   ESC_BUF_SIZ
++ #define STR_ARG_SIZ   ESC_ARG_SIZ
+++#define HISTSIZE      2000
++ 
++ /* macros */
++ #define IS_SET(flag)		((term.mode & (flag)) != 0)
++@@ -42,6 +43,9 @@
++ #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
++ #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
++ #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
+++#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
+++            term.scr + HISTSIZE + 1) % HISTSIZE] : \
+++            term.line[(y) - term.scr])
++ 
++ enum term_mode {
++ 	MODE_WRAP        = 1 << 0,
++@@ -115,6 +119,9 @@ typedef struct {
++ 	int col;      /* nb col */
++ 	Line *line;   /* screen */
++ 	Line *alt;    /* alternate screen */
+++	Line hist[HISTSIZE]; /* history buffer */
+++	int histi;    /* history index */
+++	int scr;      /* scroll back */
++ 	int *dirty;   /* dirtyness of lines */
++ 	TCursor c;    /* cursor */
++ 	int ocx;      /* old cursor col */
++@@ -185,8 +192,8 @@ static void tnewline(int);
++ static void tputtab(int);
++ static void tputc(Rune);
++ static void treset(void);
++-static void tscrollup(int, int);
++-static void tscrolldown(int, int);
+++static void tscrollup(int, int, int);
+++static void tscrolldown(int, int, int);
++ static void tsetattr(const int *, int);
++ static void tsetchar(Rune, const Glyph *, int, int);
++ static void tsetdirt(int, int);
++@@ -409,10 +416,10 @@ tlinelen(int y)
++ {
++ 	int i = term.col;
++ 
++-	if (term.line[y][i - 1].mode & ATTR_WRAP)
+++	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
++ 		return i;
++ 
++-	while (i > 0 && term.line[y][i - 1].u == ' ')
+++	while (i > 0 && TLINE(y)[i - 1].u == ' ')
++ 		--i;
++ 
++ 	return i;
++@@ -521,7 +528,7 @@ selsnap(int *x, int *y, int direction)
++ 		 * Snap around if the word wraps around at the end or
++ 		 * beginning of a line.
++ 		 */
++-		prevgp = &term.line[*y][*x];
+++		prevgp = &TLINE(*y)[*x];
++ 		prevdelim = ISDELIM(prevgp->u);
++ 		for (;;) {
++ 			newx = *x + direction;
++@@ -536,14 +543,14 @@ selsnap(int *x, int *y, int direction)
++ 					yt = *y, xt = *x;
++ 				else
++ 					yt = newy, xt = newx;
++-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
+++				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
++ 					break;
++ 			}
++ 
++ 			if (newx >= tlinelen(newy))
++ 				break;
++ 
++-			gp = &term.line[newy][newx];
+++			gp = &TLINE(newy)[newx];
++ 			delim = ISDELIM(gp->u);
++ 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
++ 					|| (delim && gp->u != prevgp->u)))
++@@ -564,14 +571,14 @@ selsnap(int *x, int *y, int direction)
++ 		*x = (direction < 0) ? 0 : term.col - 1;
++ 		if (direction < 0) {
++ 			for (; *y > 0; *y += direction) {
++-				if (!(term.line[*y-1][term.col-1].mode
+++				if (!(TLINE(*y-1)[term.col-1].mode
++ 						& ATTR_WRAP)) {
++ 					break;
++ 				}
++ 			}
++ 		} else if (direction > 0) {
++ 			for (; *y < term.row-1; *y += direction) {
++-				if (!(term.line[*y][term.col-1].mode
+++				if (!(TLINE(*y)[term.col-1].mode
++ 						& ATTR_WRAP)) {
++ 					break;
++ 				}
++@@ -602,13 +609,13 @@ getsel(void)
++ 		}
++ 
++ 		if (sel.type == SEL_RECTANGULAR) {
++-			gp = &term.line[y][sel.nb.x];
+++			gp = &TLINE(y)[sel.nb.x];
++ 			lastx = sel.ne.x;
++ 		} else {
++-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
+++			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
++ 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
++ 		}
++-		last = &term.line[y][MIN(lastx, linelen-1)];
+++		last = &TLINE(y)[MIN(lastx, linelen-1)];
++ 		while (last >= gp && last->u == ' ')
++ 			--last;
++ 
++@@ -844,6 +851,9 @@ void
++ ttywrite(const char *s, size_t n, int may_echo)
++ {
++ 	const char *next;
+++	Arg arg = (Arg) { .i = term.scr };
+++
+++	kscrolldown(&arg);
++ 
++ 	if (may_echo && IS_SET(MODE_ECHO))
++ 		twrite(s, n, 1);
++@@ -1055,13 +1065,53 @@ tswapscreen(void)
++ }
++ 
++ void
++-tscrolldown(int orig, int n)
+++kscrolldown(const Arg* a)
+++{
+++	int n = a->i;
+++
+++	if (n < 0)
+++		n = term.row + n;
+++
+++	if (n > term.scr)
+++		n = term.scr;
+++
+++	if (term.scr > 0) {
+++		term.scr -= n;
+++		selscroll(0, -n);
+++		tfulldirt();
+++	}
+++}
+++
+++void
+++kscrollup(const Arg* a)
+++{
+++	int n = a->i;
+++
+++	if (n < 0)
+++		n = term.row + n;
+++
+++	if (term.scr <= HISTSIZE-n) {
+++		term.scr += n;
+++		selscroll(0, n);
+++		tfulldirt();
+++	}
+++}
+++
+++void
+++tscrolldown(int orig, int n, int copyhist)
++ {
++ 	int i;
++ 	Line temp;
++ 
++ 	LIMIT(n, 0, term.bot-orig+1);
++ 
+++	if (copyhist) {
+++		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+++		temp = term.hist[term.histi];
+++		term.hist[term.histi] = term.line[term.bot];
+++		term.line[term.bot] = temp;
+++	}
+++
++ 	tsetdirt(orig, term.bot-n);
++ 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
++ 
++@@ -1071,17 +1121,28 @@ tscrolldown(int orig, int n)
++ 		term.line[i-n] = temp;
++ 	}
++ 
++-	selscroll(orig, n);
+++	if (term.scr == 0)
+++		selscroll(orig, n);
++ }
++ 
++ void
++-tscrollup(int orig, int n)
+++tscrollup(int orig, int n, int copyhist)
++ {
++ 	int i;
++ 	Line temp;
++ 
++ 	LIMIT(n, 0, term.bot-orig+1);
++ 
+++	if (copyhist) {
+++		term.histi = (term.histi + 1) % HISTSIZE;
+++		temp = term.hist[term.histi];
+++		term.hist[term.histi] = term.line[orig];
+++		term.line[orig] = temp;
+++	}
+++
+++	if (term.scr > 0 && term.scr < HISTSIZE)
+++		term.scr = MIN(term.scr + n, HISTSIZE-1);
+++
++ 	tclearregion(0, orig, term.col-1, orig+n-1);
++ 	tsetdirt(orig+n, term.bot);
++ 
++@@ -1091,7 +1152,8 @@ tscrollup(int orig, int n)
++ 		term.line[i+n] = temp;
++ 	}
++ 
++-	selscroll(orig, -n);
+++	if (term.scr == 0)
+++		selscroll(orig, -n);
++ }
++ 
++ void
++@@ -1120,7 +1182,7 @@ tnewline(int first_col)
++ 	int y = term.c.y;
++ 
++ 	if (y == term.bot) {
++-		tscrollup(term.top, 1);
+++		tscrollup(term.top, 1, 1);
++ 	} else {
++ 		y++;
++ 	}
++@@ -1285,14 +1347,14 @@ void
++ tinsertblankline(int n)
++ {
++ 	if (BETWEEN(term.c.y, term.top, term.bot))
++-		tscrolldown(term.c.y, n);
+++		tscrolldown(term.c.y, n, 0);
++ }
++ 
++ void
++ tdeleteline(int n)
++ {
++ 	if (BETWEEN(term.c.y, term.top, term.bot))
++-		tscrollup(term.c.y, n);
+++		tscrollup(term.c.y, n, 0);
++ }
++ 
++ int32_t
++@@ -1730,11 +1792,11 @@ csihandle(void)
++ 	case 'S': /* SU -- Scroll <n> line up */
++ 		if (csiescseq.priv) break;
++ 		DEFAULT(csiescseq.arg[0], 1);
++-		tscrollup(term.top, csiescseq.arg[0]);
+++		tscrollup(term.top, csiescseq.arg[0], 0);
++ 		break;
++ 	case 'T': /* SD -- Scroll <n> line down */
++ 		DEFAULT(csiescseq.arg[0], 1);
++-		tscrolldown(term.top, csiescseq.arg[0]);
+++		tscrolldown(term.top, csiescseq.arg[0], 0);
++ 		break;
++ 	case 'L': /* IL -- Insert <n> blank lines */
++ 		DEFAULT(csiescseq.arg[0], 1);
++@@ -2306,7 +2368,7 @@ eschandle(uchar ascii)
++ 		return 0;
++ 	case 'D': /* IND -- Linefeed */
++ 		if (term.c.y == term.bot) {
++-			tscrollup(term.top, 1);
+++			tscrollup(term.top, 1, 1);
++ 		} else {
++ 			tmoveto(term.c.x, term.c.y+1);
++ 		}
++@@ -2319,7 +2381,7 @@ eschandle(uchar ascii)
++ 		break;
++ 	case 'M': /* RI -- Reverse index */
++ 		if (term.c.y == term.top) {
++-			tscrolldown(term.top, 1);
+++			tscrolldown(term.top, 1, 1);
++ 		} else {
++ 			tmoveto(term.c.x, term.c.y-1);
++ 		}
++@@ -2542,7 +2604,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
++ void
++ tresize(int col, int row)
++ {
++-	int i;
+++	int i, j;
++ 	int minrow = MIN(row, term.row);
++ 	int mincol = MIN(col, term.col);
++ 	int *bp;
++@@ -2579,6 +2641,14 @@ tresize(int col, int row)
++ 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
++ 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
++ 
+++	for (i = 0; i < HISTSIZE; i++) {
+++		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
+++		for (j = mincol; j < col; j++) {
+++			term.hist[i][j] = term.c.attr;
+++			term.hist[i][j].u = ' ';
+++		}
+++	}
+++
++ 	/* resize each row to new width, zero-pad if needed */
++ 	for (i = 0; i < minrow; i++) {
++ 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
++@@ -2637,7 +2707,7 @@ drawregion(int x1, int y1, int x2, int y2)
++ 			continue;
++ 
++ 		term.dirty[y] = 0;
++-		xdrawline(term.line[y], x1, y, x2);
+++		xdrawline(TLINE(y), x1, y, x2);
++ 	}
++ }
++ 
++@@ -2658,8 +2728,9 @@ draw(void)
++ 		cx--;
++ 
++ 	drawregion(0, 0, term.col, term.row);
++-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
++-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+++	if (term.scr == 0)
+++		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+++				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
++ 	term.ocx = cx;
++ 	term.ocy = term.c.y;
++ 	xfinishdraw();
++diff --git a/st.h b/st.h
++index fd3b0d8..818a6f8 100644
++--- a/st.h
+++++ b/st.h
++@@ -81,6 +81,8 @@ void die(const char *, ...);
++ void redraw(void);
++ void draw(void);
++ 
+++void kscrolldown(const Arg *);
+++void kscrollup(const Arg *);
++ void printscreen(const Arg *);
++ void printsel(const Arg *);
++ void sendbreak(const Arg *);
+diff --git a/patches/st-scrollback-mouse-0.9.2.diff b/patches/st-scrollback-mouse-0.9.2.diff
+new file mode 100644
+index 0000000..a956d2b
+--- /dev/null
++++ b/patches/st-scrollback-mouse-0.9.2.diff
+@@ -0,0 +1,25 @@
++From 6b7e7e6c5c44dd6347ad49691b80d808c1b0cb77 Mon Sep 17 00:00:00 2001
++From: Jernej Jakob <jernej.jakob@gmail.com>
++Date: Mon, 1 Jul 2024 14:00:02 +0200
++Subject: [PATCH] [st][patch] Update st-scrollback-mouse for 0.9.2
++
++---
++ config.def.h | 2 ++
++ 1 file changed, 2 insertions(+)
++
++diff --git a/config.def.h b/config.def.h
++index 8b25d40..d259675 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -176,6 +176,8 @@ static uint forcemousemod = ShiftMask;
++  */
++ static MouseShortcut mshortcuts[] = {
++ 	/* mask                 button   function        argument       release */
+++	{ ShiftMask,            Button4, kscrollup,      {.i = 1} },
+++	{ ShiftMask,            Button5, kscrolldown,    {.i = 1} },
++ 	{ XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
++ 	{ ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
++ 	{ XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
++-- 
++2.44.2
++
+diff --git a/patches/st-workingdir-20200317-51e19ea.diff b/patches/st-workingdir-20200317-51e19ea.diff
+new file mode 100644
+index 0000000..65de084
+--- /dev/null
++++ b/patches/st-workingdir-20200317-51e19ea.diff
+@@ -0,0 +1,97 @@
++From ae14b869d7bc0e0cd8ed16157837ad09aaacacc0 Mon Sep 17 00:00:00 2001
++From: David Gricar <coppie@protonmail.com>
++Date: Tue, 17 Mar 2020 13:38:05 +0100
++Subject: [PATCH] Add switch to provide initial working directory
++
++This patch adds -p switch which takes one argument 'path' and can be
++used to set the initial working directory of the new st instance.
++It acts the same as running 'cd path' command after starting the st
++instance.
++---
++ st.1 |  8 ++++++++
++ x.c  | 13 +++++++++----
++ 2 files changed, 17 insertions(+), 4 deletions(-)
++
++diff --git a/st.1 b/st.1
++index e8d6059..a901122 100644
++--- a/st.1
+++++ b/st.1
++@@ -6,6 +6,8 @@ st \- simple terminal
++ .RB [ \-aiv ]
++ .RB [ \-c
++ .IR class ]
+++.RB [ \-d
+++.IR path ]
++ .RB [ \-f
++ .IR font ]
++ .RB [ \-g
++@@ -30,6 +32,8 @@ st \- simple terminal
++ .RB [ \-aiv ]
++ .RB [ \-c
++ .IR class ]
+++.RB [ \-d
+++.IR path ]
++ .RB [ \-f
++ .IR font ]
++ .RB [ \-g
++@@ -58,6 +62,10 @@ disable alternate screens in terminal
++ .BI \-c " class"
++ defines the window class (default $TERM).
++ .TP
+++.BI \-d " path"
+++changes the working directory to
+++.IR path .
+++.TP
++ .BI \-f " font"
++ defines the
++ .I font
++diff --git a/x.c b/x.c
++index 48a6676..fab2ddc 100644
++--- a/x.c
+++++ b/x.c
++@@ -250,6 +250,7 @@ static char *opt_io    = NULL;
++ static char *opt_line  = NULL;
++ static char *opt_name  = NULL;
++ static char *opt_title = NULL;
+++static char *opt_dir   = NULL;
++ 
++ static int oldbutton = 3; /* button event on startup: 3 = release */
++ 
++@@ -1958,12 +1959,12 @@ run(void)
++ void
++ usage(void)
++ {
++-	die("usage: %s [-aiv] [-c class] [-f font] [-g geometry]"
++-	    " [-n name] [-o file]\n"
+++	die("usage: %s [-aiv] [-c class] [-d path] [-f font]"
+++	    " [-g geometry] [-n name] [-o file]\n"
++ 	    "          [-T title] [-t title] [-w windowid]"
++ 	    " [[-e] command [args ...]]\n"
++-	    "       %s [-aiv] [-c class] [-f font] [-g geometry]"
++-	    " [-n name] [-o file]\n"
+++	    "       %s [-aiv] [-c class] [-d path] [-f font]"
+++	    " [-g geometry] [-n name] [-o file]\n"
++ 	    "          [-T title] [-t title] [-w windowid] -l line"
++ 	    " [stty_args ...]\n", argv0, argv0);
++ }
++@@ -2015,6 +2016,9 @@ main(int argc, char *argv[])
++ 	case 'v':
++ 		die("%s " VERSION "\n", argv0);
++ 		break;
+++	case 'd':
+++		opt_dir = EARGF(usage());
+++		break;
++ 	default:
++ 		usage();
++ 	} ARGEND;
++@@ -2034,6 +2038,7 @@ run:
++ 	xinit(cols, rows);
++ 	xsetenv();
++ 	selinit();
+++	chdir(opt_dir);
++ 	run();
++ 
++ 	return 0;
++-- 
++2.25.1
++
+diff --git a/patches/st-xresources-20200604-9ba7ecf.diff b/patches/st-xresources-20200604-9ba7ecf.diff
+new file mode 100644
+index 0000000..78ba00a
+--- /dev/null
++++ b/patches/st-xresources-20200604-9ba7ecf.diff
+@@ -0,0 +1,184 @@
++From 2752a599ee01305a435729bfacf43b1dde7cf0ef Mon Sep 17 00:00:00 2001
++From: Benji Encalada Mora <benji@encalada.dev>
++Date: Thu, 4 Jun 2020 00:41:10 -0500
++Subject: [PATCH] fix: replace xfps and actionfps variables
++
++---
++ config.def.h | 36 ++++++++++++++++++++++++
++ x.c          | 78 +++++++++++++++++++++++++++++++++++++++++++++++++---
++ 2 files changed, 110 insertions(+), 4 deletions(-)
++
++diff --git a/config.def.h b/config.def.h
++index 6f05dce..9b99782 100644
++--- a/config.def.h
+++++ b/config.def.h
++@@ -168,6 +168,42 @@ static unsigned int defaultattr = 11;
++  */
++ static uint forcemousemod = ShiftMask;
++ 
+++/*
+++ * Xresources preferences to load at startup
+++ */
+++ResourcePref resources[] = {
+++		{ "font",         STRING,  &font },
+++		{ "color0",       STRING,  &colorname[0] },
+++		{ "color1",       STRING,  &colorname[1] },
+++		{ "color2",       STRING,  &colorname[2] },
+++		{ "color3",       STRING,  &colorname[3] },
+++		{ "color4",       STRING,  &colorname[4] },
+++		{ "color5",       STRING,  &colorname[5] },
+++		{ "color6",       STRING,  &colorname[6] },
+++		{ "color7",       STRING,  &colorname[7] },
+++		{ "color8",       STRING,  &colorname[8] },
+++		{ "color9",       STRING,  &colorname[9] },
+++		{ "color10",      STRING,  &colorname[10] },
+++		{ "color11",      STRING,  &colorname[11] },
+++		{ "color12",      STRING,  &colorname[12] },
+++		{ "color13",      STRING,  &colorname[13] },
+++		{ "color14",      STRING,  &colorname[14] },
+++		{ "color15",      STRING,  &colorname[15] },
+++		{ "background",   STRING,  &colorname[256] },
+++		{ "foreground",   STRING,  &colorname[257] },
+++		{ "cursorColor",  STRING,  &colorname[258] },
+++		{ "termname",     STRING,  &termname },
+++		{ "shell",        STRING,  &shell },
+++		{ "minlatency",   INTEGER, &minlatency },
+++		{ "maxlatency",   INTEGER, &maxlatency },
+++		{ "blinktimeout", INTEGER, &blinktimeout },
+++		{ "bellvolume",   INTEGER, &bellvolume },
+++		{ "tabspaces",    INTEGER, &tabspaces },
+++		{ "borderpx",     INTEGER, &borderpx },
+++		{ "cwscale",      FLOAT,   &cwscale },
+++		{ "chscale",      FLOAT,   &chscale },
+++};
+++
++ /*
++  * Internal mouse shortcuts.
++  * Beware that overloading Button1 will disable the selection.
++diff --git a/x.c b/x.c
++index 210f184..76f167f 100644
++--- a/x.c
+++++ b/x.c
++@@ -14,6 +14,7 @@
++ #include <X11/keysym.h>
++ #include <X11/Xft/Xft.h>
++ #include <X11/XKBlib.h>
+++#include <X11/Xresource.h>
++ 
++ char *argv0;
++ #include "arg.h"
++@@ -45,6 +46,19 @@ typedef struct {
++ 	signed char appcursor; /* application cursor */
++ } Key;
++ 
+++/* Xresources preferences */
+++enum resource_type {
+++	STRING = 0,
+++	INTEGER = 1,
+++	FLOAT = 2
+++};
+++
+++typedef struct {
+++	char *name;
+++	enum resource_type type;
+++	void *dst;
+++} ResourcePref;
+++
++ /* X modifiers */
++ #define XK_ANY_MOD    UINT_MAX
++ #define XK_NO_MOD     0
++@@ -828,8 +842,8 @@ xclear(int x1, int y1, int x2, int y2)
++ void
++ xhints(void)
++ {
++-	XClassHint class = {opt_name ? opt_name : termname,
++-	                    opt_class ? opt_class : termname};
+++	XClassHint class = {opt_name ? opt_name : "st",
+++	                    opt_class ? opt_class : "St"};
++ 	XWMHints wm = {.flags = InputHint, .input = 1};
++ 	XSizeHints *sizeh;
++ 
++@@ -1104,8 +1118,6 @@ xinit(int cols, int rows)
++ 	pid_t thispid = getpid();
++ 	XColor xmousefg, xmousebg;
++ 
++-	if (!(xw.dpy = XOpenDisplay(NULL)))
++-		die("can't open display\n");
++ 	xw.scr = XDefaultScreen(xw.dpy);
++ 	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
++ 
++@@ -1964,6 +1976,59 @@ run(void)
++ 	}
++ }
++ 
+++int
+++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+++{
+++	char **sdst = dst;
+++	int *idst = dst;
+++	float *fdst = dst;
+++
+++	char fullname[256];
+++	char fullclass[256];
+++	char *type;
+++	XrmValue ret;
+++
+++	snprintf(fullname, sizeof(fullname), "%s.%s",
+++			opt_name ? opt_name : "st", name);
+++	snprintf(fullclass, sizeof(fullclass), "%s.%s",
+++			opt_class ? opt_class : "St", name);
+++	fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
+++
+++	XrmGetResource(db, fullname, fullclass, &type, &ret);
+++	if (ret.addr == NULL || strncmp("String", type, 64))
+++		return 1;
+++
+++	switch (rtype) {
+++	case STRING:
+++		*sdst = ret.addr;
+++		break;
+++	case INTEGER:
+++		*idst = strtoul(ret.addr, NULL, 10);
+++		break;
+++	case FLOAT:
+++		*fdst = strtof(ret.addr, NULL);
+++		break;
+++	}
+++	return 0;
+++}
+++
+++void
+++config_init(void)
+++{
+++	char *resm;
+++	XrmDatabase db;
+++	ResourcePref *p;
+++
+++	XrmInitialize();
+++	resm = XResourceManagerString(xw.dpy);
+++	if (!resm)
+++		return;
+++
+++	db = XrmGetStringDatabase(resm);
+++	for (p = resources; p < resources + LEN(resources); p++)
+++		resource_load(db, p->name, p->type, p->dst);
+++}
+++
++ void
++ usage(void)
++ {
++@@ -2037,6 +2102,11 @@ run:
++ 
++ 	setlocale(LC_CTYPE, "");
++ 	XSetLocaleModifiers("");
+++
+++	if(!(xw.dpy = XOpenDisplay(NULL)))
+++		die("Can't open display\n");
+++
+++	config_init();
++ 	cols = MAX(cols, 1);
++ 	rows = MAX(rows, 1);
++ 	tnew(cols, rows);
++-- 
++2.26.2
++
+diff --git a/st-copyout b/st-copyout
+new file mode 100755
+index 0000000..f6d383e
+--- /dev/null
++++ b/st-copyout
+@@ -0,0 +1,14 @@
++#!/bin/sh
++# Using external pipe with st, give a dmenu prompt of recent commands,
++# allowing the user to copy the output of one.
++# xclip required for this script.
++# By Jaywalker and Luke
++tmpfile=$(mktemp /tmp/st-cmd-output.XXXXXX)
++trap 'rm "$tmpfile"' 0 1 15
++sed -n "w $tmpfile"
++sed -i 's/\x0//g' "$tmpfile"
++ps1="$(grep "\S" "$tmpfile" | tail -n 1 | sed 's/^\s*//' | cut -d' ' -f1)"
++chosen="$(grep -F "$ps1" "$tmpfile" | sed '$ d' | tac | dmenu -p "Copy which command's output?" -i -l 10 | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
++#chosen="$(grep -F "$ps1" "$tmpfile" | sed '$ d' | tac | rofi -theme 'gruvbox-dark.rasi' -p "Copy which command's output?" -dmenu -i -l 10 | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
++eps1="$(echo "$ps1" | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
++awk "/^$chosen$/{p=1;print;next} p&&/$eps1/{p=0};p" "$tmpfile" | xclip -selection clipboard
+diff --git a/st-urlhandler b/st-urlhandler
+new file mode 100755
+index 0000000..9ebdf6f
+--- /dev/null
++++ b/st-urlhandler
+@@ -0,0 +1,25 @@
++#!/bin/sh
++
++# See ~/.config/mimeapps.list if the wrong browser is used
++# See link below:
++# https://unix.stackexchange.com/questions/307641/cant-change-the-xdg-open-url-handler-to-firefox
++
++urlregex="(((http|https|gopher|gemini|ftp|ftps|git)://|www\\.)[a-zA-Z0-9.]*[:;a-zA-Z0-9./+@$&%?$\#=_~-]*)|((magnet:\\?xt=urn:btih:)[a-zA-Z0-9]*)"
++
++urls="$(sed 's/.*│//g' | tr -d '\n' | # First remove linebreaks and mutt sidebars:
++	grep -aEo "$urlregex" | # grep only urls as defined above.
++	uniq | # Ignore neighboring duplicates.
++	sed "s/\(\.\|,\|;\|\!\\|\?\)$//;
++	s/^www./http:\/\/www\./")" # xdg-open will not detect url without http
++
++[ -z "$urls" ] && exit 1
++
++while getopts "hoc" o; do case "${o}" in
++	h) printf "Optional arguments for custom use:\\n  -c: copy\\n  -o: xdg-open\\n  -h: Show this message\\n" && exit 1 ;;
++	#o) chosen="$(echo "$urls" | dmenu -i -p 'Follow which url?' -l 10)"
++	o) chosen="$(echo "$urls" | rofi -theme 'gruvbox-dark.rasi' -p 'Follow which url?' -dmenu -i -l 10)"
++	setsid xdg-open "$chosen" >/dev/null 2>&1 & ;;
++	#c) echo "$urls" | dmenu -i -p 'Copy which url?' -l 10 | tr -d '\n' | xclip -selection clipboard ;;
++	c) echo "$urls" | rofi -theme 'gruvbox-dark.rasi' -p 'Copy which url?' -dmenu -i -l 10 | tr -d '\n' | xclip -selection clipboard ;;
++	*) printf "Invalid option: -%s\\n" "$OPTARG" && exit 1 ;;
++esac done
+diff --git a/st.1 b/st.1
+index 39120b4..b82beb3 100644
+--- a/st.1
++++ b/st.1
+@@ -6,6 +6,8 @@ st \- simple terminal
+ .RB [ \-aiv ]
+ .RB [ \-c
+ .IR class ]
++.RB [ \-d
++.IR path ]
+ .RB [ \-f
+ .IR font ]
+ .RB [ \-g
+@@ -30,6 +32,8 @@ st \- simple terminal
+ .RB [ \-aiv ]
+ .RB [ \-c
+ .IR class ]
++.RB [ \-d
++.IR path ]
+ .RB [ \-f
+ .IR font ]
+ .RB [ \-g
+@@ -58,6 +62,10 @@ disable alternate screens in terminal
+ .BI \-c " class"
+ defines the window class (default $TERM).
+ .TP
++.BI \-d " path"
++changes the working directory to
++.IR path .
++.TP
+ .BI \-f " font"
+ defines the
+ .I font
+diff --git a/st.c b/st.c
+index 2e3800e..755d84e 100644
+--- a/st.c
++++ b/st.c
+@@ -35,6 +35,7 @@
+ #define ESC_ARG_SIZ   16
+ #define STR_BUF_SIZ   ESC_BUF_SIZ
+ #define STR_ARG_SIZ   ESC_ARG_SIZ
++#define HISTSIZE      2000
+ 
+ /* macros */
+ #define IS_SET(flag)		((term.mode & (flag)) != 0)
+@@ -42,6 +43,9 @@
+ #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
+ #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
+ #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
++#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
++            term.scr + HISTSIZE + 1) % HISTSIZE] : \
++            term.line[(y) - term.scr])
+ 
+ enum term_mode {
+ 	MODE_WRAP        = 1 << 0,
+@@ -115,6 +119,9 @@ typedef struct {
+ 	int col;      /* nb col */
+ 	Line *line;   /* screen */
+ 	Line *alt;    /* alternate screen */
++	Line hist[HISTSIZE]; /* history buffer */
++	int histi;    /* history index */
++	int scr;      /* scroll back */
+ 	int *dirty;   /* dirtyness of lines */
+ 	TCursor c;    /* cursor */
+ 	int ocx;      /* old cursor col */
+@@ -185,8 +192,8 @@ static void tnewline(int);
+ static void tputtab(int);
+ static void tputc(Rune);
+ static void treset(void);
+-static void tscrollup(int, int);
+-static void tscrolldown(int, int);
++static void tscrollup(int, int, int);
++static void tscrolldown(int, int, int);
+ static void tsetattr(const int *, int);
+ static void tsetchar(Rune, const Glyph *, int, int);
+ static void tsetdirt(int, int);
+@@ -409,10 +416,10 @@ tlinelen(int y)
+ {
+ 	int i = term.col;
+ 
+-	if (term.line[y][i - 1].mode & ATTR_WRAP)
++	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
+ 		return i;
+ 
+-	while (i > 0 && term.line[y][i - 1].u == ' ')
++	while (i > 0 && TLINE(y)[i - 1].u == ' ')
+ 		--i;
+ 
+ 	return i;
+@@ -521,7 +528,7 @@ selsnap(int *x, int *y, int direction)
+ 		 * Snap around if the word wraps around at the end or
+ 		 * beginning of a line.
+ 		 */
+-		prevgp = &term.line[*y][*x];
++		prevgp = &TLINE(*y)[*x];
+ 		prevdelim = ISDELIM(prevgp->u);
+ 		for (;;) {
+ 			newx = *x + direction;
+@@ -536,14 +543,14 @@ selsnap(int *x, int *y, int direction)
+ 					yt = *y, xt = *x;
+ 				else
+ 					yt = newy, xt = newx;
+-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
++				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
+ 					break;
+ 			}
+ 
+ 			if (newx >= tlinelen(newy))
+ 				break;
+ 
+-			gp = &term.line[newy][newx];
++			gp = &TLINE(newy)[newx];
+ 			delim = ISDELIM(gp->u);
+ 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
+ 					|| (delim && gp->u != prevgp->u)))
+@@ -564,14 +571,14 @@ selsnap(int *x, int *y, int direction)
+ 		*x = (direction < 0) ? 0 : term.col - 1;
+ 		if (direction < 0) {
+ 			for (; *y > 0; *y += direction) {
+-				if (!(term.line[*y-1][term.col-1].mode
++				if (!(TLINE(*y-1)[term.col-1].mode
+ 						& ATTR_WRAP)) {
+ 					break;
+ 				}
+ 			}
+ 		} else if (direction > 0) {
+ 			for (; *y < term.row-1; *y += direction) {
+-				if (!(term.line[*y][term.col-1].mode
++				if (!(TLINE(*y)[term.col-1].mode
+ 						& ATTR_WRAP)) {
+ 					break;
+ 				}
+@@ -602,13 +609,13 @@ getsel(void)
+ 		}
+ 
+ 		if (sel.type == SEL_RECTANGULAR) {
+-			gp = &term.line[y][sel.nb.x];
++			gp = &TLINE(y)[sel.nb.x];
+ 			lastx = sel.ne.x;
+ 		} else {
+-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
++			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
+ 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
+ 		}
+-		last = &term.line[y][MIN(lastx, linelen-1)];
++		last = &TLINE(y)[MIN(lastx, linelen-1)];
+ 		while (last >= gp && last->u == ' ')
+ 			--last;
+ 
+@@ -718,8 +725,14 @@ sigchld(int a)
+ 	if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
+ 		die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
+ 
+-	if (pid != p)
++	if (pid != p) {
++		if (p == 0 && wait(&stat) < 0)
++			die("wait: %s\n", strerror(errno));
++
++		/* reinstall sigchld handler */
++		signal(SIGCHLD, sigchld);
+ 		return;
++	}
+ 
+ 	if (WIFEXITED(stat) && WEXITSTATUS(stat))
+ 		die("child exited with status %d\n", WEXITSTATUS(stat));
+@@ -803,7 +816,7 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
+ 		break;
+ 	default:
+ #ifdef __OpenBSD__
+-		if (pledge("stdio rpath tty proc", NULL) == -1)
++		if (pledge("stdio rpath tty proc exec", NULL) == -1)
+ 			die("pledge\n");
+ #endif
+ 		close(s);
+@@ -844,6 +857,9 @@ void
+ ttywrite(const char *s, size_t n, int may_echo)
+ {
+ 	const char *next;
++	Arg arg = (Arg) { .i = term.scr };
++
++	kscrolldown(&arg);
+ 
+ 	if (may_echo && IS_SET(MODE_ECHO))
+ 		twrite(s, n, 1);
+@@ -1055,13 +1071,53 @@ tswapscreen(void)
+ }
+ 
+ void
+-tscrolldown(int orig, int n)
++kscrolldown(const Arg* a)
++{
++	int n = a->i;
++
++	if (n < 0)
++		n = term.row + n;
++
++	if (n > term.scr)
++		n = term.scr;
++
++	if (term.scr > 0) {
++		term.scr -= n;
++		selscroll(0, -n);
++		tfulldirt();
++	}
++}
++
++void
++kscrollup(const Arg* a)
++{
++	int n = a->i;
++
++	if (n < 0)
++		n = term.row + n;
++
++	if (term.scr <= HISTSIZE-n) {
++		term.scr += n;
++		selscroll(0, n);
++		tfulldirt();
++	}
++}
++
++void
++tscrolldown(int orig, int n, int copyhist)
+ {
+ 	int i;
+ 	Line temp;
+ 
+ 	LIMIT(n, 0, term.bot-orig+1);
+ 
++	if (copyhist) {
++		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[term.bot];
++		term.line[term.bot] = temp;
++	}
++
+ 	tsetdirt(orig, term.bot-n);
+ 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
+ 
+@@ -1071,17 +1127,28 @@ tscrolldown(int orig, int n)
+ 		term.line[i-n] = temp;
+ 	}
+ 
+-	selscroll(orig, n);
++	if (term.scr == 0)
++		selscroll(orig, n);
+ }
+ 
+ void
+-tscrollup(int orig, int n)
++tscrollup(int orig, int n, int copyhist)
+ {
+ 	int i;
+ 	Line temp;
+ 
+ 	LIMIT(n, 0, term.bot-orig+1);
+ 
++	if (copyhist) {
++		term.histi = (term.histi + 1) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[orig];
++		term.line[orig] = temp;
++	}
++
++	if (term.scr > 0 && term.scr < HISTSIZE)
++		term.scr = MIN(term.scr + n, HISTSIZE-1);
++
+ 	tclearregion(0, orig, term.col-1, orig+n-1);
+ 	tsetdirt(orig+n, term.bot);
+ 
+@@ -1091,7 +1158,8 @@ tscrollup(int orig, int n)
+ 		term.line[i+n] = temp;
+ 	}
+ 
+-	selscroll(orig, -n);
++	if (term.scr == 0)
++		selscroll(orig, -n);
+ }
+ 
+ void
+@@ -1120,7 +1188,7 @@ tnewline(int first_col)
+ 	int y = term.c.y;
+ 
+ 	if (y == term.bot) {
+-		tscrollup(term.top, 1);
++		tscrollup(term.top, 1, 1);
+ 	} else {
+ 		y++;
+ 	}
+@@ -1288,14 +1356,14 @@ void
+ tinsertblankline(int n)
+ {
+ 	if (BETWEEN(term.c.y, term.top, term.bot))
+-		tscrolldown(term.c.y, n);
++		tscrolldown(term.c.y, n, 0);
+ }
+ 
+ void
+ tdeleteline(int n)
+ {
+ 	if (BETWEEN(term.c.y, term.top, term.bot))
+-		tscrollup(term.c.y, n);
++		tscrollup(term.c.y, n, 0);
+ }
+ 
+ int32_t
+@@ -1733,11 +1801,11 @@ csihandle(void)
+ 	case 'S': /* SU -- Scroll <n> line up */
+ 		if (csiescseq.priv) break;
+ 		DEFAULT(csiescseq.arg[0], 1);
+-		tscrollup(term.top, csiescseq.arg[0]);
++		tscrollup(term.top, csiescseq.arg[0], 0);
+ 		break;
+ 	case 'T': /* SD -- Scroll <n> line down */
+ 		DEFAULT(csiescseq.arg[0], 1);
+-		tscrolldown(term.top, csiescseq.arg[0]);
++		tscrolldown(term.top, csiescseq.arg[0], 0);
+ 		break;
+ 	case 'L': /* IL -- Insert <n> blank lines */
+ 		DEFAULT(csiescseq.arg[0], 1);
+@@ -1994,6 +2062,59 @@ strparse(void)
+ 	}
+ }
+ 
++void
++externalpipe(const Arg *arg)
++{
++	int to[2];
++	char buf[UTF_SIZ];
++	void (*oldsigpipe)(int);
++	Glyph *bp, *end;
++	int lastpos, n, newline;
++
++	if (pipe(to) == -1)
++		return;
++
++	switch (fork()) {
++	case -1:
++		close(to[0]);
++		close(to[1]);
++		return;
++	case 0:
++		dup2(to[0], STDIN_FILENO);
++		close(to[0]);
++		close(to[1]);
++		execvp(((char **)arg->v)[0], (char **)arg->v);
++		fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
++		perror("failed");
++		exit(0);
++	}
++
++	close(to[0]);
++	/* ignore sigpipe for now, in case child exists early */
++	oldsigpipe = signal(SIGPIPE, SIG_IGN);
++	newline = 0;
++	for (n = 0; n < term.row; n++) {
++		bp = term.line[n];
++		lastpos = MIN(tlinelen(n) + 1, term.col) - 1;
++		if (lastpos < 0)
++			break;
++		end = &bp[lastpos + 1];
++		for (; bp < end; ++bp)
++			if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
++				break;
++		if ((newline = term.line[n][lastpos].mode & ATTR_WRAP))
++			continue;
++		if (xwrite(to[1], "\n", 1) < 0)
++			break;
++		newline = 0;
++	}
++	if (newline)
++		(void)xwrite(to[1], "\n", 1);
++	close(to[1]);
++	/* restore */
++	signal(SIGPIPE, oldsigpipe);
++}
++
+ void
+ strdump(void)
+ {
+@@ -2309,7 +2430,7 @@ eschandle(uchar ascii)
+ 		return 0;
+ 	case 'D': /* IND -- Linefeed */
+ 		if (term.c.y == term.bot) {
+-			tscrollup(term.top, 1);
++			tscrollup(term.top, 1, 1);
+ 		} else {
+ 			tmoveto(term.c.x, term.c.y+1);
+ 		}
+@@ -2322,7 +2443,7 @@ eschandle(uchar ascii)
+ 		break;
+ 	case 'M': /* RI -- Reverse index */
+ 		if (term.c.y == term.top) {
+-			tscrolldown(term.top, 1);
++			tscrolldown(term.top, 1, 1);
+ 		} else {
+ 			tmoveto(term.c.x, term.c.y-1);
+ 		}
+@@ -2545,7 +2666,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
+ void
+ tresize(int col, int row)
+ {
+-	int i;
++	int i, j;
+ 	int minrow = MIN(row, term.row);
+ 	int mincol = MIN(col, term.col);
+ 	int *bp;
+@@ -2582,6 +2703,14 @@ tresize(int col, int row)
+ 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
+ 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
+ 
++	for (i = 0; i < HISTSIZE; i++) {
++		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
++		for (j = mincol; j < col; j++) {
++			term.hist[i][j] = term.c.attr;
++			term.hist[i][j].u = ' ';
++		}
++	}
++
+ 	/* resize each row to new width, zero-pad if needed */
+ 	for (i = 0; i < minrow; i++) {
+ 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
+@@ -2640,7 +2769,7 @@ drawregion(int x1, int y1, int x2, int y2)
+ 			continue;
+ 
+ 		term.dirty[y] = 0;
+-		xdrawline(term.line[y], x1, y, x2);
++		xdrawline(TLINE(y), x1, y, x2);
+ 	}
+ }
+ 
+@@ -2661,8 +2790,11 @@ draw(void)
+ 		cx--;
+ 
+ 	drawregion(0, 0, term.col, term.row);
+-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
++	if (term.scr == 0)
++		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
++				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
++				term.line[term.ocy], term.col);
++
+ 	term.ocx = cx;
+ 	term.ocy = term.c.y;
+ 	xfinishdraw();
+diff --git a/st.h b/st.h
+index fd3b0d8..a6be61e 100644
+--- a/st.h
++++ b/st.h
+@@ -11,7 +11,8 @@
+ #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
+ #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
+ #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
+-#define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
++#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP)) != ((b).mode & (~ATTR_WRAP)) || \
++				(a).fg != (b).fg || \
+ 				(a).bg != (b).bg)
+ #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
+ 				(t1.tv_nsec-t2.tv_nsec)/1E6)
+@@ -81,6 +82,10 @@ void die(const char *, ...);
+ void redraw(void);
+ void draw(void);
+ 
++void externalpipe(const Arg *);
++
++void kscrolldown(const Arg *);
++void kscrollup(const Arg *);
+ void printscreen(const Arg *);
+ void printsel(const Arg *);
+ void sendbreak(const Arg *);
+@@ -124,3 +129,4 @@ extern unsigned int tabspaces;
+ extern unsigned int defaultfg;
+ extern unsigned int defaultbg;
+ extern unsigned int defaultcs;
++extern float alpha_def;
+diff --git a/win.h b/win.h
+index 6de960d..94679e4 100644
+--- a/win.h
++++ b/win.h
+@@ -25,7 +25,7 @@ enum win_mode {
+ 
+ void xbell(void);
+ void xclipcopy(void);
+-void xdrawcursor(int, int, Glyph, int, int, Glyph);
++void xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);
+ void xdrawline(Line, int, int, int);
+ void xfinishdraw(void);
+ void xloadcols(void);
+diff --git a/x.c b/x.c
+index d73152b..4615736 100644
+--- a/x.c
++++ b/x.c
+@@ -14,11 +14,13 @@
+ #include <X11/keysym.h>
+ #include <X11/Xft/Xft.h>
+ #include <X11/XKBlib.h>
++#include <X11/Xresource.h>
+ 
+ char *argv0;
+ #include "arg.h"
+ #include "st.h"
+ #include "win.h"
++#include "hb.h"
+ 
+ /* types used in config.h */
+ typedef struct {
+@@ -45,6 +47,19 @@ typedef struct {
+ 	signed char appcursor; /* application cursor */
+ } Key;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* X modifiers */
+ #define XK_ANY_MOD    UINT_MAX
+ #define XK_NO_MOD     0
+@@ -59,6 +74,8 @@ static void zoom(const Arg *);
+ static void zoomabs(const Arg *);
+ static void zoomreset(const Arg *);
+ static void ttysend(const Arg *);
++static void changealpha(const Arg *);
++static float clamp(float value, float lower, float upper);
+ 
+ /* config.h for applying patches and the configuration. */
+ #include "config.h"
+@@ -105,6 +122,7 @@ typedef struct {
+ 	XSetWindowAttributes attrs;
+ 	int scr;
+ 	int isfixed; /* is fixed geometry? */
++	int depth; /* bit depth */
+ 	int l, t; /* left and top offset */
+ 	int gm; /* geometry mask */
+ } XWindow;
+@@ -141,8 +159,9 @@ typedef struct {
+ } DC;
+ 
+ static inline ushort sixd_to_16bit(int);
++static void xresetfontsettings(ushort mode, Font **font, int *frcflags);
+ static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
+-static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
++static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int, int);
+ static void xdrawglyph(Glyph, int, int);
+ static void xclear(int, int, int, int);
+ static int xgeommasktogravity(int);
+@@ -157,6 +176,8 @@ static void xhints(void);
+ static int xloadcolor(int, const char *, Color *);
+ static int xloadfont(Font *, FcPattern *);
+ static void xloadfonts(const char *, double);
++static int xloadsparefont(FcPattern *, int);
++static void xloadsparefonts(void);
+ static void xunloadfont(Font *);
+ static void xunloadfonts(void);
+ static void xsetenv(void);
+@@ -251,6 +272,7 @@ static char *opt_io    = NULL;
+ static char *opt_line  = NULL;
+ static char *opt_name  = NULL;
+ static char *opt_title = NULL;
++static char *opt_dir   = NULL;
+ 
+ static uint buttons; /* bit field of pressed buttons */
+ 
+@@ -306,6 +328,7 @@ zoomabs(const Arg *arg)
+ {
+ 	xunloadfonts();
+ 	xloadfonts(usedfont, arg->f);
++	xloadsparefonts();
+ 	cresize(0, 0);
+ 	redraw();
+ 	xhints();
+@@ -752,12 +775,12 @@ xresize(int col, int row)
+ 
+ 	XFreePixmap(xw.dpy, xw.buf);
+ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
+-			DefaultDepth(xw.dpy, xw.scr));
++			xw.depth);
+ 	XftDrawChange(xw.draw, xw.buf);
+ 	xclear(0, 0, win.w, win.h);
+ 
+ 	/* resize to new width */
+-	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));
++	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec) * 4);
+ }
+ 
+ ushort
+@@ -812,6 +835,13 @@ xloadcols(void)
+ 			else
+ 				die("could not allocate color %d\n", i);
+ 		}
++
++	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++	dc.col[defaultbg].pixel &= 0x00FFFFFF;
++	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++    dc.col[defaultbg].color.red   *= alpha;
++    dc.col[defaultbg].color.green *= alpha;
++    dc.col[defaultbg].color.blue  *= alpha;
+ 	loaded = 1;
+ }
+ 
+@@ -842,6 +872,15 @@ xsetcolorname(int x, const char *name)
+ 	XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
+ 	dc.col[x] = ncolor;
+ 
++	if (x == defaultbg) {
++		dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++		dc.col[defaultbg].pixel &= 0x00FFFFFF;
++		dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++        dc.col[defaultbg].color.red   *= alpha;
++        dc.col[defaultbg].color.green *= alpha;
++        dc.col[defaultbg].color.blue  *= alpha;
++	}
++
+ 	return 0;
+ }
+ 
+@@ -859,8 +898,8 @@ xclear(int x1, int y1, int x2, int y2)
+ void
+ xhints(void)
+ {
+-	XClassHint class = {opt_name ? opt_name : termname,
+-	                    opt_class ? opt_class : termname};
++	XClassHint class = {opt_name ? opt_name : "st",
++	                    opt_class ? opt_class : "St"};
+ 	XWMHints wm = {.flags = InputHint, .input = 1};
+ 	XSizeHints *sizeh;
+ 
+@@ -1050,6 +1089,101 @@ xloadfonts(const char *fontstr, double fontsize)
+ 	FcPatternDestroy(pattern);
+ }
+ 
++int
++xloadsparefont(FcPattern *pattern, int flags)
++{
++	FcPattern *match;
++	FcResult result;
++
++	match = FcFontMatch(NULL, pattern, &result);
++	if (!match) {
++		return 1;
++	}
++
++	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
++		FcPatternDestroy(match);
++		return 1;
++	}
++
++	frc[frclen].flags = flags;
++	/* Believe U+0000 glyph will present in each default font */
++	frc[frclen].unicodep = 0;
++	frclen++;
++
++	return 0;
++}
++
++void
++xloadsparefonts(void)
++{
++	FcPattern *pattern;
++	double sizeshift, fontval;
++	int fc;
++	char **fp;
++
++	if (frclen != 0)
++		die("can't embed spare fonts. cache isn't empty");
++
++	/* Calculate count of spare fonts */
++	fc = sizeof(font2) / sizeof(*font2);
++	if (fc == 0)
++		return;
++
++	/* Allocate memory for cache entries. */
++	if (frccap < 4 * fc) {
++		frccap += 4 * fc - frccap;
++		frc = xrealloc(frc, frccap * sizeof(Fontcache));
++	}
++
++	for (fp = font2; fp - font2 < fc; ++fp) {
++
++		if (**fp == '-')
++			pattern = XftXlfdParse(*fp, False, False);
++		else
++			pattern = FcNameParse((FcChar8 *)*fp);
++
++		if (!pattern)
++			die("can't open spare font %s\n", *fp);
++
++		if (defaultfontsize > 0) {
++			sizeshift = usedfontsize - defaultfontsize;
++			if (sizeshift != 0 &&
++					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
++					FcResultMatch) {
++				fontval += sizeshift;
++				FcPatternDel(pattern, FC_PIXEL_SIZE);
++				FcPatternDel(pattern, FC_SIZE);
++				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
++			}
++		}
++
++		FcPatternAddBool(pattern, FC_SCALABLE, 1);
++
++		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
++		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
++
++		if (xloadsparefont(pattern, FRC_NORMAL))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
++		if (xloadsparefont(pattern, FRC_ITALIC))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_WEIGHT);
++		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
++		if (xloadsparefont(pattern, FRC_ITALICBOLD))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
++		if (xloadsparefont(pattern, FRC_BOLD))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDestroy(pattern);
++	}
++}
++
+ void
+ xunloadfont(Font *f)
+ {
+@@ -1062,6 +1196,9 @@ xunloadfont(Font *f)
+ void
+ xunloadfonts(void)
+ {
++	/* Clear Harfbuzz font cache. */
++	hbunloadfonts();
++
+ 	/* Free the loaded fonts in the font cache.  */
+ 	while (frclen > 0)
+ 		XftFontClose(xw.dpy, frc[--frclen].font);
+@@ -1134,11 +1271,23 @@ xinit(int cols, int rows)
+ 	Window parent, root;
+ 	pid_t thispid = getpid();
+ 	XColor xmousefg, xmousebg;
++	XWindowAttributes attr;
++	XVisualInfo vis;
+ 
+-	if (!(xw.dpy = XOpenDisplay(NULL)))
+-		die("can't open display\n");
+ 	xw.scr = XDefaultScreen(xw.dpy);
+-	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
++
++	root = XRootWindow(xw.dpy, xw.scr);
++	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
++		parent = root;
++
++	if (XMatchVisualInfo(xw.dpy, xw.scr, 32, TrueColor, &vis) != 0) {
++		xw.vis = vis.visual;
++		xw.depth = vis.depth;
++	} else {
++		XGetWindowAttributes(xw.dpy, parent, &attr);
++		xw.vis = attr.visual;
++		xw.depth = attr.depth;
++	}
+ 
+ 	/* font */
+ 	if (!FcInit())
+@@ -1147,8 +1296,14 @@ xinit(int cols, int rows)
+ 	usedfont = (opt_font == NULL)? font : opt_font;
+ 	xloadfonts(usedfont, 0);
+ 
++	/* spare fonts */
++	xloadsparefonts();
++
++   /* Backup default alpha value */
++   //alpha_def = alpha;
++
+ 	/* colors */
+-	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
++	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
+ 	xloadcols();
+ 
+ 	/* adjust fixed window geometry */
+@@ -1168,11 +1323,8 @@ xinit(int cols, int rows)
+ 		| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
+ 	xw.attrs.colormap = xw.cmap;
+ 
+-	root = XRootWindow(xw.dpy, xw.scr);
+-	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
+-		parent = root;
+-	xw.win = XCreateWindow(xw.dpy, root, xw.l, xw.t,
+-			win.w, win.h, 0, XDefaultDepth(xw.dpy, xw.scr), InputOutput,
++	xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
++			win.w, win.h, 0, xw.depth, InputOutput,
+ 			xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
+ 			| CWEventMask | CWColormap, &xw.attrs);
+ 	if (parent != root)
+@@ -1183,12 +1335,12 @@ xinit(int cols, int rows)
+ 	dc.gc = XCreateGC(xw.dpy, xw.win, GCGraphicsExposures,
+ 			&gcvalues);
+ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
+-			DefaultDepth(xw.dpy, xw.scr));
++			xw.depth);
+ 	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
+ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
+ 
+ 	/* font spec buffer */
+-	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));
++	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec) * 4);
+ 
+ 	/* Xft rendering context */
+ 	xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
+@@ -1242,6 +1394,22 @@ xinit(int cols, int rows)
+ 		xsel.xtarget = XA_STRING;
+ }
+ 
++void
++xresetfontsettings(ushort mode, Font **font, int *frcflags)
++{
++	*font = &dc.font;
++	if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
++		*font = &dc.ibfont;
++		*frcflags = FRC_ITALICBOLD;
++	} else if (mode & ATTR_ITALIC) {
++		*font = &dc.ifont;
++		*frcflags = FRC_ITALIC;
++	} else if (mode & ATTR_BOLD) {
++		*font = &dc.bfont;
++		*frcflags = FRC_BOLD;
++	}
++}
++
+ int
+ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
+ {
+@@ -1256,128 +1424,224 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
+ 	FcPattern *fcpattern, *fontpattern;
+ 	FcFontSet *fcsets[] = { NULL };
+ 	FcCharSet *fccharset;
+-	int i, f, numspecs = 0;
++	int i, f, length = 0, start = 0, numspecs = 0;
++	float cluster_xp = xp, cluster_yp = yp;
++	HbTransformData shaped = { 0 };
++
++	/* Initial values. */
++	mode = prevmode = glyphs[0].mode & ~ATTR_WRAP;
++	xresetfontsettings(mode, &font, &frcflags);
+ 
+ 	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
+-		/* Fetch rune and mode for current glyph. */
+-		rune = glyphs[i].u;
+-		mode = glyphs[i].mode;
++		mode = glyphs[i].mode & ~ATTR_WRAP;
+ 
+ 		/* Skip dummy wide-character spacing. */
+-		if (mode == ATTR_WDUMMY)
++		if (mode & ATTR_WDUMMY && i < (len - 1))
+ 			continue;
+ 
+-		/* Determine font for glyph if different from previous glyph. */
+-		if (prevmode != mode) {
+-			prevmode = mode;
+-			font = &dc.font;
+-			frcflags = FRC_NORMAL;
+-			runewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);
+-			if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
+-				font = &dc.ibfont;
+-				frcflags = FRC_ITALICBOLD;
+-			} else if (mode & ATTR_ITALIC) {
+-				font = &dc.ifont;
+-				frcflags = FRC_ITALIC;
+-			} else if (mode & ATTR_BOLD) {
+-				font = &dc.bfont;
+-				frcflags = FRC_BOLD;
++		if (
++			prevmode != mode
++			|| ATTRCMP(glyphs[start], glyphs[i])
++			|| selected(x + i, y) != selected(x + start, y)
++			|| i == (len - 1)
++		) {
++			/* Handle 1-character wide segments and end of line */
++			length = i - start;
++			if (i == start) {
++				length = 1;
++			} else if (i == (len - 1)) {
++				length = (i - start + 1);
+ 			}
+-			yp = winy + font->ascent;
+-		}
+-
+-		/* Lookup character index with default font. */
+-		glyphidx = XftCharIndex(xw.dpy, font->match, rune);
+-		if (glyphidx) {
+-			specs[numspecs].font = font->match;
+-			specs[numspecs].glyph = glyphidx;
+-			specs[numspecs].x = (short)xp;
+-			specs[numspecs].y = (short)yp;
+-			xp += runewidth;
+-			numspecs++;
+-			continue;
+-		}
+ 
+-		/* Fallback on font cache, search the font cache for match. */
+-		for (f = 0; f < frclen; f++) {
+-			glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
+-			/* Everything correct. */
+-			if (glyphidx && frc[f].flags == frcflags)
+-				break;
+-			/* We got a default font for a not found glyph. */
+-			if (!glyphidx && frc[f].flags == frcflags
+-					&& frc[f].unicodep == rune) {
+-				break;
++			/* Shape the segment. */
++			hbtransform(&shaped, font->match, glyphs, start, length);
++			runewidth = win.cw * ((glyphs[start].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++			cluster_xp = xp; cluster_yp = yp;
++			for (int code_idx = 0; code_idx < shaped.count; code_idx++) {
++				int idx = shaped.glyphs[code_idx].cluster;
++
++				if (glyphs[start + idx].mode & ATTR_WDUMMY)
++					continue;
++
++				/* Advance the drawing cursor if we've moved to a new cluster */
++				if (code_idx > 0 && idx != shaped.glyphs[code_idx - 1].cluster) {
++					xp += runewidth;
++					cluster_xp = xp;
++					cluster_yp = yp;
++					runewidth = win.cw * ((glyphs[start + idx].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++				}
++
++				if (shaped.glyphs[code_idx].codepoint != 0) {
++					/* If symbol is found, put it into the specs. */
++					specs[numspecs].font = font->match;
++					specs[numspecs].glyph = shaped.glyphs[code_idx].codepoint;
++					specs[numspecs].x = cluster_xp + (short)(shaped.positions[code_idx].x_offset / 64.);
++					specs[numspecs].y = cluster_yp - (short)(shaped.positions[code_idx].y_offset / 64.);
++					cluster_xp += shaped.positions[code_idx].x_advance / 64.;
++					cluster_yp += shaped.positions[code_idx].y_advance / 64.;
++					numspecs++;
++				} else {
++					/* If it's not found, try to fetch it through the font cache. */
++					rune = glyphs[start + idx].u;
++					for (f = 0; f < frclen; f++) {
++						glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
++						/* Everything correct. */
++						if (glyphidx && frc[f].flags == frcflags)
++							break;
++						/* We got a default font for a not found glyph. */
++						if (!glyphidx && frc[f].flags == frcflags
++								&& frc[f].unicodep == rune) {
++							break;
++						}
++					}
++
++					/* Nothing was found. Use fontconfig to find matching font. */
++					if (f >= frclen) {
++						if (!font->set)
++							font->set = FcFontSort(0, font->pattern,
++																		 1, 0, &fcres);
++						fcsets[0] = font->set;
++
++						/*
++						 * Nothing was found in the cache. Now use
++						 * some dozen of Fontconfig calls to get the
++						 * font for one single character.
++						 *
++						 * Xft and fontconfig are design failures.
++						 */
++						fcpattern = FcPatternDuplicate(font->pattern);
++						fccharset = FcCharSetCreate();
++
++						FcCharSetAddChar(fccharset, rune);
++						FcPatternAddCharSet(fcpattern, FC_CHARSET,
++								fccharset);
++						FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
++
++						FcConfigSubstitute(0, fcpattern,
++								FcMatchPattern);
++						FcDefaultSubstitute(fcpattern);
++
++						fontpattern = FcFontSetMatch(0, fcsets, 1,
++								fcpattern, &fcres);
++
++						/* Allocate memory for the new cache entry. */
++						if (frclen >= frccap) {
++							frccap += 16;
++							frc = xrealloc(frc, frccap * sizeof(Fontcache));
++						}
++
++						frc[frclen].font = XftFontOpenPattern(xw.dpy,
++								fontpattern);
++						if (!frc[frclen].font)
++							die("XftFontOpenPattern failed seeking fallback font: %s\n",
++								strerror(errno));
++						frc[frclen].flags = frcflags;
++						frc[frclen].unicodep = rune;
++
++						glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
++
++						f = frclen;
++						frclen++;
++
++						FcPatternDestroy(fcpattern);
++						FcCharSetDestroy(fccharset);
++					}
++
++					specs[numspecs].font = frc[f].font;
++					specs[numspecs].glyph = glyphidx;
++					specs[numspecs].x = (short)xp;
++					specs[numspecs].y = (short)yp;
++					numspecs++;
++				}
+ 			}
+-		}
+-
+-		/* Nothing was found. Use fontconfig to find matching font. */
+-		if (f >= frclen) {
+-			if (!font->set)
+-				font->set = FcFontSort(0, font->pattern,
+-				                       1, 0, &fcres);
+-			fcsets[0] = font->set;
+-
+-			/*
+-			 * Nothing was found in the cache. Now use
+-			 * some dozen of Fontconfig calls to get the
+-			 * font for one single character.
+-			 *
+-			 * Xft and fontconfig are design failures.
+-			 */
+-			fcpattern = FcPatternDuplicate(font->pattern);
+-			fccharset = FcCharSetCreate();
+-
+-			FcCharSetAddChar(fccharset, rune);
+-			FcPatternAddCharSet(fcpattern, FC_CHARSET,
+-					fccharset);
+-			FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
+-
+-			FcConfigSubstitute(0, fcpattern,
+-					FcMatchPattern);
+-			FcDefaultSubstitute(fcpattern);
+ 
+-			fontpattern = FcFontSetMatch(0, fcsets, 1,
+-					fcpattern, &fcres);
++			/* Cleanup and get ready for next segment. */
++			hbcleanup(&shaped);
++			start = i;
+ 
+-			/* Allocate memory for the new cache entry. */
+-			if (frclen >= frccap) {
+-				frccap += 16;
+-				frc = xrealloc(frc, frccap * sizeof(Fontcache));
++			/* Determine font for glyph if different from previous glyph. */
++			if (prevmode != mode) {
++				prevmode = mode;
++				xresetfontsettings(mode, &font, &frcflags);
++				yp = winy + font->ascent;
+ 			}
++		}
++	}
+ 
+-			frc[frclen].font = XftFontOpenPattern(xw.dpy,
+-					fontpattern);
+-			if (!frc[frclen].font)
+-				die("XftFontOpenPattern failed seeking fallback font: %s\n",
+-					strerror(errno));
+-			frc[frclen].flags = frcflags;
+-			frc[frclen].unicodep = rune;
++	return numspecs;
++}
+ 
+-			glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
++//void
++//changealpha(const Arg *arg)
++//{
++//   if (arg->f == -1.0f && alpha >= 0.1f)
++//      alpha -= 0.1f;
++//   else if (arg->f == 1.0f && alpha < 1.0f)
++//      alpha += 0.1f;
++//   else if (arg->f == 0.0f)
++//      alpha = alpha_def;
++//   else
++//      return;
++//
++//   dc.col[defaultbg].color.alpha = (unsigned short)(0xFFFF * alpha);
++//   /* Required to remove artifacting from borderpx */
++//   cresize(0, 0);
++//   redraw();
++//}
++
++#include <stdio.h>
++#include <stdlib.h>
++void log_to_file(const char *message) {
++    const char *log_file_path = getenv("HOME"); // Get the home directory
++    if (log_file_path == NULL) {
++        return; // If HOME is not set, don't log
++    }
++
++    char file_path[256];
++    snprintf(file_path, sizeof(file_path), "%s/st_test.txt", log_file_path);
++
++    FILE *file = fopen(file_path, "a"); // Open the file in append mode
++    if (file != NULL) {
++        fprintf(file, "%s\n", message); // Write the message to the file
++        fclose(file);
++    }
++}
++
++float clamp(float value, float lower, float upper)
++{
++    if(value < lower)
++        return lower;
++    if(value > upper)
++        return upper;
++    return value;
++}
++void
++changealpha(const Arg *arg)
++{
++    if((alpha > 0 && arg->f < 0) || (alpha < 1 && arg->f > 0))
++        alpha += arg->f;
+ 
+-			f = frclen;
+-			frclen++;
++    //if (alpha < 0.03){
++    //    defaultbg = alphaBg;
++    //}else {
++    //    defaultbg = defaultAlphaBg;
++    //}
+ 
+-			FcPatternDestroy(fcpattern);
+-			FcCharSetDestroy(fccharset);
+-		}
++    alpha = clamp(alpha, 0.0, 1.0);
++    alphaUnfocus = clamp(alpha-alphaOffset, 0.0, 1.0);
+ 
+-		specs[numspecs].font = frc[f].font;
+-		specs[numspecs].glyph = glyphidx;
+-		specs[numspecs].x = (short)xp;
+-		specs[numspecs].y = (short)yp;
+-		xp += runewidth;
+-		numspecs++;
+-	}
++    xloadcols();
++    redraw();
+ 
+-	return numspecs;
++    // Debug
++    //char log_message[128];
++    //snprintf(log_message, sizeof(log_message), "changealpha called, alpha: %.2f", alpha);
++    //log_to_file(log_message);
+ }
+ 
+ void
+-xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
++xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y, int charlen)
+ {
+-	int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
+ 	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
+ 	    width = charlen * win.cw;
+ 	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
+@@ -1513,21 +1777,24 @@ void
+ xdrawglyph(Glyph g, int x, int y)
+ {
+ 	int numspecs;
+-	XftGlyphFontSpec spec;
++	XftGlyphFontSpec *specs = xw.specbuf;
+ 
+-	numspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);
+-	xdrawglyphfontspecs(&spec, g, numspecs, x, y);
++	numspecs = xmakeglyphfontspecs(specs, &g, 1, x, y);
++	xdrawglyphfontspecs(specs, g, numspecs, x, y, (g.mode & ATTR_WIDE) ? 2 : 1);
+ }
+ 
+ void
+-xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
++xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
+ {
+ 	Color drawcol;
+ 
+ 	/* remove the old cursor */
+ 	if (selected(ox, oy))
+ 		og.mode ^= ATTR_REVERSE;
+-	xdrawglyph(og, ox, oy);
++
++	/* Redraw the line where cursor was previously.
++	 * It will restore the ligatures broken by the cursor. */
++	xdrawline(line, 0, oy, len);
+ 
+ 	if (IS_SET(MODE_HIDE))
+ 		return;
+@@ -1661,18 +1928,16 @@ xdrawline(Line line, int x1, int y1, int x2)
+ 	Glyph base, new;
+ 	XftGlyphFontSpec *specs = xw.specbuf;
+ 
+-	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
+ 	i = ox = 0;
+-	for (x = x1; x < x2 && i < numspecs; x++) {
++	for (x = x1; x < x2; x++) {
+ 		new = line[x];
+ 		if (new.mode == ATTR_WDUMMY)
+ 			continue;
+ 		if (selected(x, y1))
+ 			new.mode ^= ATTR_REVERSE;
+-		if (i > 0 && ATTRCMP(base, new)) {
+-			xdrawglyphfontspecs(specs, base, i, ox, y1);
+-			specs += i;
+-			numspecs -= i;
++		if ((i > 0) && ATTRCMP(base, new)) {
++			numspecs = xmakeglyphfontspecs(specs, &line[ox], x - ox, ox, y1);
++			xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x - ox);
+ 			i = 0;
+ 		}
+ 		if (i == 0) {
+@@ -1681,8 +1946,10 @@ xdrawline(Line line, int x1, int y1, int x2)
+ 		}
+ 		i++;
+ 	}
+-	if (i > 0)
+-		xdrawglyphfontspecs(specs, base, i, ox, y1);
++	if (i > 0) {
++		numspecs = xmakeglyphfontspecs(specs, &line[ox], x2 - ox, ox, y1);
++		xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x2 - ox);
++	}
+ }
+ 
+ void
+@@ -2023,15 +2290,68 @@ run(void)
+ 	}
+ }
+ 
++int
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char **sdst = dst;
++	int *idst = dst;
++	float *fdst = dst;
++
++	char fullname[256];
++	char fullclass[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s",
++			opt_name ? opt_name : "st", name);
++	snprintf(fullclass, sizeof(fullclass), "%s.%s",
++			opt_class ? opt_class : "St", name);
++	fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
++
++	XrmGetResource(db, fullname, fullclass, &type, &ret);
++	if (ret.addr == NULL || strncmp("String", type, 64))
++		return 1;
++
++	switch (rtype) {
++	case STRING:
++		*sdst = ret.addr;
++		break;
++	case INTEGER:
++		*idst = strtoul(ret.addr, NULL, 10);
++		break;
++	case FLOAT:
++		*fdst = strtof(ret.addr, NULL);
++		break;
++	}
++	return 0;
++}
++
++void
++config_init(void)
++{
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	XrmInitialize();
++	resm = XResourceManagerString(xw.dpy);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LEN(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++}
++
+ void
+ usage(void)
+ {
+-	die("usage: %s [-aiv] [-c class] [-f font] [-g geometry]"
+-	    " [-n name] [-o file]\n"
++	die("usage: %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
+ 	    "          [-T title] [-t title] [-w windowid]"
+ 	    " [[-e] command [args ...]]\n"
+-	    "       %s [-aiv] [-c class] [-f font] [-g geometry]"
+-	    " [-n name] [-o file]\n"
++	    "       %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
+ 	    "          [-T title] [-t title] [-w windowid] -l line"
+ 	    " [stty_args ...]\n", argv0, argv0);
+ }
+@@ -2047,6 +2367,10 @@ main(int argc, char *argv[])
+ 	case 'a':
+ 		allowaltscreen = 0;
+ 		break;
++	case 'A':
++		alpha = strtof(EARGF(usage()), NULL);
++		LIMIT(alpha, 0.0, 1.0);
++		break;
+ 	case 'c':
+ 		opt_class = EARGF(usage());
+ 		break;
+@@ -2083,6 +2407,9 @@ main(int argc, char *argv[])
+ 	case 'v':
+ 		die("%s " VERSION "\n", argv0);
+ 		break;
++	case 'd':
++		opt_dir = EARGF(usage());
++		break;
+ 	default:
+ 		usage();
+ 	} ARGEND;
+@@ -2096,12 +2423,18 @@ run:
+ 
+ 	setlocale(LC_CTYPE, "");
+ 	XSetLocaleModifiers("");
++
++	if(!(xw.dpy = XOpenDisplay(NULL)))
++		die("Can't open display\n");
++
++	config_init();
+ 	cols = MAX(cols, 1);
+ 	rows = MAX(rows, 1);
+ 	tnew(cols, rows);
+ 	xinit(cols, rows);
+ 	xsetenv();
+ 	selinit();
++	chdir(opt_dir);
+ 	run();
+ 
+ 	return 0;
diff --git a/hb.c b/hb.c
new file mode 100644
index 0000000..99412c8
--- /dev/null
+++ b/hb.c
@@ -0,0 +1,125 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <X11/Xft/Xft.h>
+#include <X11/cursorfont.h>
+#include <hb.h>
+#include <hb-ft.h>
+
+#include "st.h"
+#include "hb.h"
+
+#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
+#define BUFFER_STEP 256
+
+hb_font_t *hbfindfont(XftFont *match);
+
+typedef struct {
+	XftFont *match;
+	hb_font_t *font;
+} HbFontMatch;
+
+typedef struct {
+	size_t capacity;
+	HbFontMatch *fonts;
+} HbFontCache;
+
+static HbFontCache hbfontcache = { 0, NULL };
+
+typedef struct {
+	size_t capacity;
+	Rune *runes;
+} RuneBuffer;
+
+static RuneBuffer hbrunebuffer = { 0, NULL };
+
+/*
+ * Poplulate the array with a list of font features, wrapped in FEATURE macro,
+ * e. g.
+ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
+ */
+hb_feature_t features[] = { };
+
+void
+hbunloadfonts()
+{
+	for (int i = 0; i < hbfontcache.capacity; i++) {
+		hb_font_destroy(hbfontcache.fonts[i].font);
+		XftUnlockFace(hbfontcache.fonts[i].match);
+	}
+
+	if (hbfontcache.fonts != NULL) {
+		free(hbfontcache.fonts);
+		hbfontcache.fonts = NULL;
+	}
+	hbfontcache.capacity = 0;
+}
+
+hb_font_t *
+hbfindfont(XftFont *match)
+{
+	for (int i = 0; i < hbfontcache.capacity; i++) {
+		if (hbfontcache.fonts[i].match == match)
+			return hbfontcache.fonts[i].font;
+	}
+
+	/* Font not found in cache, caching it now. */
+	hbfontcache.fonts = realloc(hbfontcache.fonts, sizeof(HbFontMatch) * (hbfontcache.capacity + 1));
+	FT_Face face = XftLockFace(match);
+	hb_font_t *font = hb_ft_font_create(face, NULL);
+	if (font == NULL)
+		die("Failed to load Harfbuzz font.");
+
+	hbfontcache.fonts[hbfontcache.capacity].match = match;
+	hbfontcache.fonts[hbfontcache.capacity].font = font;
+	hbfontcache.capacity += 1;
+
+	return font;
+}
+
+void hbtransform(HbTransformData *data, XftFont *xfont, const Glyph *glyphs, int start, int length) {
+	ushort mode = USHRT_MAX;
+	unsigned int glyph_count;
+	int rune_idx, glyph_idx, end = start + length;
+
+	hb_font_t *font = hbfindfont(xfont);
+	if (font == NULL)
+		return;
+
+	hb_buffer_t *buffer = hb_buffer_create();
+	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
+	hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
+
+	/* Resize the buffer if required length is larger. */
+	if (hbrunebuffer.capacity < length) {
+		hbrunebuffer.capacity = (length / BUFFER_STEP + 1) * BUFFER_STEP;
+		hbrunebuffer.runes = realloc(hbrunebuffer.runes, hbrunebuffer.capacity * sizeof(Rune));
+	}
+
+	/* Fill buffer with codepoints. */
+	for (rune_idx = 0, glyph_idx = start; glyph_idx < end; glyph_idx++, rune_idx++) {
+		hbrunebuffer.runes[rune_idx] = glyphs[glyph_idx].u;
+		mode = glyphs[glyph_idx].mode;
+		if (mode & ATTR_WDUMMY)
+			hbrunebuffer.runes[rune_idx] = 0x0020;
+	}
+	hb_buffer_add_codepoints(buffer, hbrunebuffer.runes, length, 0, length);
+
+	/* Shape the segment. */
+	hb_shape(font, buffer, features, sizeof(features)/sizeof(hb_feature_t));
+
+	/* Get new glyph info. */
+	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
+	hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);
+
+	/* Fill the output. */
+	data->buffer = buffer;
+	data->glyphs = info;
+	data->positions = pos;
+	data->count = glyph_count;
+}
+
+void hbcleanup(HbTransformData *data) {
+	hb_buffer_destroy(data->buffer);
+	memset(data, 0, sizeof(HbTransformData));
+}
diff --git a/hb.h b/hb.h
new file mode 100644
index 0000000..3b0ef44
--- /dev/null
+++ b/hb.h
@@ -0,0 +1,14 @@
+#include <X11/Xft/Xft.h>
+#include <hb.h>
+#include <hb-ft.h>
+
+typedef struct {
+	hb_buffer_t *buffer;
+	hb_glyph_info_t *glyphs;
+	hb_glyph_position_t *positions;
+	unsigned int count;
+} HbTransformData;
+
+void hbunloadfonts();
+void hbtransform(HbTransformData *, XftFont *, const Glyph *, int, int);
+void hbcleanup(HbTransformData *);
diff --git a/patches/get.sh b/patches/get.sh
new file mode 100755
index 0000000..6569b6b
--- /dev/null
+++ b/patches/get.sh
@@ -0,0 +1,57 @@
+# Example
+# https://dwm.suckless.org/patches/alpha/
+# curl -O https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# wget https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff
+# python -c "import urllib.request; urllib.request.urlretrieve('https://dwm.suckless.org/patches/alpha/dwm-alpha-20230401-348f655.diff', 'dwm-alpha-20230401-348f655.diff')"
+# exit 0
+
+download_if_not_exists() {
+  local url="$1"
+  local filename=$(basename "$url") # Extract the file name from the URL
+
+  # Check if the file already exists
+  if [[ -f "$filename" ]]; then
+    echo "File '$filename' already exists. Skipping download."
+  else
+    echo "Downloading '$filename'..."
+    curl -O "$url"
+    if [[ $? -eq 0 ]]; then
+      echo "Downloaded '$filename' successfully."
+    else
+      echo "Failed to download '$filename'."
+    fi
+  fi
+}
+
+# https://st.suckless.org/patches/font2/
+download_if_not_exists https://st.suckless.org/patches/font2/st-font2-0.8.5.diff
+
+# https://st.suckless.org/patches/scrollback/
+download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-0.9.2.diff
+download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-mouse-0.9.2.diff
+# More efficient scrolling
+#download_if_not_exists https://st.suckless.org/patches/scrollback/st-scrollback-ringbuffer-0.9.2.diff
+
+# https://st.suckless.org/patches/xresources/
+download_if_not_exists https://st.suckless.org/patches/xresources/st-xresources-20200604-9ba7ecf.diff
+
+# https://st.suckless.org/patches/alpha/
+download_if_not_exists https://st.suckless.org/patches/alpha/st-alpha-20240814-a0274bc.diff
+
+# https://st.suckless.org/patches/ligatures/
+download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
+#download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-alpha-scrollback-ringbuffer-20240427-0.9.2.diff
+#download_if_not_exists https://st.suckless.org/patches/ligatures/0.9.2/st-ligatures-boxdraw-20240427-0.9.2.diff
+
+# https://st.suckless.org/patches/boxdraw/
+#download_if_not_exists https://st.suckless.org/patches/boxdraw/st-boxdraw_v2-0.8.5.diff
+
+# https://st.suckless.org/patches/workingdir/
+download_if_not_exists https://st.suckless.org/patches/workingdir/st-workingdir-20200317-51e19ea.diff
+
+# https://st.suckless.org/patches/changealpha/
+download_if_not_exists https://st.suckless.org/patches/changealpha/st-changealpha-20230519-b44f2ad.diff
+
+# https://st.suckless.org/patches/externalpipe/
+download_if_not_exists https://st.suckless.org/patches/externalpipe/st-externalpipe-0.8.5.diff
+
diff --git a/patches/st-alpha-20240814-a0274bc.diff b/patches/st-alpha-20240814-a0274bc.diff
new file mode 100644
index 0000000..6913d19
--- /dev/null
+++ b/patches/st-alpha-20240814-a0274bc.diff
@@ -0,0 +1,129 @@
+diff --git a/config.def.h b/config.def.h
+index 2cd740a..019a4e1 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -93,6 +93,9 @@ char *termname = "st-256color";
+  */
+ unsigned int tabspaces = 8;
+ 
++/* bg opacity */
++float alpha = 0.8;
++
+ /* Terminal colors (16 first used in escape sequence) */
+ static const char *colorname[] = {
+ 	/* 8 normal colors */
+diff --git a/x.c b/x.c
+index d73152b..f32fd6c 100644
+--- a/x.c
++++ b/x.c
+@@ -105,6 +105,7 @@ typedef struct {
+ 	XSetWindowAttributes attrs;
+ 	int scr;
+ 	int isfixed; /* is fixed geometry? */
++	int depth; /* bit depth */
+ 	int l, t; /* left and top offset */
+ 	int gm; /* geometry mask */
+ } XWindow;
+@@ -752,7 +753,7 @@ xresize(int col, int row)
+ 
+ 	XFreePixmap(xw.dpy, xw.buf);
+ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
+-			DefaultDepth(xw.dpy, xw.scr));
++			xw.depth);
+ 	XftDrawChange(xw.draw, xw.buf);
+ 	xclear(0, 0, win.w, win.h);
+ 
+@@ -812,6 +813,10 @@ xloadcols(void)
+ 			else
+ 				die("could not allocate color %d\n", i);
+ 		}
++
++	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++	dc.col[defaultbg].pixel &= 0x00FFFFFF;
++	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
+ 	loaded = 1;
+ }
+ 
+@@ -842,6 +847,12 @@ xsetcolorname(int x, const char *name)
+ 	XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
+ 	dc.col[x] = ncolor;
+ 
++	if (x == defaultbg) {
++		dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
++		dc.col[defaultbg].pixel &= 0x00FFFFFF;
++		dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
++	}
++
+ 	return 0;
+ }
+ 
+@@ -1134,11 +1145,25 @@ xinit(int cols, int rows)
+ 	Window parent, root;
+ 	pid_t thispid = getpid();
+ 	XColor xmousefg, xmousebg;
++	XWindowAttributes attr;
++	XVisualInfo vis;
+ 
+ 	if (!(xw.dpy = XOpenDisplay(NULL)))
+ 		die("can't open display\n");
+ 	xw.scr = XDefaultScreen(xw.dpy);
+-	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
++
++	root = XRootWindow(xw.dpy, xw.scr);
++	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
++		parent = root;
++
++	if (XMatchVisualInfo(xw.dpy, xw.scr, 32, TrueColor, &vis) != 0) {
++		xw.vis = vis.visual;
++		xw.depth = vis.depth;
++	} else {
++		XGetWindowAttributes(xw.dpy, parent, &attr);
++		xw.vis = attr.visual;
++		xw.depth = attr.depth;
++	}
+ 
+ 	/* font */
+ 	if (!FcInit())
+@@ -1148,7 +1173,7 @@ xinit(int cols, int rows)
+ 	xloadfonts(usedfont, 0);
+ 
+ 	/* colors */
+-	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
++	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
+ 	xloadcols();
+ 
+ 	/* adjust fixed window geometry */
+@@ -1168,11 +1193,8 @@ xinit(int cols, int rows)
+ 		| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
+ 	xw.attrs.colormap = xw.cmap;
+ 
+-	root = XRootWindow(xw.dpy, xw.scr);
+-	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
+-		parent = root;
+-	xw.win = XCreateWindow(xw.dpy, root, xw.l, xw.t,
+-			win.w, win.h, 0, XDefaultDepth(xw.dpy, xw.scr), InputOutput,
++	xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
++			win.w, win.h, 0, xw.depth, InputOutput,
+ 			xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
+ 			| CWEventMask | CWColormap, &xw.attrs);
+ 	if (parent != root)
+@@ -1183,7 +1205,7 @@ xinit(int cols, int rows)
+ 	dc.gc = XCreateGC(xw.dpy, xw.win, GCGraphicsExposures,
+ 			&gcvalues);
+ 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
+-			DefaultDepth(xw.dpy, xw.scr));
++			xw.depth);
+ 	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
+ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
+ 
+@@ -2047,6 +2069,10 @@ main(int argc, char *argv[])
+ 	case 'a':
+ 		allowaltscreen = 0;
+ 		break;
++	case 'A':
++		alpha = strtof(EARGF(usage()), NULL);
++		LIMIT(alpha, 0.0, 1.0);
++		break;
+ 	case 'c':
+ 		opt_class = EARGF(usage());
+ 		break;
diff --git a/patches/st-changealpha-20230519-b44f2ad.diff b/patches/st-changealpha-20230519-b44f2ad.diff
new file mode 100644
index 0000000..172969f
--- /dev/null
+++ b/patches/st-changealpha-20230519-b44f2ad.diff
@@ -0,0 +1,80 @@
+diff --git a/config.def.h b/config.def.h
+index 91ab8ca..8a06176 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -93,6 +93,9 @@ char *termname = "st-256color";
+  */
+ unsigned int tabspaces = 8;
+ 
++/* Background opacity */
++float alpha_def;
++
+ /* Terminal colors (16 first used in escape sequence) */
+ static const char *colorname[] = {
+ 	/* 8 normal colors */
+@@ -201,6 +204,9 @@ static Shortcut shortcuts[] = {
+ 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
+ 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
+ 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
++	{ MODKEY,               XK_bracketleft, chgalpha,       {.f = -1} }, /* Decrease opacity */
++	{ MODKEY|ShiftMask,     XK_braceright,  chgalpha,       {.f = +1} }, /* Increase opacity */
++	{ MODKEY,               XK_bracketright,chgalpha,       {.f =  0} }, /* Reset opacity */
+ };
+ 
+ /*
+diff --git a/st.h b/st.h
+index fd3b0d8..3bb587e 100644
+--- a/st.h
++++ b/st.h
+@@ -124,3 +124,4 @@ extern unsigned int tabspaces;
+ extern unsigned int defaultfg;
+ extern unsigned int defaultbg;
+ extern unsigned int defaultcs;
++extern float alpha_def;
+diff --git a/x.c b/x.c
+index aa09997..f8c8c1a 100644
+--- a/x.c
++++ b/x.c
+@@ -59,6 +59,7 @@ static void zoom(const Arg *);
+ static void zoomabs(const Arg *);
+ static void zoomreset(const Arg *);
+ static void ttysend(const Arg *);
++static void chgalpha(const Arg *);
+ 
+ /* config.h for applying patches and the configuration. */
+ #include "config.h"
+@@ -1147,6 +1148,9 @@ xinit(int cols, int rows)
+ 	usedfont = (opt_font == NULL)? font : opt_font;
+ 	xloadfonts(usedfont, 0);
+ 
++   /* Backup default alpha value */
++   alpha_def = alpha;
++
+ 	/* colors */
+ 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
+ 	xloadcols();
+@@ -1371,6 +1375,24 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
+ 	return numspecs;
+ }
+ 
++void
++chgalpha(const Arg *arg)
++{
++   if (arg->f == -1.0f && alpha >= 0.1f)
++      alpha -= 0.1f;
++   else if (arg->f == 1.0f && alpha < 1.0f)
++      alpha += 0.1f;
++   else if (arg->f == 0.0f)
++      alpha = alpha_def;
++   else
++      return;
++
++   dc.col[defaultbg].color.alpha = (unsigned short)(0xFFFF * alpha);
++   /* Required to remove artifacting from borderpx */
++   cresize(0, 0);
++   redraw();
++}
++
+ void
+ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
+ {
diff --git a/patches/st-externalpipe-0.8.5.diff b/patches/st-externalpipe-0.8.5.diff
new file mode 100644
index 0000000..daf91d3
--- /dev/null
+++ b/patches/st-externalpipe-0.8.5.diff
@@ -0,0 +1,104 @@
+diff --git a/st.c b/st.c
+index 034954d..98f2589 100644
+--- a/st.c
++++ b/st.c
+@@ -718,8 +718,14 @@ sigchld(int a)
+ 	if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
+ 		die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
+ 
+-	if (pid != p)
++	if (pid != p) {
++		if (p == 0 && wait(&stat) < 0)
++			die("wait: %s\n", strerror(errno));
++
++		/* reinstall sigchld handler */
++		signal(SIGCHLD, sigchld);
+ 		return;
++	}
+ 
+ 	if (WIFEXITED(stat) && WEXITSTATUS(stat))
+ 		die("child exited with status %d\n", WEXITSTATUS(stat));
+@@ -803,7 +809,7 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
+ 		break;
+ 	default:
+ #ifdef __OpenBSD__
+-		if (pledge("stdio rpath tty proc", NULL) == -1)
++		if (pledge("stdio rpath tty proc exec", NULL) == -1)
+ 			die("pledge\n");
+ #endif
+ 		close(s);
+@@ -1991,6 +1997,59 @@ strparse(void)
+ 	}
+ }
+ 
++void
++externalpipe(const Arg *arg)
++{
++	int to[2];
++	char buf[UTF_SIZ];
++	void (*oldsigpipe)(int);
++	Glyph *bp, *end;
++	int lastpos, n, newline;
++
++	if (pipe(to) == -1)
++		return;
++
++	switch (fork()) {
++	case -1:
++		close(to[0]);
++		close(to[1]);
++		return;
++	case 0:
++		dup2(to[0], STDIN_FILENO);
++		close(to[0]);
++		close(to[1]);
++		execvp(((char **)arg->v)[0], (char **)arg->v);
++		fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
++		perror("failed");
++		exit(0);
++	}
++
++	close(to[0]);
++	/* ignore sigpipe for now, in case child exists early */
++	oldsigpipe = signal(SIGPIPE, SIG_IGN);
++	newline = 0;
++	for (n = 0; n < term.row; n++) {
++		bp = term.line[n];
++		lastpos = MIN(tlinelen(n) + 1, term.col) - 1;
++		if (lastpos < 0)
++			break;
++		end = &bp[lastpos + 1];
++		for (; bp < end; ++bp)
++			if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
++				break;
++		if ((newline = term.line[n][lastpos].mode & ATTR_WRAP))
++			continue;
++		if (xwrite(to[1], "\n", 1) < 0)
++			break;
++		newline = 0;
++	}
++	if (newline)
++		(void)xwrite(to[1], "\n", 1);
++	close(to[1]);
++	/* restore */
++	signal(SIGPIPE, oldsigpipe);
++}
++
+ void
+ strdump(void)
+ {
+diff --git a/st.h b/st.h
+index fd3b0d8..754cd08 100644
+--- a/st.h
++++ b/st.h
+@@ -81,6 +81,7 @@ void die(const char *, ...);
+ void redraw(void);
+ void draw(void);
+ 
++void externalpipe(const Arg *);
+ void printscreen(const Arg *);
+ void printsel(const Arg *);
+ void sendbreak(const Arg *);
+-- 
+2.42.0
+
diff --git a/patches/st-font2-0.8.5.diff b/patches/st-font2-0.8.5.diff
new file mode 100644
index 0000000..9b22b8a
--- /dev/null
+++ b/patches/st-font2-0.8.5.diff
@@ -0,0 +1,163 @@
+From 1635e04d3643dd4caa0c7c2043b585c6d7e4705f Mon Sep 17 00:00:00 2001
+From: Rizqi Nur Assyaufi <bandithijo@gmail.com>
+Date: Mon, 18 Jul 2022 01:15:45 +0800
+Subject: [PATCH] [st][patch][font2] Add patch for st-0.8.5
+
+---
+ config.def.h |   6 +++
+ x.c          | 101 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 107 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 91ab8ca..717b2f0 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -6,6 +6,12 @@
+  * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
+  */
+ static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
++/* Spare fonts */
++static char *font2[] = {
++/*	"Inconsolata for Powerline:pixelsize=12:antialias=true:autohint=true", */
++/*	"Hack Nerd Font Mono:pixelsize=11:antialias=true:autohint=true", */
++};
++
+ static int borderpx = 2;
+
+ /*
+diff --git a/x.c b/x.c
+index 8a16faa..220fc4f 100644
+--- a/x.c
++++ b/x.c
+@@ -157,6 +157,8 @@ static void xhints(void);
+ static int xloadcolor(int, const char *, Color *);
+ static int xloadfont(Font *, FcPattern *);
+ static void xloadfonts(const char *, double);
++static int xloadsparefont(FcPattern *, int);
++static void xloadsparefonts(void);
+ static void xunloadfont(Font *);
+ static void xunloadfonts(void);
+ static void xsetenv(void);
+@@ -306,6 +308,7 @@ zoomabs(const Arg *arg)
+ {
+ 	xunloadfonts();
+ 	xloadfonts(usedfont, arg->f);
++	xloadsparefonts();
+ 	cresize(0, 0);
+ 	redraw();
+ 	xhints();
+@@ -1034,6 +1037,101 @@ xloadfonts(const char *fontstr, double fontsize)
+ 	FcPatternDestroy(pattern);
+ }
+
++int
++xloadsparefont(FcPattern *pattern, int flags)
++{
++	FcPattern *match;
++	FcResult result;
++
++	match = FcFontMatch(NULL, pattern, &result);
++	if (!match) {
++		return 1;
++	}
++
++	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
++		FcPatternDestroy(match);
++		return 1;
++	}
++
++	frc[frclen].flags = flags;
++	/* Believe U+0000 glyph will present in each default font */
++	frc[frclen].unicodep = 0;
++	frclen++;
++
++	return 0;
++}
++
++void
++xloadsparefonts(void)
++{
++	FcPattern *pattern;
++	double sizeshift, fontval;
++	int fc;
++	char **fp;
++
++	if (frclen != 0)
++		die("can't embed spare fonts. cache isn't empty");
++
++	/* Calculate count of spare fonts */
++	fc = sizeof(font2) / sizeof(*font2);
++	if (fc == 0)
++		return;
++
++	/* Allocate memory for cache entries. */
++	if (frccap < 4 * fc) {
++		frccap += 4 * fc - frccap;
++		frc = xrealloc(frc, frccap * sizeof(Fontcache));
++	}
++
++	for (fp = font2; fp - font2 < fc; ++fp) {
++
++		if (**fp == '-')
++			pattern = XftXlfdParse(*fp, False, False);
++		else
++			pattern = FcNameParse((FcChar8 *)*fp);
++
++		if (!pattern)
++			die("can't open spare font %s\n", *fp);
++
++		if (defaultfontsize > 0) {
++			sizeshift = usedfontsize - defaultfontsize;
++			if (sizeshift != 0 &&
++					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
++					FcResultMatch) {
++				fontval += sizeshift;
++				FcPatternDel(pattern, FC_PIXEL_SIZE);
++				FcPatternDel(pattern, FC_SIZE);
++				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
++			}
++		}
++
++		FcPatternAddBool(pattern, FC_SCALABLE, 1);
++
++		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
++		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
++
++		if (xloadsparefont(pattern, FRC_NORMAL))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
++		if (xloadsparefont(pattern, FRC_ITALIC))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_WEIGHT);
++		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
++		if (xloadsparefont(pattern, FRC_ITALICBOLD))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDel(pattern, FC_SLANT);
++		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
++		if (xloadsparefont(pattern, FRC_BOLD))
++			die("can't open spare font %s\n", *fp);
++
++		FcPatternDestroy(pattern);
++	}
++}
++
+ void
+ xunloadfont(Font *f)
+ {
+@@ -1131,6 +1229,9 @@ xinit(int cols, int rows)
+ 	usedfont = (opt_font == NULL)? font : opt_font;
+ 	xloadfonts(usedfont, 0);
+
++	/* spare fonts */
++	xloadsparefonts();
++
+ 	/* colors */
+ 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
+ 	xloadcols();
+--
+2.37.1
+
diff --git a/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff b/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
new file mode 100644
index 0000000..3e9d675
--- /dev/null
+++ b/patches/st-ligatures-alpha-scrollback-20240427-0.9.2.diff
@@ -0,0 +1,635 @@
+diff --git a/Makefile b/Makefile
+index 470ac86..38240da 100644
+--- a/Makefile
++++ b/Makefile
+@@ -4,7 +4,7 @@
+ 
+ include config.mk
+ 
+-SRC = st.c x.c
++SRC = st.c x.c hb.c
+ OBJ = $(SRC:.c=.o)
+ 
+ all: st
+@@ -22,7 +22,8 @@ config.h:
+ 	$(CC) $(STCFLAGS) -c $<
+ 
+ st.o: config.h st.h win.h
+-x.o: arg.h config.h st.h win.h
++x.o: arg.h config.h st.h win.h hb.h
++hb.o: st.h
+ 
+ $(OBJ): config.h config.mk
+ 
+diff --git a/config.mk b/config.mk
+index 47c615e..d7439a3 100644
+--- a/config.mk
++++ b/config.mk
+@@ -15,10 +15,12 @@ PKG_CONFIG = pkg-config
+ # includes and libs
+ INCS = -I$(X11INC) \
+        `$(PKG_CONFIG) --cflags fontconfig` \
+-       `$(PKG_CONFIG) --cflags freetype2`
+-LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender\
++       `$(PKG_CONFIG) --cflags freetype2` \
++       `$(PKG_CONFIG) --cflags harfbuzz`
++LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender \
+        `$(PKG_CONFIG) --libs fontconfig` \
+-       `$(PKG_CONFIG) --libs freetype2`
++       `$(PKG_CONFIG) --libs freetype2` \
++       `$(PKG_CONFIG) --libs harfbuzz`
+ 
+ # flags
+ STCPPFLAGS = -DVERSION=\"$(VERSION)\" -D_XOPEN_SOURCE=600
+diff --git a/hb.c b/hb.c
+new file mode 100644
+index 0000000..99412c8
+--- /dev/null
++++ b/hb.c
+@@ -0,0 +1,125 @@
++#include <stdlib.h>
++#include <stdio.h>
++#include <math.h>
++#include <X11/Xft/Xft.h>
++#include <X11/cursorfont.h>
++#include <hb.h>
++#include <hb-ft.h>
++
++#include "st.h"
++#include "hb.h"
++
++#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
++#define BUFFER_STEP 256
++
++hb_font_t *hbfindfont(XftFont *match);
++
++typedef struct {
++	XftFont *match;
++	hb_font_t *font;
++} HbFontMatch;
++
++typedef struct {
++	size_t capacity;
++	HbFontMatch *fonts;
++} HbFontCache;
++
++static HbFontCache hbfontcache = { 0, NULL };
++
++typedef struct {
++	size_t capacity;
++	Rune *runes;
++} RuneBuffer;
++
++static RuneBuffer hbrunebuffer = { 0, NULL };
++
++/*
++ * Poplulate the array with a list of font features, wrapped in FEATURE macro,
++ * e. g.
++ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
++ */
++hb_feature_t features[] = { };
++
++void
++hbunloadfonts()
++{
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		hb_font_destroy(hbfontcache.fonts[i].font);
++		XftUnlockFace(hbfontcache.fonts[i].match);
++	}
++
++	if (hbfontcache.fonts != NULL) {
++		free(hbfontcache.fonts);
++		hbfontcache.fonts = NULL;
++	}
++	hbfontcache.capacity = 0;
++}
++
++hb_font_t *
++hbfindfont(XftFont *match)
++{
++	for (int i = 0; i < hbfontcache.capacity; i++) {
++		if (hbfontcache.fonts[i].match == match)
++			return hbfontcache.fonts[i].font;
++	}
++
++	/* Font not found in cache, caching it now. */
++	hbfontcache.fonts = realloc(hbfontcache.fonts, sizeof(HbFontMatch) * (hbfontcache.capacity + 1));
++	FT_Face face = XftLockFace(match);
++	hb_font_t *font = hb_ft_font_create(face, NULL);
++	if (font == NULL)
++		die("Failed to load Harfbuzz font.");
++
++	hbfontcache.fonts[hbfontcache.capacity].match = match;
++	hbfontcache.fonts[hbfontcache.capacity].font = font;
++	hbfontcache.capacity += 1;
++
++	return font;
++}
++
++void hbtransform(HbTransformData *data, XftFont *xfont, const Glyph *glyphs, int start, int length) {
++	ushort mode = USHRT_MAX;
++	unsigned int glyph_count;
++	int rune_idx, glyph_idx, end = start + length;
++
++	hb_font_t *font = hbfindfont(xfont);
++	if (font == NULL)
++		return;
++
++	hb_buffer_t *buffer = hb_buffer_create();
++	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
++	hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
++
++	/* Resize the buffer if required length is larger. */
++	if (hbrunebuffer.capacity < length) {
++		hbrunebuffer.capacity = (length / BUFFER_STEP + 1) * BUFFER_STEP;
++		hbrunebuffer.runes = realloc(hbrunebuffer.runes, hbrunebuffer.capacity * sizeof(Rune));
++	}
++
++	/* Fill buffer with codepoints. */
++	for (rune_idx = 0, glyph_idx = start; glyph_idx < end; glyph_idx++, rune_idx++) {
++		hbrunebuffer.runes[rune_idx] = glyphs[glyph_idx].u;
++		mode = glyphs[glyph_idx].mode;
++		if (mode & ATTR_WDUMMY)
++			hbrunebuffer.runes[rune_idx] = 0x0020;
++	}
++	hb_buffer_add_codepoints(buffer, hbrunebuffer.runes, length, 0, length);
++
++	/* Shape the segment. */
++	hb_shape(font, buffer, features, sizeof(features)/sizeof(hb_feature_t));
++
++	/* Get new glyph info. */
++	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
++	hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);
++
++	/* Fill the output. */
++	data->buffer = buffer;
++	data->glyphs = info;
++	data->positions = pos;
++	data->count = glyph_count;
++}
++
++void hbcleanup(HbTransformData *data) {
++	hb_buffer_destroy(data->buffer);
++	memset(data, 0, sizeof(HbTransformData));
++}
+diff --git a/hb.h b/hb.h
+new file mode 100644
+index 0000000..3b0ef44
+--- /dev/null
++++ b/hb.h
+@@ -0,0 +1,14 @@
++#include <X11/Xft/Xft.h>
++#include <hb.h>
++#include <hb-ft.h>
++
++typedef struct {
++	hb_buffer_t *buffer;
++	hb_glyph_info_t *glyphs;
++	hb_glyph_position_t *positions;
++	unsigned int count;
++} HbTransformData;
++
++void hbunloadfonts();
++void hbtransform(HbTransformData *, XftFont *, const Glyph *, int, int);
++void hbcleanup(HbTransformData *);
+diff --git a/st.c b/st.c
+index 79ee9ba..454771d 100644
+--- a/st.c
++++ b/st.c
+@@ -2711,7 +2711,9 @@ draw(void)
+ 	drawregion(0, 0, term.col, term.row);
+ 	if (term.scr == 0)
+ 		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+-				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
++				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
++				term.line[term.ocy], term.col);
++
+ 	term.ocx = cx;
+ 	term.ocy = term.c.y;
+ 	xfinishdraw();
+diff --git a/st.h b/st.h
+index 78762a2..01eea49 100644
+--- a/st.h
++++ b/st.h
+@@ -11,7 +11,8 @@
+ #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
+ #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
+ #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
+-#define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
++#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP)) != ((b).mode & (~ATTR_WRAP)) || \
++				(a).fg != (b).fg || \
+ 				(a).bg != (b).bg)
+ #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
+ 				(t1.tv_nsec-t2.tv_nsec)/1E6)
+diff --git a/win.h b/win.h
+index 6de960d..94679e4 100644
+--- a/win.h
++++ b/win.h
+@@ -25,7 +25,7 @@ enum win_mode {
+ 
+ void xbell(void);
+ void xclipcopy(void);
+-void xdrawcursor(int, int, Glyph, int, int, Glyph);
++void xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);
+ void xdrawline(Line, int, int, int);
+ void xfinishdraw(void);
+ void xloadcols(void);
+diff --git a/x.c b/x.c
+index 27e81d1..5e11c1f 100644
+--- a/x.c
++++ b/x.c
+@@ -19,6 +19,7 @@ char *argv0;
+ #include "arg.h"
+ #include "st.h"
+ #include "win.h"
++#include "hb.h"
+ 
+ /* types used in config.h */
+ typedef struct {
+@@ -142,8 +143,9 @@ typedef struct {
+ } DC;
+ 
+ static inline ushort sixd_to_16bit(int);
++static void xresetfontsettings(ushort mode, Font **font, int *frcflags);
+ static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
+-static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
++static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int, int);
+ static void xdrawglyph(Glyph, int, int);
+ static void xclear(int, int, int, int);
+ static int xgeommasktogravity(int);
+@@ -759,7 +761,7 @@ xresize(int col, int row)
+ 	xclear(0, 0, win.w, win.h);
+ 
+ 	/* resize to new width */
+-	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));
++	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec) * 4);
+ }
+ 
+ ushort
+@@ -1071,6 +1073,9 @@ xunloadfont(Font *f)
+ void
+ xunloadfonts(void)
+ {
++	/* Clear Harfbuzz font cache. */
++	hbunloadfonts();
++
+ 	/* Free the loaded fonts in the font cache.  */
+ 	while (frclen > 0)
+ 		XftFontClose(xw.dpy, frc[--frclen].font);
+@@ -1202,7 +1207,7 @@ xinit(int cols, int rows)
+ 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
+ 
+ 	/* font spec buffer */
+-	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));
++	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec) * 4);
+ 
+ 	/* Xft rendering context */
+ 	xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
+@@ -1256,6 +1261,22 @@ xinit(int cols, int rows)
+ 		xsel.xtarget = XA_STRING;
+ }
+ 
++void
++xresetfontsettings(ushort mode, Font **font, int *frcflags)
++{
++	*font = &dc.font;
++	if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
++		*font = &dc.ibfont;
++		*frcflags = FRC_ITALICBOLD;
++	} else if (mode & ATTR_ITALIC) {
++		*font = &dc.ifont;
++		*frcflags = FRC_ITALIC;
++	} else if (mode & ATTR_BOLD) {
++		*font = &dc.bfont;
++		*frcflags = FRC_BOLD;
++	}
++}
++
+ int
+ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
+ {
+@@ -1270,128 +1291,156 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
+ 	FcPattern *fcpattern, *fontpattern;
+ 	FcFontSet *fcsets[] = { NULL };
+ 	FcCharSet *fccharset;
+-	int i, f, numspecs = 0;
++	int i, f, length = 0, start = 0, numspecs = 0;
++	float cluster_xp = xp, cluster_yp = yp;
++	HbTransformData shaped = { 0 };
++
++	/* Initial values. */
++	mode = prevmode = glyphs[0].mode & ~ATTR_WRAP;
++	xresetfontsettings(mode, &font, &frcflags);
+ 
+ 	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
+-		/* Fetch rune and mode for current glyph. */
+-		rune = glyphs[i].u;
+-		mode = glyphs[i].mode;
++		mode = glyphs[i].mode & ~ATTR_WRAP;
+ 
+ 		/* Skip dummy wide-character spacing. */
+-		if (mode == ATTR_WDUMMY)
++		if (mode & ATTR_WDUMMY && i < (len - 1))
+ 			continue;
+ 
+-		/* Determine font for glyph if different from previous glyph. */
+-		if (prevmode != mode) {
+-			prevmode = mode;
+-			font = &dc.font;
+-			frcflags = FRC_NORMAL;
+-			runewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);
+-			if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
+-				font = &dc.ibfont;
+-				frcflags = FRC_ITALICBOLD;
+-			} else if (mode & ATTR_ITALIC) {
+-				font = &dc.ifont;
+-				frcflags = FRC_ITALIC;
+-			} else if (mode & ATTR_BOLD) {
+-				font = &dc.bfont;
+-				frcflags = FRC_BOLD;
++		if (
++			prevmode != mode
++			|| ATTRCMP(glyphs[start], glyphs[i])
++			|| selected(x + i, y) != selected(x + start, y)
++			|| i == (len - 1)
++		) {
++			/* Handle 1-character wide segments and end of line */
++			length = i - start;
++			if (i == start) {
++				length = 1;
++			} else if (i == (len - 1)) {
++				length = (i - start + 1);
+ 			}
+-			yp = winy + font->ascent;
+-		}
+ 
+-		/* Lookup character index with default font. */
+-		glyphidx = XftCharIndex(xw.dpy, font->match, rune);
+-		if (glyphidx) {
+-			specs[numspecs].font = font->match;
+-			specs[numspecs].glyph = glyphidx;
+-			specs[numspecs].x = (short)xp;
+-			specs[numspecs].y = (short)yp;
+-			xp += runewidth;
+-			numspecs++;
+-			continue;
+-		}
+-
+-		/* Fallback on font cache, search the font cache for match. */
+-		for (f = 0; f < frclen; f++) {
+-			glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
+-			/* Everything correct. */
+-			if (glyphidx && frc[f].flags == frcflags)
+-				break;
+-			/* We got a default font for a not found glyph. */
+-			if (!glyphidx && frc[f].flags == frcflags
+-					&& frc[f].unicodep == rune) {
+-				break;
++			/* Shape the segment. */
++			hbtransform(&shaped, font->match, glyphs, start, length);
++			runewidth = win.cw * ((glyphs[start].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++			cluster_xp = xp; cluster_yp = yp;
++			for (int code_idx = 0; code_idx < shaped.count; code_idx++) {
++				int idx = shaped.glyphs[code_idx].cluster;
++
++				if (glyphs[start + idx].mode & ATTR_WDUMMY)
++					continue;
++
++				/* Advance the drawing cursor if we've moved to a new cluster */
++				if (code_idx > 0 && idx != shaped.glyphs[code_idx - 1].cluster) {
++					xp += runewidth;
++					cluster_xp = xp;
++					cluster_yp = yp;
++					runewidth = win.cw * ((glyphs[start + idx].mode & ATTR_WIDE) ? 2.0f : 1.0f);
++				}
++
++				if (shaped.glyphs[code_idx].codepoint != 0) {
++					/* If symbol is found, put it into the specs. */
++					specs[numspecs].font = font->match;
++					specs[numspecs].glyph = shaped.glyphs[code_idx].codepoint;
++					specs[numspecs].x = cluster_xp + (short)(shaped.positions[code_idx].x_offset / 64.);
++					specs[numspecs].y = cluster_yp - (short)(shaped.positions[code_idx].y_offset / 64.);
++					cluster_xp += shaped.positions[code_idx].x_advance / 64.;
++					cluster_yp += shaped.positions[code_idx].y_advance / 64.;
++					numspecs++;
++				} else {
++					/* If it's not found, try to fetch it through the font cache. */
++					rune = glyphs[start + idx].u;
++					for (f = 0; f < frclen; f++) {
++						glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
++						/* Everything correct. */
++						if (glyphidx && frc[f].flags == frcflags)
++							break;
++						/* We got a default font for a not found glyph. */
++						if (!glyphidx && frc[f].flags == frcflags
++								&& frc[f].unicodep == rune) {
++							break;
++						}
++					}
++
++					/* Nothing was found. Use fontconfig to find matching font. */
++					if (f >= frclen) {
++						if (!font->set)
++							font->set = FcFontSort(0, font->pattern,
++																		 1, 0, &fcres);
++						fcsets[0] = font->set;
++
++						/*
++						 * Nothing was found in the cache. Now use
++						 * some dozen of Fontconfig calls to get the
++						 * font for one single character.
++						 *
++						 * Xft and fontconfig are design failures.
++						 */
++						fcpattern = FcPatternDuplicate(font->pattern);
++						fccharset = FcCharSetCreate();
++
++						FcCharSetAddChar(fccharset, rune);
++						FcPatternAddCharSet(fcpattern, FC_CHARSET,
++								fccharset);
++						FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
++
++						FcConfigSubstitute(0, fcpattern,
++								FcMatchPattern);
++						FcDefaultSubstitute(fcpattern);
++
++						fontpattern = FcFontSetMatch(0, fcsets, 1,
++								fcpattern, &fcres);
++
++						/* Allocate memory for the new cache entry. */
++						if (frclen >= frccap) {
++							frccap += 16;
++							frc = xrealloc(frc, frccap * sizeof(Fontcache));
++						}
++
++						frc[frclen].font = XftFontOpenPattern(xw.dpy,
++								fontpattern);
++						if (!frc[frclen].font)
++							die("XftFontOpenPattern failed seeking fallback font: %s\n",
++								strerror(errno));
++						frc[frclen].flags = frcflags;
++						frc[frclen].unicodep = rune;
++
++						glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
++
++						f = frclen;
++						frclen++;
++
++						FcPatternDestroy(fcpattern);
++						FcCharSetDestroy(fccharset);
++					}
++
++					specs[numspecs].font = frc[f].font;
++					specs[numspecs].glyph = glyphidx;
++					specs[numspecs].x = (short)xp;
++					specs[numspecs].y = (short)yp;
++					numspecs++;
++				}
+ 			}
+-		}
+ 
+-		/* Nothing was found. Use fontconfig to find matching font. */
+-		if (f >= frclen) {
+-			if (!font->set)
+-				font->set = FcFontSort(0, font->pattern,
+-				                       1, 0, &fcres);
+-			fcsets[0] = font->set;
++			/* Cleanup and get ready for next segment. */
++			hbcleanup(&shaped);
++			start = i;
+ 
+-			/*
+-			 * Nothing was found in the cache. Now use
+-			 * some dozen of Fontconfig calls to get the
+-			 * font for one single character.
+-			 *
+-			 * Xft and fontconfig are design failures.
+-			 */
+-			fcpattern = FcPatternDuplicate(font->pattern);
+-			fccharset = FcCharSetCreate();
+-
+-			FcCharSetAddChar(fccharset, rune);
+-			FcPatternAddCharSet(fcpattern, FC_CHARSET,
+-					fccharset);
+-			FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
+-
+-			FcConfigSubstitute(0, fcpattern,
+-					FcMatchPattern);
+-			FcDefaultSubstitute(fcpattern);
+-
+-			fontpattern = FcFontSetMatch(0, fcsets, 1,
+-					fcpattern, &fcres);
+-
+-			/* Allocate memory for the new cache entry. */
+-			if (frclen >= frccap) {
+-				frccap += 16;
+-				frc = xrealloc(frc, frccap * sizeof(Fontcache));
++			/* Determine font for glyph if different from previous glyph. */
++			if (prevmode != mode) {
++				prevmode = mode;
++				xresetfontsettings(mode, &font, &frcflags);
++				yp = winy + font->ascent;
+ 			}
+-
+-			frc[frclen].font = XftFontOpenPattern(xw.dpy,
+-					fontpattern);
+-			if (!frc[frclen].font)
+-				die("XftFontOpenPattern failed seeking fallback font: %s\n",
+-					strerror(errno));
+-			frc[frclen].flags = frcflags;
+-			frc[frclen].unicodep = rune;
+-
+-			glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
+-
+-			f = frclen;
+-			frclen++;
+-
+-			FcPatternDestroy(fcpattern);
+-			FcCharSetDestroy(fccharset);
+ 		}
+-
+-		specs[numspecs].font = frc[f].font;
+-		specs[numspecs].glyph = glyphidx;
+-		specs[numspecs].x = (short)xp;
+-		specs[numspecs].y = (short)yp;
+-		xp += runewidth;
+-		numspecs++;
+ 	}
+ 
+ 	return numspecs;
+ }
+ 
+ void
+-xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
++xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y, int charlen)
+ {
+-	int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
+ 	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
+ 	    width = charlen * win.cw;
+ 	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
+@@ -1527,21 +1576,24 @@ void
+ xdrawglyph(Glyph g, int x, int y)
+ {
+ 	int numspecs;
+-	XftGlyphFontSpec spec;
++	XftGlyphFontSpec *specs = xw.specbuf;
+ 
+-	numspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);
+-	xdrawglyphfontspecs(&spec, g, numspecs, x, y);
++	numspecs = xmakeglyphfontspecs(specs, &g, 1, x, y);
++	xdrawglyphfontspecs(specs, g, numspecs, x, y, (g.mode & ATTR_WIDE) ? 2 : 1);
+ }
+ 
+ void
+-xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
++xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
+ {
+ 	Color drawcol;
+ 
+ 	/* remove the old cursor */
+ 	if (selected(ox, oy))
+ 		og.mode ^= ATTR_REVERSE;
+-	xdrawglyph(og, ox, oy);
++
++	/* Redraw the line where cursor was previously.
++	 * It will restore the ligatures broken by the cursor. */
++	xdrawline(line, 0, oy, len);
+ 
+ 	if (IS_SET(MODE_HIDE))
+ 		return;
+@@ -1669,18 +1721,16 @@ xdrawline(Line line, int x1, int y1, int x2)
+ 	Glyph base, new;
+ 	XftGlyphFontSpec *specs = xw.specbuf;
+ 
+-	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
+ 	i = ox = 0;
+-	for (x = x1; x < x2 && i < numspecs; x++) {
++	for (x = x1; x < x2; x++) {
+ 		new = line[x];
+ 		if (new.mode == ATTR_WDUMMY)
+ 			continue;
+ 		if (selected(x, y1))
+ 			new.mode ^= ATTR_REVERSE;
+-		if (i > 0 && ATTRCMP(base, new)) {
+-			xdrawglyphfontspecs(specs, base, i, ox, y1);
+-			specs += i;
+-			numspecs -= i;
++		if ((i > 0) && ATTRCMP(base, new)) {
++			numspecs = xmakeglyphfontspecs(specs, &line[ox], x - ox, ox, y1);
++			xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x - ox);
+ 			i = 0;
+ 		}
+ 		if (i == 0) {
+@@ -1689,8 +1739,10 @@ xdrawline(Line line, int x1, int y1, int x2)
+ 		}
+ 		i++;
+ 	}
+-	if (i > 0)
+-		xdrawglyphfontspecs(specs, base, i, ox, y1);
++	if (i > 0) {
++		numspecs = xmakeglyphfontspecs(specs, &line[ox], x2 - ox, ox, y1);
++		xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x2 - ox);
++	}
+ }
+ 
+ void
diff --git a/patches/st-scrollback-0.9.2.diff b/patches/st-scrollback-0.9.2.diff
new file mode 100644
index 0000000..f9782e8
--- /dev/null
+++ b/patches/st-scrollback-0.9.2.diff
@@ -0,0 +1,351 @@
+diff --git a/config.def.h b/config.def.h
+index 2cd740a..40b7d93 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -201,6 +201,8 @@ static Shortcut shortcuts[] = {
+ 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
+ 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
+ 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
++	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
++    { ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
+ };
+ 
+ /*
+diff --git a/st.c b/st.c
+index b9f66e7..2478942 100644
+--- a/st.c
++++ b/st.c
+@@ -35,6 +35,7 @@
+ #define ESC_ARG_SIZ   16
+ #define STR_BUF_SIZ   ESC_BUF_SIZ
+ #define STR_ARG_SIZ   ESC_ARG_SIZ
++#define HISTSIZE      2000
+ 
+ /* macros */
+ #define IS_SET(flag)		((term.mode & (flag)) != 0)
+@@ -42,6 +43,9 @@
+ #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
+ #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
+ #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
++#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
++            term.scr + HISTSIZE + 1) % HISTSIZE] : \
++            term.line[(y) - term.scr])
+ 
+ enum term_mode {
+ 	MODE_WRAP        = 1 << 0,
+@@ -115,6 +119,9 @@ typedef struct {
+ 	int col;      /* nb col */
+ 	Line *line;   /* screen */
+ 	Line *alt;    /* alternate screen */
++	Line hist[HISTSIZE]; /* history buffer */
++	int histi;    /* history index */
++	int scr;      /* scroll back */
+ 	int *dirty;   /* dirtyness of lines */
+ 	TCursor c;    /* cursor */
+ 	int ocx;      /* old cursor col */
+@@ -185,8 +192,8 @@ static void tnewline(int);
+ static void tputtab(int);
+ static void tputc(Rune);
+ static void treset(void);
+-static void tscrollup(int, int);
+-static void tscrolldown(int, int);
++static void tscrollup(int, int, int);
++static void tscrolldown(int, int, int);
+ static void tsetattr(const int *, int);
+ static void tsetchar(Rune, const Glyph *, int, int);
+ static void tsetdirt(int, int);
+@@ -409,10 +416,10 @@ tlinelen(int y)
+ {
+ 	int i = term.col;
+ 
+-	if (term.line[y][i - 1].mode & ATTR_WRAP)
++	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
+ 		return i;
+ 
+-	while (i > 0 && term.line[y][i - 1].u == ' ')
++	while (i > 0 && TLINE(y)[i - 1].u == ' ')
+ 		--i;
+ 
+ 	return i;
+@@ -521,7 +528,7 @@ selsnap(int *x, int *y, int direction)
+ 		 * Snap around if the word wraps around at the end or
+ 		 * beginning of a line.
+ 		 */
+-		prevgp = &term.line[*y][*x];
++		prevgp = &TLINE(*y)[*x];
+ 		prevdelim = ISDELIM(prevgp->u);
+ 		for (;;) {
+ 			newx = *x + direction;
+@@ -536,14 +543,14 @@ selsnap(int *x, int *y, int direction)
+ 					yt = *y, xt = *x;
+ 				else
+ 					yt = newy, xt = newx;
+-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
++				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
+ 					break;
+ 			}
+ 
+ 			if (newx >= tlinelen(newy))
+ 				break;
+ 
+-			gp = &term.line[newy][newx];
++			gp = &TLINE(newy)[newx];
+ 			delim = ISDELIM(gp->u);
+ 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
+ 					|| (delim && gp->u != prevgp->u)))
+@@ -564,14 +571,14 @@ selsnap(int *x, int *y, int direction)
+ 		*x = (direction < 0) ? 0 : term.col - 1;
+ 		if (direction < 0) {
+ 			for (; *y > 0; *y += direction) {
+-				if (!(term.line[*y-1][term.col-1].mode
++				if (!(TLINE(*y-1)[term.col-1].mode
+ 						& ATTR_WRAP)) {
+ 					break;
+ 				}
+ 			}
+ 		} else if (direction > 0) {
+ 			for (; *y < term.row-1; *y += direction) {
+-				if (!(term.line[*y][term.col-1].mode
++				if (!(TLINE(*y)[term.col-1].mode
+ 						& ATTR_WRAP)) {
+ 					break;
+ 				}
+@@ -602,13 +609,13 @@ getsel(void)
+ 		}
+ 
+ 		if (sel.type == SEL_RECTANGULAR) {
+-			gp = &term.line[y][sel.nb.x];
++			gp = &TLINE(y)[sel.nb.x];
+ 			lastx = sel.ne.x;
+ 		} else {
+-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
++			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
+ 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
+ 		}
+-		last = &term.line[y][MIN(lastx, linelen-1)];
++		last = &TLINE(y)[MIN(lastx, linelen-1)];
+ 		while (last >= gp && last->u == ' ')
+ 			--last;
+ 
+@@ -844,6 +851,9 @@ void
+ ttywrite(const char *s, size_t n, int may_echo)
+ {
+ 	const char *next;
++	Arg arg = (Arg) { .i = term.scr };
++
++	kscrolldown(&arg);
+ 
+ 	if (may_echo && IS_SET(MODE_ECHO))
+ 		twrite(s, n, 1);
+@@ -1055,13 +1065,53 @@ tswapscreen(void)
+ }
+ 
+ void
+-tscrolldown(int orig, int n)
++kscrolldown(const Arg* a)
++{
++	int n = a->i;
++
++	if (n < 0)
++		n = term.row + n;
++
++	if (n > term.scr)
++		n = term.scr;
++
++	if (term.scr > 0) {
++		term.scr -= n;
++		selscroll(0, -n);
++		tfulldirt();
++	}
++}
++
++void
++kscrollup(const Arg* a)
++{
++	int n = a->i;
++
++	if (n < 0)
++		n = term.row + n;
++
++	if (term.scr <= HISTSIZE-n) {
++		term.scr += n;
++		selscroll(0, n);
++		tfulldirt();
++	}
++}
++
++void
++tscrolldown(int orig, int n, int copyhist)
+ {
+ 	int i;
+ 	Line temp;
+ 
+ 	LIMIT(n, 0, term.bot-orig+1);
+ 
++	if (copyhist) {
++		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[term.bot];
++		term.line[term.bot] = temp;
++	}
++
+ 	tsetdirt(orig, term.bot-n);
+ 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
+ 
+@@ -1071,17 +1121,28 @@ tscrolldown(int orig, int n)
+ 		term.line[i-n] = temp;
+ 	}
+ 
+-	selscroll(orig, n);
++	if (term.scr == 0)
++		selscroll(orig, n);
+ }
+ 
+ void
+-tscrollup(int orig, int n)
++tscrollup(int orig, int n, int copyhist)
+ {
+ 	int i;
+ 	Line temp;
+ 
+ 	LIMIT(n, 0, term.bot-orig+1);
+ 
++	if (copyhist) {
++		term.histi = (term.histi + 1) % HISTSIZE;
++		temp = term.hist[term.histi];
++		term.hist[term.histi] = term.line[orig];
++		term.line[orig] = temp;
++	}
++
++	if (term.scr > 0 && term.scr < HISTSIZE)
++		term.scr = MIN(term.scr + n, HISTSIZE-1);
++
+ 	tclearregion(0, orig, term.col-1, orig+n-1);
+ 	tsetdirt(orig+n, term.bot);
+ 
+@@ -1091,7 +1152,8 @@ tscrollup(int orig, int n)
+ 		term.line[i+n] = temp;
+ 	}
+ 
+-	selscroll(orig, -n);
++	if (term.scr == 0)
++		selscroll(orig, -n);
+ }
+ 
+ void
+@@ -1120,7 +1182,7 @@ tnewline(int first_col)
+ 	int y = term.c.y;
+ 
+ 	if (y == term.bot) {
+-		tscrollup(term.top, 1);
++		tscrollup(term.top, 1, 1);
+ 	} else {
+ 		y++;
+ 	}
+@@ -1285,14 +1347,14 @@ void
+ tinsertblankline(int n)
+ {
+ 	if (BETWEEN(term.c.y, term.top, term.bot))
+-		tscrolldown(term.c.y, n);
++		tscrolldown(term.c.y, n, 0);
+ }
+ 
+ void
+ tdeleteline(int n)
+ {
+ 	if (BETWEEN(term.c.y, term.top, term.bot))
+-		tscrollup(term.c.y, n);
++		tscrollup(term.c.y, n, 0);
+ }
+ 
+ int32_t
+@@ -1730,11 +1792,11 @@ csihandle(void)
+ 	case 'S': /* SU -- Scroll <n> line up */
+ 		if (csiescseq.priv) break;
+ 		DEFAULT(csiescseq.arg[0], 1);
+-		tscrollup(term.top, csiescseq.arg[0]);
++		tscrollup(term.top, csiescseq.arg[0], 0);
+ 		break;
+ 	case 'T': /* SD -- Scroll <n> line down */
+ 		DEFAULT(csiescseq.arg[0], 1);
+-		tscrolldown(term.top, csiescseq.arg[0]);
++		tscrolldown(term.top, csiescseq.arg[0], 0);
+ 		break;
+ 	case 'L': /* IL -- Insert <n> blank lines */
+ 		DEFAULT(csiescseq.arg[0], 1);
+@@ -2306,7 +2368,7 @@ eschandle(uchar ascii)
+ 		return 0;
+ 	case 'D': /* IND -- Linefeed */
+ 		if (term.c.y == term.bot) {
+-			tscrollup(term.top, 1);
++			tscrollup(term.top, 1, 1);
+ 		} else {
+ 			tmoveto(term.c.x, term.c.y+1);
+ 		}
+@@ -2319,7 +2381,7 @@ eschandle(uchar ascii)
+ 		break;
+ 	case 'M': /* RI -- Reverse index */
+ 		if (term.c.y == term.top) {
+-			tscrolldown(term.top, 1);
++			tscrolldown(term.top, 1, 1);
+ 		} else {
+ 			tmoveto(term.c.x, term.c.y-1);
+ 		}
+@@ -2542,7 +2604,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
+ void
+ tresize(int col, int row)
+ {
+-	int i;
++	int i, j;
+ 	int minrow = MIN(row, term.row);
+ 	int mincol = MIN(col, term.col);
+ 	int *bp;
+@@ -2579,6 +2641,14 @@ tresize(int col, int row)
+ 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
+ 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
+ 
++	for (i = 0; i < HISTSIZE; i++) {
++		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
++		for (j = mincol; j < col; j++) {
++			term.hist[i][j] = term.c.attr;
++			term.hist[i][j].u = ' ';
++		}
++	}
++
+ 	/* resize each row to new width, zero-pad if needed */
+ 	for (i = 0; i < minrow; i++) {
+ 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
+@@ -2637,7 +2707,7 @@ drawregion(int x1, int y1, int x2, int y2)
+ 			continue;
+ 
+ 		term.dirty[y] = 0;
+-		xdrawline(term.line[y], x1, y, x2);
++		xdrawline(TLINE(y), x1, y, x2);
+ 	}
+ }
+ 
+@@ -2658,8 +2728,9 @@ draw(void)
+ 		cx--;
+ 
+ 	drawregion(0, 0, term.col, term.row);
+-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
++	if (term.scr == 0)
++		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
++				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+ 	term.ocx = cx;
+ 	term.ocy = term.c.y;
+ 	xfinishdraw();
+diff --git a/st.h b/st.h
+index fd3b0d8..818a6f8 100644
+--- a/st.h
++++ b/st.h
+@@ -81,6 +81,8 @@ void die(const char *, ...);
+ void redraw(void);
+ void draw(void);
+ 
++void kscrolldown(const Arg *);
++void kscrollup(const Arg *);
+ void printscreen(const Arg *);
+ void printsel(const Arg *);
+ void sendbreak(const Arg *);
diff --git a/patches/st-scrollback-mouse-0.9.2.diff b/patches/st-scrollback-mouse-0.9.2.diff
new file mode 100644
index 0000000..a956d2b
--- /dev/null
+++ b/patches/st-scrollback-mouse-0.9.2.diff
@@ -0,0 +1,25 @@
+From 6b7e7e6c5c44dd6347ad49691b80d808c1b0cb77 Mon Sep 17 00:00:00 2001
+From: Jernej Jakob <jernej.jakob@gmail.com>
+Date: Mon, 1 Jul 2024 14:00:02 +0200
+Subject: [PATCH] [st][patch] Update st-scrollback-mouse for 0.9.2
+
+---
+ config.def.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 8b25d40..d259675 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -176,6 +176,8 @@ static uint forcemousemod = ShiftMask;
+  */
+ static MouseShortcut mshortcuts[] = {
+ 	/* mask                 button   function        argument       release */
++	{ ShiftMask,            Button4, kscrollup,      {.i = 1} },
++	{ ShiftMask,            Button5, kscrolldown,    {.i = 1} },
+ 	{ XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
+ 	{ ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
+ 	{ XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
+-- 
+2.44.2
+
diff --git a/patches/st-workingdir-20200317-51e19ea.diff b/patches/st-workingdir-20200317-51e19ea.diff
new file mode 100644
index 0000000..65de084
--- /dev/null
+++ b/patches/st-workingdir-20200317-51e19ea.diff
@@ -0,0 +1,97 @@
+From ae14b869d7bc0e0cd8ed16157837ad09aaacacc0 Mon Sep 17 00:00:00 2001
+From: David Gricar <coppie@protonmail.com>
+Date: Tue, 17 Mar 2020 13:38:05 +0100
+Subject: [PATCH] Add switch to provide initial working directory
+
+This patch adds -p switch which takes one argument 'path' and can be
+used to set the initial working directory of the new st instance.
+It acts the same as running 'cd path' command after starting the st
+instance.
+---
+ st.1 |  8 ++++++++
+ x.c  | 13 +++++++++----
+ 2 files changed, 17 insertions(+), 4 deletions(-)
+
+diff --git a/st.1 b/st.1
+index e8d6059..a901122 100644
+--- a/st.1
++++ b/st.1
+@@ -6,6 +6,8 @@ st \- simple terminal
+ .RB [ \-aiv ]
+ .RB [ \-c
+ .IR class ]
++.RB [ \-d
++.IR path ]
+ .RB [ \-f
+ .IR font ]
+ .RB [ \-g
+@@ -30,6 +32,8 @@ st \- simple terminal
+ .RB [ \-aiv ]
+ .RB [ \-c
+ .IR class ]
++.RB [ \-d
++.IR path ]
+ .RB [ \-f
+ .IR font ]
+ .RB [ \-g
+@@ -58,6 +62,10 @@ disable alternate screens in terminal
+ .BI \-c " class"
+ defines the window class (default $TERM).
+ .TP
++.BI \-d " path"
++changes the working directory to
++.IR path .
++.TP
+ .BI \-f " font"
+ defines the
+ .I font
+diff --git a/x.c b/x.c
+index 48a6676..fab2ddc 100644
+--- a/x.c
++++ b/x.c
+@@ -250,6 +250,7 @@ static char *opt_io    = NULL;
+ static char *opt_line  = NULL;
+ static char *opt_name  = NULL;
+ static char *opt_title = NULL;
++static char *opt_dir   = NULL;
+ 
+ static int oldbutton = 3; /* button event on startup: 3 = release */
+ 
+@@ -1958,12 +1959,12 @@ run(void)
+ void
+ usage(void)
+ {
+-	die("usage: %s [-aiv] [-c class] [-f font] [-g geometry]"
+-	    " [-n name] [-o file]\n"
++	die("usage: %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
+ 	    "          [-T title] [-t title] [-w windowid]"
+ 	    " [[-e] command [args ...]]\n"
+-	    "       %s [-aiv] [-c class] [-f font] [-g geometry]"
+-	    " [-n name] [-o file]\n"
++	    "       %s [-aiv] [-c class] [-d path] [-f font]"
++	    " [-g geometry] [-n name] [-o file]\n"
+ 	    "          [-T title] [-t title] [-w windowid] -l line"
+ 	    " [stty_args ...]\n", argv0, argv0);
+ }
+@@ -2015,6 +2016,9 @@ main(int argc, char *argv[])
+ 	case 'v':
+ 		die("%s " VERSION "\n", argv0);
+ 		break;
++	case 'd':
++		opt_dir = EARGF(usage());
++		break;
+ 	default:
+ 		usage();
+ 	} ARGEND;
+@@ -2034,6 +2038,7 @@ run:
+ 	xinit(cols, rows);
+ 	xsetenv();
+ 	selinit();
++	chdir(opt_dir);
+ 	run();
+ 
+ 	return 0;
+-- 
+2.25.1
+
diff --git a/patches/st-xresources-20200604-9ba7ecf.diff b/patches/st-xresources-20200604-9ba7ecf.diff
new file mode 100644
index 0000000..78ba00a
--- /dev/null
+++ b/patches/st-xresources-20200604-9ba7ecf.diff
@@ -0,0 +1,184 @@
+From 2752a599ee01305a435729bfacf43b1dde7cf0ef Mon Sep 17 00:00:00 2001
+From: Benji Encalada Mora <benji@encalada.dev>
+Date: Thu, 4 Jun 2020 00:41:10 -0500
+Subject: [PATCH] fix: replace xfps and actionfps variables
+
+---
+ config.def.h | 36 ++++++++++++++++++++++++
+ x.c          | 78 +++++++++++++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 110 insertions(+), 4 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 6f05dce..9b99782 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -168,6 +168,42 @@ static unsigned int defaultattr = 11;
+  */
+ static uint forcemousemod = ShiftMask;
+ 
++/*
++ * Xresources preferences to load at startup
++ */
++ResourcePref resources[] = {
++		{ "font",         STRING,  &font },
++		{ "color0",       STRING,  &colorname[0] },
++		{ "color1",       STRING,  &colorname[1] },
++		{ "color2",       STRING,  &colorname[2] },
++		{ "color3",       STRING,  &colorname[3] },
++		{ "color4",       STRING,  &colorname[4] },
++		{ "color5",       STRING,  &colorname[5] },
++		{ "color6",       STRING,  &colorname[6] },
++		{ "color7",       STRING,  &colorname[7] },
++		{ "color8",       STRING,  &colorname[8] },
++		{ "color9",       STRING,  &colorname[9] },
++		{ "color10",      STRING,  &colorname[10] },
++		{ "color11",      STRING,  &colorname[11] },
++		{ "color12",      STRING,  &colorname[12] },
++		{ "color13",      STRING,  &colorname[13] },
++		{ "color14",      STRING,  &colorname[14] },
++		{ "color15",      STRING,  &colorname[15] },
++		{ "background",   STRING,  &colorname[256] },
++		{ "foreground",   STRING,  &colorname[257] },
++		{ "cursorColor",  STRING,  &colorname[258] },
++		{ "termname",     STRING,  &termname },
++		{ "shell",        STRING,  &shell },
++		{ "minlatency",   INTEGER, &minlatency },
++		{ "maxlatency",   INTEGER, &maxlatency },
++		{ "blinktimeout", INTEGER, &blinktimeout },
++		{ "bellvolume",   INTEGER, &bellvolume },
++		{ "tabspaces",    INTEGER, &tabspaces },
++		{ "borderpx",     INTEGER, &borderpx },
++		{ "cwscale",      FLOAT,   &cwscale },
++		{ "chscale",      FLOAT,   &chscale },
++};
++
+ /*
+  * Internal mouse shortcuts.
+  * Beware that overloading Button1 will disable the selection.
+diff --git a/x.c b/x.c
+index 210f184..76f167f 100644
+--- a/x.c
++++ b/x.c
+@@ -14,6 +14,7 @@
+ #include <X11/keysym.h>
+ #include <X11/Xft/Xft.h>
+ #include <X11/XKBlib.h>
++#include <X11/Xresource.h>
+ 
+ char *argv0;
+ #include "arg.h"
+@@ -45,6 +46,19 @@ typedef struct {
+ 	signed char appcursor; /* application cursor */
+ } Key;
+ 
++/* Xresources preferences */
++enum resource_type {
++	STRING = 0,
++	INTEGER = 1,
++	FLOAT = 2
++};
++
++typedef struct {
++	char *name;
++	enum resource_type type;
++	void *dst;
++} ResourcePref;
++
+ /* X modifiers */
+ #define XK_ANY_MOD    UINT_MAX
+ #define XK_NO_MOD     0
+@@ -828,8 +842,8 @@ xclear(int x1, int y1, int x2, int y2)
+ void
+ xhints(void)
+ {
+-	XClassHint class = {opt_name ? opt_name : termname,
+-	                    opt_class ? opt_class : termname};
++	XClassHint class = {opt_name ? opt_name : "st",
++	                    opt_class ? opt_class : "St"};
+ 	XWMHints wm = {.flags = InputHint, .input = 1};
+ 	XSizeHints *sizeh;
+ 
+@@ -1104,8 +1118,6 @@ xinit(int cols, int rows)
+ 	pid_t thispid = getpid();
+ 	XColor xmousefg, xmousebg;
+ 
+-	if (!(xw.dpy = XOpenDisplay(NULL)))
+-		die("can't open display\n");
+ 	xw.scr = XDefaultScreen(xw.dpy);
+ 	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
+ 
+@@ -1964,6 +1976,59 @@ run(void)
+ 	}
+ }
+ 
++int
++resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
++{
++	char **sdst = dst;
++	int *idst = dst;
++	float *fdst = dst;
++
++	char fullname[256];
++	char fullclass[256];
++	char *type;
++	XrmValue ret;
++
++	snprintf(fullname, sizeof(fullname), "%s.%s",
++			opt_name ? opt_name : "st", name);
++	snprintf(fullclass, sizeof(fullclass), "%s.%s",
++			opt_class ? opt_class : "St", name);
++	fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
++
++	XrmGetResource(db, fullname, fullclass, &type, &ret);
++	if (ret.addr == NULL || strncmp("String", type, 64))
++		return 1;
++
++	switch (rtype) {
++	case STRING:
++		*sdst = ret.addr;
++		break;
++	case INTEGER:
++		*idst = strtoul(ret.addr, NULL, 10);
++		break;
++	case FLOAT:
++		*fdst = strtof(ret.addr, NULL);
++		break;
++	}
++	return 0;
++}
++
++void
++config_init(void)
++{
++	char *resm;
++	XrmDatabase db;
++	ResourcePref *p;
++
++	XrmInitialize();
++	resm = XResourceManagerString(xw.dpy);
++	if (!resm)
++		return;
++
++	db = XrmGetStringDatabase(resm);
++	for (p = resources; p < resources + LEN(resources); p++)
++		resource_load(db, p->name, p->type, p->dst);
++}
++
+ void
+ usage(void)
+ {
+@@ -2037,6 +2102,11 @@ run:
+ 
+ 	setlocale(LC_CTYPE, "");
+ 	XSetLocaleModifiers("");
++
++	if(!(xw.dpy = XOpenDisplay(NULL)))
++		die("Can't open display\n");
++
++	config_init();
+ 	cols = MAX(cols, 1);
+ 	rows = MAX(rows, 1);
+ 	tnew(cols, rows);
+-- 
+2.26.2
+
diff --git a/st-copyout b/st-copyout
new file mode 100755
index 0000000..f6d383e
--- /dev/null
+++ b/st-copyout
@@ -0,0 +1,14 @@
+#!/bin/sh
+# Using external pipe with st, give a dmenu prompt of recent commands,
+# allowing the user to copy the output of one.
+# xclip required for this script.
+# By Jaywalker and Luke
+tmpfile=$(mktemp /tmp/st-cmd-output.XXXXXX)
+trap 'rm "$tmpfile"' 0 1 15
+sed -n "w $tmpfile"
+sed -i 's/\x0//g' "$tmpfile"
+ps1="$(grep "\S" "$tmpfile" | tail -n 1 | sed 's/^\s*//' | cut -d' ' -f1)"
+chosen="$(grep -F "$ps1" "$tmpfile" | sed '$ d' | tac | dmenu -p "Copy which command's output?" -i -l 10 | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
+#chosen="$(grep -F "$ps1" "$tmpfile" | sed '$ d' | tac | rofi -theme 'gruvbox-dark.rasi' -p "Copy which command's output?" -dmenu -i -l 10 | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
+eps1="$(echo "$ps1" | sed 's/[^^]/[&]/g; s/\^/\\^/g')"
+awk "/^$chosen$/{p=1;print;next} p&&/$eps1/{p=0};p" "$tmpfile" | xclip -selection clipboard
diff --git a/st-urlhandler b/st-urlhandler
new file mode 100755
index 0000000..9ebdf6f
--- /dev/null
+++ b/st-urlhandler
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+# See ~/.config/mimeapps.list if the wrong browser is used
+# See link below:
+# https://unix.stackexchange.com/questions/307641/cant-change-the-xdg-open-url-handler-to-firefox
+
+urlregex="(((http|https|gopher|gemini|ftp|ftps|git)://|www\\.)[a-zA-Z0-9.]*[:;a-zA-Z0-9./+@$&%?$\#=_~-]*)|((magnet:\\?xt=urn:btih:)[a-zA-Z0-9]*)"
+
+urls="$(sed 's/.*│//g' | tr -d '\n' | # First remove linebreaks and mutt sidebars:
+	grep -aEo "$urlregex" | # grep only urls as defined above.
+	uniq | # Ignore neighboring duplicates.
+	sed "s/\(\.\|,\|;\|\!\\|\?\)$//;
+	s/^www./http:\/\/www\./")" # xdg-open will not detect url without http
+
+[ -z "$urls" ] && exit 1
+
+while getopts "hoc" o; do case "${o}" in
+	h) printf "Optional arguments for custom use:\\n  -c: copy\\n  -o: xdg-open\\n  -h: Show this message\\n" && exit 1 ;;
+	#o) chosen="$(echo "$urls" | dmenu -i -p 'Follow which url?' -l 10)"
+	o) chosen="$(echo "$urls" | rofi -theme 'gruvbox-dark.rasi' -p 'Follow which url?' -dmenu -i -l 10)"
+	setsid xdg-open "$chosen" >/dev/null 2>&1 & ;;
+	#c) echo "$urls" | dmenu -i -p 'Copy which url?' -l 10 | tr -d '\n' | xclip -selection clipboard ;;
+	c) echo "$urls" | rofi -theme 'gruvbox-dark.rasi' -p 'Copy which url?' -dmenu -i -l 10 | tr -d '\n' | xclip -selection clipboard ;;
+	*) printf "Invalid option: -%s\\n" "$OPTARG" && exit 1 ;;
+esac done
diff --git a/st.1 b/st.1
index 39120b4..b82beb3 100644
--- a/st.1
+++ b/st.1
@@ -6,6 +6,8 @@ st \- simple terminal
 .RB [ \-aiv ]
 .RB [ \-c
 .IR class ]
+.RB [ \-d
+.IR path ]
 .RB [ \-f
 .IR font ]
 .RB [ \-g
@@ -30,6 +32,8 @@ st \- simple terminal
 .RB [ \-aiv ]
 .RB [ \-c
 .IR class ]
+.RB [ \-d
+.IR path ]
 .RB [ \-f
 .IR font ]
 .RB [ \-g
@@ -58,6 +62,10 @@ disable alternate screens in terminal
 .BI \-c " class"
 defines the window class (default $TERM).
 .TP
+.BI \-d " path"
+changes the working directory to
+.IR path .
+.TP
 .BI \-f " font"
 defines the
 .I font
diff --git a/st.c b/st.c
index 2e3800e..755d84e 100644
--- a/st.c
+++ b/st.c
@@ -35,6 +35,7 @@
 #define ESC_ARG_SIZ   16
 #define STR_BUF_SIZ   ESC_BUF_SIZ
 #define STR_ARG_SIZ   ESC_ARG_SIZ
+#define HISTSIZE      2000
 
 /* macros */
 #define IS_SET(flag)		((term.mode & (flag)) != 0)
@@ -42,6 +43,9 @@
 #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
+#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
+            term.scr + HISTSIZE + 1) % HISTSIZE] : \
+            term.line[(y) - term.scr])
 
 enum term_mode {
 	MODE_WRAP        = 1 << 0,
@@ -115,6 +119,9 @@ typedef struct {
 	int col;      /* nb col */
 	Line *line;   /* screen */
 	Line *alt;    /* alternate screen */
+	Line hist[HISTSIZE]; /* history buffer */
+	int histi;    /* history index */
+	int scr;      /* scroll back */
 	int *dirty;   /* dirtyness of lines */
 	TCursor c;    /* cursor */
 	int ocx;      /* old cursor col */
@@ -185,8 +192,8 @@ static void tnewline(int);
 static void tputtab(int);
 static void tputc(Rune);
 static void treset(void);
-static void tscrollup(int, int);
-static void tscrolldown(int, int);
+static void tscrollup(int, int, int);
+static void tscrolldown(int, int, int);
 static void tsetattr(const int *, int);
 static void tsetchar(Rune, const Glyph *, int, int);
 static void tsetdirt(int, int);
@@ -409,10 +416,10 @@ tlinelen(int y)
 {
 	int i = term.col;
 
-	if (term.line[y][i - 1].mode & ATTR_WRAP)
+	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
 		return i;
 
-	while (i > 0 && term.line[y][i - 1].u == ' ')
+	while (i > 0 && TLINE(y)[i - 1].u == ' ')
 		--i;
 
 	return i;
@@ -521,7 +528,7 @@ selsnap(int *x, int *y, int direction)
 		 * Snap around if the word wraps around at the end or
 		 * beginning of a line.
 		 */
-		prevgp = &term.line[*y][*x];
+		prevgp = &TLINE(*y)[*x];
 		prevdelim = ISDELIM(prevgp->u);
 		for (;;) {
 			newx = *x + direction;
@@ -536,14 +543,14 @@ selsnap(int *x, int *y, int direction)
 					yt = *y, xt = *x;
 				else
 					yt = newy, xt = newx;
-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
+				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
 					break;
 			}
 
 			if (newx >= tlinelen(newy))
 				break;
 
-			gp = &term.line[newy][newx];
+			gp = &TLINE(newy)[newx];
 			delim = ISDELIM(gp->u);
 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
 					|| (delim && gp->u != prevgp->u)))
@@ -564,14 +571,14 @@ selsnap(int *x, int *y, int direction)
 		*x = (direction < 0) ? 0 : term.col - 1;
 		if (direction < 0) {
 			for (; *y > 0; *y += direction) {
-				if (!(term.line[*y-1][term.col-1].mode
+				if (!(TLINE(*y-1)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
 			}
 		} else if (direction > 0) {
 			for (; *y < term.row-1; *y += direction) {
-				if (!(term.line[*y][term.col-1].mode
+				if (!(TLINE(*y)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
@@ -602,13 +609,13 @@ getsel(void)
 		}
 
 		if (sel.type == SEL_RECTANGULAR) {
-			gp = &term.line[y][sel.nb.x];
+			gp = &TLINE(y)[sel.nb.x];
 			lastx = sel.ne.x;
 		} else {
-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
+			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
 		}
-		last = &term.line[y][MIN(lastx, linelen-1)];
+		last = &TLINE(y)[MIN(lastx, linelen-1)];
 		while (last >= gp && last->u == ' ')
 			--last;
 
@@ -718,8 +725,14 @@ sigchld(int a)
 	if ((p = waitpid(pid, &stat, WNOHANG)) < 0)
 		die("waiting for pid %hd failed: %s\n", pid, strerror(errno));
 
-	if (pid != p)
+	if (pid != p) {
+		if (p == 0 && wait(&stat) < 0)
+			die("wait: %s\n", strerror(errno));
+
+		/* reinstall sigchld handler */
+		signal(SIGCHLD, sigchld);
 		return;
+	}
 
 	if (WIFEXITED(stat) && WEXITSTATUS(stat))
 		die("child exited with status %d\n", WEXITSTATUS(stat));
@@ -803,7 +816,7 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
 		break;
 	default:
 #ifdef __OpenBSD__
-		if (pledge("stdio rpath tty proc", NULL) == -1)
+		if (pledge("stdio rpath tty proc exec", NULL) == -1)
 			die("pledge\n");
 #endif
 		close(s);
@@ -844,6 +857,9 @@ void
 ttywrite(const char *s, size_t n, int may_echo)
 {
 	const char *next;
+	Arg arg = (Arg) { .i = term.scr };
+
+	kscrolldown(&arg);
 
 	if (may_echo && IS_SET(MODE_ECHO))
 		twrite(s, n, 1);
@@ -1055,13 +1071,53 @@ tswapscreen(void)
 }
 
 void
-tscrolldown(int orig, int n)
+kscrolldown(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (n > term.scr)
+		n = term.scr;
+
+	if (term.scr > 0) {
+		term.scr -= n;
+		selscroll(0, -n);
+		tfulldirt();
+	}
+}
+
+void
+kscrollup(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (term.scr <= HISTSIZE-n) {
+		term.scr += n;
+		selscroll(0, n);
+		tfulldirt();
+	}
+}
+
+void
+tscrolldown(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
+	if (copyhist) {
+		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[term.bot];
+		term.line[term.bot] = temp;
+	}
+
 	tsetdirt(orig, term.bot-n);
 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
 
@@ -1071,17 +1127,28 @@ tscrolldown(int orig, int n)
 		term.line[i-n] = temp;
 	}
 
-	selscroll(orig, n);
+	if (term.scr == 0)
+		selscroll(orig, n);
 }
 
 void
-tscrollup(int orig, int n)
+tscrollup(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
+	if (copyhist) {
+		term.histi = (term.histi + 1) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[orig];
+		term.line[orig] = temp;
+	}
+
+	if (term.scr > 0 && term.scr < HISTSIZE)
+		term.scr = MIN(term.scr + n, HISTSIZE-1);
+
 	tclearregion(0, orig, term.col-1, orig+n-1);
 	tsetdirt(orig+n, term.bot);
 
@@ -1091,7 +1158,8 @@ tscrollup(int orig, int n)
 		term.line[i+n] = temp;
 	}
 
-	selscroll(orig, -n);
+	if (term.scr == 0)
+		selscroll(orig, -n);
 }
 
 void
@@ -1120,7 +1188,7 @@ tnewline(int first_col)
 	int y = term.c.y;
 
 	if (y == term.bot) {
-		tscrollup(term.top, 1);
+		tscrollup(term.top, 1, 1);
 	} else {
 		y++;
 	}
@@ -1288,14 +1356,14 @@ void
 tinsertblankline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrolldown(term.c.y, n);
+		tscrolldown(term.c.y, n, 0);
 }
 
 void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n);
+		tscrollup(term.c.y, n, 0);
 }
 
 int32_t
@@ -1733,11 +1801,11 @@ csihandle(void)
 	case 'S': /* SU -- Scroll <n> line up */
 		if (csiescseq.priv) break;
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrollup(term.top, csiescseq.arg[0]);
+		tscrollup(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'T': /* SD -- Scroll <n> line down */
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrolldown(term.top, csiescseq.arg[0]);
+		tscrolldown(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'L': /* IL -- Insert <n> blank lines */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -1994,6 +2062,59 @@ strparse(void)
 	}
 }
 
+void
+externalpipe(const Arg *arg)
+{
+	int to[2];
+	char buf[UTF_SIZ];
+	void (*oldsigpipe)(int);
+	Glyph *bp, *end;
+	int lastpos, n, newline;
+
+	if (pipe(to) == -1)
+		return;
+
+	switch (fork()) {
+	case -1:
+		close(to[0]);
+		close(to[1]);
+		return;
+	case 0:
+		dup2(to[0], STDIN_FILENO);
+		close(to[0]);
+		close(to[1]);
+		execvp(((char **)arg->v)[0], (char **)arg->v);
+		fprintf(stderr, "st: execvp %s\n", ((char **)arg->v)[0]);
+		perror("failed");
+		exit(0);
+	}
+
+	close(to[0]);
+	/* ignore sigpipe for now, in case child exists early */
+	oldsigpipe = signal(SIGPIPE, SIG_IGN);
+	newline = 0;
+	for (n = 0; n < term.row; n++) {
+		bp = term.line[n];
+		lastpos = MIN(tlinelen(n) + 1, term.col) - 1;
+		if (lastpos < 0)
+			break;
+		end = &bp[lastpos + 1];
+		for (; bp < end; ++bp)
+			if (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)
+				break;
+		if ((newline = term.line[n][lastpos].mode & ATTR_WRAP))
+			continue;
+		if (xwrite(to[1], "\n", 1) < 0)
+			break;
+		newline = 0;
+	}
+	if (newline)
+		(void)xwrite(to[1], "\n", 1);
+	close(to[1]);
+	/* restore */
+	signal(SIGPIPE, oldsigpipe);
+}
+
 void
 strdump(void)
 {
@@ -2309,7 +2430,7 @@ eschandle(uchar ascii)
 		return 0;
 	case 'D': /* IND -- Linefeed */
 		if (term.c.y == term.bot) {
-			tscrollup(term.top, 1);
+			tscrollup(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y+1);
 		}
@@ -2322,7 +2443,7 @@ eschandle(uchar ascii)
 		break;
 	case 'M': /* RI -- Reverse index */
 		if (term.c.y == term.top) {
-			tscrolldown(term.top, 1);
+			tscrolldown(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y-1);
 		}
@@ -2545,7 +2666,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
 void
 tresize(int col, int row)
 {
-	int i;
+	int i, j;
 	int minrow = MIN(row, term.row);
 	int mincol = MIN(col, term.col);
 	int *bp;
@@ -2582,6 +2703,14 @@ tresize(int col, int row)
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
+	for (i = 0; i < HISTSIZE; i++) {
+		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
+		for (j = mincol; j < col; j++) {
+			term.hist[i][j] = term.c.attr;
+			term.hist[i][j].u = ' ';
+		}
+	}
+
 	/* resize each row to new width, zero-pad if needed */
 	for (i = 0; i < minrow; i++) {
 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
@@ -2640,7 +2769,7 @@ drawregion(int x1, int y1, int x2, int y2)
 			continue;
 
 		term.dirty[y] = 0;
-		xdrawline(term.line[y], x1, y, x2);
+		xdrawline(TLINE(y), x1, y, x2);
 	}
 }
 
@@ -2661,8 +2790,11 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+	if (term.scr == 0)
+		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
+				term.line[term.ocy], term.col);
+
 	term.ocx = cx;
 	term.ocy = term.c.y;
 	xfinishdraw();
diff --git a/st.h b/st.h
index fd3b0d8..a6be61e 100644
--- a/st.h
+++ b/st.h
@@ -11,7 +11,8 @@
 #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
 #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
 #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
-#define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
+#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP)) != ((b).mode & (~ATTR_WRAP)) || \
+				(a).fg != (b).fg || \
 				(a).bg != (b).bg)
 #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
 				(t1.tv_nsec-t2.tv_nsec)/1E6)
@@ -81,6 +82,10 @@ void die(const char *, ...);
 void redraw(void);
 void draw(void);
 
+void externalpipe(const Arg *);
+
+void kscrolldown(const Arg *);
+void kscrollup(const Arg *);
 void printscreen(const Arg *);
 void printsel(const Arg *);
 void sendbreak(const Arg *);
@@ -124,3 +129,4 @@ extern unsigned int tabspaces;
 extern unsigned int defaultfg;
 extern unsigned int defaultbg;
 extern unsigned int defaultcs;
+extern float alpha_def;
diff --git a/win.h b/win.h
index 6de960d..94679e4 100644
--- a/win.h
+++ b/win.h
@@ -25,7 +25,7 @@ enum win_mode {
 
 void xbell(void);
 void xclipcopy(void);
-void xdrawcursor(int, int, Glyph, int, int, Glyph);
+void xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);
 void xdrawline(Line, int, int, int);
 void xfinishdraw(void);
 void xloadcols(void);
diff --git a/x.c b/x.c
index d73152b..4615736 100644
--- a/x.c
+++ b/x.c
@@ -14,11 +14,13 @@
 #include <X11/keysym.h>
 #include <X11/Xft/Xft.h>
 #include <X11/XKBlib.h>
+#include <X11/Xresource.h>
 
 char *argv0;
 #include "arg.h"
 #include "st.h"
 #include "win.h"
+#include "hb.h"
 
 /* types used in config.h */
 typedef struct {
@@ -45,6 +47,19 @@ typedef struct {
 	signed char appcursor; /* application cursor */
 } Key;
 
+/* Xresources preferences */
+enum resource_type {
+	STRING = 0,
+	INTEGER = 1,
+	FLOAT = 2
+};
+
+typedef struct {
+	char *name;
+	enum resource_type type;
+	void *dst;
+} ResourcePref;
+
 /* X modifiers */
 #define XK_ANY_MOD    UINT_MAX
 #define XK_NO_MOD     0
@@ -59,6 +74,8 @@ static void zoom(const Arg *);
 static void zoomabs(const Arg *);
 static void zoomreset(const Arg *);
 static void ttysend(const Arg *);
+static void changealpha(const Arg *);
+static float clamp(float value, float lower, float upper);
 
 /* config.h for applying patches and the configuration. */
 #include "config.h"
@@ -105,6 +122,7 @@ typedef struct {
 	XSetWindowAttributes attrs;
 	int scr;
 	int isfixed; /* is fixed geometry? */
+	int depth; /* bit depth */
 	int l, t; /* left and top offset */
 	int gm; /* geometry mask */
 } XWindow;
@@ -141,8 +159,9 @@ typedef struct {
 } DC;
 
 static inline ushort sixd_to_16bit(int);
+static void xresetfontsettings(ushort mode, Font **font, int *frcflags);
 static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
-static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
+static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int, int);
 static void xdrawglyph(Glyph, int, int);
 static void xclear(int, int, int, int);
 static int xgeommasktogravity(int);
@@ -157,6 +176,8 @@ static void xhints(void);
 static int xloadcolor(int, const char *, Color *);
 static int xloadfont(Font *, FcPattern *);
 static void xloadfonts(const char *, double);
+static int xloadsparefont(FcPattern *, int);
+static void xloadsparefonts(void);
 static void xunloadfont(Font *);
 static void xunloadfonts(void);
 static void xsetenv(void);
@@ -251,6 +272,7 @@ static char *opt_io    = NULL;
 static char *opt_line  = NULL;
 static char *opt_name  = NULL;
 static char *opt_title = NULL;
+static char *opt_dir   = NULL;
 
 static uint buttons; /* bit field of pressed buttons */
 
@@ -306,6 +328,7 @@ zoomabs(const Arg *arg)
 {
 	xunloadfonts();
 	xloadfonts(usedfont, arg->f);
+	xloadsparefonts();
 	cresize(0, 0);
 	redraw();
 	xhints();
@@ -752,12 +775,12 @@ xresize(int col, int row)
 
 	XFreePixmap(xw.dpy, xw.buf);
 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
-			DefaultDepth(xw.dpy, xw.scr));
+			xw.depth);
 	XftDrawChange(xw.draw, xw.buf);
 	xclear(0, 0, win.w, win.h);
 
 	/* resize to new width */
-	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));
+	xw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec) * 4);
 }
 
 ushort
@@ -812,6 +835,13 @@ xloadcols(void)
 			else
 				die("could not allocate color %d\n", i);
 		}
+
+	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
+	dc.col[defaultbg].pixel &= 0x00FFFFFF;
+	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
+    dc.col[defaultbg].color.red   *= alpha;
+    dc.col[defaultbg].color.green *= alpha;
+    dc.col[defaultbg].color.blue  *= alpha;
 	loaded = 1;
 }
 
@@ -842,6 +872,15 @@ xsetcolorname(int x, const char *name)
 	XftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);
 	dc.col[x] = ncolor;
 
+	if (x == defaultbg) {
+		dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
+		dc.col[defaultbg].pixel &= 0x00FFFFFF;
+		dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
+        dc.col[defaultbg].color.red   *= alpha;
+        dc.col[defaultbg].color.green *= alpha;
+        dc.col[defaultbg].color.blue  *= alpha;
+	}
+
 	return 0;
 }
 
@@ -859,8 +898,8 @@ xclear(int x1, int y1, int x2, int y2)
 void
 xhints(void)
 {
-	XClassHint class = {opt_name ? opt_name : termname,
-	                    opt_class ? opt_class : termname};
+	XClassHint class = {opt_name ? opt_name : "st",
+	                    opt_class ? opt_class : "St"};
 	XWMHints wm = {.flags = InputHint, .input = 1};
 	XSizeHints *sizeh;
 
@@ -1050,6 +1089,101 @@ xloadfonts(const char *fontstr, double fontsize)
 	FcPatternDestroy(pattern);
 }
 
+int
+xloadsparefont(FcPattern *pattern, int flags)
+{
+	FcPattern *match;
+	FcResult result;
+
+	match = FcFontMatch(NULL, pattern, &result);
+	if (!match) {
+		return 1;
+	}
+
+	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
+		FcPatternDestroy(match);
+		return 1;
+	}
+
+	frc[frclen].flags = flags;
+	/* Believe U+0000 glyph will present in each default font */
+	frc[frclen].unicodep = 0;
+	frclen++;
+
+	return 0;
+}
+
+void
+xloadsparefonts(void)
+{
+	FcPattern *pattern;
+	double sizeshift, fontval;
+	int fc;
+	char **fp;
+
+	if (frclen != 0)
+		die("can't embed spare fonts. cache isn't empty");
+
+	/* Calculate count of spare fonts */
+	fc = sizeof(font2) / sizeof(*font2);
+	if (fc == 0)
+		return;
+
+	/* Allocate memory for cache entries. */
+	if (frccap < 4 * fc) {
+		frccap += 4 * fc - frccap;
+		frc = xrealloc(frc, frccap * sizeof(Fontcache));
+	}
+
+	for (fp = font2; fp - font2 < fc; ++fp) {
+
+		if (**fp == '-')
+			pattern = XftXlfdParse(*fp, False, False);
+		else
+			pattern = FcNameParse((FcChar8 *)*fp);
+
+		if (!pattern)
+			die("can't open spare font %s\n", *fp);
+
+		if (defaultfontsize > 0) {
+			sizeshift = usedfontsize - defaultfontsize;
+			if (sizeshift != 0 &&
+					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
+					FcResultMatch) {
+				fontval += sizeshift;
+				FcPatternDel(pattern, FC_PIXEL_SIZE);
+				FcPatternDel(pattern, FC_SIZE);
+				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
+			}
+		}
+
+		FcPatternAddBool(pattern, FC_SCALABLE, 1);
+
+		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
+		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
+
+		if (xloadsparefont(pattern, FRC_NORMAL))
+			die("can't open spare font %s\n", *fp);
+
+		FcPatternDel(pattern, FC_SLANT);
+		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
+		if (xloadsparefont(pattern, FRC_ITALIC))
+			die("can't open spare font %s\n", *fp);
+
+		FcPatternDel(pattern, FC_WEIGHT);
+		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+		if (xloadsparefont(pattern, FRC_ITALICBOLD))
+			die("can't open spare font %s\n", *fp);
+
+		FcPatternDel(pattern, FC_SLANT);
+		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
+		if (xloadsparefont(pattern, FRC_BOLD))
+			die("can't open spare font %s\n", *fp);
+
+		FcPatternDestroy(pattern);
+	}
+}
+
 void
 xunloadfont(Font *f)
 {
@@ -1062,6 +1196,9 @@ xunloadfont(Font *f)
 void
 xunloadfonts(void)
 {
+	/* Clear Harfbuzz font cache. */
+	hbunloadfonts();
+
 	/* Free the loaded fonts in the font cache.  */
 	while (frclen > 0)
 		XftFontClose(xw.dpy, frc[--frclen].font);
@@ -1134,11 +1271,23 @@ xinit(int cols, int rows)
 	Window parent, root;
 	pid_t thispid = getpid();
 	XColor xmousefg, xmousebg;
+	XWindowAttributes attr;
+	XVisualInfo vis;
 
-	if (!(xw.dpy = XOpenDisplay(NULL)))
-		die("can't open display\n");
 	xw.scr = XDefaultScreen(xw.dpy);
-	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
+
+	root = XRootWindow(xw.dpy, xw.scr);
+	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
+		parent = root;
+
+	if (XMatchVisualInfo(xw.dpy, xw.scr, 32, TrueColor, &vis) != 0) {
+		xw.vis = vis.visual;
+		xw.depth = vis.depth;
+	} else {
+		XGetWindowAttributes(xw.dpy, parent, &attr);
+		xw.vis = attr.visual;
+		xw.depth = attr.depth;
+	}
 
 	/* font */
 	if (!FcInit())
@@ -1147,8 +1296,14 @@ xinit(int cols, int rows)
 	usedfont = (opt_font == NULL)? font : opt_font;
 	xloadfonts(usedfont, 0);
 
+	/* spare fonts */
+	xloadsparefonts();
+
+   /* Backup default alpha value */
+   //alpha_def = alpha;
+
 	/* colors */
-	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
+	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
 	xloadcols();
 
 	/* adjust fixed window geometry */
@@ -1168,11 +1323,8 @@ xinit(int cols, int rows)
 		| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
 	xw.attrs.colormap = xw.cmap;
 
-	root = XRootWindow(xw.dpy, xw.scr);
-	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
-		parent = root;
-	xw.win = XCreateWindow(xw.dpy, root, xw.l, xw.t,
-			win.w, win.h, 0, XDefaultDepth(xw.dpy, xw.scr), InputOutput,
+	xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
+			win.w, win.h, 0, xw.depth, InputOutput,
 			xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
 			| CWEventMask | CWColormap, &xw.attrs);
 	if (parent != root)
@@ -1183,12 +1335,12 @@ xinit(int cols, int rows)
 	dc.gc = XCreateGC(xw.dpy, xw.win, GCGraphicsExposures,
 			&gcvalues);
 	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
-			DefaultDepth(xw.dpy, xw.scr));
+			xw.depth);
 	XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
 	XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
 
 	/* font spec buffer */
-	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));
+	xw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec) * 4);
 
 	/* Xft rendering context */
 	xw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);
@@ -1242,6 +1394,22 @@ xinit(int cols, int rows)
 		xsel.xtarget = XA_STRING;
 }
 
+void
+xresetfontsettings(ushort mode, Font **font, int *frcflags)
+{
+	*font = &dc.font;
+	if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
+		*font = &dc.ibfont;
+		*frcflags = FRC_ITALICBOLD;
+	} else if (mode & ATTR_ITALIC) {
+		*font = &dc.ifont;
+		*frcflags = FRC_ITALIC;
+	} else if (mode & ATTR_BOLD) {
+		*font = &dc.bfont;
+		*frcflags = FRC_BOLD;
+	}
+}
+
 int
 xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
 {
@@ -1256,128 +1424,224 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 	FcPattern *fcpattern, *fontpattern;
 	FcFontSet *fcsets[] = { NULL };
 	FcCharSet *fccharset;
-	int i, f, numspecs = 0;
+	int i, f, length = 0, start = 0, numspecs = 0;
+	float cluster_xp = xp, cluster_yp = yp;
+	HbTransformData shaped = { 0 };
+
+	/* Initial values. */
+	mode = prevmode = glyphs[0].mode & ~ATTR_WRAP;
+	xresetfontsettings(mode, &font, &frcflags);
 
 	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
-		/* Fetch rune and mode for current glyph. */
-		rune = glyphs[i].u;
-		mode = glyphs[i].mode;
+		mode = glyphs[i].mode & ~ATTR_WRAP;
 
 		/* Skip dummy wide-character spacing. */
-		if (mode == ATTR_WDUMMY)
+		if (mode & ATTR_WDUMMY && i < (len - 1))
 			continue;
 
-		/* Determine font for glyph if different from previous glyph. */
-		if (prevmode != mode) {
-			prevmode = mode;
-			font = &dc.font;
-			frcflags = FRC_NORMAL;
-			runewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);
-			if ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {
-				font = &dc.ibfont;
-				frcflags = FRC_ITALICBOLD;
-			} else if (mode & ATTR_ITALIC) {
-				font = &dc.ifont;
-				frcflags = FRC_ITALIC;
-			} else if (mode & ATTR_BOLD) {
-				font = &dc.bfont;
-				frcflags = FRC_BOLD;
+		if (
+			prevmode != mode
+			|| ATTRCMP(glyphs[start], glyphs[i])
+			|| selected(x + i, y) != selected(x + start, y)
+			|| i == (len - 1)
+		) {
+			/* Handle 1-character wide segments and end of line */
+			length = i - start;
+			if (i == start) {
+				length = 1;
+			} else if (i == (len - 1)) {
+				length = (i - start + 1);
 			}
-			yp = winy + font->ascent;
-		}
-
-		/* Lookup character index with default font. */
-		glyphidx = XftCharIndex(xw.dpy, font->match, rune);
-		if (glyphidx) {
-			specs[numspecs].font = font->match;
-			specs[numspecs].glyph = glyphidx;
-			specs[numspecs].x = (short)xp;
-			specs[numspecs].y = (short)yp;
-			xp += runewidth;
-			numspecs++;
-			continue;
-		}
 
-		/* Fallback on font cache, search the font cache for match. */
-		for (f = 0; f < frclen; f++) {
-			glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
-			/* Everything correct. */
-			if (glyphidx && frc[f].flags == frcflags)
-				break;
-			/* We got a default font for a not found glyph. */
-			if (!glyphidx && frc[f].flags == frcflags
-					&& frc[f].unicodep == rune) {
-				break;
+			/* Shape the segment. */
+			hbtransform(&shaped, font->match, glyphs, start, length);
+			runewidth = win.cw * ((glyphs[start].mode & ATTR_WIDE) ? 2.0f : 1.0f);
+			cluster_xp = xp; cluster_yp = yp;
+			for (int code_idx = 0; code_idx < shaped.count; code_idx++) {
+				int idx = shaped.glyphs[code_idx].cluster;
+
+				if (glyphs[start + idx].mode & ATTR_WDUMMY)
+					continue;
+
+				/* Advance the drawing cursor if we've moved to a new cluster */
+				if (code_idx > 0 && idx != shaped.glyphs[code_idx - 1].cluster) {
+					xp += runewidth;
+					cluster_xp = xp;
+					cluster_yp = yp;
+					runewidth = win.cw * ((glyphs[start + idx].mode & ATTR_WIDE) ? 2.0f : 1.0f);
+				}
+
+				if (shaped.glyphs[code_idx].codepoint != 0) {
+					/* If symbol is found, put it into the specs. */
+					specs[numspecs].font = font->match;
+					specs[numspecs].glyph = shaped.glyphs[code_idx].codepoint;
+					specs[numspecs].x = cluster_xp + (short)(shaped.positions[code_idx].x_offset / 64.);
+					specs[numspecs].y = cluster_yp - (short)(shaped.positions[code_idx].y_offset / 64.);
+					cluster_xp += shaped.positions[code_idx].x_advance / 64.;
+					cluster_yp += shaped.positions[code_idx].y_advance / 64.;
+					numspecs++;
+				} else {
+					/* If it's not found, try to fetch it through the font cache. */
+					rune = glyphs[start + idx].u;
+					for (f = 0; f < frclen; f++) {
+						glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
+						/* Everything correct. */
+						if (glyphidx && frc[f].flags == frcflags)
+							break;
+						/* We got a default font for a not found glyph. */
+						if (!glyphidx && frc[f].flags == frcflags
+								&& frc[f].unicodep == rune) {
+							break;
+						}
+					}
+
+					/* Nothing was found. Use fontconfig to find matching font. */
+					if (f >= frclen) {
+						if (!font->set)
+							font->set = FcFontSort(0, font->pattern,
+																		 1, 0, &fcres);
+						fcsets[0] = font->set;
+
+						/*
+						 * Nothing was found in the cache. Now use
+						 * some dozen of Fontconfig calls to get the
+						 * font for one single character.
+						 *
+						 * Xft and fontconfig are design failures.
+						 */
+						fcpattern = FcPatternDuplicate(font->pattern);
+						fccharset = FcCharSetCreate();
+
+						FcCharSetAddChar(fccharset, rune);
+						FcPatternAddCharSet(fcpattern, FC_CHARSET,
+								fccharset);
+						FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
+
+						FcConfigSubstitute(0, fcpattern,
+								FcMatchPattern);
+						FcDefaultSubstitute(fcpattern);
+
+						fontpattern = FcFontSetMatch(0, fcsets, 1,
+								fcpattern, &fcres);
+
+						/* Allocate memory for the new cache entry. */
+						if (frclen >= frccap) {
+							frccap += 16;
+							frc = xrealloc(frc, frccap * sizeof(Fontcache));
+						}
+
+						frc[frclen].font = XftFontOpenPattern(xw.dpy,
+								fontpattern);
+						if (!frc[frclen].font)
+							die("XftFontOpenPattern failed seeking fallback font: %s\n",
+								strerror(errno));
+						frc[frclen].flags = frcflags;
+						frc[frclen].unicodep = rune;
+
+						glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
+
+						f = frclen;
+						frclen++;
+
+						FcPatternDestroy(fcpattern);
+						FcCharSetDestroy(fccharset);
+					}
+
+					specs[numspecs].font = frc[f].font;
+					specs[numspecs].glyph = glyphidx;
+					specs[numspecs].x = (short)xp;
+					specs[numspecs].y = (short)yp;
+					numspecs++;
+				}
 			}
-		}
-
-		/* Nothing was found. Use fontconfig to find matching font. */
-		if (f >= frclen) {
-			if (!font->set)
-				font->set = FcFontSort(0, font->pattern,
-				                       1, 0, &fcres);
-			fcsets[0] = font->set;
-
-			/*
-			 * Nothing was found in the cache. Now use
-			 * some dozen of Fontconfig calls to get the
-			 * font for one single character.
-			 *
-			 * Xft and fontconfig are design failures.
-			 */
-			fcpattern = FcPatternDuplicate(font->pattern);
-			fccharset = FcCharSetCreate();
-
-			FcCharSetAddChar(fccharset, rune);
-			FcPatternAddCharSet(fcpattern, FC_CHARSET,
-					fccharset);
-			FcPatternAddBool(fcpattern, FC_SCALABLE, 1);
-
-			FcConfigSubstitute(0, fcpattern,
-					FcMatchPattern);
-			FcDefaultSubstitute(fcpattern);
 
-			fontpattern = FcFontSetMatch(0, fcsets, 1,
-					fcpattern, &fcres);
+			/* Cleanup and get ready for next segment. */
+			hbcleanup(&shaped);
+			start = i;
 
-			/* Allocate memory for the new cache entry. */
-			if (frclen >= frccap) {
-				frccap += 16;
-				frc = xrealloc(frc, frccap * sizeof(Fontcache));
+			/* Determine font for glyph if different from previous glyph. */
+			if (prevmode != mode) {
+				prevmode = mode;
+				xresetfontsettings(mode, &font, &frcflags);
+				yp = winy + font->ascent;
 			}
+		}
+	}
 
-			frc[frclen].font = XftFontOpenPattern(xw.dpy,
-					fontpattern);
-			if (!frc[frclen].font)
-				die("XftFontOpenPattern failed seeking fallback font: %s\n",
-					strerror(errno));
-			frc[frclen].flags = frcflags;
-			frc[frclen].unicodep = rune;
+	return numspecs;
+}
 
-			glyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);
+//void
+//changealpha(const Arg *arg)
+//{
+//   if (arg->f == -1.0f && alpha >= 0.1f)
+//      alpha -= 0.1f;
+//   else if (arg->f == 1.0f && alpha < 1.0f)
+//      alpha += 0.1f;
+//   else if (arg->f == 0.0f)
+//      alpha = alpha_def;
+//   else
+//      return;
+//
+//   dc.col[defaultbg].color.alpha = (unsigned short)(0xFFFF * alpha);
+//   /* Required to remove artifacting from borderpx */
+//   cresize(0, 0);
+//   redraw();
+//}
+
+#include <stdio.h>
+#include <stdlib.h>
+void log_to_file(const char *message) {
+    const char *log_file_path = getenv("HOME"); // Get the home directory
+    if (log_file_path == NULL) {
+        return; // If HOME is not set, don't log
+    }
+
+    char file_path[256];
+    snprintf(file_path, sizeof(file_path), "%s/st_test.txt", log_file_path);
+
+    FILE *file = fopen(file_path, "a"); // Open the file in append mode
+    if (file != NULL) {
+        fprintf(file, "%s\n", message); // Write the message to the file
+        fclose(file);
+    }
+}
+
+float clamp(float value, float lower, float upper)
+{
+    if(value < lower)
+        return lower;
+    if(value > upper)
+        return upper;
+    return value;
+}
+void
+changealpha(const Arg *arg)
+{
+    if((alpha > 0 && arg->f < 0) || (alpha < 1 && arg->f > 0))
+        alpha += arg->f;
 
-			f = frclen;
-			frclen++;
+    //if (alpha < 0.03){
+    //    defaultbg = alphaBg;
+    //}else {
+    //    defaultbg = defaultAlphaBg;
+    //}
 
-			FcPatternDestroy(fcpattern);
-			FcCharSetDestroy(fccharset);
-		}
+    alpha = clamp(alpha, 0.0, 1.0);
+    alphaUnfocus = clamp(alpha-alphaOffset, 0.0, 1.0);
 
-		specs[numspecs].font = frc[f].font;
-		specs[numspecs].glyph = glyphidx;
-		specs[numspecs].x = (short)xp;
-		specs[numspecs].y = (short)yp;
-		xp += runewidth;
-		numspecs++;
-	}
+    xloadcols();
+    redraw();
 
-	return numspecs;
+    // Debug
+    //char log_message[128];
+    //snprintf(log_message, sizeof(log_message), "changealpha called, alpha: %.2f", alpha);
+    //log_to_file(log_message);
 }
 
 void
-xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
+xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y, int charlen)
 {
-	int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
 	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
 	    width = charlen * win.cw;
 	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
@@ -1513,21 +1777,24 @@ void
 xdrawglyph(Glyph g, int x, int y)
 {
 	int numspecs;
-	XftGlyphFontSpec spec;
+	XftGlyphFontSpec *specs = xw.specbuf;
 
-	numspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);
-	xdrawglyphfontspecs(&spec, g, numspecs, x, y);
+	numspecs = xmakeglyphfontspecs(specs, &g, 1, x, y);
+	xdrawglyphfontspecs(specs, g, numspecs, x, y, (g.mode & ATTR_WIDE) ? 2 : 1);
 }
 
 void
-xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
+xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
 {
 	Color drawcol;
 
 	/* remove the old cursor */
 	if (selected(ox, oy))
 		og.mode ^= ATTR_REVERSE;
-	xdrawglyph(og, ox, oy);
+
+	/* Redraw the line where cursor was previously.
+	 * It will restore the ligatures broken by the cursor. */
+	xdrawline(line, 0, oy, len);
 
 	if (IS_SET(MODE_HIDE))
 		return;
@@ -1661,18 +1928,16 @@ xdrawline(Line line, int x1, int y1, int x2)
 	Glyph base, new;
 	XftGlyphFontSpec *specs = xw.specbuf;
 
-	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
 	i = ox = 0;
-	for (x = x1; x < x2 && i < numspecs; x++) {
+	for (x = x1; x < x2; x++) {
 		new = line[x];
 		if (new.mode == ATTR_WDUMMY)
 			continue;
 		if (selected(x, y1))
 			new.mode ^= ATTR_REVERSE;
-		if (i > 0 && ATTRCMP(base, new)) {
-			xdrawglyphfontspecs(specs, base, i, ox, y1);
-			specs += i;
-			numspecs -= i;
+		if ((i > 0) && ATTRCMP(base, new)) {
+			numspecs = xmakeglyphfontspecs(specs, &line[ox], x - ox, ox, y1);
+			xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x - ox);
 			i = 0;
 		}
 		if (i == 0) {
@@ -1681,8 +1946,10 @@ xdrawline(Line line, int x1, int y1, int x2)
 		}
 		i++;
 	}
-	if (i > 0)
-		xdrawglyphfontspecs(specs, base, i, ox, y1);
+	if (i > 0) {
+		numspecs = xmakeglyphfontspecs(specs, &line[ox], x2 - ox, ox, y1);
+		xdrawglyphfontspecs(specs, base, numspecs, ox, y1, x2 - ox);
+	}
 }
 
 void
@@ -2023,15 +2290,68 @@ run(void)
 	}
 }
 
+int
+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
+{
+	char **sdst = dst;
+	int *idst = dst;
+	float *fdst = dst;
+
+	char fullname[256];
+	char fullclass[256];
+	char *type;
+	XrmValue ret;
+
+	snprintf(fullname, sizeof(fullname), "%s.%s",
+			opt_name ? opt_name : "st", name);
+	snprintf(fullclass, sizeof(fullclass), "%s.%s",
+			opt_class ? opt_class : "St", name);
+	fullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\0';
+
+	XrmGetResource(db, fullname, fullclass, &type, &ret);
+	if (ret.addr == NULL || strncmp("String", type, 64))
+		return 1;
+
+	switch (rtype) {
+	case STRING:
+		*sdst = ret.addr;
+		break;
+	case INTEGER:
+		*idst = strtoul(ret.addr, NULL, 10);
+		break;
+	case FLOAT:
+		*fdst = strtof(ret.addr, NULL);
+		break;
+	}
+	return 0;
+}
+
+void
+config_init(void)
+{
+	char *resm;
+	XrmDatabase db;
+	ResourcePref *p;
+
+	XrmInitialize();
+	resm = XResourceManagerString(xw.dpy);
+	if (!resm)
+		return;
+
+	db = XrmGetStringDatabase(resm);
+	for (p = resources; p < resources + LEN(resources); p++)
+		resource_load(db, p->name, p->type, p->dst);
+}
+
 void
 usage(void)
 {
-	die("usage: %s [-aiv] [-c class] [-f font] [-g geometry]"
-	    " [-n name] [-o file]\n"
+	die("usage: %s [-aiv] [-c class] [-d path] [-f font]"
+	    " [-g geometry] [-n name] [-o file]\n"
 	    "          [-T title] [-t title] [-w windowid]"
 	    " [[-e] command [args ...]]\n"
-	    "       %s [-aiv] [-c class] [-f font] [-g geometry]"
-	    " [-n name] [-o file]\n"
+	    "       %s [-aiv] [-c class] [-d path] [-f font]"
+	    " [-g geometry] [-n name] [-o file]\n"
 	    "          [-T title] [-t title] [-w windowid] -l line"
 	    " [stty_args ...]\n", argv0, argv0);
 }
@@ -2047,6 +2367,10 @@ main(int argc, char *argv[])
 	case 'a':
 		allowaltscreen = 0;
 		break;
+	case 'A':
+		alpha = strtof(EARGF(usage()), NULL);
+		LIMIT(alpha, 0.0, 1.0);
+		break;
 	case 'c':
 		opt_class = EARGF(usage());
 		break;
@@ -2083,6 +2407,9 @@ main(int argc, char *argv[])
 	case 'v':
 		die("%s " VERSION "\n", argv0);
 		break;
+	case 'd':
+		opt_dir = EARGF(usage());
+		break;
 	default:
 		usage();
 	} ARGEND;
@@ -2096,12 +2423,18 @@ run:
 
 	setlocale(LC_CTYPE, "");
 	XSetLocaleModifiers("");
+
+	if(!(xw.dpy = XOpenDisplay(NULL)))
+		die("Can't open display\n");
+
+	config_init();
 	cols = MAX(cols, 1);
 	rows = MAX(rows, 1);
 	tnew(cols, rows);
 	xinit(cols, rows);
 	xsetenv();
 	selinit();
+	chdir(opt_dir);
 	run();
 
 	return 0;
