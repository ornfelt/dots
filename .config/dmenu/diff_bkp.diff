diff --git a/README b/README
index 4d333ca..a8fcdfe 100644
--- a/README
+++ b/README
@@ -1,12 +1,3 @@
-Added patches:
-
-Customized versions of: 
-
-https://tools.suckless.org/dmenu/patches/gruvbox/
-https://tools.suckless.org/dmenu/patches/center/
-
-I also continously add fixes from suckless git log.
-
 dmenu - dynamic menu
 ====================
 dmenu is an efficient dynamic menu for X.
diff --git a/arg.h b/arg.h
index 8f7beba..e94e02b 100644
--- a/arg.h
+++ b/arg.h
@@ -10,40 +10,40 @@ extern char *argv0;
 
 /* use main(int argc, char *argv[]) */
 #define ARGBEGIN	for (argv0 = *argv, argv++, argc--;\
-        argv[0] && argv[0][0] == '-'\
-        && argv[0][1];\
-        argc--, argv++) {\
-    char argc_;\
-    char **argv_;\
-    int brk_;\
-    if (argv[0][1] == '-' && argv[0][2] == '\0') {\
-        argv++;\
-        argc--;\
-        break;\
-    }\
-    for (brk_ = 0, argv[0]++, argv_ = argv;\
-            argv[0][0] && !brk_;\
-            argv[0]++) {\
-        if (argv_ != argv)\
-        break;\
-        argc_ = argv[0][0];\
-        switch (argc_)
+					argv[0] && argv[0][0] == '-'\
+					&& argv[0][1];\
+					argc--, argv++) {\
+				char argc_;\
+				char **argv_;\
+				int brk_;\
+				if (argv[0][1] == '-' && argv[0][2] == '\0') {\
+					argv++;\
+					argc--;\
+					break;\
+				}\
+				for (brk_ = 0, argv[0]++, argv_ = argv;\
+						argv[0][0] && !brk_;\
+						argv[0]++) {\
+					if (argv_ != argv)\
+						break;\
+					argc_ = argv[0][0];\
+					switch (argc_)
 
 #define ARGEND			}\
-}
+			}
 
 #define ARGC()		argc_
 
 #define EARGF(x)	((argv[0][1] == '\0' && argv[1] == NULL)?\
-        ((x), abort(), (char *)0) :\
-        (brk_ = 1, (argv[0][1] != '\0')?\
-         (&argv[0][1]) :\
-         (argc--, argv++, argv[0])))
+				((x), abort(), (char *)0) :\
+				(brk_ = 1, (argv[0][1] != '\0')?\
+					(&argv[0][1]) :\
+					(argc--, argv++, argv[0])))
 
 #define ARGF()		((argv[0][1] == '\0' && argv[1] == NULL)?\
-        (char *)0 :\
-        (brk_ = 1, (argv[0][1] != '\0')?\
-         (&argv[0][1]) :\
-         (argc--, argv++, argv[0])))
+				(char *)0 :\
+				(brk_ = 1, (argv[0][1] != '\0')?\
+					(&argv[0][1]) :\
+					(argc--, argv++, argv[0])))
 
 #endif
diff --git a/config.h b/config.h
index 68669ac..a710a0e 100644
--- a/config.h
+++ b/config.h
@@ -1,24 +1,24 @@
 /* See LICENSE file for copyright and license details. */
 /* Default settings; can be overriden by command line. */
 
-static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom */
+static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
 static int centered = 1;                    /* -c option; centers dmenu on screen */
-static int min_width = 500;                 /* minimum width when centered */
-static int max_width = 900;                 /* minimum width when centered */
-
+static int min_width = 500;                    /* minimum width when centered */
+static const float menu_height_ratio = 4.0f;  /* This is the ratio used in the original calculation */
 /* -fn option overrides fonts[0]; default X11 font or font set */
-/* static const char *fonts[] = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
+//static const char *fonts[] = {
+//	"monospace:size=10"
+//};
 static const char *fonts[] = { "JetBrainsMono Nerd Font:size=11:style=bold" };
-// Original:
-/* static const char *fonts[] = {"monospace:size=10"}; */
-
 static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
 static const char *colors[SchemeLast][2] = {
-    /*              fg          bg       */
-    [SchemeNorm] = { "#ebdbb2", "#282828" },
-    /* [SchemeSel] = { "#ebdbb2", "#98971a" }, */
+	/*     fg         bg       */
+	[SchemeNorm] = { "#ebdbb2", "#282828" },
     [SchemeSel] = { "#ebdbb2", "#458588" },
-    [SchemeOut] = { "#ebdbb2", "#8ec07c" },
+    [SchemeSelHighlight] = { "#d79921", "#458588" },
+    [SchemeNormHighlight] = { "#d79921", "#282828" },
+	[SchemeOut] = { "#ebdbb2", "#8ec07c" },
+    [SchemeOutHighlight] = { "#83a598", "#458588" },
 };
 
 /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
@@ -29,3 +29,6 @@ static unsigned int lines      = 0;
  * for example: " /?\"&[]"
  */
 static const char worddelimiters[] = " ";
+
+/* Size of the window border */
+static unsigned int border_width = 0;
diff --git a/config.mk b/config.mk
index 566348b..137f7c8 100644
--- a/config.mk
+++ b/config.mk
@@ -1,5 +1,5 @@
 # dmenu version
-VERSION = 5.2
+VERSION = 5.3
 
 # paths
 PREFIX = /usr/local
diff --git a/dmenu.1 b/dmenu.1
index 323f93c..c036baa 100644
--- a/dmenu.1
+++ b/dmenu.1
@@ -40,6 +40,9 @@ which lists programs in the user's $PATH and runs the result in their $SHELL.
 .B \-b
 dmenu appears at the bottom of the screen.
 .TP
+.B \-c
+dmenu appears centered on the screen.
+.TP
 .B \-f
 dmenu grabs the keyboard before reading stdin if not reading from a tty. This
 is faster, but will lock up X until stdin reaches end\-of\-file.
diff --git a/dmenu.c b/dmenu.c
index 1bbc3ac..b5592c3 100644
--- a/dmenu.c
+++ b/dmenu.c
@@ -21,16 +21,15 @@
 
 /* macros */
 #define INTERSECT(x,y,w,h,r)  (MAX(0, MIN((x)+(w),(r).x_org+(r).width)  - MAX((x),(r).x_org)) \
-        * MAX(0, MIN((y)+(h),(r).y_org+(r).height) - MAX((y),(r).y_org)))
+                             * MAX(0, MIN((y)+(h),(r).y_org+(r).height) - MAX((y),(r).y_org)))
 #define TEXTW(X)              (drw_fontset_getwidth(drw, (X)) + lrpad)
 
 /* enums */
-enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */
-
+enum { SchemeNorm, SchemeSel, SchemeOut, SchemeNormHighlight, SchemeSelHighlight, SchemeOutHighlight, SchemeLast }; /* color schemes */
 struct item {
-    char *text;
-    struct item *left, *right;
-    int out;
+	char *text;
+	struct item *left, *right;
+	int out;
 };
 
 static char text[BUFSIZ] = "";
@@ -60,768 +59,806 @@ static char *(*fstrstr)(const char *, const char *) = strstr;
 static unsigned int
 textw_clamp(const char *str, unsigned int n)
 {
-    unsigned int w = drw_fontset_getwidth_clamp(drw, str, n) + lrpad;
-    return MIN(w, n);
+	unsigned int w = drw_fontset_getwidth_clamp(drw, str, n) + lrpad;
+	return MIN(w, n);
 }
 
 static void
 appenditem(struct item *item, struct item **list, struct item **last)
 {
-    if (*last)
-        (*last)->right = item;
-    else
-        *list = item;
-
-    item->left = *last;
-    item->right = NULL;
-    *last = item;
+	if (*last)
+		(*last)->right = item;
+	else
+		*list = item;
+
+	item->left = *last;
+	item->right = NULL;
+	*last = item;
 }
 
 static void
 calcoffsets(void)
 {
-    int i, n;
-
-    if (lines > 0)
-        n = lines * bh;
-    else
-        n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
-    /* calculate which items will begin the next page and previous page */
-    for (i = 0, next = curr; next; next = next->right)
-        if ((i += (lines > 0) ? bh : textw_clamp(next->text, n)) > n)
-            break;
-    for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
-        if ((i += (lines > 0) ? bh : textw_clamp(prev->left->text, n)) > n)
-            break;
+	int i, n;
+
+	if (lines > 0)
+		n = lines * bh;
+	else
+		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
+	/* calculate which items will begin the next page and previous page */
+	for (i = 0, next = curr; next; next = next->right)
+		if ((i += (lines > 0) ? bh : textw_clamp(next->text, n)) > n)
+			break;
+	for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
+		if ((i += (lines > 0) ? bh : textw_clamp(prev->left->text, n)) > n)
+			break;
 }
 
 static int
 max_textw(void)
 {
-    int len = 0;
-    for (struct item *item = items; item && item->text; item++)
-        len = MAX(TEXTW(item->text), len);
-    return len;
+	int len = 0;
+	for (struct item *item = items; item && item->text; item++)
+		len = MAX(TEXTW(item->text), len);
+	return len;
 }
 
 static void
 cleanup(void)
 {
-    size_t i;
-
-    XUngrabKey(dpy, AnyKey, AnyModifier, root);
-    for (i = 0; i < SchemeLast; i++)
-        free(scheme[i]);
-    for (i = 0; items && items[i].text; ++i)
-        free(items[i].text);
-    free(items);
-    drw_free(drw);
-    XSync(dpy, False);
-    XCloseDisplay(dpy);
+	size_t i;
+
+	XUngrabKey(dpy, AnyKey, AnyModifier, root);
+	for (i = 0; i < SchemeLast; i++)
+		free(scheme[i]);
+	for (i = 0; items && items[i].text; ++i)
+		free(items[i].text);
+	free(items);
+	drw_free(drw);
+	XSync(dpy, False);
+	XCloseDisplay(dpy);
 }
 
 static char *
 cistrstr(const char *h, const char *n)
 {
-    size_t i;
-
-    if (!n[0])
-        return (char *)h;
-
-    for (; *h; ++h) {
-        for (i = 0; n[i] && tolower((unsigned char)n[i]) ==
-                tolower((unsigned char)h[i]); ++i)
-            ;
-        if (n[i] == '\0')
-            return (char *)h;
-    }
-    return NULL;
+	size_t i;
+
+	if (!n[0])
+		return (char *)h;
+
+	for (; *h; ++h) {
+		for (i = 0; n[i] && tolower((unsigned char)n[i]) ==
+		            tolower((unsigned char)h[i]); ++i)
+			;
+		if (n[i] == '\0')
+			return (char *)h;
+	}
+	return NULL;
+}
+
+static void
+drawhighlights(struct item *item, int x, int y, int maxw)
+{
+	char restorechar, tokens[sizeof text], *highlight,  *token;
+	int indentx, highlightlen;
+
+	drw_setscheme(drw, scheme[item == sel ? SchemeSelHighlight : item->out ? SchemeOutHighlight : SchemeNormHighlight]);
+	strcpy(tokens, text);
+	for (token = strtok(tokens, " "); token; token = strtok(NULL, " ")) {
+		highlight = fstrstr(item->text, token);
+		while (highlight) {
+			// Move item str end, calc width for highlight indent, & restore
+			highlightlen = highlight - item->text;
+			restorechar = *highlight;
+			item->text[highlightlen] = '\0';
+			indentx = TEXTW(item->text);
+			item->text[highlightlen] = restorechar;
+
+			// Move highlight str end, draw highlight, & restore
+			restorechar = highlight[strlen(token)];
+			highlight[strlen(token)] = '\0';
+			if (indentx - (lrpad / 2) - 1 < maxw)
+				drw_text(
+					drw,
+					x + indentx - (lrpad / 2) - 1,
+					y,
+					MIN(maxw - indentx, TEXTW(highlight) - lrpad),
+					bh, 0, highlight, 0
+				);
+			highlight[strlen(token)] = restorechar;
+
+			if (strlen(highlight) - strlen(token) < strlen(token)) break;
+			highlight = fstrstr(highlight + strlen(token), token);
+		}
+	}
 }
 
 static int
 drawitem(struct item *item, int x, int y, int w)
 {
-    if (item == sel)
-        drw_setscheme(drw, scheme[SchemeSel]);
-    else if (item->out)
-        drw_setscheme(drw, scheme[SchemeOut]);
-    else
-        drw_setscheme(drw, scheme[SchemeNorm]);
-
-    return drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
+	if (item == sel)
+		drw_setscheme(drw, scheme[SchemeSel]);
+	else if (item->out)
+		drw_setscheme(drw, scheme[SchemeOut]);
+	else
+		drw_setscheme(drw, scheme[SchemeNorm]);
+
+	int r = drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
+	drawhighlights(item, x, y, w);
+	return r;
 }
 
 static void
 drawmenu(void)
 {
-    unsigned int curpos;
-    struct item *item;
-    int x = 0, y = 0, w;
-
-    drw_setscheme(drw, scheme[SchemeNorm]);
-    drw_rect(drw, 0, 0, mw, mh, 1, 1);
-
-    if (prompt && *prompt) {
-        drw_setscheme(drw, scheme[SchemeSel]);
-        x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
-    }
-    /* draw input field */
-    w = (lines > 0 || !matches) ? mw - x : inputw;
-    drw_setscheme(drw, scheme[SchemeNorm]);
-    drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
-
-    curpos = TEXTW(text) - TEXTW(&text[cursor]);
-    if ((curpos += lrpad / 2 - 1) < w) {
-        drw_setscheme(drw, scheme[SchemeNorm]);
-        drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
-    }
-
-    if (lines > 0) {
-        /* draw vertical list */
-        for (item = curr; item != next; item = item->right)
-            drawitem(item, x, y += bh, mw - x);
-    } else if (matches) {
-        /* draw horizontal list */
-        x += inputw;
-        w = TEXTW("<");
-        if (curr->left) {
-            drw_setscheme(drw, scheme[SchemeNorm]);
-            drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
-        }
-        x += w;
-        for (item = curr; item != next; item = item->right)
-            x = drawitem(item, x, 0, textw_clamp(item->text, mw - x - TEXTW(">")));
-        if (next) {
-            w = TEXTW(">");
-            drw_setscheme(drw, scheme[SchemeNorm]);
-            drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
-        }
-    }
-    drw_map(drw, win, 0, 0, mw, mh);
+	unsigned int curpos;
+	struct item *item;
+	int x = 0, y = 0, w;
+
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	drw_rect(drw, 0, 0, mw, mh, 1, 1);
+
+	if (prompt && *prompt) {
+		drw_setscheme(drw, scheme[SchemeSel]);
+		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
+	}
+	/* draw input field */
+	w = (lines > 0 || !matches) ? mw - x : inputw;
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+
+	curpos = TEXTW(text) - TEXTW(&text[cursor]);
+	if ((curpos += lrpad / 2 - 1) < w) {
+		drw_setscheme(drw, scheme[SchemeNorm]);
+		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
+	}
+
+	if (lines > 0) {
+		/* draw vertical list */
+		for (item = curr; item != next; item = item->right)
+			drawitem(item, x, y += bh, mw - x);
+	} else if (matches) {
+		/* draw horizontal list */
+		x += inputw;
+		w = TEXTW("<");
+		if (curr->left) {
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
+		}
+		x += w;
+		for (item = curr; item != next; item = item->right)
+			x = drawitem(item, x, 0, textw_clamp(item->text, mw - x - TEXTW(">")));
+		if (next) {
+			w = TEXTW(">");
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
+		}
+	}
+	drw_map(drw, win, 0, 0, mw, mh);
 }
 
 static void
 grabfocus(void)
 {
-    struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
-    Window focuswin;
-    int i, revertwin;
-
-    for (i = 0; i < 100; ++i) {
-        XGetInputFocus(dpy, &focuswin, &revertwin);
-        if (focuswin == win)
-            return;
-        XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
-        nanosleep(&ts, NULL);
-    }
-    die("cannot grab focus");
+	struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
+	Window focuswin;
+	int i, revertwin;
+
+	for (i = 0; i < 100; ++i) {
+		XGetInputFocus(dpy, &focuswin, &revertwin);
+		if (focuswin == win)
+			return;
+		XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
+		nanosleep(&ts, NULL);
+	}
+	die("cannot grab focus");
 }
 
 static void
 grabkeyboard(void)
 {
-    struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
-    int i;
-
-    if (embed)
-        return;
-    /* try to grab keyboard, we may have to wait for another process to ungrab */
-    for (i = 0; i < 1000; i++) {
-        if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
-                    GrabModeAsync, CurrentTime) == GrabSuccess)
-            return;
-        nanosleep(&ts, NULL);
-    }
-    die("cannot grab keyboard");
+	struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
+	int i;
+
+	if (embed)
+		return;
+	/* try to grab keyboard, we may have to wait for another process to ungrab */
+	for (i = 0; i < 1000; i++) {
+		if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
+		                  GrabModeAsync, CurrentTime) == GrabSuccess)
+			return;
+		nanosleep(&ts, NULL);
+	}
+	die("cannot grab keyboard");
 }
 
 static void
 match(void)
 {
-    static char **tokv = NULL;
-    static int tokn = 0;
-
-    char buf[sizeof text], *s;
-    int i, tokc = 0;
-    size_t len, textsize;
-    struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
-
-    strcpy(buf, text);
-    /* separate input text into tokens to be matched individually */
-    for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
-        if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
-            die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
-    len = tokc ? strlen(tokv[0]) : 0;
-
-    matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
-    textsize = strlen(text) + 1;
-    for (item = items; item && item->text; item++) {
-        for (i = 0; i < tokc; i++)
-            if (!fstrstr(item->text, tokv[i]))
-                break;
-        if (i != tokc) /* not all tokens match */
-            continue;
-        /* exact matches go first, then prefixes, then substrings */
-        if (!tokc || !fstrncmp(text, item->text, textsize))
-            appenditem(item, &matches, &matchend);
-        else if (!fstrncmp(tokv[0], item->text, len))
-            appenditem(item, &lprefix, &prefixend);
-        else
-            appenditem(item, &lsubstr, &substrend);
-    }
-    if (lprefix) {
-        if (matches) {
-            matchend->right = lprefix;
-            lprefix->left = matchend;
-        } else
-            matches = lprefix;
-        matchend = prefixend;
-    }
-    if (lsubstr) {
-        if (matches) {
-            matchend->right = lsubstr;
-            lsubstr->left = matchend;
-        } else
-            matches = lsubstr;
-        matchend = substrend;
-    }
-    curr = sel = matches;
-    calcoffsets();
+	static char **tokv = NULL;
+	static int tokn = 0;
+
+	char buf[sizeof text], *s;
+	int i, tokc = 0;
+	size_t len, textsize;
+	struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
+
+	strcpy(buf, text);
+	/* separate input text into tokens to be matched individually */
+	for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
+		if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
+			die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
+	len = tokc ? strlen(tokv[0]) : 0;
+
+	matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
+	textsize = strlen(text) + 1;
+	for (item = items; item && item->text; item++) {
+		for (i = 0; i < tokc; i++)
+			if (!fstrstr(item->text, tokv[i]))
+				break;
+		if (i != tokc) /* not all tokens match */
+			continue;
+		/* exact matches go first, then prefixes, then substrings */
+		if (!tokc || !fstrncmp(text, item->text, textsize))
+			appenditem(item, &matches, &matchend);
+		else if (!fstrncmp(tokv[0], item->text, len))
+			appenditem(item, &lprefix, &prefixend);
+		else
+			appenditem(item, &lsubstr, &substrend);
+	}
+	if (lprefix) {
+		if (matches) {
+			matchend->right = lprefix;
+			lprefix->left = matchend;
+		} else
+			matches = lprefix;
+		matchend = prefixend;
+	}
+	if (lsubstr) {
+		if (matches) {
+			matchend->right = lsubstr;
+			lsubstr->left = matchend;
+		} else
+			matches = lsubstr;
+		matchend = substrend;
+	}
+	curr = sel = matches;
+	calcoffsets();
 }
 
 static void
 insert(const char *str, ssize_t n)
 {
-    if (strlen(text) + n > sizeof text - 1)
-        return;
-    /* move existing text out of the way, insert new text, and update cursor */
-    memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
-    if (n > 0)
-        memcpy(&text[cursor], str, n);
-    cursor += n;
-    match();
+	if (strlen(text) + n > sizeof text - 1)
+		return;
+	/* move existing text out of the way, insert new text, and update cursor */
+	memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
+	if (n > 0)
+		memcpy(&text[cursor], str, n);
+	cursor += n;
+	match();
 }
 
 static size_t
 nextrune(int inc)
 {
-    ssize_t n;
+	ssize_t n;
 
-    /* return location of next utf8 rune in the given direction (+1 or -1) */
-    for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
-        ;
-    return n;
+	/* return location of next utf8 rune in the given direction (+1 or -1) */
+	for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
+		;
+	return n;
 }
 
 static void
 movewordedge(int dir)
 {
-    if (dir < 0) { /* move cursor to the start of the word*/
-        while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
-            cursor = nextrune(-1);
-        while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
-            cursor = nextrune(-1);
-    } else { /* move cursor to the end of the word */
-        while (text[cursor] && strchr(worddelimiters, text[cursor]))
-            cursor = nextrune(+1);
-        while (text[cursor] && !strchr(worddelimiters, text[cursor]))
-            cursor = nextrune(+1);
-    }
+	if (dir < 0) { /* move cursor to the start of the word*/
+		while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+			cursor = nextrune(-1);
+		while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+			cursor = nextrune(-1);
+	} else { /* move cursor to the end of the word */
+		while (text[cursor] && strchr(worddelimiters, text[cursor]))
+			cursor = nextrune(+1);
+		while (text[cursor] && !strchr(worddelimiters, text[cursor]))
+			cursor = nextrune(+1);
+	}
 }
 
 static void
 keypress(XKeyEvent *ev)
 {
-    char buf[64];
-    int len;
-    KeySym ksym = NoSymbol;
-    Status status;
-
-    len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
-    switch (status) {
-        default: /* XLookupNone, XBufferOverflow */
-            return;
-        case XLookupChars: /* composed string from input method */
-            goto insert;
-        case XLookupKeySym:
-        case XLookupBoth: /* a KeySym and a string are returned: use keysym */
-            break;
-    }
-
-    if (ev->state & ControlMask) {
-        switch(ksym) {
-            case XK_a: ksym = XK_Home;      break;
-            case XK_b: ksym = XK_Left;      break;
-            case XK_c: ksym = XK_Escape;    break;
-            case XK_d: ksym = XK_Delete;    break;
-            case XK_e: ksym = XK_End;       break;
-            case XK_f: ksym = XK_Right;     break;
-            case XK_g: ksym = XK_Escape;    break;
-            case XK_h: ksym = XK_BackSpace; break;
-            case XK_i: ksym = XK_Tab;       break;
-            case XK_j: /* fallthrough */
-            case XK_J: /* fallthrough */
-            case XK_m: /* fallthrough */
-            case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
-            case XK_n: ksym = XK_Down;      break;
-            case XK_p: ksym = XK_Up;        break;
-
-            case XK_k: /* delete right */
-                       text[cursor] = '\0';
-                       match();
-                       break;
-            case XK_u: /* delete left */
-                       insert(NULL, 0 - cursor);
-                       break;
-            case XK_w: /* delete word */
-                       while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
-                           insert(NULL, nextrune(-1) - cursor);
-                       while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
-                           insert(NULL, nextrune(-1) - cursor);
-                       break;
-            case XK_y: /* paste selection */
-            case XK_Y:
-                       XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
-                               utf8, utf8, win, CurrentTime);
-                       return;
-            case XK_Left:
-            case XK_KP_Left:
-                       movewordedge(-1);
-                       goto draw;
-            case XK_Right:
-            case XK_KP_Right:
-                       movewordedge(+1);
-                       goto draw;
-            case XK_Return:
-            case XK_KP_Enter:
-                       break;
-            case XK_bracketleft:
-                       cleanup();
-                       exit(1);
-            default:
-                       return;
-        }
-    } else if (ev->state & Mod1Mask) {
-        switch(ksym) {
-            case XK_b:
-                movewordedge(-1);
-                goto draw;
-            case XK_f:
-                movewordedge(+1);
-                goto draw;
-            case XK_g: ksym = XK_Home;  break;
-            case XK_G: ksym = XK_End;   break;
-            case XK_h: ksym = XK_Up;    break;
-            case XK_j: ksym = XK_Next;  break;
-            case XK_k: ksym = XK_Prior; break;
-            case XK_l: ksym = XK_Down;  break;
-            default:
-                       return;
-        }
-    }
-
-    switch(ksym) {
-        default:
+	char buf[64];
+	int len;
+	KeySym ksym = NoSymbol;
+	Status status;
+
+	len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
+	switch (status) {
+	default: /* XLookupNone, XBufferOverflow */
+		return;
+	case XLookupChars: /* composed string from input method */
+		goto insert;
+	case XLookupKeySym:
+	case XLookupBoth: /* a KeySym and a string are returned: use keysym */
+		break;
+	}
+
+	if (ev->state & ControlMask) {
+		switch(ksym) {
+		case XK_a: ksym = XK_Home;      break;
+		case XK_b: ksym = XK_Left;      break;
+		case XK_c: ksym = XK_Escape;    break;
+		case XK_d: ksym = XK_Delete;    break;
+		case XK_e: ksym = XK_End;       break;
+		case XK_f: ksym = XK_Right;     break;
+		case XK_g: ksym = XK_Escape;    break;
+		case XK_h: ksym = XK_BackSpace; break;
+		case XK_i: ksym = XK_Tab;       break;
+		case XK_j: /* fallthrough */
+		case XK_J: /* fallthrough */
+		case XK_m: /* fallthrough */
+		case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
+		case XK_n: ksym = XK_Down;      break;
+		case XK_p: ksym = XK_Up;        break;
+
+		case XK_k: /* delete right */
+			text[cursor] = '\0';
+			match();
+			break;
+		case XK_u: /* delete left */
+			insert(NULL, 0 - cursor);
+			break;
+		case XK_w: /* delete word */
+			while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+				insert(NULL, nextrune(-1) - cursor);
+			while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+				insert(NULL, nextrune(-1) - cursor);
+			break;
+		case XK_y: /* paste selection */
+		case XK_Y:
+			XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
+			                  utf8, utf8, win, CurrentTime);
+			return;
+		case XK_Left:
+		case XK_KP_Left:
+			movewordedge(-1);
+			goto draw;
+		case XK_Right:
+		case XK_KP_Right:
+			movewordedge(+1);
+			goto draw;
+		case XK_Return:
+		case XK_KP_Enter:
+			break;
+		case XK_bracketleft:
+			cleanup();
+			exit(1);
+		default:
+			return;
+		}
+	} else if (ev->state & Mod1Mask) {
+		switch(ksym) {
+		case XK_b:
+			movewordedge(-1);
+			goto draw;
+		case XK_f:
+			movewordedge(+1);
+			goto draw;
+		case XK_g: ksym = XK_Home;  break;
+		case XK_G: ksym = XK_End;   break;
+		case XK_h: ksym = XK_Up;    break;
+		case XK_j: ksym = XK_Next;  break;
+		case XK_k: ksym = XK_Prior; break;
+		case XK_l: ksym = XK_Down;  break;
+		default:
+			return;
+		}
+	}
+
+	switch(ksym) {
+	default:
 insert:
-            if (!iscntrl((unsigned char)*buf))
-                insert(buf, len);
-            break;
-        case XK_Delete:
-        case XK_KP_Delete:
-            if (text[cursor] == '\0')
-                return;
-            cursor = nextrune(+1);
-            /* fallthrough */
-        case XK_BackSpace:
-            if (cursor == 0)
-                return;
-            insert(NULL, nextrune(-1) - cursor);
-            break;
-        case XK_End:
-        case XK_KP_End:
-            if (text[cursor] != '\0') {
-                cursor = strlen(text);
-                break;
-            }
-            if (next) {
-                /* jump to end of list and position items in reverse */
-                curr = matchend;
-                calcoffsets();
-                curr = prev;
-                calcoffsets();
-                while (next && (curr = curr->right))
-                    calcoffsets();
-            }
-            sel = matchend;
-            break;
-        case XK_Escape:
-            cleanup();
-            exit(1);
-        case XK_Home:
-        case XK_KP_Home:
-            if (sel == matches) {
-                cursor = 0;
-                break;
-            }
-            sel = curr = matches;
-            calcoffsets();
-            break;
-        case XK_Left:
-        case XK_KP_Left:
-            if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
-                cursor = nextrune(-1);
-                break;
-            }
-            if (lines > 0)
-                return;
-            /* fallthrough */
-        case XK_Up:
-        case XK_KP_Up:
-            if (sel && sel->left && (sel = sel->left)->right == curr) {
-                curr = prev;
-                calcoffsets();
-            }
-            break;
-        case XK_Next:
-        case XK_KP_Next:
-            if (!next)
-                return;
-            sel = curr = next;
-            calcoffsets();
-            break;
-        case XK_Prior:
-        case XK_KP_Prior:
-            if (!prev)
-                return;
-            sel = curr = prev;
-            calcoffsets();
-            break;
-        case XK_Return:
-        case XK_KP_Enter:
-            puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
-            if (!(ev->state & ControlMask)) {
-                cleanup();
-                exit(0);
-            }
-            if (sel)
-                sel->out = 1;
-            break;
-        case XK_Right:
-        case XK_KP_Right:
-            if (text[cursor] != '\0') {
-                cursor = nextrune(+1);
-                break;
-            }
-            if (lines > 0)
-                return;
-            /* fallthrough */
-        case XK_Down:
-        case XK_KP_Down:
-            if (sel && sel->right && (sel = sel->right) == next) {
-                curr = next;
-                calcoffsets();
-            }
-            break;
-        case XK_Tab:
-            if (!sel)
-                return;
-            cursor = strnlen(sel->text, sizeof text - 1);
-            memcpy(text, sel->text, cursor);
-            text[cursor] = '\0';
-            match();
-            break;
-    }
+		if (!iscntrl((unsigned char)*buf))
+			insert(buf, len);
+		break;
+	case XK_Delete:
+	case XK_KP_Delete:
+		if (text[cursor] == '\0')
+			return;
+		cursor = nextrune(+1);
+		/* fallthrough */
+	case XK_BackSpace:
+		if (cursor == 0)
+			return;
+		insert(NULL, nextrune(-1) - cursor);
+		break;
+	case XK_End:
+	case XK_KP_End:
+		if (text[cursor] != '\0') {
+			cursor = strlen(text);
+			break;
+		}
+		if (next) {
+			/* jump to end of list and position items in reverse */
+			curr = matchend;
+			calcoffsets();
+			curr = prev;
+			calcoffsets();
+			while (next && (curr = curr->right))
+				calcoffsets();
+		}
+		sel = matchend;
+		break;
+	case XK_Escape:
+		cleanup();
+		exit(1);
+	case XK_Home:
+	case XK_KP_Home:
+		if (sel == matches) {
+			cursor = 0;
+			break;
+		}
+		sel = curr = matches;
+		calcoffsets();
+		break;
+	case XK_Left:
+	case XK_KP_Left:
+		if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
+			cursor = nextrune(-1);
+			break;
+		}
+		if (lines > 0)
+			return;
+		/* fallthrough */
+	case XK_Up:
+	case XK_KP_Up:
+		if (sel && sel->left && (sel = sel->left)->right == curr) {
+			curr = prev;
+			calcoffsets();
+		}
+		break;
+	case XK_Next:
+	case XK_KP_Next:
+		if (!next)
+			return;
+		sel = curr = next;
+		calcoffsets();
+		break;
+	case XK_Prior:
+	case XK_KP_Prior:
+		if (!prev)
+			return;
+		sel = curr = prev;
+		calcoffsets();
+		break;
+	case XK_Return:
+	case XK_KP_Enter:
+		puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
+		if (!(ev->state & ControlMask)) {
+			cleanup();
+			exit(0);
+		}
+		if (sel)
+			sel->out = 1;
+		break;
+	case XK_Right:
+	case XK_KP_Right:
+		if (text[cursor] != '\0') {
+			cursor = nextrune(+1);
+			break;
+		}
+		if (lines > 0)
+			return;
+		/* fallthrough */
+	case XK_Down:
+	case XK_KP_Down:
+		if (sel && sel->right && (sel = sel->right) == next) {
+			curr = next;
+			calcoffsets();
+		}
+		break;
+	case XK_Tab:
+		if (!sel)
+			return;
+		cursor = strnlen(sel->text, sizeof text - 1);
+		memcpy(text, sel->text, cursor);
+		text[cursor] = '\0';
+		match();
+		break;
+	}
 
 draw:
-    drawmenu();
+	drawmenu();
 }
 
 static void
 paste(void)
 {
-    char *p, *q;
-    int di;
-    unsigned long dl;
-    Atom da;
-
-    /* we have been given the current selection, now insert it into input */
-    if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
-                utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
-            == Success && p) {
-        insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
-        XFree(p);
-    }
-    drawmenu();
+	char *p, *q;
+	int di;
+	unsigned long dl;
+	Atom da;
+
+	/* we have been given the current selection, now insert it into input */
+	if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
+	                   utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
+	    == Success && p) {
+		insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
+		XFree(p);
+	}
+	drawmenu();
 }
 
 static void
 readstdin(void)
 {
-    char *line = NULL;
-    size_t i, itemsiz = 0, linesiz = 0;
-    ssize_t len;
-
-    /* read each line from stdin and add it to the item list */
-    for (i = 0; (len = getline(&line, &linesiz, stdin)) != -1; i++) {
-        if (i + 1 >= itemsiz) {
-            itemsiz += 256;
-            if (!(items = realloc(items, itemsiz * sizeof(*items))))
-                die("cannot realloc %zu bytes:", itemsiz * sizeof(*items));
-        }
-        if (line[len - 1] == '\n')
-            line[len - 1] = '\0';
+	char *line = NULL;
+	size_t i, itemsiz = 0, linesiz = 0;
+	ssize_t len;
+
+	/* read each line from stdin and add it to the item list */
+	for (i = 0; (len = getline(&line, &linesiz, stdin)) != -1; i++) {
+		if (i + 1 >= itemsiz) {
+			itemsiz += 256;
+			if (!(items = realloc(items, itemsiz * sizeof(*items))))
+				die("cannot realloc %zu bytes:", itemsiz * sizeof(*items));
+		}
+		if (line[len - 1] == '\n')
+			line[len - 1] = '\0';
 		if (!(items[i].text = strdup(line)))
 			die("strdup:");
 
-        items[i].out = 0;
-    }
-    free(line);
-    if (items)
-        items[i].text = NULL;
-    lines = MIN(lines, i);
+		items[i].out = 0;
+	}
+	free(line);
+	if (items)
+		items[i].text = NULL;
+	lines = MIN(lines, i);
 }
 
 static void
 run(void)
 {
-    XEvent ev;
-
-    while (!XNextEvent(dpy, &ev)) {
-        if (XFilterEvent(&ev, win))
-            continue;
-        switch(ev.type) {
-            case DestroyNotify:
-                if (ev.xdestroywindow.window != win)
-                    break;
-                cleanup();
-                exit(1);
-            case Expose:
-                if (ev.xexpose.count == 0)
-                    drw_map(drw, win, 0, 0, mw, mh);
-                break;
-            case FocusIn:
-                /* regrab focus from parent window */
-                if (ev.xfocus.window != win)
-                    grabfocus();
-                break;
-            case KeyPress:
-                keypress(&ev.xkey);
-                break;
-            case SelectionNotify:
-                if (ev.xselection.property == utf8)
-                    paste();
-                break;
-            case VisibilityNotify:
-                if (ev.xvisibility.state != VisibilityUnobscured)
-                    XRaiseWindow(dpy, win);
-                break;
-        }
-    }
+	XEvent ev;
+
+	while (!XNextEvent(dpy, &ev)) {
+		if (XFilterEvent(&ev, win))
+			continue;
+		switch(ev.type) {
+		case DestroyNotify:
+			if (ev.xdestroywindow.window != win)
+				break;
+			cleanup();
+			exit(1);
+		case Expose:
+			if (ev.xexpose.count == 0)
+				drw_map(drw, win, 0, 0, mw, mh);
+			break;
+		case FocusIn:
+			/* regrab focus from parent window */
+			if (ev.xfocus.window != win)
+				grabfocus();
+			break;
+		case KeyPress:
+			keypress(&ev.xkey);
+			break;
+		case SelectionNotify:
+			if (ev.xselection.property == utf8)
+				paste();
+			break;
+		case VisibilityNotify:
+			if (ev.xvisibility.state != VisibilityUnobscured)
+				XRaiseWindow(dpy, win);
+			break;
+		}
+	}
 }
 
 static void
 setup(void)
 {
-    int x, y, i, j;
-    unsigned int du;
-    XSetWindowAttributes swa;
-    XIM xim;
-    Window w, dw, *dws;
-    XWindowAttributes wa;
-    XClassHint ch = {"dmenu", "dmenu"};
+	int x, y, i, j;
+	unsigned int du;
+	XSetWindowAttributes swa;
+	XIM xim;
+	Window w, dw, *dws;
+	XWindowAttributes wa;
+	XClassHint ch = {"dmenu", "dmenu"};
 #ifdef XINERAMA
-    XineramaScreenInfo *info;
-    Window pw;
-    int a, di, n, area = 0;
+	XineramaScreenInfo *info;
+	Window pw;
+	int a, di, n, area = 0;
 #endif
-    /* init appearance */
-    for (j = 0; j < SchemeLast; j++)
-        scheme[j] = drw_scm_create(drw, colors[j], 2);
-
-    clip = XInternAtom(dpy, "CLIPBOARD",   False);
-    utf8 = XInternAtom(dpy, "UTF8_STRING", False);
-
-    /* calculate menu geometry */
-    bh = drw->fonts->h + 2;
-    lines = MAX(lines, 0);
-    mh = (lines + 1) * bh;
-    promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+	/* init appearance */
+	for (j = 0; j < SchemeLast; j++)
+		scheme[j] = drw_scm_create(drw, colors[j], 2);
+
+	clip = XInternAtom(dpy, "CLIPBOARD",   False);
+	utf8 = XInternAtom(dpy, "UTF8_STRING", False);
+
+	/* calculate menu geometry */
+	bh = drw->fonts->h + 2;
+	lines = MAX(lines, 0);
+	mh = (lines + 1) * bh;
+	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
 #ifdef XINERAMA
-    i = 0;
-    if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
-        XGetInputFocus(dpy, &w, &di);
-        if (mon >= 0 && mon < n)
-            i = mon;
-        else if (w != root && w != PointerRoot && w != None) {
-            /* find top-level window containing current input focus */
-            do {
-                if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
-                    XFree(dws);
-            } while (w != root && w != pw);
-            /* find xinerama screen with which the window intersects most */
-            if (XGetWindowAttributes(dpy, pw, &wa))
-                for (j = 0; j < n; j++)
-                    if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
-                        area = a;
-                        i = j;
-                    }
-        }
-        /* no focused window is on screen, so use pointer location instead */
-        if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
-            for (i = 0; i < n; i++)
-                if (INTERSECT(x, y, 1, 1, info[i]) != 0)
-                    break;
-
-        if (centered) {
-            //mw = MIN(MAX(max_textw() + promptw, min_width), info[i].width);
-            //// Custom max width
-            //if (mw > max_width)
-            //	mw = 900;
-            mw = 900;
-            x = info[i].x_org + ((info[i].width  - mw) / 2);
-            y = info[i].y_org + ((info[i].height - mh) / 2);
-        } else {
-            x = info[i].x_org;
-            y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
-            mw = info[i].width;
-        }
-
-        XFree(info);
-    } else
+	i = 0;
+	if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
+		XGetInputFocus(dpy, &w, &di);
+		if (mon >= 0 && mon < n)
+			i = mon;
+		else if (w != root && w != PointerRoot && w != None) {
+			/* find top-level window containing current input focus */
+			do {
+				if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
+					XFree(dws);
+			} while (w != root && w != pw);
+			/* find xinerama screen with which the window intersects most */
+			if (XGetWindowAttributes(dpy, pw, &wa))
+				for (j = 0; j < n; j++)
+					if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
+						area = a;
+						i = j;
+					}
+		}
+		/* no focused window is on screen, so use pointer location instead */
+		if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
+			for (i = 0; i < n; i++)
+				if (INTERSECT(x, y, 1, 1, info[i]) != 0)
+					break;
+
+		if (centered) {
+			mw = MIN(MAX(max_textw() + promptw, min_width), info[i].width);
+            //mw = 900;
+			x = info[i].x_org + ((info[i].width  - mw) / 2);
+			y = info[i].y_org + ((info[i].height - mh) / menu_height_ratio);
+		} else {
+			x = info[i].x_org;
+			y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
+			mw = info[i].width;
+		}
+
+		XFree(info);
+	} else
 #endif
-    {
-        if (!XGetWindowAttributes(dpy, parentwin, &wa))
-            die("could not get embedding window attributes: 0x%lx",
-                    parentwin);
-
-        if (centered) {
-            //mw = MIN(MAX(max_textw() + promptw, min_width), wa.width);
-            mw = 900;
-            x = (wa.width  - mw) / 2;
-            y = (wa.height - mh) / 2;
-        } else {
-            x = 0;
-            y = topbar ? 0 : wa.height - mh;
-            mw = wa.width;
-        }
-    }
-    promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
-    inputw = mw / 3; /* input width: ~33% of monitor width */
-    match();
-
-    /* create menu window */
-    swa.override_redirect = True;
-    swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
-    swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
-    win = XCreateWindow(dpy, root, x, y, mw, mh, 0,
-            CopyFromParent, CopyFromParent, CopyFromParent,
-            CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
-    XSetClassHint(dpy, win, &ch);
-
-
-    /* input methods */
-    if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
-        die("XOpenIM failed: could not open input device");
-
-    xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
-            XNClientWindow, win, XNFocusWindow, win, NULL);
-
-    XMapRaised(dpy, win);
-    if (embed) {
-        XReparentWindow(dpy, win, parentwin, x, y);
-        XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
-        if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
-            for (i = 0; i < du && dws[i] != win; ++i)
-                XSelectInput(dpy, dws[i], FocusChangeMask);
-            XFree(dws);
-        }
-        grabfocus();
-    }
-    drw_resize(drw, mw, mh);
-    drawmenu();
+	{
+		if (!XGetWindowAttributes(dpy, parentwin, &wa))
+			die("could not get embedding window attributes: 0x%lx",
+			    parentwin);
+
+		if (centered) {
+			mw = MIN(MAX(max_textw() + promptw, min_width), wa.width);
+			x = (wa.width  - mw) / 2;
+			y = (wa.height - mh) / 2;
+		} else {
+			x = 0;
+			y = topbar ? 0 : wa.height - mh;
+			mw = wa.width;
+		}
+	}
+	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+	inputw = mw / 3; /* input width: ~33% of monitor width */
+	match();
+
+	/* create menu window */
+	swa.override_redirect = True;
+	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
+	win = XCreateWindow(dpy, root, x, y, mw, mh, border_width,
+	                    CopyFromParent, CopyFromParent, CopyFromParent,
+	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
+	if (border_width)
+		XSetWindowBorder(dpy, win, scheme[SchemeSel][ColBg].pixel);
+	XSetClassHint(dpy, win, &ch);
+
+	/* input methods */
+	if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
+		die("XOpenIM failed: could not open input device");
+
+	xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+	                XNClientWindow, win, XNFocusWindow, win, NULL);
+
+	XMapRaised(dpy, win);
+	if (embed) {
+		XReparentWindow(dpy, win, parentwin, x, y);
+		XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
+		if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
+			for (i = 0; i < du && dws[i] != win; ++i)
+				XSelectInput(dpy, dws[i], FocusChangeMask);
+			XFree(dws);
+		}
+		grabfocus();
+	}
+	drw_resize(drw, mw, mh);
+	drawmenu();
 }
 
 static void
 usage(void)
 {
-    die("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
-            "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
+	die("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
+	    "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
 }
 
 int
 main(int argc, char *argv[])
 {
-    XWindowAttributes wa;
-    int i, fast = 0;
-
-    for (i = 1; i < argc; i++)
-        /* these options take no arguments */
-        if (!strcmp(argv[i], "-v")) {      /* prints version information */
-            puts("dmenu-"VERSION);
-            exit(0);
-        } else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
-            topbar = 0;
-        else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
-            fast = 1;
-        else if (!strcmp(argv[i], "-c"))   /* removes center dmenu on screen */
-            centered = 0;
-        else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
-            fstrncmp = strncasecmp;
-            fstrstr = cistrstr;
-        } else if (i + 1 == argc)
-            usage();
-    /* these options take one argument */
-        else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
-            lines = atoi(argv[++i]);
-        else if (!strcmp(argv[i], "-m"))
-            mon = atoi(argv[++i]);
-        else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
-            prompt = argv[++i];
-        else if (!strcmp(argv[i], "-fn"))  /* font or font set */
-            fonts[0] = argv[++i];
-        else if (!strcmp(argv[i], "-nb"))  /* normal background color */
-            colors[SchemeNorm][ColBg] = argv[++i];
-        else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
-            colors[SchemeNorm][ColFg] = argv[++i];
-        else if (!strcmp(argv[i], "-sb"))  /* selected background color */
-            colors[SchemeSel][ColBg] = argv[++i];
-        else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
-            colors[SchemeSel][ColFg] = argv[++i];
-        else if (!strcmp(argv[i], "-w"))   /* embedding window id */
-            embed = argv[++i];
-        else
-            usage();
-
-    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-        fputs("warning: no locale support\n", stderr);
-    if (!(dpy = XOpenDisplay(NULL)))
-        die("cannot open display");
-    screen = DefaultScreen(dpy);
-    root = RootWindow(dpy, screen);
-    if (!embed || !(parentwin = strtol(embed, NULL, 0)))
-        parentwin = root;
-    if (!XGetWindowAttributes(dpy, parentwin, &wa))
-        die("could not get embedding window attributes: 0x%lx",
-                parentwin);
-    drw = drw_create(dpy, screen, root, wa.width, wa.height);
-    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-        die("no fonts could be loaded.");
-    lrpad = drw->fonts->h;
+	XWindowAttributes wa;
+	int i, fast = 0;
+
+	for (i = 1; i < argc; i++)
+		/* these options take no arguments */
+		if (!strcmp(argv[i], "-v")) {      /* prints version information */
+			puts("dmenu-"VERSION);
+			exit(0);
+		} else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
+			topbar = 0;
+		else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
+			fast = 1;
+		else if (!strcmp(argv[i], "-c"))   /* centers dmenu on screen */
+			centered = 1;
+		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
+			fstrncmp = strncasecmp;
+			fstrstr = cistrstr;
+		} else if (i + 1 == argc)
+			usage();
+		/* these options take one argument */
+		else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
+			lines = atoi(argv[++i]);
+		else if (!strcmp(argv[i], "-m"))
+			mon = atoi(argv[++i]);
+		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
+			prompt = argv[++i];
+		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
+			fonts[0] = argv[++i];
+		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
+			colors[SchemeNorm][ColBg] = argv[++i];
+		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
+			colors[SchemeNorm][ColFg] = argv[++i];
+		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
+			colors[SchemeSel][ColBg] = argv[++i];
+		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
+			colors[SchemeSel][ColFg] = argv[++i];
+		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
+			embed = argv[++i];
+		else if (!strcmp(argv[i], "-bw"))
+			border_width = atoi(argv[++i]); /* border width */
+		else
+			usage();
+
+	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+		fputs("warning: no locale support\n", stderr);
+	if (!(dpy = XOpenDisplay(NULL)))
+		die("cannot open display");
+	screen = DefaultScreen(dpy);
+	root = RootWindow(dpy, screen);
+	if (!embed || !(parentwin = strtol(embed, NULL, 0)))
+		parentwin = root;
+	if (!XGetWindowAttributes(dpy, parentwin, &wa))
+		die("could not get embedding window attributes: 0x%lx",
+		    parentwin);
+	drw = drw_create(dpy, screen, root, wa.width, wa.height);
+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+		die("no fonts could be loaded.");
+	lrpad = drw->fonts->h;
 
 #ifdef __OpenBSD__
-    if (pledge("stdio rpath", NULL) == -1)
-        die("pledge");
+	if (pledge("stdio rpath", NULL) == -1)
+		die("pledge");
 #endif
 
-    if (fast && !isatty(0)) {
-        grabkeyboard();
-        readstdin();
-    } else {
-        readstdin();
-        grabkeyboard();
-    }
-    setup();
-    run();
-
-    return 1; /* unreachable */
+	if (fast && !isatty(0)) {
+		grabkeyboard();
+		readstdin();
+	} else {
+		readstdin();
+		grabkeyboard();
+	}
+	setup();
+	run();
+
+	return 1; /* unreachable */
 }
diff --git a/drw.c b/drw.c
index 65e9134..c41e6af 100644
--- a/drw.c
+++ b/drw.c
@@ -9,94 +9,80 @@
 #include "util.h"
 
 #define UTF_INVALID 0xFFFD
-#define UTF_SIZ     4
 
-static const unsigned char utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
-static const unsigned char utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
-static const long utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
-static const long utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
-
-static long
-utf8decodebyte(const char c, size_t *i)
-{
-    for (*i = 0; *i < (UTF_SIZ + 1); ++(*i))
-        if (((unsigned char)c & utfmask[*i]) == utfbyte[*i])
-            return (unsigned char)c & ~utfmask[*i];
-    return 0;
-}
-
-static size_t
-utf8validate(long *u, size_t i)
-{
-    if (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))
-        *u = UTF_INVALID;
-    for (i = 1; *u > utfmax[i]; ++i)
-        ;
-    return i;
-}
-
-static size_t
-utf8decode(const char *c, long *u, size_t clen)
+static int
+utf8decode(const char *s_in, long *u, int *err)
 {
-    size_t i, j, len, type;
-    long udecoded;
-
-    *u = UTF_INVALID;
-    if (!clen)
-        return 0;
-    udecoded = utf8decodebyte(c[0], &len);
-    if (!BETWEEN(len, 1, UTF_SIZ))
-        return 1;
-    for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
-        udecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);
-        if (type)
-            return j;
-    }
-    if (j < len)
-        return 0;
-    *u = udecoded;
-    utf8validate(u, len);
-
-    return len;
+	static const unsigned char lens[] = {
+		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
+		/* 110XX */ 2, 2, 2, 2,
+		/* 1110X */ 3, 3,
+		/* 11110 */ 4,
+		/* 11111 */ 0,  /* invalid */
+	};
+	static const unsigned char leading_mask[] = { 0x7F, 0x1F, 0x0F, 0x07 };
+	static const unsigned int overlong[] = { 0x0, 0x80, 0x0800, 0x10000 };
+
+	const unsigned char *s = (const unsigned char *)s_in;
+	int len = lens[*s >> 3];
+	*u = UTF_INVALID;
+	*err = 1;
+	if (len == 0)
+		return 1;
+
+	long cp = s[0] & leading_mask[len - 1];
+	for (int i = 1; i < len; ++i) {
+		if (s[i] == '\0' || (s[i] & 0xC0) != 0x80)
+			return i;
+		cp = (cp << 6) | (s[i] & 0x3F);
+	}
+	/* out of range, surrogate, overlong encoding */
+	if (cp > 0x10FFFF || (cp >> 11) == 0x1B || cp < overlong[len - 1])
+		return len;
+
+	*err = 0;
+	*u = cp;
+	return len;
 }
 
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
 {
-    Drw *drw = ecalloc(1, sizeof(Drw));
-
-    drw->dpy = dpy;
-    drw->screen = screen;
-    drw->root = root;
-    drw->w = w;
-    drw->h = h;
-    drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
-    drw->gc = XCreateGC(dpy, root, 0, NULL);
-    XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
-
-    return drw;
+	Drw *drw = ecalloc(1, sizeof(Drw));
+
+	drw->dpy = dpy;
+	drw->screen = screen;
+	drw->root = root;
+	drw->w = w;
+	drw->h = h;
+	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+	drw->gc = XCreateGC(dpy, root, 0, NULL);
+	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+
+	return drw;
 }
 
 void
 drw_resize(Drw *drw, unsigned int w, unsigned int h)
 {
-    if (!drw)
-        return;
-
-    drw->w = w;
-    drw->h = h;
-    if (drw->drawable)
-        XFreePixmap(drw->dpy, drw->drawable);
-    drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
+	if (!drw)
+		return;
+
+	drw->w = w;
+	drw->h = h;
+	if (drw->drawable)
+		XFreePixmap(drw->dpy, drw->drawable);
+	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
 }
 
 void
 drw_free(Drw *drw)
 {
-    XFreePixmap(drw->dpy, drw->drawable);
-    XFreeGC(drw->dpy, drw->gc);
-    drw_fontset_free(drw->fonts);
-    free(drw);
+	XFreePixmap(drw->dpy, drw->drawable);
+	XFreeGC(drw->dpy, drw->gc);
+	drw_fontset_free(drw->fonts);
+	free(drw);
 }
 
 /* This function is an implementation detail. Library users should use
@@ -105,91 +91,91 @@ drw_free(Drw *drw)
 static Fnt *
 xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
 {
-    Fnt *font;
-    XftFont *xfont = NULL;
-    FcPattern *pattern = NULL;
-
-    if (fontname) {
-        /* Using the pattern found at font->xfont->pattern does not yield the
-         * same substitution results as using the pattern returned by
-         * FcNameParse; using the latter results in the desired fallback
-         * behaviour whereas the former just results in missing-character
-         * rectangles being drawn, at least with some fonts. */
-        if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-            fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
-            return NULL;
-        }
-        if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-            fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
-            XftFontClose(drw->dpy, xfont);
-            return NULL;
-        }
-    } else if (fontpattern) {
-        if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-            fprintf(stderr, "error, cannot load font from pattern.\n");
-            return NULL;
-        }
-    } else {
-        die("no font specified.");
-    }
-
-    font = ecalloc(1, sizeof(Fnt));
-    font->xfont = xfont;
-    font->pattern = pattern;
-    font->h = xfont->ascent + xfont->descent;
-    font->dpy = drw->dpy;
-
-    return font;
+	Fnt *font;
+	XftFont *xfont = NULL;
+	FcPattern *pattern = NULL;
+
+	if (fontname) {
+		/* Using the pattern found at font->xfont->pattern does not yield the
+		 * same substitution results as using the pattern returned by
+		 * FcNameParse; using the latter results in the desired fallback
+		 * behaviour whereas the former just results in missing-character
+		 * rectangles being drawn, at least with some fonts. */
+		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
+			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
+			return NULL;
+		}
+		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
+			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
+			XftFontClose(drw->dpy, xfont);
+			return NULL;
+		}
+	} else if (fontpattern) {
+		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
+			fprintf(stderr, "error, cannot load font from pattern.\n");
+			return NULL;
+		}
+	} else {
+		die("no font specified.");
+	}
+
+	font = ecalloc(1, sizeof(Fnt));
+	font->xfont = xfont;
+	font->pattern = pattern;
+	font->h = xfont->ascent + xfont->descent;
+	font->dpy = drw->dpy;
+
+	return font;
 }
 
 static void
 xfont_free(Fnt *font)
 {
-    if (!font)
-        return;
-    if (font->pattern)
-        FcPatternDestroy(font->pattern);
-    XftFontClose(font->dpy, font->xfont);
-    free(font);
+	if (!font)
+		return;
+	if (font->pattern)
+		FcPatternDestroy(font->pattern);
+	XftFontClose(font->dpy, font->xfont);
+	free(font);
 }
 
 Fnt*
 drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
 {
-    Fnt *cur, *ret = NULL;
-    size_t i;
-
-    if (!drw || !fonts)
-        return NULL;
-
-    for (i = 1; i <= fontcount; i++) {
-        if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
-            cur->next = ret;
-            ret = cur;
-        }
-    }
-    return (drw->fonts = ret);
+	Fnt *cur, *ret = NULL;
+	size_t i;
+
+	if (!drw || !fonts)
+		return NULL;
+
+	for (i = 1; i <= fontcount; i++) {
+		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
+			cur->next = ret;
+			ret = cur;
+		}
+	}
+	return (drw->fonts = ret);
 }
 
 void
 drw_fontset_free(Fnt *font)
 {
-    if (font) {
-        drw_fontset_free(font->next);
-        xfont_free(font);
-    }
+	if (font) {
+		drw_fontset_free(font->next);
+		xfont_free(font);
+	}
 }
 
 void
 drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 {
-    if (!drw || !dest || !clrname)
-        return;
+	if (!drw || !dest || !clrname)
+		return;
 
-    if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
-                DefaultColormap(drw->dpy, drw->screen),
-                clrname, dest))
-        die("error, cannot allocate color '%s'", clrname);
+	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+	                       DefaultColormap(drw->dpy, drw->screen),
+	                       clrname, dest))
+		die("error, cannot allocate color '%s'", clrname);
 }
 
 /* Wrapper to create color schemes. The caller has to call free(3) on the
@@ -197,42 +183,42 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 Clr *
 drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
 {
-    size_t i;
-    Clr *ret;
+	size_t i;
+	Clr *ret;
 
-    /* need at least two colors for a scheme */
-    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
-        return NULL;
+	/* need at least two colors for a scheme */
+	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
+		return NULL;
 
-    for (i = 0; i < clrcount; i++)
-        drw_clr_create(drw, &ret[i], clrnames[i]);
-    return ret;
+	for (i = 0; i < clrcount; i++)
+		drw_clr_create(drw, &ret[i], clrnames[i]);
+	return ret;
 }
 
 void
 drw_setfontset(Drw *drw, Fnt *set)
 {
-    if (drw)
-        drw->fonts = set;
+	if (drw)
+		drw->fonts = set;
 }
 
 void
 drw_setscheme(Drw *drw, Clr *scm)
 {
-    if (drw)
-        drw->scheme = scm;
+	if (drw)
+		drw->scheme = scm;
 }
 
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
-    if (!drw || !drw->scheme)
-        return;
-    XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
-    if (filled)
-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-    else
-        XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
+	if (!drw || !drw->scheme)
+		return;
+	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
+	if (filled)
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+	else
+		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
 }
 
 int
@@ -240,101 +226,112 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 {
 	int ty, ellipsis_x = 0;
 	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len, hash, h0, h1;
-    XftDraw *d = NULL;
-    Fnt *usedfont, *curfont, *nextfont;
-    int utf8strlen, utf8charlen, render = x || y || w || h;
-    long utf8codepoint = 0;
-    const char *utf8str;
-    FcCharSet *fccharset;
-    FcPattern *fcpattern;
-    FcPattern *match;
-    XftResult result;
-    int charexists = 0, overflow = 0;
-    /* keep track of a couple codepoints for which we have no match. */
-    static unsigned int nomatches[128], ellipsis_width;
-
-    if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
-        return 0;
-
-    if (!render) {
-        w = invert ? invert : ~invert;
-    } else {
-        XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-        d = XftDrawCreate(drw->dpy, drw->drawable,
-                DefaultVisual(drw->dpy, drw->screen),
-                DefaultColormap(drw->dpy, drw->screen));
-        x += lpad;
-        w -= lpad;
-    }
-
-    usedfont = drw->fonts;
-    if (!ellipsis_width && render)
-        ellipsis_width = drw_fontset_getwidth(drw, "...");
-    while (1) {
-        ew = ellipsis_len = utf8strlen = 0;
-        utf8str = text;
-        nextfont = NULL;
-        while (*text) {
-            utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
-            for (curfont = drw->fonts; curfont; curfont = curfont->next) {
-                charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
-                if (charexists) {
-                    drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
-                    if (ew + ellipsis_width <= w) {
-                        /* keep track where the ellipsis still fits */
-                        ellipsis_x = x + ew;
-                        ellipsis_w = w - ew;
-                        ellipsis_len = utf8strlen;
-                    }
-
-                    if (ew + tmpw > w) {
-                        overflow = 1;
-                        /* called from drw_fontset_getwidth_clamp():
-                         * it wants the width AFTER the overflow
-                         */
-                        if (!render)
-                            x += tmpw;
-                        else
-                            utf8strlen = ellipsis_len;
-                    } else if (curfont == usedfont) {
-                        utf8strlen += utf8charlen;
-                        text += utf8charlen;
-                        ew += tmpw;
-                    } else {
-                        nextfont = curfont;
-                    }
-                    break;
-                }
-            }
-
-            if (overflow || !charexists || nextfont)
-                break;
-            else
-                charexists = 0;
-        }
-
-        if (utf8strlen) {
-            if (render) {
-                ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
-                XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
-                        usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
-            }
-            x += ew;
-            w -= ew;
-        }
-        if (render && overflow)
-            drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
-
-        if (!*text || overflow) {
-            break;
-        } else if (nextfont) {
-            charexists = 0;
-            usedfont = nextfont;
-        } else {
-            /* Regardless of whether or not a fallback font is found, the
-             * character must be drawn. */
-            charexists = 1;
+	XftDraw *d = NULL;
+	Fnt *usedfont, *curfont, *nextfont;
+	int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
+	long utf8codepoint = 0;
+	const char *utf8str;
+	FcCharSet *fccharset;
+	FcPattern *fcpattern;
+	FcPattern *match;
+	XftResult result;
+	int charexists = 0, overflow = 0;
+	/* keep track of a couple codepoints for which we have no match. */
+	static unsigned int nomatches[128], ellipsis_width, invalid_width;
+	static const char invalid[] = "";
+
+	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
+		return 0;
+
+	if (!render) {
+		w = invert ? invert : ~invert;
+	} else {
+		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+		if (w < lpad)
+			return x + w;
+		d = XftDrawCreate(drw->dpy, drw->drawable,
+		                  DefaultVisual(drw->dpy, drw->screen),
+		                  DefaultColormap(drw->dpy, drw->screen));
+		x += lpad;
+		w -= lpad;
+	}
+
+	usedfont = drw->fonts;
+	if (!ellipsis_width && render)
+		ellipsis_width = drw_fontset_getwidth(drw, "...");
+	if (!invalid_width && render)
+		invalid_width = drw_fontset_getwidth(drw, invalid);
+	while (1) {
+		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
+		utf8str = text;
+		nextfont = NULL;
+		while (*text) {
+			utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
+			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
+				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
+				if (charexists) {
+					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
+					if (ew + ellipsis_width <= w) {
+						/* keep track where the ellipsis still fits */
+						ellipsis_x = x + ew;
+						ellipsis_w = w - ew;
+						ellipsis_len = utf8strlen;
+					}
+
+					if (ew + tmpw > w) {
+						overflow = 1;
+						/* called from drw_fontset_getwidth_clamp():
+						 * it wants the width AFTER the overflow
+						 */
+						if (!render)
+							x += tmpw;
+						else
+							utf8strlen = ellipsis_len;
+					} else if (curfont == usedfont) {
+						text += utf8charlen;
+						utf8strlen += utf8err ? 0 : utf8charlen;
+						ew += utf8err ? 0 : tmpw;
+					} else {
+						nextfont = curfont;
+					}
+					break;
+				}
+			}
+
+			if (overflow || !charexists || nextfont || utf8err)
+				break;
+			else
+				charexists = 0;
+		}
+
+		if (utf8strlen) {
+			if (render) {
+				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
+				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
+				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
+			}
+			x += ew;
+			w -= ew;
+		}
+		if (utf8err && (!render || invalid_width < w)) {
+			if (render)
+				drw_text(drw, x, y, w, h, 0, invalid, invert);
+			x += invalid_width;
+			w -= invalid_width;
+		}
+		if (render && overflow)
+			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
+
+		if (!*text || overflow) {
+			break;
+		} else if (nextfont) {
+			charexists = 0;
+			usedfont = nextfont;
+		} else {
+			/* Regardless of whether or not a fallback font is found, the
+			 * character must be drawn. */
+			charexists = 1;
 
 			hash = (unsigned int)utf8codepoint;
 			hash = ((hash >> 16) ^ hash) * 0x21F0AAAD;
@@ -345,107 +342,107 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 			if (nomatches[h0] == utf8codepoint || nomatches[h1] == utf8codepoint)
 				goto no_match;
 
-            fccharset = FcCharSetCreate();
-            FcCharSetAddChar(fccharset, utf8codepoint);
-
-            if (!drw->fonts->pattern) {
-                /* Refer to the comment in xfont_create for more information. */
-                die("the first font in the cache must be loaded from a font string.");
-            }
-
-            fcpattern = FcPatternDuplicate(drw->fonts->pattern);
-            FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
-            FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
-
-            FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
-            FcDefaultSubstitute(fcpattern);
-            match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
-
-            FcCharSetDestroy(fccharset);
-            FcPatternDestroy(fcpattern);
-
-            if (match) {
-                usedfont = xfont_create(drw, NULL, match);
-                if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
-                    for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
-                        ; /* NOP */
-                    curfont->next = usedfont;
-                } else {
-                    xfont_free(usedfont);
-                    nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
+			fccharset = FcCharSetCreate();
+			FcCharSetAddChar(fccharset, utf8codepoint);
+
+			if (!drw->fonts->pattern) {
+				/* Refer to the comment in xfont_create for more information. */
+				die("the first font in the cache must be loaded from a font string.");
+			}
+
+			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
+			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
+			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
+
+			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
+			FcDefaultSubstitute(fcpattern);
+			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
+
+			FcCharSetDestroy(fccharset);
+			FcPatternDestroy(fcpattern);
+
+			if (match) {
+				usedfont = xfont_create(drw, NULL, match);
+				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
+					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
+						; /* NOP */
+					curfont->next = usedfont;
+				} else {
+					xfont_free(usedfont);
+					nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
 no_match:
-                    usedfont = drw->fonts;
-                }
-            }
-        }
-    }
-    if (d)
-        XftDrawDestroy(d);
-
-    return x + (render ? w : 0);
+					usedfont = drw->fonts;
+				}
+			}
+		}
+	}
+	if (d)
+		XftDrawDestroy(d);
+
+	return x + (render ? w : 0);
 }
 
 void
 drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 {
-    if (!drw)
-        return;
+	if (!drw)
+		return;
 
-    XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
-    XSync(drw->dpy, False);
+	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
+	XSync(drw->dpy, False);
 }
 
 unsigned int
 drw_fontset_getwidth(Drw *drw, const char *text)
 {
-    if (!drw || !drw->fonts || !text)
-        return 0;
-    return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+	if (!drw || !drw->fonts || !text)
+		return 0;
+	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
 }
 
 unsigned int
 drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
 {
-    unsigned int tmp = 0;
-    if (drw && drw->fonts && text && n)
-        tmp = drw_text(drw, 0, 0, 0, 0, 0, text, n);
-    return MIN(n, tmp);
+	unsigned int tmp = 0;
+	if (drw && drw->fonts && text && n)
+		tmp = drw_text(drw, 0, 0, 0, 0, 0, text, n);
+	return MIN(n, tmp);
 }
 
 void
 drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
 {
-    XGlyphInfo ext;
+	XGlyphInfo ext;
 
-    if (!font || !text)
-        return;
+	if (!font || !text)
+		return;
 
-    XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-    if (w)
-        *w = ext.xOff;
-    if (h)
-        *h = font->h;
+	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
+	if (w)
+		*w = ext.xOff;
+	if (h)
+		*h = font->h;
 }
 
 Cur *
 drw_cur_create(Drw *drw, int shape)
 {
-    Cur *cur;
+	Cur *cur;
 
-    if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
-        return NULL;
+	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
+		return NULL;
 
-    cur->cursor = XCreateFontCursor(drw->dpy, shape);
+	cur->cursor = XCreateFontCursor(drw->dpy, shape);
 
-    return cur;
+	return cur;
 }
 
 void
 drw_cur_free(Drw *drw, Cur *cursor)
 {
-    if (!cursor)
-        return;
+	if (!cursor)
+		return;
 
-    XFreeCursor(drw->dpy, cursor->cursor);
-    free(cursor);
+	XFreeCursor(drw->dpy, cursor->cursor);
+	free(cursor);
 }
diff --git a/drw.h b/drw.h
index 337ce66..fd7631b 100644
--- a/drw.h
+++ b/drw.h
@@ -1,29 +1,29 @@
 /* See LICENSE file for copyright and license details. */
 
 typedef struct {
-    Cursor cursor;
+	Cursor cursor;
 } Cur;
 
 typedef struct Fnt {
-    Display *dpy;
-    unsigned int h;
-    XftFont *xfont;
-    FcPattern *pattern;
-    struct Fnt *next;
+	Display *dpy;
+	unsigned int h;
+	XftFont *xfont;
+	FcPattern *pattern;
+	struct Fnt *next;
 } Fnt;
 
 enum { ColFg, ColBg }; /* Clr scheme index */
 typedef XftColor Clr;
 
 typedef struct {
-    unsigned int w, h;
-    Display *dpy;
-    int screen;
-    Window root;
-    Drawable drawable;
-    GC gc;
-    Clr *scheme;
-    Fnt *fonts;
+	unsigned int w, h;
+	Display *dpy;
+	int screen;
+	Window root;
+	Drawable drawable;
+	GC gc;
+	Clr *scheme;
+	Fnt *fonts;
 } Drw;
 
 /* Drawable abstraction */
diff --git a/stest.c b/stest.c
index 916c93b..e27d3a5 100644
--- a/stest.c
+++ b/stest.c
@@ -23,87 +23,87 @@ static struct stat old, new;
 static void
 test(const char *path, const char *name)
 {
-    struct stat st, ln;
+	struct stat st, ln;
 
-    if ((!stat(path, &st) && (FLAG('a') || name[0] != '.')                      /* hidden files      */
-                && (!FLAG('b') || S_ISBLK(st.st_mode))                          /* block special     */
-                && (!FLAG('c') || S_ISCHR(st.st_mode))                          /* character special */
-                && (!FLAG('d') || S_ISDIR(st.st_mode))                          /* directory         */
-                && (!FLAG('e') || access(path, F_OK) == 0)                      /* exists            */
-                && (!FLAG('f') || S_ISREG(st.st_mode))                          /* regular file      */
-                && (!FLAG('g') || st.st_mode & S_ISGID)                         /* set-group-id flag */
-                && (!FLAG('h') || (!lstat(path, &ln) && S_ISLNK(ln.st_mode)))   /* symbolic link     */
-                && (!FLAG('n') || st.st_mtime > new.st_mtime)                   /* newer than file   */
-                && (!FLAG('o') || st.st_mtime < old.st_mtime)                   /* older than file   */
-                && (!FLAG('p') || S_ISFIFO(st.st_mode))                         /* named pipe        */
-                && (!FLAG('r') || access(path, R_OK) == 0)                      /* readable          */
-                && (!FLAG('s') || st.st_size > 0)                               /* not empty         */
-                && (!FLAG('u') || st.st_mode & S_ISUID)                         /* set-user-id flag  */
-                && (!FLAG('w') || access(path, W_OK) == 0)                      /* writable          */
-                && (!FLAG('x') || access(path, X_OK) == 0)) != FLAG('v')) {     /* executable        */
-        if (FLAG('q'))
-            exit(0);
-        match = 1;
-        puts(name);
-    }
+	if ((!stat(path, &st) && (FLAG('a') || name[0] != '.')        /* hidden files      */
+	&& (!FLAG('b') || S_ISBLK(st.st_mode))                        /* block special     */
+	&& (!FLAG('c') || S_ISCHR(st.st_mode))                        /* character special */
+	&& (!FLAG('d') || S_ISDIR(st.st_mode))                        /* directory         */
+	&& (!FLAG('e') || access(path, F_OK) == 0)                    /* exists            */
+	&& (!FLAG('f') || S_ISREG(st.st_mode))                        /* regular file      */
+	&& (!FLAG('g') || st.st_mode & S_ISGID)                       /* set-group-id flag */
+	&& (!FLAG('h') || (!lstat(path, &ln) && S_ISLNK(ln.st_mode))) /* symbolic link     */
+	&& (!FLAG('n') || st.st_mtime > new.st_mtime)                 /* newer than file   */
+	&& (!FLAG('o') || st.st_mtime < old.st_mtime)                 /* older than file   */
+	&& (!FLAG('p') || S_ISFIFO(st.st_mode))                       /* named pipe        */
+	&& (!FLAG('r') || access(path, R_OK) == 0)                    /* readable          */
+	&& (!FLAG('s') || st.st_size > 0)                             /* not empty         */
+	&& (!FLAG('u') || st.st_mode & S_ISUID)                       /* set-user-id flag  */
+	&& (!FLAG('w') || access(path, W_OK) == 0)                    /* writable          */
+	&& (!FLAG('x') || access(path, X_OK) == 0)) != FLAG('v')) {   /* executable        */
+		if (FLAG('q'))
+			exit(0);
+		match = 1;
+		puts(name);
+	}
 }
 
 static void
 usage(void)
 {
-    fprintf(stderr, "usage: %s [-abcdefghlpqrsuvwx] "
-            "[-n file] [-o file] [file...]\n", argv0);
-    exit(2); /* like test(1) return > 1 on error */
+	fprintf(stderr, "usage: %s [-abcdefghlpqrsuvwx] "
+	        "[-n file] [-o file] [file...]\n", argv0);
+	exit(2); /* like test(1) return > 1 on error */
 }
 
 int
 main(int argc, char *argv[])
 {
-    struct dirent *d;
-    char path[PATH_MAX], *line = NULL, *file;
-    size_t linesiz = 0;
-    ssize_t n;
-    DIR *dir;
-    int r;
+	struct dirent *d;
+	char path[PATH_MAX], *line = NULL, *file;
+	size_t linesiz = 0;
+	ssize_t n;
+	DIR *dir;
+	int r;
 
-    ARGBEGIN {
-        case 'n': /* newer than file */
-        case 'o': /* older than file */
-            file = EARGF(usage());
-            if (!(FLAG(ARGC()) = !stat(file, (ARGC() == 'n' ? &new : &old))))
-                perror(file);
-            break;
-        default:
-            /* miscellaneous operators */
-            if (strchr("abcdefghlpqrsuvwx", ARGC()))
-                FLAG(ARGC()) = 1;
-            else
-                usage(); /* unknown flag */
-    } ARGEND;
+	ARGBEGIN {
+	case 'n': /* newer than file */
+	case 'o': /* older than file */
+		file = EARGF(usage());
+		if (!(FLAG(ARGC()) = !stat(file, (ARGC() == 'n' ? &new : &old))))
+			perror(file);
+		break;
+	default:
+		/* miscellaneous operators */
+		if (strchr("abcdefghlpqrsuvwx", ARGC()))
+			FLAG(ARGC()) = 1;
+		else
+			usage(); /* unknown flag */
+	} ARGEND;
 
-    if (!argc) {
-        /* read list from stdin */
-        while ((n = getline(&line, &linesiz, stdin)) > 0) {
-            if (line[n - 1] == '\n')
-                line[n - 1] = '\0';
-            test(line, line);
-        }
-        free(line);
-    } else {
-        for (; argc; argc--, argv++) {
-            if (FLAG('l') && (dir = opendir(*argv))) {
-                /* test directory contents */
-                while ((d = readdir(dir))) {
-                    r = snprintf(path, sizeof path, "%s/%s",
-                            *argv, d->d_name);
-                    if (r >= 0 && (size_t)r < sizeof path)
-                        test(path, d->d_name);
-                }
-                closedir(dir);
-            } else {
-                test(*argv, *argv);
-            }
-        }
-    }
-    return match ? 0 : 1;
+	if (!argc) {
+		/* read list from stdin */
+		while ((n = getline(&line, &linesiz, stdin)) > 0) {
+			if (line[n - 1] == '\n')
+				line[n - 1] = '\0';
+			test(line, line);
+		}
+		free(line);
+	} else {
+		for (; argc; argc--, argv++) {
+			if (FLAG('l') && (dir = opendir(*argv))) {
+				/* test directory contents */
+				while ((d = readdir(dir))) {
+					r = snprintf(path, sizeof path, "%s/%s",
+					             *argv, d->d_name);
+					if (r >= 0 && (size_t)r < sizeof path)
+						test(path, d->d_name);
+				}
+				closedir(dir);
+			} else {
+				test(*argv, *argv);
+			}
+		}
+	}
+	return match ? 0 : 1;
 }
diff --git a/util.c b/util.c
index 36afb58..8e26a51 100644
--- a/util.c
+++ b/util.c
@@ -1,4 +1,5 @@
 /* See LICENSE file for copyright and license details. */
+#include <errno.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -9,28 +10,28 @@
 void
 die(const char *fmt, ...)
 {
-    va_list ap;
+	va_list ap;
+	int saved_errno;
 
-    va_start(ap, fmt);
-    vfprintf(stderr, fmt, ap);
-    va_end(ap);
+	saved_errno = errno;
 
-    if (fmt[0] && fmt[strlen(fmt)-1] == ':') {
-        fputc(' ', stderr);
-        perror(NULL);
-    } else {
-        fputc('\n', stderr);
-    }
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
 
-    exit(1);
+	if (fmt[0] && fmt[strlen(fmt)-1] == ':')
+		fprintf(stderr, " %s", strerror(saved_errno));
+	fputc('\n', stderr);
+
+	exit(1);
 }
 
 void *
 ecalloc(size_t nmemb, size_t size)
 {
-    void *p;
+	void *p;
 
-    if (!(p = calloc(nmemb, size)))
-        die("calloc:");
-    return p;
+	if (!(p = calloc(nmemb, size)))
+		die("calloc:");
+	return p;
 }
