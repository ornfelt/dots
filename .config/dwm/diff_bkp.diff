diff --git a/LICENSE b/LICENSE
index 1e1b5a4..995172f 100644
--- a/LICENSE
+++ b/LICENSE
@@ -17,7 +17,7 @@ MIT/X Consortium License
 © 2015-2016 Quentin Rameau <quinq@fifth.space>
 © 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
 © 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
-© 2019-2020 Luke Smith <luke@lukesmith.xyz>
+© 2020-2022 Chris Down <chris@chrisdown.name>
 
 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
diff --git a/Makefile b/Makefile
index 63569d7..ffa69b4 100644
--- a/Makefile
+++ b/Makefile
@@ -13,16 +13,19 @@ all: dwm
 
 ${OBJ}: config.h config.mk
 
+config.h:
+	cp config.def.h $@
+
 dwm: ${OBJ}
 	${CC} -o $@ ${OBJ} ${LDFLAGS}
 
 clean:
-	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
+	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
 
 dist: clean
 	mkdir -p dwm-${VERSION}
-	cp -R LICENSE Makefile README config.mk\
-		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
+	cp -R LICENSE Makefile README config.def.h config.mk\
+		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
 	gzip dwm-${VERSION}.tar
 	rm -rf dwm-${VERSION}
@@ -34,7 +37,6 @@ install: all
 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
-	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
 
 uninstall:
 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
diff --git a/README b/README
index 482b545..95d4fd0 100644
--- a/README
+++ b/README
@@ -1,13 +1,5 @@
-See patches in dir 'patches'.
-
-I also continously add fixes from suckless git log:
-https://git.suckless.org/
-https://dwm.suckless.org/
-
-============================
 dwm - dynamic window manager
 ============================
-
 dwm is an extremely fast, small, and dynamic window manager for X.
 
 
diff --git a/config.h b/config.h
index 342750a..98fb30c 100644
--- a/config.h
+++ b/config.h
@@ -28,15 +28,16 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
 static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
 static int showbar              = 1;        /* 0 means no bar */
 static int topbar               = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
 /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
 /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
 static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
-static char normbgcolor[]       = "#222222";
-static char normbordercolor[]   = "#444444";
-static char normfgcolor[]       = "#bbbbbb";
-static char selfgcolor[]        = "#eeeeee";
-static char selbordercolor[]    = "#770000";
-static char selbgcolor[]        = "#005577";
+static char normbgcolor[]       = "#282828";
+static char normbordercolor[]   = "#282828";
+static char normfgcolor[]       = "#ebdbb2";
+static char selfgcolor[]        = "#ebdbb2";
+static char selbordercolor[]    = "#ebdbb2";
+static char selbgcolor[]        = "#282828";
 static const char col1[]        = "#98971a";
 static const char col21[]       = "#fb4934";
 static const char col22[]       = "#ebdbb2";
@@ -56,8 +57,10 @@ typedef struct {
     const char *name;
     const void *cmd;
 } Sp;
-const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
-const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
+//const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
+//const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
+const char *spcmd1[] = {"st", "-n", "spterm", "-e", "python3", NULL };
+const char *spcmd2[] = {"st", "-n", "spcalc", NULL };
 /* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
 static Sp scratchpads[] = {
     /* name          cmd  */
@@ -90,6 +93,7 @@ static const Rule rules[] = {
 static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
 static int nmaster     = 1;    /* number of clients in master area */
 static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+static const int refreshrate = 120;  /* refresh rate (per second) for client move/resize */
 
 #define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
 #include "vanitygaps.c"
@@ -127,8 +131,13 @@ static const Layout layouts[] = {
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
+#define STATUSBAR "dwmblocks"
+
 /* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
 static const char *termcmd[]  = { TERMINAL, NULL };
+//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
 
 /*
  * Xresources preferences to load at startup
@@ -157,7 +166,6 @@ ResourcePref resources[] = {
 };
 
 #include <X11/XF86keysym.h>
-#include "shiftview.c"
 
 static const Key keys[] = {
     /*  modifier                    key                 function            argument */
@@ -203,12 +211,12 @@ static const Key keys[] = {
         { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
         { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
         { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
-        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
-        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
+        { MODKEY1,                  XK_Tab,             shiftviewclients,          { .i = +1 } },
+        { MODKEY1|ShiftMask,        XK_Tab,             shiftviewclients,          { .i = -1 } },
         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
         /* { MODKEY,                   XK_Tab,             view,               {0} }, */
         { MODKEY,                   XK_q,               killclient,         {0} },
-        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
+        { MODKEY|ShiftMask,         XK_p,               togglebars,          {0} },
         { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
         { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
         { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
@@ -328,17 +336,19 @@ static const Key keys[] = {
         /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
 };
 
+#define STATUSBAR "dwmblocks"
+
 /* button definitions */
 /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
 static const Button buttons[] = {
     /* click                event mask      button          function        argument */
 #ifndef __OpenBSD__
-    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
-    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
-    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
-    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
-    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
-    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
+    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
 #endif
     { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
     { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
diff --git a/config.mk b/config.mk
index 1fc4bf1..93f9739 100644
--- a/config.mk
+++ b/config.mk
@@ -1,5 +1,5 @@
 # dwm version
-VERSION = 6.5
+VERSION = 6.6
 
 # Customize below to fit your system
 
@@ -19,10 +19,12 @@ FREETYPELIBS = -lfontconfig -lXft
 FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
 #FREETYPEINC = ${X11INC}/freetype2
+#MANPREFIX = ${PREFIX}/man
+#KVMLIB = -lkvm
 
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
 
 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
diff --git a/drw.c b/drw.c
index d43d8c2..fc0f6f9 100644
--- a/drw.c
+++ b/drw.c
@@ -13,7 +13,6 @@
 static int
 utf8decode(const char *s_in, long *u, int *err)
 {
-
 	static const unsigned char lens[] = {
 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
@@ -27,63 +26,63 @@ utf8decode(const char *s_in, long *u, int *err)
 
 	const unsigned char *s = (const unsigned char *)s_in;
 	int len = lens[*s >> 3];
-
-    *u = UTF_INVALID;
+	*u = UTF_INVALID;
 	*err = 1;
 	if (len == 0)
-        return 1;
+		return 1;
 
 	long cp = s[0] & leading_mask[len - 1];
 	for (int i = 1; i < len; ++i) {
 		if (s[i] == '\0' || (s[i] & 0xC0) != 0x80)
 			return i;
 		cp = (cp << 6) | (s[i] & 0x3F);
-    }
+	}
 	/* out of range, surrogate, overlong encoding */
 	if (cp > 0x10FFFF || (cp >> 11) == 0x1B || cp < overlong[len - 1])
 		return len;
 
 	*err = 0;
 	*u = cp;
-    return len;
+	return len;
 }
 
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
 {
-    Drw *drw = ecalloc(1, sizeof(Drw));
-
-    drw->dpy = dpy;
-    drw->screen = screen;
-    drw->root = root;
-    drw->w = w;
-    drw->h = h;
-    drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
-    drw->gc = XCreateGC(dpy, root, 0, NULL);
-    XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
-
-    return drw;
+	Drw *drw = ecalloc(1, sizeof(Drw));
+
+	drw->dpy = dpy;
+	drw->screen = screen;
+	drw->root = root;
+	drw->w = w;
+	drw->h = h;
+	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
+	drw->gc = XCreateGC(dpy, root, 0, NULL);
+	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
+
+	return drw;
 }
 
 void
 drw_resize(Drw *drw, unsigned int w, unsigned int h)
 {
-    if (!drw)
-        return;
-
-    drw->w = w;
-    drw->h = h;
-    if (drw->drawable)
-        XFreePixmap(drw->dpy, drw->drawable);
-    drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
+	if (!drw)
+		return;
+
+	drw->w = w;
+	drw->h = h;
+	if (drw->drawable)
+		XFreePixmap(drw->dpy, drw->drawable);
+	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
 }
 
 void
 drw_free(Drw *drw)
 {
-    XFreePixmap(drw->dpy, drw->drawable);
-    XFreeGC(drw->dpy, drw->gc);
-    free(drw);
+	XFreePixmap(drw->dpy, drw->drawable);
+	XFreeGC(drw->dpy, drw->gc);
+	drw_fontset_free(drw->fonts);
+	free(drw);
 }
 
 /* This function is an implementation detail. Library users should use
@@ -92,136 +91,159 @@ drw_free(Drw *drw)
 static Fnt *
 xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
 {
-    Fnt *font;
-    XftFont *xfont = NULL;
-    FcPattern *pattern = NULL;
-
-    if (fontname) {
-        /* Using the pattern found at font->xfont->pattern does not yield the
-         * same substitution results as using the pattern returned by
-         * FcNameParse; using the latter results in the desired fallback
-         * behaviour whereas the former just results in missing-character
-         * rectangles being drawn, at least with some fonts. */
-        if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-            fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
-            return NULL;
-        }
-        if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-            fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
-            XftFontClose(drw->dpy, xfont);
-            return NULL;
-        }
-    } else if (fontpattern) {
-        if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-            fprintf(stderr, "error, cannot load font from pattern.\n");
-            return NULL;
-        }
-    } else {
-        die("no font specified.");
-    }
-
-    font = ecalloc(1, sizeof(Fnt));
-    font->xfont = xfont;
-    font->pattern = pattern;
-    font->h = xfont->ascent + xfont->descent;
-    font->dpy = drw->dpy;
-
-    return font;
+	Fnt *font;
+	XftFont *xfont = NULL;
+	FcPattern *pattern = NULL;
+
+	if (fontname) {
+		/* Using the pattern found at font->xfont->pattern does not yield the
+		 * same substitution results as using the pattern returned by
+		 * FcNameParse; using the latter results in the desired fallback
+		 * behaviour whereas the former just results in missing-character
+		 * rectangles being drawn, at least with some fonts. */
+		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
+			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
+			return NULL;
+		}
+		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
+			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
+			XftFontClose(drw->dpy, xfont);
+			return NULL;
+		}
+	} else if (fontpattern) {
+		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
+			fprintf(stderr, "error, cannot load font from pattern.\n");
+			return NULL;
+		}
+	} else {
+		die("no font specified.");
+	}
+
+	font = ecalloc(1, sizeof(Fnt));
+	font->xfont = xfont;
+	font->pattern = pattern;
+	font->h = xfont->ascent + xfont->descent;
+	font->dpy = drw->dpy;
+
+	return font;
 }
 
 static void
 xfont_free(Fnt *font)
 {
-    if (!font)
-        return;
-    if (font->pattern)
-        FcPatternDestroy(font->pattern);
-    XftFontClose(font->dpy, font->xfont);
-    free(font);
+	if (!font)
+		return;
+	if (font->pattern)
+		FcPatternDestroy(font->pattern);
+	XftFontClose(font->dpy, font->xfont);
+	free(font);
 }
 
 Fnt*
 drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
 {
-    Fnt *cur, *ret = NULL;
-    size_t i;
-
-    if (!drw || !fonts)
-        return NULL;
-
-    for (i = 1; i <= fontcount; i++) {
-        if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
-            cur->next = ret;
-            ret = cur;
-        }
-    }
-    return (drw->fonts = ret);
+	Fnt *cur, *ret = NULL;
+	size_t i;
+
+	if (!drw || !fonts)
+		return NULL;
+
+	for (i = 1; i <= fontcount; i++) {
+		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
+			cur->next = ret;
+			ret = cur;
+		}
+	}
+	return (drw->fonts = ret);
 }
 
 void
 drw_fontset_free(Fnt *font)
 {
-    if (font) {
-        drw_fontset_free(font->next);
-        xfont_free(font);
-    }
+	if (font) {
+		drw_fontset_free(font->next);
+		xfont_free(font);
+	}
 }
 
 void
 drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 {
-    if (!drw || !dest || !clrname)
-        return;
+	if (!drw || !dest || !clrname)
+		return;
 
-    if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
-                DefaultColormap(drw->dpy, drw->screen),
-                clrname, dest))
-        die("error, cannot allocate color '%s'", clrname);
+	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+	                       DefaultColormap(drw->dpy, drw->screen),
+	                       clrname, dest))
+		die("error, cannot allocate color '%s'", clrname);
 
     dest->pixel |= 0xff << 24;
 }
 
-/* Wrapper to create color schemes. The caller has to call free(3) on the
- * returned color scheme when done using it. */
+/* Create color schemes. */
 Clr *
 drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
 {
-    size_t i;
-    Clr *ret;
+	size_t i;
+	Clr *ret;
 
-    /* need at least two colors for a scheme */
-    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
-        return NULL;
+	/* need at least two colors for a scheme */
+    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(Clr))))
+		return NULL;
 
-    for (i = 0; i < clrcount; i++)
-        drw_clr_create(drw, &ret[i], clrnames[i]);
-    return ret;
+	for (i = 0; i < clrcount; i++)
+		drw_clr_create(drw, &ret[i], clrnames[i]);
+	return ret;
+}
+
+void
+drw_clr_free(Drw *drw, Clr *c)
+{
+	if (!drw || !c)
+		return;
+
+	/* c is typedef XftColor Clr */
+	XftColorFree(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
+	             DefaultColormap(drw->dpy, drw->screen), c);
+}
+
+void
+drw_scm_free(Drw *drw, Clr *scm, size_t clrcount)
+{
+	size_t i;
+
+	if (!drw || !scm)
+		return;
+
+	for (i = 0; i < clrcount; i++)
+		drw_clr_free(drw, &scm[i]);
+    free(scm);
 }
 
 void
 drw_setfontset(Drw *drw, Fnt *set)
 {
-    if (drw)
-        drw->fonts = set;
+	if (drw)
+		drw->fonts = set;
 }
 
 void
 drw_setscheme(Drw *drw, Clr *scm)
 {
-    if (drw)
-        drw->scheme = scm;
+	if (drw)
+		drw->scheme = scm;
 }
 
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
-    if (!drw || !drw->scheme)
-        return;
-    XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
-    if (filled)
-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-    else
-        XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
+	if (!drw || !drw->scheme)
+		return;
+	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
+	if (filled)
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+	else
+		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
 }
 
 int
@@ -229,52 +251,51 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 {
 	int ty, ellipsis_x = 0;
 	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len, hash, h0, h1;
-    XftDraw *d = NULL;
-    Fnt *usedfont, *curfont, *nextfont;
-    int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
-    long utf8codepoint = 0;
-    const char *utf8str;
-    FcCharSet *fccharset;
-    FcPattern *fcpattern;
-    FcPattern *match;
-    XftResult result;
+	XftDraw *d = NULL;
+	Fnt *usedfont, *curfont, *nextfont;
+	int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
+	long utf8codepoint = 0;
+	const char *utf8str;
+	FcCharSet *fccharset;
+	FcPattern *fcpattern;
+	FcPattern *match;
+	XftResult result;
 	int charexists = 0, overflow = 0;
 	/* keep track of a couple codepoints for which we have no match. */
 	static unsigned int nomatches[128], ellipsis_width, invalid_width;
 	static const char invalid[] = "�";
 
-    if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
-        return 0;
+	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
+		return 0;
 
-    if (!render) {
-        w = invert ? invert : ~invert;
-    } else {
-        XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
-        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+	if (!render) {
+		w = invert ? invert : ~invert;
+	} else {
+		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 		if (w < lpad)
 			return x + w;
-        d = XftDrawCreate(drw->dpy, drw->drawable,
-                DefaultVisual(drw->dpy, drw->screen),
-                DefaultColormap(drw->dpy, drw->screen));
-        x += lpad;
-        w -= lpad;
-    }
-
-    usedfont = drw->fonts;
+		d = XftDrawCreate(drw->dpy, drw->drawable,
+		                  DefaultVisual(drw->dpy, drw->screen),
+		                  DefaultColormap(drw->dpy, drw->screen));
+		x += lpad;
+		w -= lpad;
+	}
+
+	usedfont = drw->fonts;
 	if (!ellipsis_width && render)
 		ellipsis_width = drw_fontset_getwidth(drw, "...");
 	if (!invalid_width && render)
 		invalid_width = drw_fontset_getwidth(drw, invalid);
-    while (1) {
-        utf8strlen = 0;
-        ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
-        utf8str = text;
-        nextfont = NULL;
-        while (*text) {
-            utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
-            for (curfont = drw->fonts; curfont; curfont = curfont->next) {
-                charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
-                if (charexists) {
+	while (1) {
+		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
+		utf8str = text;
+		nextfont = NULL;
+		while (*text) {
+			utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
+			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
+				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
+				if (charexists) {
 					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
 					if (ew + ellipsis_width <= w) {
 						/* keep track where the ellipsis still fits */
@@ -293,31 +314,31 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 						else
 							utf8strlen = ellipsis_len;
 					} else if (curfont == usedfont) {
-                        text += utf8charlen;
+						text += utf8charlen;
 						utf8strlen += utf8err ? 0 : utf8charlen;
 						ew += utf8err ? 0 : tmpw;
-                    } else {
-                        nextfont = curfont;
-                    }
-                    break;
-                }
-            }
-
-            if (overflow || !charexists || nextfont || utf8err)
-                break;
-            else
-                charexists = 0;
-        }
-
-        if (utf8strlen) {
+					} else {
+						nextfont = curfont;
+					}
+					break;
+				}
+			}
+
+			if (overflow || !charexists || nextfont || utf8err)
+				break;
+			else
+				charexists = 0;
+		}
+
+		if (utf8strlen) {
 			if (render) {
 				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
 				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
 				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
-            }
+			}
 			x += ew;
 			w -= ew;
-        }
+		}
 		if (utf8err && (!render || invalid_width < w)) {
 			if (render)
 				drw_text(drw, x, y, w, h, 0, invalid, invert);
@@ -327,15 +348,15 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 		if (render && overflow)
 			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
 
-        if (!*text || overflow) {
-            break;
-        } else if (nextfont) {
-            charexists = 0;
-            usedfont = nextfont;
-        } else {
-            /* Regardless of whether or not a fallback font is found, the
-             * character must be drawn. */
-            charexists = 1;
+		if (!*text || overflow) {
+			break;
+		} else if (nextfont) {
+			charexists = 0;
+			usedfont = nextfont;
+		} else {
+			/* Regardless of whether or not a fallback font is found, the
+			 * character must be drawn. */
+			charexists = 1;
 
 			hash = (unsigned int)utf8codepoint;
 			hash = ((hash >> 16) ^ hash) * 0x21F0AAAD;
@@ -346,63 +367,62 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 			if (nomatches[h0] == utf8codepoint || nomatches[h1] == utf8codepoint)
 				goto no_match;
 
-            fccharset = FcCharSetCreate();
-            FcCharSetAddChar(fccharset, utf8codepoint);
-
-            if (!drw->fonts->pattern) {
-                /* Refer to the comment in xfont_create for more information. */
-                die("the first font in the cache must be loaded from a font string.");
-            }
-
-            fcpattern = FcPatternDuplicate(drw->fonts->pattern);
-            FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
-            FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
-            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
-
-            FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
-            FcDefaultSubstitute(fcpattern);
-            match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
-
-            FcCharSetDestroy(fccharset);
-            FcPatternDestroy(fcpattern);
-
-            if (match) {
-                usedfont = xfont_create(drw, NULL, match);
-                if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
-                    for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
-                        ; /* NOP */
-                    curfont->next = usedfont;
-                } else {
-                    xfont_free(usedfont);
-                    nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
+			fccharset = FcCharSetCreate();
+			FcCharSetAddChar(fccharset, utf8codepoint);
+
+			if (!drw->fonts->pattern) {
+				/* Refer to the comment in xfont_create for more information. */
+				die("the first font in the cache must be loaded from a font string.");
+			}
+
+			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
+			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
+			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
+
+			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
+			FcDefaultSubstitute(fcpattern);
+			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
+
+			FcCharSetDestroy(fccharset);
+			FcPatternDestroy(fcpattern);
+
+			if (match) {
+				usedfont = xfont_create(drw, NULL, match);
+				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
+					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
+						; /* NOP */
+					curfont->next = usedfont;
+				} else {
+					xfont_free(usedfont);
+					nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
 no_match:
-                    usedfont = drw->fonts;
-                }
-            }
-        }
-    }
-    if (d)
-        XftDrawDestroy(d);
-
-    return x + (render ? w : 0);
+					usedfont = drw->fonts;
+				}
+			}
+		}
+	}
+	if (d)
+		XftDrawDestroy(d);
+
+	return x + (render ? w : 0);
 }
 
 void
 drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 {
-    if (!drw)
-        return;
+	if (!drw)
+		return;
 
-    XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
-    XSync(drw->dpy, False);
+	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
+	XSync(drw->dpy, False);
 }
 
 unsigned int
 drw_fontset_getwidth(Drw *drw, const char *text)
 {
-    if (!drw || !drw->fonts || !text)
-        return 0;
-    return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+	if (!drw || !drw->fonts || !text)
+		return 0;
+	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
 }
 
 unsigned int
@@ -417,37 +437,37 @@ drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
 void
 drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
 {
-    XGlyphInfo ext;
+	XGlyphInfo ext;
 
-    if (!font || !text)
-        return;
+	if (!font || !text)
+		return;
 
-    XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-    if (w)
-        *w = ext.xOff;
-    if (h)
-        *h = font->h;
+	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
+	if (w)
+		*w = ext.xOff;
+	if (h)
+		*h = font->h;
 }
 
 Cur *
 drw_cur_create(Drw *drw, int shape)
 {
-    Cur *cur;
+	Cur *cur;
 
-    if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
-        return NULL;
+	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
+		return NULL;
 
-    cur->cursor = XCreateFontCursor(drw->dpy, shape);
+	cur->cursor = XCreateFontCursor(drw->dpy, shape);
 
-    return cur;
+	return cur;
 }
 
 void
 drw_cur_free(Drw *drw, Cur *cursor)
 {
-    if (!cursor)
-        return;
+	if (!cursor)
+		return;
 
-    XFreeCursor(drw->dpy, cursor->cursor);
-    free(cursor);
+	XFreeCursor(drw->dpy, cursor->cursor);
+	free(cursor);
 }
diff --git a/drw.h b/drw.h
index ea76849..fbfec02 100644
--- a/drw.h
+++ b/drw.h
@@ -1,29 +1,29 @@
 /* See LICENSE file for copyright and license details. */
 
 typedef struct {
-    Cursor cursor;
+	Cursor cursor;
 } Cur;
 
 typedef struct Fnt {
-    Display *dpy;
-    unsigned int h;
-    XftFont *xfont;
-    FcPattern *pattern;
-    struct Fnt *next;
+	Display *dpy;
+	unsigned int h;
+	XftFont *xfont;
+	FcPattern *pattern;
+	struct Fnt *next;
 } Fnt;
 
 enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
 typedef XftColor Clr;
 
 typedef struct {
-    unsigned int w, h;
-    Display *dpy;
-    int screen;
-    Window root;
-    Drawable drawable;
-    GC gc;
-    Clr *scheme;
-    Fnt *fonts;
+	unsigned int w, h;
+	Display *dpy;
+	int screen;
+	Window root;
+	Drawable drawable;
+	GC gc;
+	Clr *scheme;
+	Fnt *fonts;
 } Drw;
 
 /* Drawable abstraction */
@@ -40,7 +40,9 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
 
 /* Colorscheme abstraction */
 void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+void drw_clr_free(Drw *drw, Clr *c);
 Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+void drw_scm_free(Drw *drw, Clr *scm, size_t clrcount);
 
 /* Cursor abstraction */
 Cur *drw_cur_create(Drw *drw, int shape);
diff --git a/dwm.1 b/dwm.1
index 7feba78..d04bec6 100644
--- a/dwm.1
+++ b/dwm.1
@@ -1,16 +1,21 @@
 .TH DWM 1 dwm\-VERSION
 .SH NAME
-dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
+dwm \- dynamic window manager
 .SH SYNOPSIS
 .B dwm
 .RB [ \-v ]
 .SH DESCRIPTION
-dwm is a dynamic window manager for X.
+dwm is a dynamic window manager for X. It manages windows in tiled, monocle
+and floating layouts. Either layout can be applied dynamically, optimising the
+environment for the application in use and the task performed.
 .P
-dwm "orders" windows based on recency and primacy, while dwm layouts may
-change, the most recent "master" window is shown in the most prominent
-position. There are bindings for cycling through and promoting windows to the
-master position.
+In tiled layouts windows are managed in a master and stacking area. The master
+area on the left contains one window by default, and the stacking area on the
+right contains all other windows. The number of master area windows can be
+adjusted from zero to an arbitrary number. In monocle layout all windows are
+maximised to the screen size. In floating layout windows can be resized and
+moved freely. Dialog windows are always managed floating, regardless of the
+layout applied.
 .P
 Windows are grouped by tags. Each window can be tagged with one or multiple
 tags. Selecting certain tags displays all windows with these tags.
@@ -26,18 +31,17 @@ indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
 .P
-.I
-libxft-bgra
-should be installed for this build of dwm. Arch users may install it via the
-AUR. Color characters and emoji are enabled, but these will cause crashes
-without the fix
-.I
-libxft-bgra
-offers.
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
-prints version information to standard output, then exits.
+prints version information to stderr, then exits.
 .SH USAGE
 .SS Status bar
 .TP
@@ -46,142 +50,118 @@ is read and displayed in the status text area. It can be set with the
 .BR xsetroot (1)
 command.
 .TP
-.B Left click
+.B Button1
 click on a tag label to display all windows with that tag, click on the layout
 label toggles between tiled and floating layout.
 .TP
-.B Right click
+.B Button3
 click on a tag label adds/removes all windows with that tag to/from the view.
 .TP
-.B Super\-Left click
+.B Mod1\-Button1
 click on a tag label applies that tag to the focused window.
 .TP
-.B Super\-Right click
+.B Mod1\-Button3
 click on a tag label adds/removes that tag to/from the focused window.
 .SS Keyboard commands
 .TP
-.B Super\-Return
-Start terminal,
+.B Mod1\-Shift\-Return
+Start
 .BR st(1).
 .TP
-.B Super\-d
+.B Mod1\-p
 Spawn
 .BR dmenu(1)
 for launching other programs.
 .TP
-.B Super\-b
-Toggles bar on and off.
+.B Mod1\-,
+Focus previous screen, if any.
 .TP
-.B Super\-q
-Close focused window.
+.B Mod1\-.
+Focus next screen, if any.
 .TP
-.B Super\-t/T
-Sets tiled/bstack layouts.
+.B Mod1\-Shift\-,
+Send focused window to previous screen, if any.
 .TP
-.B Super\-f
-Toggle fullscreen window.
+.B Mod1\-Shift\-.
+Send focused window to next screen, if any.
 .TP
-.B Super\-F
-Toggle floating layout.
+.B Mod1\-b
+Toggles bar on and off.
+.TP
+.B Mod1\-t
+Sets tiled layout.
 .TP
-.B Super\-y/Y
-Sets Fibonacci spiral/dwinde layouts.
+.B Mod1\-f
+Sets floating layout.
 .TP
-.B Super\-u/U
-Sets centered master layout.
+.B Mod1\-m
+Sets monocle layout.
 .TP
-.B Super\-i/I
-Sets centered master or floating master layouts.
+.B Mod1\-space
+Toggles between current and previous layout.
 .TP
-.B Super\-space
-Zooms/cycles focused window to/from master area.
+.B Mod1\-j
+Focus next window.
 .TP
-.B Super\-j/k
-Focus next/previous window.
+.B Mod1\-k
+Focus previous window.
 .TP
-.B Super\-Shift\-j/k
-Move selected window down/up in stack.
+.B Mod1\-i
+Increase number of windows in master area.
 .TP
-.B Super\-o/O
-Increase/decrease number of windows in master area.
+.B Mod1\-d
+Decrease number of windows in master area.
 .TP
-.B Super\-l
+.B Mod1\-l
 Increase master area size.
 .TP
-.B Super\-h
+.B Mod1\-h
 Decrease master area size.
 .TP
-.B Super\-Shift\-space
-Toggle focused window between tiled and floating state.
-.TP
-.B Super\-Tab
-Toggles to the previously selected tags.
-.TP
-.B Super\-g
-Moves to the previous tag.
-.TP
-.B Super\-Shift\-g
-Moves selected window to the previous tag.
-.TP
-.B Super\-;
-Moves to the next tag.
+.B Mod1\-Return
+Zooms/cycles focused window to/from master area (tiled layouts only).
 .TP
-.B Super\-Shift\-;
-Moves selected window to the next tag.
-.TP
-.B Super\-PageUp
-Moves to the previous tag.
-.TP
-.B Super\-Shift\-PageUp
-Moves selected window to the previous tag.
-.TP
-.B Super\-Pagedown
-Moves to the next tag.
-.TP
-.B Super\-Shift\-PageDown
-Moves selected window to the next tag.
+.B Mod1\-Shift\-c
+Close focused window.
 .TP
-.B Super\-a
-Toggle gaps.
+.B Mod1\-Shift\-f
+Toggle fullscreen for focused window.
 .TP
-.B Super\-z
-Increase gaps between windows.
+.B Mod1\-Shift\-space
+Toggle focused window between tiled and floating state.
 .TP
-.B Super\-x
-Decrease gaps between windows.
+.B Mod1\-Tab
+Toggles to the previously selected tags.
 .TP
-.B Super\-Shift\-[1..n]
+.B Mod1\-Shift\-[1..n]
 Apply nth tag to focused window.
 .TP
-.B Super\-Shift\-0
+.B Mod1\-Shift\-0
 Apply all tags to focused window.
 .TP
-.B Super\-Control\-Shift\-[1..n]
+.B Mod1\-Control\-Shift\-[1..n]
 Add/remove nth tag to/from focused window.
 .TP
-.B Super\-[1..n]
+.B Mod1\-[1..n]
 View all windows with nth tag.
 .TP
-.B Super\-0
+.B Mod1\-0
 View all windows with any tag.
 .TP
-.B Super\-Control\-[1..n]
+.B Mod1\-Control\-[1..n]
 Add/remove all windows with nth tag to/from the view.
 .TP
-.B Super\-Shift\-q
+.B Mod1\-Shift\-q
 Quit dwm.
-.TP
-.B Mod1\-Control\-Shift\-q
-Menu to refresh/quit/reboot/shutdown.
 .SS Mouse commands
 .TP
-.B Super\-Left click
+.B Mod1\-Button1
 Move focused window while dragging. Tiled windows will be toggled to the floating state.
 .TP
-.B Super\-Middle click
+.B Mod1\-Button2
 Toggles focused window between floating and tiled state.
 .TP
-.B Super\-Right click
+.B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
 .SH FILES
 The files containing programs to be started along with dwm are searched for in
@@ -201,13 +181,6 @@ This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
-.SH SIGNALS
-.TP
-.B SIGHUP - 1
-Restart the dwm process.
-.TP
-.B SIGTERM - 15
-Cleanly terminate the dwm process.
 .SH SEE ALSO
 .BR dmenu (1),
 .BR st (1)
diff --git a/dwm.c b/dwm.c
index 9086e16..c1962e8 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -43,6 +44,10 @@
 #include <X11/Xft/Xft.h>
 #include <X11/Xlib-xcb.h>
 #include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
 
 #include "drw.h"
 #include "util.h"
@@ -53,18 +58,18 @@
 #define GETINC(X)               ((X) - 2000)
 #define INC(X)                  ((X) + 2000)
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
-        * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
 #define ISINC(X)                ((X) > 1000 && (X) < 3000)
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
 #define PREVSEL                 3000
-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
-#define TAGMASK			((1 << NUMTAGS) - 1)
-#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
-#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+#define TAGMASK     			((1 << NUMTAGS) - 1)
+#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
 #define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
 
@@ -72,106 +77,107 @@
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
 enum { SchemeNorm, SchemeSel }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
-    NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
+       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
-    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
-    int i;
-    unsigned int ui;
-    float f;
-    const void *v;
+	int i;
+	unsigned int ui;
+	float f;
+	const void *v;
 } Arg;
 
 typedef struct {
-    unsigned int click;
-    unsigned int mask;
-    unsigned int button;
-    void (*func)(const Arg *arg);
-    const Arg arg;
+	unsigned int click;
+	unsigned int mask;
+	unsigned int button;
+	void (*func)(const Arg *arg);
+	const Arg arg;
 } Button;
 
 typedef struct Monitor Monitor;
 typedef struct Client Client;
 struct Client {
-    char name[256];
-    float mina, maxa;
-    int x, y, w, h;
-    int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
-    int oldx, oldy, oldw, oldh;
-    int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
-    int bw, oldbw;
-    unsigned int tags;
-    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
+	char name[256];
+	float mina, maxa;
+	float cfact;
+	int x, y, w, h;
+	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
+	int oldx, oldy, oldw, oldh;
+	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+	int bw, oldbw;
+	unsigned int tags;
+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
     pid_t pid;
-    Client *next;
-    Client *snext;
+	Client *next;
+	Client *snext;
     Client *swallowing;
-    Monitor *mon;
-    Window win;
+	Monitor *mon;
+	Window win;
 };
 
 typedef struct {
-    unsigned int mod;
-    KeySym keysym;
-    void (*func)(const Arg *);
-    const Arg arg;
+	unsigned int mod;
+	KeySym keysym;
+	void (*func)(const Arg *);
+	const Arg arg;
 } Key;
 
 typedef struct {
-    const char *symbol;
-    void (*arrange)(Monitor *);
+	const char *symbol;
+	void (*arrange)(Monitor *);
 } Layout;
 
 struct Monitor {
-    char ltsymbol[16];
-    float mfact;
-    int nmaster;
-    int num;
-    int by;               /* bar geometry */
-    int mx, my, mw, mh;   /* screen size */
-    int wx, wy, ww, wh;   /* window area  */
-    int gappih;           /* horizontal gap between windows */
-    int gappiv;           /* vertical gap between windows */
-    int gappoh;           /* horizontal outer gaps */
-    int gappov;           /* vertical outer gaps */
-    unsigned int seltags;
-    unsigned int sellt;
-    unsigned int tagset[2];
-    int showbar;
-    int topbar;
-    Client *clients;
-    Client *sel;
-    Client *stack;
-    Monitor *next;
-    Window barwin;
-    const Layout *lt[2];
+	char ltsymbol[16];
+	float mfact;
+	int nmaster;
+	int num;
+	int by;               /* bar geometry */
+	int mx, my, mw, mh;   /* screen size */
+	int wx, wy, ww, wh;   /* window area  */
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
+	unsigned int seltags;
+	unsigned int sellt;
+	unsigned int tagset[2];
+	int showbar;
+	int topbar;
+	Client *clients;
+	Client *sel;
+	Client *stack;
+	Monitor *next;
+	Window barwin;
+	const Layout *lt[2];
 };
 
 typedef struct {
-    const char *class;
-    const char *instance;
-    const char *title;
-    unsigned int tags;
-    int isfloating;
-    int isterminal;
-    int noswallow;
-    int monitor;
+	const char *class;
+	const char *instance;
+	const char *title;
+	unsigned int tags;
+	int isfloating;
+	int isterminal;
+	int noswallow;
+	int monitor;
 } Rule;
 
 /* Xresources preferences */
 enum resource_type {
-    STRING = 0,
-    INTEGER = 1,
-    FLOAT = 2
+	STRING = 0,
+	INTEGER = 1,
+	FLOAT = 2
 };
 
 typedef struct {
-    char *name;
-    enum resource_type type;
-    void *dst;
+	char *name;
+	enum resource_type type;
+	void *dst;
 } ResourcePref;
 
 /* function declarations */
@@ -189,12 +195,12 @@ static void clientmessage(XEvent *e);
 static void configure(Client *c);
 static void configurenotify(XEvent *e);
 static void configurerequest(XEvent *e);
-static void copyvalidchars(char *text, char *rawtext);
 static Monitor *createmon(void);
 static void destroynotify(XEvent *e);
 static void detach(Client *c);
 static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
+static Monitor *numtomon(int num);
 static void drawbar(Monitor *m);
 static void drawbars(void);
 static int drawstatusbar(Monitor *m, int bh, char* text);
@@ -202,10 +208,12 @@ static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
+static void focusnthmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
 static long getstate(Window w);
+static pid_t getstatusbarpid();
 static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
@@ -216,7 +224,6 @@ static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
 static void monocle(Monitor *m);
-static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *c);
@@ -229,7 +236,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
-static void runAutostart(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
@@ -237,24 +244,34 @@ static void sendmonview(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
+static void setsticky(Client *c, int sticky);
 static void setlayout(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shifttag(const Arg *arg);
+static void shifttagclients(const Arg *arg);
+static void shiftview(const Arg *arg);
+static void shiftviewclients(const Arg *arg);
+static void shiftboth(const Arg *arg);
+static void swaptags(const Arg *arg);
+static void shiftswaptags(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void showhide(Client *c);
-#ifndef __OpenBSD__
-static int getdwmblockspid();
-static void sigdwmblocks(const Arg *arg);
-#endif
-static void sighup(int unused);
-static void sigterm(int unused);
+static void sigstatusbar(const Arg *arg);
 static void spawn(const Arg *arg);
 static int stackpos(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagview(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tagmonview(const Arg *arg);
+static void tagnextmon(const Arg *arg);
+static void tagnewmon(const Arg *arg);
+static void tagnthmon(const Arg *arg);
+static void tagnthmonview(const Arg *arg);
 static void togglebar(const Arg *arg);
+static void togglebars(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void togglescratch(const Arg *arg);
 static void togglesticky(const Arg *arg);
@@ -291,12 +308,15 @@ static Client *termforwin(const Client *c);
 static pid_t winpid(Window w);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
-static char stext[256];
-/* static char stext[1024]; */
-static char rawstext[256];
-static int dwmblockssig;
-pid_t dwmblockspid = 0;
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
+static int statussig;
+static int statusw;
+static pid_t statuspid = -1;
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
@@ -304,22 +324,20 @@ static int lrpad;            /* sum of left and right padding for text */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
-    [ButtonPress] = buttonpress,
-    [ClientMessage] = clientmessage,
-    [ConfigureRequest] = configurerequest,
-    [ConfigureNotify] = configurenotify,
-    [DestroyNotify] = destroynotify,
-    [Expose] = expose,
-    [FocusIn] = focusin,
-    [KeyPress] = keypress,
-    [MappingNotify] = mappingnotify,
-    [MapRequest] = maprequest,
-    [MotionNotify] = motionnotify,
-    [PropertyNotify] = propertynotify,
-    [UnmapNotify] = unmapnotify
+	[ButtonPress] = buttonpress,
+	[ClientMessage] = clientmessage,
+	[ConfigureRequest] = configurerequest,
+	[ConfigureNotify] = configurenotify,
+	[DestroyNotify] = destroynotify,
+	[Expose] = expose,
+	[FocusIn] = focusin,
+	[KeyPress] = keypress,
+	[MappingNotify] = mappingnotify,
+	[MapRequest] = maprequest,
+	[PropertyNotify] = propertynotify,
+	[UnmapNotify] = unmapnotify
 };
 static Atom wmatom[WMLast], netatom[NetLast];
-static int restart = 0;
 static int running = 1;
 static Cur *cursor[CurLast];
 static Clr **scheme;
@@ -340,528 +358,529 @@ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 void
 applyrules(Client *c)
 {
-    const char *class, *instance;
-    unsigned int i;
-    const Rule *r;
-    Monitor *m;
-    XClassHint ch = { NULL, NULL };
-
-    /* rule matching */
-    c->isfloating = 0;
-    c->tags = 0;
-    XGetClassHint(dpy, c->win, &ch);
-    class    = ch.res_class ? ch.res_class : broken;
-    instance = ch.res_name  ? ch.res_name  : broken;
-
-    for (i = 0; i < LENGTH(rules); i++) {
-        r = &rules[i];
-        if ((!r->title || strstr(c->name, r->title))
-                && (!r->class || strstr(class, r->class))
-                && (!r->instance || strstr(instance, r->instance)))
-        {
-            c->isterminal = r->isterminal;
-            c->isfloating = r->isfloating;
-            c->noswallow  = r->noswallow;
-            c->tags |= r->tags;
-            if ((r->tags & SPTAGMASK) && r->isfloating) {
-                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
-            }
-
-            for (m = mons; m && m->num != r->monitor; m = m->next);
-            if (m)
-                c->mon = m;
-        }
-    }
-    if (ch.res_class)
-        XFree(ch.res_class);
-    if (ch.res_name)
-        XFree(ch.res_name);
-    c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+	const char *class, *instance;
+	unsigned int i;
+	const Rule *r;
+	Monitor *m;
+	XClassHint ch = { NULL, NULL };
+
+	/* rule matching */
+	c->isfloating = 0;
+	c->tags = 0;
+	XGetClassHint(dpy, c->win, &ch);
+	class    = ch.res_class ? ch.res_class : broken;
+	instance = ch.res_name  ? ch.res_name  : broken;
+
+	for (i = 0; i < LENGTH(rules); i++) {
+		r = &rules[i];
+		if ((!r->title || strstr(c->name, r->title))
+		&& (!r->class || strstr(class, r->class))
+		&& (!r->instance || strstr(instance, r->instance)))
+		{
+			c->isterminal = r->isterminal;
+			c->noswallow  = r->noswallow;
+			c->isfloating = r->isfloating;
+			c->tags |= r->tags;
+			if ((r->tags & SPTAGMASK) && r->isfloating) {
+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+			}
+
+			for (m = mons; m && m->num != r->monitor; m = m->next);
+			if (m)
+				c->mon = m;
+		}
+	}
+	if (ch.res_class)
+		XFree(ch.res_class);
+	if (ch.res_name)
+		XFree(ch.res_name);
+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
 }
 
 int
 applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
 {
-    int baseismin;
-    Monitor *m = c->mon;
-
-    /* set minimum possible */
-    *w = MAX(1, *w);
-    *h = MAX(1, *h);
-    if (interact) {
-        if (*x > sw)
-            *x = sw - WIDTH(c);
-        if (*y > sh)
-            *y = sh - HEIGHT(c);
-        if (*x + *w + 2 * c->bw < 0)
-            *x = 0;
-        if (*y + *h + 2 * c->bw < 0)
-            *y = 0;
-    } else {
-        if (*x >= m->wx + m->ww)
-            *x = m->wx + m->ww - WIDTH(c);
-        if (*y >= m->wy + m->wh)
-            *y = m->wy + m->wh - HEIGHT(c);
-        if (*x + *w + 2 * c->bw <= m->wx)
-            *x = m->wx;
-        if (*y + *h + 2 * c->bw <= m->wy)
-            *y = m->wy;
-    }
-    if (*h < bh)
-        *h = bh;
-    if (*w < bh)
-        *w = bh;
-    if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
-        if (!c->hintsvalid)
-            updatesizehints(c);
-        /* see last two sentences in ICCCM 4.1.2.3 */
-        baseismin = c->basew == c->minw && c->baseh == c->minh;
-        if (!baseismin) { /* temporarily remove base dimensions */
-            *w -= c->basew;
-            *h -= c->baseh;
-        }
-        /* adjust for aspect limits */
-        if (c->mina > 0 && c->maxa > 0) {
-            if (c->maxa < (float)*w / *h)
-                *w = *h * c->maxa + 0.5;
-            else if (c->mina < (float)*h / *w)
-                *h = *w * c->mina + 0.5;
-        }
-        if (baseismin) { /* increment calculation requires this */
-            *w -= c->basew;
-            *h -= c->baseh;
-        }
-        /* adjust for increment value */
-        if (c->incw)
-            *w -= *w % c->incw;
-        if (c->inch)
-            *h -= *h % c->inch;
-        /* restore base dimensions */
-        *w = MAX(*w + c->basew, c->minw);
-        *h = MAX(*h + c->baseh, c->minh);
-        if (c->maxw)
-            *w = MIN(*w, c->maxw);
-        if (c->maxh)
-            *h = MIN(*h, c->maxh);
-    }
-    return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
+	int baseismin;
+	Monitor *m = c->mon;
+
+	/* set minimum possible */
+	*w = MAX(1, *w);
+	*h = MAX(1, *h);
+	if (interact) {
+		if (*x > sw)
+			*x = sw - WIDTH(c);
+		if (*y > sh)
+			*y = sh - HEIGHT(c);
+		if (*x + *w + 2 * c->bw < 0)
+			*x = 0;
+		if (*y + *h + 2 * c->bw < 0)
+			*y = 0;
+	} else {
+		if (*x >= m->wx + m->ww)
+			*x = m->wx + m->ww - WIDTH(c);
+		if (*y >= m->wy + m->wh)
+			*y = m->wy + m->wh - HEIGHT(c);
+		if (*x + *w + 2 * c->bw <= m->wx)
+			*x = m->wx;
+		if (*y + *h + 2 * c->bw <= m->wy)
+			*y = m->wy;
+	}
+	if (*h < bh)
+		*h = bh;
+	if (*w < bh)
+		*w = bh;
+	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
+		if (!c->hintsvalid)
+			updatesizehints(c);
+		/* see last two sentences in ICCCM 4.1.2.3 */
+		baseismin = c->basew == c->minw && c->baseh == c->minh;
+		if (!baseismin) { /* temporarily remove base dimensions */
+			*w -= c->basew;
+			*h -= c->baseh;
+		}
+		/* adjust for aspect limits */
+		if (c->mina > 0 && c->maxa > 0) {
+			if (c->maxa < (float)*w / *h)
+				*w = *h * c->maxa + 0.5;
+			else if (c->mina < (float)*h / *w)
+				*h = *w * c->mina + 0.5;
+		}
+		if (baseismin) { /* increment calculation requires this */
+			*w -= c->basew;
+			*h -= c->baseh;
+		}
+		/* adjust for increment value */
+		if (c->incw)
+			*w -= *w % c->incw;
+		if (c->inch)
+			*h -= *h % c->inch;
+		/* restore base dimensions */
+		*w = MAX(*w + c->basew, c->minw);
+		*h = MAX(*h + c->baseh, c->minh);
+		if (c->maxw)
+			*w = MIN(*w, c->maxw);
+		if (c->maxh)
+			*h = MIN(*h, c->maxh);
+	}
+	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
 }
 
 void
 arrange(Monitor *m)
 {
-    if (m)
-        showhide(m->stack);
-    else for (m = mons; m; m = m->next)
-        showhide(m->stack);
-    if (m) {
-        arrangemon(m);
-        restack(m);
-    } else for (m = mons; m; m = m->next)
-        arrangemon(m);
+	if (m)
+		showhide(m->stack);
+	else for (m = mons; m; m = m->next)
+		showhide(m->stack);
+	if (m) {
+		arrangemon(m);
+		restack(m);
+	} else for (m = mons; m; m = m->next)
+		arrangemon(m);
 }
 
 void
 arrangemon(Monitor *m)
 {
-    strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-    if (m->lt[m->sellt]->arrange)
-        m->lt[m->sellt]->arrange(m);
+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+	if (m->lt[m->sellt]->arrange)
+		m->lt[m->sellt]->arrange(m);
 }
 
 void
 attach(Client *c)
 {
-    c->next = c->mon->clients;
-    c->mon->clients = c;
+	c->next = c->mon->clients;
+	c->mon->clients = c;
 }
 
 void
 attachstack(Client *c)
 {
-    c->snext = c->mon->stack;
-    c->mon->stack = c;
+	c->snext = c->mon->stack;
+	c->mon->stack = c;
 }
 
 void
 swallow(Client *p, Client *c)
 {
-    if (c->noswallow || c->isterminal)
-        return;
-    if (!swallowfloating && c->isfloating)
-        return;
-
-    detach(c);
-    detachstack(c);
 
-    setclientstate(c, WithdrawnState);
-    XUnmapWindow(dpy, p->win);
+	if (c->noswallow || c->isterminal)
+		return;
+	if (c->noswallow && !swallowfloating && c->isfloating)
+		return;
 
-    p->swallowing = c;
-    c->mon = p->mon;
+	detach(c);
+	detachstack(c);
 
-    Window w = p->win;
-    p->win = c->win;
-    c->win = w;
-    updatetitle(p);
+	setclientstate(c, WithdrawnState);
+	XUnmapWindow(dpy, p->win);
 
-    XWindowChanges wc;
-    wc.border_width = p->bw;
-    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
-    XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
-    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
+	p->swallowing = c;
+	c->mon = p->mon;
 
-    arrange(p->mon);
-    configure(p);
-    updateclientlist();
+	Window w = p->win;
+	p->win = c->win;
+	c->win = w;
+	updatetitle(p);
+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+	arrange(p->mon);
+	configure(p);
+	updateclientlist();
 }
 
 void
 unswallow(Client *c)
 {
-    c->win = c->swallowing->win;
-
-    free(c->swallowing);
-    c->swallowing = NULL;
+	c->win = c->swallowing->win;
 
-    /* unfullscreen the client */
-    setfullscreen(c, 0);
-    updatetitle(c);
-    arrange(c->mon);
-    XMapWindow(dpy, c->win);
-
-    XWindowChanges wc;
-    wc.border_width = c->bw;
-    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
-    XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+	free(c->swallowing);
+	c->swallowing = NULL;
 
-    setclientstate(c, NormalState);
-    focus(NULL);
-    arrange(c->mon);
+	/* unfullscreen the client */
+	setfullscreen(c, 0);
+	updatetitle(c);
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	setclientstate(c, NormalState);
+	focus(NULL);
+	arrange(c->mon);
 }
 
 void
 buttonpress(XEvent *e)
 {
-    unsigned int i, x, click, occ = 0;
-    Arg arg = {0};
-    Client *c;
-    Monitor *m;
-    XButtonPressedEvent *ev = &e->xbutton;
-
-    click = ClkRootWin;
-    /* focus monitor if necessary */
-    if ((m = wintomon(ev->window)) && m != selmon) {
-        unfocus(selmon->sel, 1);
-        selmon = m;
-        focus(NULL);
-    }
-    if (ev->window == selmon->barwin) {
-        i = x = 0;
-        for (c = m->clients; c; c = c->next)
-            occ |= c->tags == 255 ? 0 : c->tags;
-        do {
-            /* do not reserve space for vacant tags */
-            if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-                continue;
-            x += TEXTW(tags[i]);
-        } while (ev->x >= x && ++i < LENGTH(tags));
-        if (i < LENGTH(tags)) {
-            click = ClkTagBar;
-            arg.ui = 1 << i;
-        } else if (ev->x < x + TEXTW(selmon->ltsymbol))
-            click = ClkLtSymbol;
-        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
+	unsigned int i, x, click;
+	Arg arg = {0};
+	Client *c;
+	Monitor *m;
+	XButtonPressedEvent *ev = &e->xbutton;
+
+	click = ClkRootWin;
+	/* focus monitor if necessary */
+	if ((m = wintomon(ev->window)) && m != selmon
+	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+		unfocus(selmon->sel, 1);
+		selmon = m;
+		focus(NULL);
+	}
+	if (ev->window == selmon->barwin) {
+		i = x = 0;
+		unsigned int occ = 0;
+		for(c = m->clients; c; c=c->next)
+			occ |= c->tags == TAGMASK ? 0 : c->tags;
+		do {
+			/* Do not reserve space for vacant tags */
+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+				continue;
+			x += TEXTW(tags[i]);
+		} while (ev->x >= x && ++i < LENGTH(tags));
+		if (i < LENGTH(tags)) {
+			click = ClkTagBar;
+			arg.ui = 1 << i;
+		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+			click = ClkLtSymbol;
+        } else if (ev->x > selmon->ww - statusw) {
+            x = selmon->ww - statusw;
             click = ClkStatusText;
 
-            char *text = rawstext;
-            int i = -1;
-            char ch;
-            dwmblockssig = 0;
-            while (text[++i]) {
-                if ((unsigned char)text[i] < ' ') {
-                    ch = text[i];
-                    text[i] = '\0';
-                    x += TEXTW(text) - lrpad;
-                    text[i] = ch;
-                    text += i+1;
-                    i = -1;
-                    if (x >= ev->x) break;
-                    dwmblockssig = ch;
-                }
-            }
-        } else
-            click = ClkWinTitle;
-    } else if ((c = wintoclient(ev->window))) {
-        focus(c);
-        restack(selmon);
-        XAllowEvents(dpy, ReplayPointer, CurrentTime);
-        click = ClkClientWin;
-    }
-    for (i = 0; i < LENGTH(buttons); i++)
-        if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
-                && CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
-            buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
+			char *text, *s, ch;
+			statussig = 0;
+			for (text = s = stext; *s && x <= ev->x; s++) {
+				if ((unsigned char)(*s) < ' ') {
+					ch = *s;
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = ch;
+					text = s + 1;
+					if (x >= ev->x)
+						break;
+					statussig = ch;
+				} else if (*s == '^') {
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = '^';
+					if (*(++s) == 'f')
+						x += atoi(++s);
+					while (*(s++) != '^');
+					text = s;
+					s--;
+				}
+			}
+	} else if ((c = wintoclient(ev->window))) {
+		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+			focus(c);
+		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+		click = ClkClientWin;
+	}
+	for (i = 0; i < LENGTH(buttons); i++)
+		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
+		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
+			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
 }
 
 void
 checkotherwm(void)
 {
-    xerrorxlib = XSetErrorHandler(xerrorstart);
-    /* this causes an error if some other window manager is running */
-    XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
-    XSync(dpy, False);
-    XSetErrorHandler(xerror);
-    XSync(dpy, False);
+	xerrorxlib = XSetErrorHandler(xerrorstart);
+	/* this causes an error if some other window manager is running */
+	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
+	XSync(dpy, False);
+	XSetErrorHandler(xerror);
+	XSync(dpy, False);
 }
 
 void
 cleanup(void)
 {
-    Arg a = {.ui = ~0};
-    Layout foo = { "", NULL };
-    Monitor *m;
-    size_t i;
-
-    view(&a);
-    selmon->lt[selmon->sellt] = &foo;
-    for (m = mons; m; m = m->next)
-        while (m->stack)
-            unmanage(m->stack, 0);
-    XUngrabKey(dpy, AnyKey, AnyModifier, root);
-    while (mons)
-        cleanupmon(mons);
-    for (i = 0; i < CurLast; i++)
-        drw_cur_free(drw, cursor[i]);
-    /* for (i = 0; i < LENGTH(colors); i++) */
-    for (i = 0; i < LENGTH(colors) + 1; i++)
-        free(scheme[i]);
-    free(scheme);
-    XDestroyWindow(dpy, wmcheckwin);
-    drw_free(drw);
-    XSync(dpy, False);
-    XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
-    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	Arg a = {.ui = ~0};
+	Layout foo = { "", NULL };
+	Monitor *m;
+	size_t i;
+
+	view(&a);
+	selmon->lt[selmon->sellt] = &foo;
+	for (m = mons; m; m = m->next)
+		while (m->stack)
+			unmanage(m->stack, 0);
+	XUngrabKey(dpy, AnyKey, AnyModifier, root);
+	while (mons)
+		cleanupmon(mons);
+	for (i = 0; i < CurLast; i++)
+		drw_cur_free(drw, cursor[i]);
+	for (i = 0; i < LENGTH(colors); i++)
+		drw_scm_free(drw, scheme[i], 3);
+	free(scheme);
+	XDestroyWindow(dpy, wmcheckwin);
+	drw_free(drw);
+	XSync(dpy, False);
+	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
+	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
 }
 
 void
 cleanupmon(Monitor *mon)
 {
-    Monitor *m;
+	Monitor *m;
 
-    if (mon == mons)
-        mons = mons->next;
-    else {
-        for (m = mons; m && m->next != mon; m = m->next);
-        m->next = mon->next;
-    }
-    XUnmapWindow(dpy, mon->barwin);
-    XDestroyWindow(dpy, mon->barwin);
-    free(mon);
+	if (mon == mons)
+		mons = mons->next;
+	else {
+		for (m = mons; m && m->next != mon; m = m->next);
+		m->next = mon->next;
+	}
+	XUnmapWindow(dpy, mon->barwin);
+	XDestroyWindow(dpy, mon->barwin);
+	free(mon);
 }
 
 void
 clientmessage(XEvent *e)
 {
-    XClientMessageEvent *cme = &e->xclient;
-    Client *c = wintoclient(cme->window);
+	XClientMessageEvent *cme = &e->xclient;
+	Client *c = wintoclient(cme->window);
 
-    if (!c)
-        return;
-    if (cme->message_type == netatom[NetWMState]) {
-        if (cme->data.l[1] == netatom[NetWMFullscreen]
-                || cme->data.l[2] == netatom[NetWMFullscreen])
-            setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-                        || (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
-    } else if (cme->message_type == netatom[NetActiveWindow]) {
-        if (c != selmon->sel && !c->isurgent)
-            seturgent(c, 1);
-    }
+	if (!c)
+		return;
+	if (cme->message_type == netatom[NetWMState]) {
+		if (cme->data.l[1] == netatom[NetWMFullscreen]
+		|| cme->data.l[2] == netatom[NetWMFullscreen])
+			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+
+        if (cme->data.l[1] == netatom[NetWMSticky]
+                || cme->data.l[2] == netatom[NetWMSticky])
+            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
+	} else if (cme->message_type == netatom[NetActiveWindow]) {
+		if (c != selmon->sel && !c->isurgent)
+			seturgent(c, 1);
+	}
 }
 
 void
 configure(Client *c)
 {
-    XConfigureEvent ce;
+	XConfigureEvent ce;
 
-    ce.type = ConfigureNotify;
-    ce.display = dpy;
-    ce.event = c->win;
-    ce.window = c->win;
-    ce.x = c->x;
-    ce.y = c->y;
-    ce.width = c->w;
-    ce.height = c->h;
-    ce.border_width = c->bw;
-    ce.above = None;
-    ce.override_redirect = False;
-    XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
+	ce.type = ConfigureNotify;
+	ce.display = dpy;
+	ce.event = c->win;
+	ce.window = c->win;
+	ce.x = c->x;
+	ce.y = c->y;
+	ce.width = c->w;
+	ce.height = c->h;
+	ce.border_width = c->bw;
+	ce.above = None;
+	ce.override_redirect = False;
+	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
 }
 
 void
 configurenotify(XEvent *e)
 {
-    Monitor *m;
-    Client *c;
-    XConfigureEvent *ev = &e->xconfigure;
-    int dirty;
-
-    /* TODO: updategeom handling sucks, needs to be simplified */
-    if (ev->window == root) {
-        dirty = (sw != ev->width || sh != ev->height);
-        sw = ev->width;
-        sh = ev->height;
-        if (updategeom() || dirty) {
-            drw_resize(drw, sw, bh);
-            updatebars();
-            for (m = mons; m; m = m->next) {
-                for (c = m->clients; c; c = c->next)
-                    if (c->isfullscreen)
-                        resizeclient(c, m->mx, m->my, m->mw, m->mh);
-                XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
-            }
-            focus(NULL);
-            arrange(NULL);
-        }
-    }
+	Monitor *m;
+	Client *c;
+	XConfigureEvent *ev = &e->xconfigure;
+	int dirty;
+
+	/* TODO: updategeom handling sucks, needs to be simplified */
+	if (ev->window == root) {
+		dirty = (sw != ev->width || sh != ev->height);
+		sw = ev->width;
+		sh = ev->height;
+		if (updategeom() || dirty) {
+			drw_resize(drw, sw, bh);
+			updatebars();
+			for (m = mons; m; m = m->next) {
+				for (c = m->clients; c; c = c->next)
+					if (c->isfullscreen)
+						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+			}
+			focus(NULL);
+			arrange(NULL);
+		}
+	}
 }
 
 void
 configurerequest(XEvent *e)
 {
-    Client *c;
-    Monitor *m;
-    XConfigureRequestEvent *ev = &e->xconfigurerequest;
-    XWindowChanges wc;
-
-    if ((c = wintoclient(ev->window))) {
-        if (ev->value_mask & CWBorderWidth)
-            c->bw = ev->border_width;
-        else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-            m = c->mon;
-            if (ev->value_mask & CWX) {
-                c->oldx = c->x;
-                c->x = m->mx + ev->x;
-            }
-            if (ev->value_mask & CWY) {
-                c->oldy = c->y;
-                c->y = m->my + ev->y;
-            }
-            if (ev->value_mask & CWWidth) {
-                c->oldw = c->w;
-                c->w = ev->width;
-            }
-            if (ev->value_mask & CWHeight) {
-                c->oldh = c->h;
-                c->h = ev->height;
-            }
-            if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
-                c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
-            if ((c->y + c->h) > m->my + m->mh && c->isfloating)
-                c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
-            if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
-                configure(c);
-            if (ISVISIBLE(c))
-                XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-        } else
-            configure(c);
-    } else {
-        wc.x = ev->x;
-        wc.y = ev->y;
-        wc.width = ev->width;
-        wc.height = ev->height;
-        wc.border_width = ev->border_width;
-        wc.sibling = ev->above;
-        wc.stack_mode = ev->detail;
-        XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
-    }
-    XSync(dpy, False);
-}
-
-void
-copyvalidchars(char *text, char *rawtext)
-{
-    int i = -1, j = 0;
-
-    while(rawtext[++i]) {
-        if ((unsigned char)rawtext[i] >= ' ') {
-            text[j++] = rawtext[i];
-        }
-    }
-    text[j] = '\0';
+	Client *c;
+	Monitor *m;
+	XConfigureRequestEvent *ev = &e->xconfigurerequest;
+	XWindowChanges wc;
+
+	if ((c = wintoclient(ev->window))) {
+		if (ev->value_mask & CWBorderWidth)
+			c->bw = ev->border_width;
+		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
+			m = c->mon;
+			if (ev->value_mask & CWX) {
+				c->oldx = c->x;
+				c->x = m->mx + ev->x;
+			}
+			if (ev->value_mask & CWY) {
+				c->oldy = c->y;
+				c->y = m->my + ev->y;
+			}
+			if (ev->value_mask & CWWidth) {
+				c->oldw = c->w;
+				c->w = ev->width;
+			}
+			if (ev->value_mask & CWHeight) {
+				c->oldh = c->h;
+				c->h = ev->height;
+			}
+			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
+				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
+			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
+				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
+			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
+				configure(c);
+			if (ISVISIBLE(c))
+				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+		} else
+			configure(c);
+	} else {
+		wc.x = ev->x;
+		wc.y = ev->y;
+		wc.width = ev->width;
+		wc.height = ev->height;
+		wc.border_width = ev->border_width;
+		wc.sibling = ev->above;
+		wc.stack_mode = ev->detail;
+		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
+	}
+	XSync(dpy, False);
 }
 
 Monitor *
 createmon(void)
 {
-    Monitor *m;
+	Monitor *m;
 
-    m = ecalloc(1, sizeof(Monitor));
-    m->tagset[0] = m->tagset[1] = 1;
-    m->mfact = mfact;
-    m->nmaster = nmaster;
-    m->showbar = showbar;
-    m->topbar = topbar;
-    m->gappih = gappih;
-    m->gappiv = gappiv;
-    m->gappoh = gappoh;
-    m->gappov = gappov;
-    m->lt[0] = &layouts[0];
-    m->lt[1] = &layouts[1 % LENGTH(layouts)];
-    strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
-    return m;
+	m = ecalloc(1, sizeof(Monitor));
+    if (mons)
+        m->tagset[0] = m->tagset[1] = 2;
+    else
+        m->tagset[0] = m->tagset[1] = 1;
+	m->mfact = mfact;
+	m->nmaster = nmaster;
+	m->showbar = showbar;
+	m->topbar = topbar;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
+	m->lt[0] = &layouts[0];
+	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	return m;
 }
 
 void
 destroynotify(XEvent *e)
 {
-    Client *c;
-    XDestroyWindowEvent *ev = &e->xdestroywindow;
+	Client *c;
+	XDestroyWindowEvent *ev = &e->xdestroywindow;
 
-    if ((c = wintoclient(ev->window)))
-        unmanage(c, 1);
+	if ((c = wintoclient(ev->window)))
+		unmanage(c, 1);
 
-    else if ((c = swallowingclient(ev->window)))
-        unmanage(c->swallowing, 1);
+	else if ((c = swallowingclient(ev->window)))
+		unmanage(c->swallowing, 1);
 }
 
 void
 detach(Client *c)
 {
-    Client **tc;
+	Client **tc;
 
-    for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
-    *tc = c->next;
+	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
+	*tc = c->next;
 }
 
 void
 detachstack(Client *c)
 {
-    Client **tc, *t;
+	Client **tc, *t;
 
-    for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
-    *tc = c->snext;
+	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
+	*tc = c->snext;
 
-    if (c == c->mon->sel) {
-        for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
-        c->mon->sel = t;
-    }
+	if (c == c->mon->sel) {
+		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
+		c->mon->sel = t;
+	}
 }
 
 Monitor *
 dirtomon(int dir)
+{
+	Monitor *m = NULL;
+
+	if (dir > 0) {
+		if (!(m = selmon->next))
+			m = mons;
+	} else if (selmon == mons)
+		for (m = mons; m->next; m = m->next);
+	else
+		for (m = mons; m->next != selmon; m = m->next);
+	return m;
+}
+
+Monitor *
+numtomon(int num)
 {
     Monitor *m = NULL;
+    int i = 0;
 
-    if (dir > 0) {
-        if (!(m = selmon->next))
-            m = mons;
-    } else if (selmon == mons)
-        for (m = mons; m->next; m = m->next);
-    else
-        for (m = mons; m->next != selmon; m = m->next);
+    for(m = mons, i=0; m->next && i < num; m = m->next)
+        i++;
     return m;
 }
 
@@ -936,7 +955,7 @@ drawstatusbar(Monitor *m, int bh, char* stext)
                     if (ptr == NULL) printf("Fail to read wr...");
                     do{
                         ch = fgetc(ptr);
-                        // Check if contains + and 2 (= hot)
+                        // Check if temp is above +20 (= hot)
                         if (hotbool){
                             if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
                                 drw_clr_create(drw, &drw->scheme[ColFg], col21);
@@ -990,108 +1009,124 @@ drawstatusbar(Monitor *m, int bh, char* stext)
 void
 drawbar(Monitor *m)
 {
-    if (!m->showbar) return;
-    int x, w, tw = 0;
-    int boxs = drw->fonts->h / 9;
-    int boxw = drw->fonts->h / 6 + 2;
-    unsigned int i, occ = 0, urg = 0;
-    Client *c;
+	int x, w, tw = 0;
+	int boxs = drw->fonts->h / 9;
+	int boxw = drw->fonts->h / 6 + 2;
+	unsigned int i, occ = 0, urg = 0;
+	Client *c;
 
-    /* draw status first so it can be overdrawn by tags later */
-    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
-    if (m == selmon || 1) { 
-        tw = m->ww - drawstatusbar(m, bh, stext);
-    }
+	if (!m->showbar)
+		return;
 
-    for (c = m->clients; c; c = c->next) {
-        occ |= c->tags == 255 ? 0 : c->tags;
-        if (c->isurgent)
-            urg |= c->tags;
-    }
-    x = 0;
-    for (i = 0; i < LENGTH(tags); i++) {
-        /* do not draw vacant tags */
-        if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-            continue;
-
-        w = TEXTW(tags[i]);
-        drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-        drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-        x += w;
-    }
-    w = TEXTW(m->ltsymbol);
-    drw_setscheme(drw, scheme[SchemeNorm]);
-    x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
-
-    if ((w = m->ww - tw - x) > bh) {
-        drw_setscheme(drw, scheme[SchemeNorm]);
-        drw_rect(drw, x, 0, w, bh, 1, 1);
-    }
-    drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+	/* draw status first so it can be overdrawn by tags later */
+	//if (m == selmon) { /* status is only drawn on selected monitor */
+    if (m == selmon || 1) { 
+		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
+	}
+
+	for (c = m->clients; c; c = c->next) {
+		occ |= c->tags == TAGMASK ? 0 : c->tags;
+		if (c->isurgent)
+			urg |= c->tags;
+	}
+	x = 0;
+	for (i = 0; i < LENGTH(tags); i++) {
+		/* Do not draw vacant tags */
+		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+			continue;
+		w = TEXTW(tags[i]);
+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+		x += w;
+	}
+	w = TEXTW(m->ltsymbol);
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+
+	if ((w = m->ww - tw - x) > bh) {
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_rect(drw, x, 0, w, bh, 1, 1);
+	}
+	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
 
 void
 drawbars(void)
 {
-    Monitor *m;
+	Monitor *m;
 
-    for (m = mons; m; m = m->next)
-        drawbar(m);
+	for (m = mons; m; m = m->next)
+		drawbar(m);
 }
 
 void
 expose(XEvent *e)
 {
-    Monitor *m;
-    XExposeEvent *ev = &e->xexpose;
+	Monitor *m;
+	XExposeEvent *ev = &e->xexpose;
 
-    if (ev->count == 0 && (m = wintomon(ev->window)))
-        drawbar(m);
+	if (ev->count == 0 && (m = wintomon(ev->window)))
+		drawbar(m);
 }
 
 void
 focus(Client *c)
 {
-    if (!c || !ISVISIBLE(c))
-        for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-    if (selmon->sel && selmon->sel != c)
-        unfocus(selmon->sel, 0);
-    if (c) {
-        if (c->mon != selmon)
-            selmon = c->mon;
-        if (c->isurgent)
-            seturgent(c, 0);
-        detachstack(c);
-        attachstack(c);
-        grabbuttons(c, 1);
-        XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-        setfocus(c);
-    } else {
-        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-    }
-    selmon->sel = c;
-    drawbars();
+	if (!c || !ISVISIBLE(c))
+		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
+	if (selmon->sel && selmon->sel != c)
+		unfocus(selmon->sel, 0);
+	if (c) {
+		if (c->mon != selmon)
+			selmon = c->mon;
+		if (c->isurgent)
+			seturgent(c, 0);
+		detachstack(c);
+		attachstack(c);
+		grabbuttons(c, 1);
+		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+		setfocus(c);
+	} else {
+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	}
+	selmon->sel = c;
+	drawbars();
 }
 
 /* there are some broken focus acquiring clients needing extra handling */
 void
 focusin(XEvent *e)
 {
-    XFocusChangeEvent *ev = &e->xfocus;
+	XFocusChangeEvent *ev = &e->xfocus;
 
-    if (selmon->sel && ev->window != selmon->sel->win)
-        setfocus(selmon->sel);
+	if (selmon->sel && ev->window != selmon->sel->win)
+		setfocus(selmon->sel);
 }
 
 void
 focusmon(const Arg *arg)
+{
+	Monitor *m;
+
+	if (!mons->next)
+		return;
+	if ((m = dirtomon(arg->i)) == selmon)
+		return;
+	unfocus(selmon->sel, 0);
+	selmon = m;
+	focus(NULL);
+}
+
+void
+focusnthmon(const Arg *arg)
 {
     Monitor *m;
 
     if (!mons->next)
         return;
-    if ((m = dirtomon(arg->i)) == selmon)
+
+    if ((m = numtomon(arg->i)) == selmon)
         return;
     unfocus(selmon->sel, 0);
     XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
@@ -1102,622 +1137,669 @@ focusmon(const Arg *arg)
 void
 focusstack(const Arg *arg)
 {
-    int i = stackpos(arg);
-    Client *c, *p;
+	int i = stackpos(arg);
+	Client *c, *p;
 
-    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
-        return;
+	if(i < 0)
+		return;
 
-    for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
-            i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
-    focus(c ? c : p);
-    restack(selmon);
+	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
+	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
+	focus(c ? c : p);
+	restack(selmon);
 }
 
 Atom
 getatomprop(Client *c, Atom prop)
 {
-    int di;
-    unsigned long dl;
-    unsigned char *p = NULL;
-    Atom da, atom = None;
+	int di;
+	unsigned long dl;
+	unsigned char *p = NULL;
+	Atom da, atom = None;
 
-    if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
-                &da, &di, &dl, &dl, &p) == Success && p) {
-        atom = *(Atom *)p;
-        XFree(p);
-    }
-    return atom;
+	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
+		&da, &di, &dl, &dl, &p) == Success && p) {
+		atom = *(Atom *)p;
+		XFree(p);
+	}
+	return atom;
 }
 
-#ifndef __OpenBSD__
-int getdwmblockspid()
-{
-    char buf[16];
-    FILE *fp = popen("pidof -s dwmblocks", "r");
-    fgets(buf, sizeof(buf), fp);
-    pid_t pid = strtoul(buf, NULL, 10);
-    pclose(fp);
-    dwmblockspid = pid;
-    return pid != 0 ? 0 : -1;
+pid_t
+getstatusbarpid()
+{
+	char buf[32], *str = buf, *c;
+	FILE *fp;
+
+	if (statuspid > 0) {
+		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+		if ((fp = fopen(buf, "r"))) {
+			fgets(buf, sizeof(buf), fp);
+			while ((c = strchr(str, '/')))
+				str = c + 1;
+			fclose(fp);
+			if (!strcmp(str, STATUSBAR))
+				return statuspid;
+		}
+	}
+	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+		return -1;
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+	return strtoul(buf, NULL, 10);
 }
-#endif
 
 int
 getrootptr(int *x, int *y)
 {
-    int di;
-    unsigned int dui;
-    Window dummy;
+	int di;
+	unsigned int dui;
+	Window dummy;
 
-    return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
+	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
 }
 
 long
 getstate(Window w)
 {
-    int format;
-    long result = -1;
-    unsigned char *p = NULL;
-    unsigned long n, extra;
-    Atom real;
+	int format;
+	long result = -1;
+	unsigned char *p = NULL;
+	unsigned long n, extra;
+	Atom real;
 
-    if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
-                &real, &format, &n, &extra, (unsigned char **)&p) != Success)
-        return -1;
-    if (n != 0)
-        result = *p;
-    XFree(p);
-    return result;
+	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
+		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
+		return -1;
+	if (n != 0)
+		result = *p;
+	XFree(p);
+	return result;
 }
 
 int
 gettextprop(Window w, Atom atom, char *text, unsigned int size)
 {
-    char **list = NULL;
-    int n;
-    XTextProperty name;
-
-    if (!text || size == 0)
-        return 0;
-    text[0] = '\0';
-    if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
-        return 0;
-    if (name.encoding == XA_STRING)
-        strncpy(text, (char *)name.value, size - 1);
-    else {
-        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
-            strncpy(text, *list, size - 1);
-            XFreeStringList(list);
-        }
-    }
-    text[size - 1] = '\0';
-    XFree(name.value);
-    return 1;
+	char **list = NULL;
+	int n;
+	XTextProperty name;
+
+	if (!text || size == 0)
+		return 0;
+	text[0] = '\0';
+	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
+		return 0;
+	if (name.encoding == XA_STRING) {
+		strncpy(text, (char *)name.value, size - 1);
+	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+		strncpy(text, *list, size - 1);
+		XFreeStringList(list);
+	}
+	text[size - 1] = '\0';
+	XFree(name.value);
+	return 1;
 }
 
 void
 grabbuttons(Client *c, int focused)
 {
-    updatenumlockmask();
-    {
-        unsigned int i, j;
-        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-        if (!focused)
-            XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-                    BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
-        for (i = 0; i < LENGTH(buttons); i++)
-            if (buttons[i].click == ClkClientWin)
-                for (j = 0; j < LENGTH(modifiers); j++)
-                    XGrabButton(dpy, buttons[i].button,
-                            buttons[i].mask | modifiers[j],
-                            c->win, False, BUTTONMASK,
-                            GrabModeAsync, GrabModeSync, None, None);
-    }
+	updatenumlockmask();
+	{
+		unsigned int i, j;
+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+		if (!focused)
+			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
+				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
+		for (i = 0; i < LENGTH(buttons); i++)
+			if (buttons[i].click == ClkClientWin)
+				for (j = 0; j < LENGTH(modifiers); j++)
+					XGrabButton(dpy, buttons[i].button,
+						buttons[i].mask | modifiers[j],
+						c->win, False, BUTTONMASK,
+						GrabModeAsync, GrabModeSync, None, None);
+	}
 }
 
 void
 grabkeys(void)
 {
-    updatenumlockmask();
-    {
-        unsigned int i, j, k;
-        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-        int start, end, skip;
-        KeySym *syms;
-
-        XUngrabKey(dpy, AnyKey, AnyModifier, root);
-        XDisplayKeycodes(dpy, &start, &end);
-        syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
-        if (!syms)
-            return;
-        for (k = start; k <= end; k++)
-            for (i = 0; i < LENGTH(keys); i++)
-                /* skip modifier codes, we do that ourselves */
-                if (keys[i].keysym == syms[(k - start) * skip])
-                    for (j = 0; j < LENGTH(modifiers); j++)
-                        XGrabKey(dpy, k,
-                                keys[i].mod | modifiers[j],
-                                root, True,
-                                GrabModeAsync, GrabModeAsync);
-        XFree(syms);
-    }
+	updatenumlockmask();
+	{
+		unsigned int i, j, k;
+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+		int start, end, skip;
+		KeySym *syms;
+
+		XUngrabKey(dpy, AnyKey, AnyModifier, root);
+		XDisplayKeycodes(dpy, &start, &end);
+		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
+		if (!syms)
+			return;
+		for (k = start; k <= end; k++)
+			for (i = 0; i < LENGTH(keys); i++)
+				/* skip modifier codes, we do that ourselves */
+				if (keys[i].keysym == syms[(k - start) * skip])
+					for (j = 0; j < LENGTH(modifiers); j++)
+						XGrabKey(dpy, k,
+							 keys[i].mod | modifiers[j],
+							 root, True,
+							 GrabModeAsync, GrabModeAsync);
+		XFree(syms);
+	}
 }
 
 void
 incnmaster(const Arg *arg)
 {
-    selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-    arrange(selmon);
+	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	arrange(selmon);
 }
 
 #ifdef XINERAMA
-static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+static int
+isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
 {
-    while (n--)
-        if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
-                && unique[n].width == info->width && unique[n].height == info->height)
-            return 0;
-    return 1;
+	while (n--)
+		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
+		&& unique[n].width == info->width && unique[n].height == info->height)
+			return 0;
+	return 1;
 }
 #endif /* XINERAMA */
 
 void
 keypress(XEvent *e)
 {
-    unsigned int i;
-    KeySym keysym;
-    XKeyEvent *ev;
+	unsigned int i;
+	KeySym keysym;
+	XKeyEvent *ev;
 
-    ev = &e->xkey;
-    keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-    for (i = 0; i < LENGTH(keys); i++)
-        if (keysym == keys[i].keysym
-                && CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
-                && keys[i].func)
-            keys[i].func(&(keys[i].arg));
+	ev = &e->xkey;
+	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+	for (i = 0; i < LENGTH(keys); i++)
+		if (keysym == keys[i].keysym
+		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
+		&& keys[i].func)
+			keys[i].func(&(keys[i].arg));
 }
 
 void
 killclient(const Arg *arg)
 {
-    if (!selmon->sel)
-        return;
-    if (!sendevent(selmon->sel, wmatom[WMDelete])) {
-        XGrabServer(dpy);
-        XSetErrorHandler(xerrordummy);
-        XSetCloseDownMode(dpy, DestroyAll);
-        XKillClient(dpy, selmon->sel->win);
-        XSync(dpy, False);
-        XSetErrorHandler(xerror);
-        XUngrabServer(dpy);
-    }
+	if (!selmon->sel)
+		return;
+	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
+		XGrabServer(dpy);
+		XSetErrorHandler(xerrordummy);
+		XSetCloseDownMode(dpy, DestroyAll);
+		XKillClient(dpy, selmon->sel->win);
+		XSync(dpy, False);
+		XSetErrorHandler(xerror);
+		XUngrabServer(dpy);
+	}
 }
 
 void
 manage(Window w, XWindowAttributes *wa)
 {
-    Client *c, *t = NULL, *term = NULL;
-    Window trans = None;
-    XWindowChanges wc;
-
-    c = ecalloc(1, sizeof(Client));
-    c->win = w;
-    c->pid = winpid(w);
-    /* geometry */
-    c->x = c->oldx = wa->x;
-    c->y = c->oldy = wa->y;
-    c->w = c->oldw = wa->width;
-    c->h = c->oldh = wa->height;
-    c->oldbw = wa->border_width;
-
-    updatetitle(c);
-    if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
-        c->mon = t->mon;
-        c->tags = t->tags;
-    } else {
-        c->mon = selmon;
-        applyrules(c);
-        term = termforwin(c);
-    }
-
-    if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
-        c->x = c->mon->wx + c->mon->ww - WIDTH(c);
-    if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
-        c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
-    c->x = MAX(c->x, c->mon->wx);
-    c->y = MAX(c->y, c->mon->wy);
-    c->bw = borderpx;
-    /* if (c->isfloating) c->bw = 0; */
-
-    wc.border_width = c->bw;
-    XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-    XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
-    configure(c); /* propagates border_width, if size doesn't change */
-    updatewindowtype(c);
-    updatewmhints(c);
-    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
-    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
-    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
-    c->sfx = c->x;
-    c->sfy = c->y;
-    c->sfw = c->w;
-    c->sfh = c->h;
-
-    XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
-    grabbuttons(c, 0);
-    if (!c->isfloating)
-        c->isfloating = c->oldstate = t || c->isfixed;
-    if (c->isfloating) {
-        XRaiseWindow(dpy, c->win);
-        if (strcmp(c->name, "YAD") == 0) {
-            c->x = 1488;
-            c->y = 42;
-            c->w = 405;
-            c->h = 280;
-        }
-    }
-    attach(c);
-    attachstack(c);
-    XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
-            (unsigned char *) &(c->win), 1);
-    XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
-    setclientstate(c, NormalState);
-    if (c->mon == selmon)
-        unfocus(selmon->sel, 0);
-    c->mon->sel = c;
-    XMapWindow(dpy, c->win);
-    if (term)
-        swallow(term, c);
-    arrange(c->mon);
-    focus(NULL);
+	Client *c, *t = NULL, *term = NULL;
+	Window trans = None;
+	XWindowChanges wc;
+
+	c = ecalloc(1, sizeof(Client));
+	c->win = w;
+	c->pid = winpid(w);
+	/* geometry */
+	c->x = c->oldx = wa->x;
+	c->y = c->oldy = wa->y;
+	c->w = c->oldw = wa->width;
+	c->h = c->oldh = wa->height;
+	c->oldbw = wa->border_width;
+	c->cfact = 1.0;
+
+	updatetitle(c);
+	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+		c->mon = t->mon;
+		c->tags = t->tags;
+	} else {
+		c->mon = selmon;
+		applyrules(c);
+		term = termforwin(c);
+	}
+
+	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
+	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
+		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
+	c->x = MAX(c->x, c->mon->wx);
+	c->y = MAX(c->y, c->mon->wy);
+	c->bw = borderpx;
+
+	wc.border_width = c->bw;
+	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
+	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+	configure(c); /* propagates border_width, if size doesn't change */
+	updatewindowtype(c);
+	updatesizehints(c);
+	updatewmhints(c);
+	c->sfx = c->x;
+	c->sfy = c->y;
+	c->sfw = c->w;
+	c->sfh = c->h;
+	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+	grabbuttons(c, 0);
+	if (!c->isfloating)
+		c->isfloating = c->oldstate = trans != None || c->isfixed;
+	if (c->isfloating)
+		XRaiseWindow(dpy, c->win);
+	attach(c);
+	attachstack(c);
+	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+		(unsigned char *) &(c->win), 1);
+	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
+	setclientstate(c, NormalState);
+	if (c->mon == selmon)
+		unfocus(selmon->sel, 0);
+	c->mon->sel = c;
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	if (term)
+		swallow(term, c);
+	focus(NULL);
 }
 
 void
 mappingnotify(XEvent *e)
 {
-    XMappingEvent *ev = &e->xmapping;
+	XMappingEvent *ev = &e->xmapping;
 
-    XRefreshKeyboardMapping(ev);
-    if (ev->request == MappingKeyboard)
-        grabkeys();
+	XRefreshKeyboardMapping(ev);
+	if (ev->request == MappingKeyboard)
+		grabkeys();
 }
 
 void
 maprequest(XEvent *e)
 {
-    static XWindowAttributes wa;
-    XMapRequestEvent *ev = &e->xmaprequest;
+	static XWindowAttributes wa;
+	XMapRequestEvent *ev = &e->xmaprequest;
 
-    if (!XGetWindowAttributes(dpy, ev->window, &wa))
-        return;
-    if (wa.override_redirect)
-        return;
-    if (!wintoclient(ev->window))
-        manage(ev->window, &wa);
+	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
+		return;
+	if (!wintoclient(ev->window))
+		manage(ev->window, &wa);
 }
 
 void
 monocle(Monitor *m)
 {
-    unsigned int n;
-    int oh, ov, ih, iv;
-    Client *c;
-
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n > 0) /* override layout symbol */
-        snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-    for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
-}
-
-void
-motionnotify(XEvent *e)
-{
-    static Monitor *mon = NULL;
-    Monitor *m;
-    XMotionEvent *ev = &e->xmotion;
+	unsigned int n = 0;
+	Client *c;
 
-    if (ev->window != root)
-        return;
-    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-        unfocus(selmon->sel, 1);
-        selmon = m;
-        focus(NULL);
-    }
-    mon = m;
+	for (c = m->clients; c; c = c->next)
+		if (ISVISIBLE(c))
+			n++;
+	if (n > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
+		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
 }
 
 void
 movemouse(const Arg *arg)
 {
-    int x, y, ocx, ocy, nx, ny;
-    Client *c;
-    Monitor *m;
-    XEvent ev;
-    Time lasttime = 0;
-
-    if (!(c = selmon->sel))
-        return;
-    if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
-        return;
-    restack(selmon);
-    ocx = c->x;
-    ocy = c->y;
-    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-                None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
-        return;
-    if (!getrootptr(&x, &y))
-        return;
-    do {
-        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-        switch(ev.type) {
-            case ConfigureRequest:
-            case Expose:
-            case MapRequest:
-                handler[ev.type](&ev);
-                break;
-            case MotionNotify:
-                // Increase display rate when dragging  and resizing floats
-                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
-                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
-                    continue;
-                lasttime = ev.xmotion.time;
-
-                nx = ocx + (ev.xmotion.x - x);
-                ny = ocy + (ev.xmotion.y - y);
-                if (abs(selmon->wx - nx) < snap)
-                    nx = selmon->wx;
-                else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-                    nx = selmon->wx + selmon->ww - WIDTH(c);
-                if (abs(selmon->wy - ny) < snap)
-                    ny = selmon->wy;
-                else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-                    ny = selmon->wy + selmon->wh - HEIGHT(c);
-                if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-                        && (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-                    togglefloating(NULL);
-                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-                    resize(c, nx, ny, c->w, c->h, 1);
-                break;
-        }
-    } while (ev.type != ButtonRelease);
-    XUngrabPointer(dpy, CurrentTime);
-    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-        sendmon(c, m);
-        selmon = m;
-        focus(NULL);
-    }
+	int x, y, ocx, ocy, nx, ny;
+	Client *c;
+	Monitor *m;
+	XEvent ev;
+	Time lasttime = 0;
+
+	if (!(c = selmon->sel))
+		return;
+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+		return;
+	restack(selmon);
+	ocx = c->x;
+	ocy = c->y;
+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+		return;
+	if (!getrootptr(&x, &y))
+		return;
+	do {
+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+		switch(ev.type) {
+		case ConfigureRequest:
+		case Expose:
+		case MapRequest:
+			handler[ev.type](&ev);
+			break;
+		case MotionNotify:
+            if ((ev.xmotion.time - lasttime) <= (1000 / refreshrate))
+				continue;
+			lasttime = ev.xmotion.time;
+
+			nx = ocx + (ev.xmotion.x - x);
+			ny = ocy + (ev.xmotion.y - y);
+			if (abs(selmon->wx - nx) < snap)
+				nx = selmon->wx;
+			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+				nx = selmon->wx + selmon->ww - WIDTH(c);
+			if (abs(selmon->wy - ny) < snap)
+				ny = selmon->wy;
+			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+				ny = selmon->wy + selmon->wh - HEIGHT(c);
+			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+				togglefloating(NULL);
+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+				resize(c, nx, ny, c->w, c->h, 1);
+			break;
+		}
+	} while (ev.type != ButtonRelease);
+	XUngrabPointer(dpy, CurrentTime);
+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+		sendmon(c, m);
+		selmon = m;
+		focus(NULL);
+	}
 }
 
 Client *
 nexttiled(Client *c)
 {
-    for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
-    return c;
+	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+	return c;
 }
 
 void
 pop(Client *c)
 {
-    detach(c);
-    attach(c);
-    focus(c);
-    arrange(c->mon);
-}
-
-void
-pushstack(const Arg *arg)
-{
-    int i = stackpos(arg);
-    Client *sel = selmon->sel, *c, *p;
-
-    if(i < 0 || !sel)
-        return;
-    else if(i == 0) {
-        detach(sel);
-        attach(sel);
-    }
-    else {
-        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
-            if(!(i -= (ISVISIBLE(c) && c != sel)))
-                break;
-        c = c ? c : p;
-        detach(sel);
-        sel->next = c->next;
-        c->next = sel;
-    }
-    arrange(selmon);
+	detach(c);
+	attach(c);
+	focus(c);
+	arrange(c->mon);
 }
 
 void
 propertynotify(XEvent *e)
 {
-    Client *c;
-    Window trans;
-    XPropertyEvent *ev = &e->xproperty;
-
-    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
-        updatestatus();
-    } else if (ev->state == PropertyDelete) {
-        return; /* ignore */
-    } else if ((c = wintoclient(ev->window))) {
-        switch(ev->atom) {
-            default: break;
-            case XA_WM_TRANSIENT_FOR:
-                     if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
-                             (c->isfloating = (wintoclient(trans)) != NULL))
-                         arrange(c->mon);
-                     break;
-            case XA_WM_NORMAL_HINTS:
-                     c->hintsvalid = 0;
-                     break;
-            case XA_WM_HINTS:
-                     updatewmhints(c);
-                     drawbars();
-                     break;
-        }
-        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
-            updatetitle(c);
-            if (c == c->mon->sel)
-                drawbar(c->mon);
-        }
-
-        if (ev->atom == netatom[NetWMWindowType])
-            updatewindowtype(c);
-    }
+	Client *c;
+	Window trans;
+	XPropertyEvent *ev = &e->xproperty;
+
+	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+		updatestatus();
+	else if (ev->state == PropertyDelete)
+		return; /* ignore */
+	else if ((c = wintoclient(ev->window))) {
+		switch(ev->atom) {
+		default: break;
+		case XA_WM_TRANSIENT_FOR:
+			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
+				(c->isfloating = (wintoclient(trans)) != NULL))
+				arrange(c->mon);
+			break;
+		case XA_WM_NORMAL_HINTS:
+			c->hintsvalid = 0;
+			break;
+		case XA_WM_HINTS:
+			updatewmhints(c);
+			drawbars();
+			break;
+		}
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+			updatetitle(c);
+		if (ev->atom == netatom[NetWMWindowType])
+			updatewindowtype(c);
+	}
+}
+
+void
+pushstack(const Arg *arg) {
+	int i = stackpos(arg);
+	Client *sel = selmon->sel, *c, *p;
+
+	if(i < 0)
+		return;
+	else if(i == 0) {
+		detach(sel);
+		attach(sel);
+	}
+	else {
+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+			if(!(i -= (ISVISIBLE(c) && c != sel)))
+				break;
+		c = c ? c : p;
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	arrange(selmon);
 }
 
 void
 quit(const Arg *arg)
 {
-    if(arg->i) restart = 1;
-    running = 0;
+	running = 0;
 }
 
 Monitor *
 recttomon(int x, int y, int w, int h)
 {
-    Monitor *m, *r = selmon;
-    int a, area = 0;
+	Monitor *m, *r = selmon;
+	int a, area = 0;
 
-    for (m = mons; m; m = m->next)
-        if ((a = INTERSECT(x, y, w, h, m)) > area) {
-            area = a;
-            r = m;
-        }
-    return r;
+	for (m = mons; m; m = m->next)
+		if ((a = INTERSECT(x, y, w, h, m)) > area) {
+			area = a;
+			r = m;
+		}
+	return r;
 }
 
 void
 resize(Client *c, int x, int y, int w, int h, int interact)
 {
-    if (applysizehints(c, &x, &y, &w, &h, interact))
-        resizeclient(c, x, y, w, h);
+	if (applysizehints(c, &x, &y, &w, &h, interact))
+		resizeclient(c, x, y, w, h);
 }
 
 void
 resizeclient(Client *c, int x, int y, int w, int h)
 {
-    XWindowChanges wc;
-
-    c->oldx = c->x; c->x = wc.x = x;
-    c->oldy = c->y; c->y = wc.y = y;
-    c->oldw = c->w; c->w = wc.width = w;
-    c->oldh = c->h; c->h = wc.height = h;
-    wc.border_width = c->bw;
-    // Don't show border if floating or if only 1 client
-    if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
-                || &monocle == c->mon->lt[c->mon->sellt]->arrange)
-            && !c->isfullscreen) {
-        /* && !c->isfullscreen && !c->isfloating) { */
-        c->w = wc.width += c->bw * 2;
-        c->h = wc.height += c->bw * 2;
-        wc.border_width = 0;
-    }
+	XWindowChanges wc;
 
-    XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
-    configure(c);
-    XSync(dpy, False);
+	c->oldx = c->x; c->x = wc.x = x;
+	c->oldy = c->y; c->y = wc.y = y;
+	c->oldw = c->w; c->w = wc.width = w;
+	c->oldh = c->h; c->h = wc.height = h;
+	wc.border_width = c->bw;
+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+	    && !c->isfullscreen && !c->isfloating) {
+        wc.width += c->bw * 2;
+        wc.height += c->bw * 2;
+		wc.border_width = 0;
+	}
+	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+	configure(c);
+	XSync(dpy, False);
 }
 
 void
 resizemouse(const Arg *arg)
 {
-    int ocx, ocy, nw, nh;
-    Client *c;
-    Monitor *m;
-    XEvent ev;
-    Time lasttime = 0;
-
-    if (!(c = selmon->sel))
-        return;
-    if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
-        return;
-    restack(selmon);
-    ocx = c->x;
-    ocy = c->y;
-    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-                None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
-        return;
-    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-    do {
-        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-        switch(ev.type) {
-            case ConfigureRequest:
-            case Expose:
-            case MapRequest:
-                handler[ev.type](&ev);
-                break;
-            case MotionNotify:
-                if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-                    continue;
-                lasttime = ev.xmotion.time;
-
-                nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
-                nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
-                if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
-                        && c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
-                {
-                    if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-                            && (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
-                        togglefloating(NULL);
-                }
-                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-                    resize(c, c->x, c->y, nw, nh, 1);
-                break;
-        }
-    } while (ev.type != ButtonRelease);
-    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-    XUngrabPointer(dpy, CurrentTime);
-    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-        sendmon(c, m);
-        selmon = m;
-        focus(NULL);
-    }
+	int ocx, ocy, nw, nh;
+	Client *c;
+	Monitor *m;
+	XEvent ev;
+	Time lasttime = 0;
+
+	if (!(c = selmon->sel))
+		return;
+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+		return;
+	restack(selmon);
+	ocx = c->x;
+	ocy = c->y;
+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
+		return;
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	do {
+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+		switch(ev.type) {
+		case ConfigureRequest:
+		case Expose:
+		case MapRequest:
+			handler[ev.type](&ev);
+			break;
+		case MotionNotify:
+            if ((ev.xmotion.time - lasttime) <= (1000 / refreshrate))
+				continue;
+			lasttime = ev.xmotion.time;
+
+			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
+			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
+			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
+			{
+				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
+					togglefloating(NULL);
+			}
+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+				resize(c, c->x, c->y, nw, nh, 1);
+			break;
+		}
+	} while (ev.type != ButtonRelease);
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	XUngrabPointer(dpy, CurrentTime);
+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+		sendmon(c, m);
+		selmon = m;
+		focus(NULL);
+	}
 }
 
 void
 restack(Monitor *m)
 {
-    Client *c;
-    XEvent ev;
-    XWindowChanges wc;
-
-    drawbar(m);
-    if (!m->sel)
-        return;
-    if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
-        XRaiseWindow(dpy, m->sel->win);
-    if (m->lt[m->sellt]->arrange) {
-        wc.stack_mode = Below;
-        wc.sibling = m->barwin;
-        for (c = m->stack; c; c = c->snext)
-            if (!c->isfloating && ISVISIBLE(c)) {
-                XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
-                wc.sibling = c->win;
-            }
-    }
-    XSync(dpy, False);
-    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+	Client *c;
+	XEvent ev;
+	XWindowChanges wc;
+
+	drawbar(m);
+	if (!m->sel)
+		return;
+	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+		XRaiseWindow(dpy, m->sel->win);
+	if (m->lt[m->sellt]->arrange) {
+		wc.stack_mode = Below;
+		wc.sibling = m->barwin;
+		for (c = m->stack; c; c = c->snext)
+			if (!c->isfloating && ISVISIBLE(c)) {
+				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
+				wc.sibling = c->win;
+			}
+	}
+	XSync(dpy, False);
+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 }
 
 void
 run(void)
 {
-    XEvent ev;
-    /* main event loop */
-    XSync(dpy, False);
-    while (running && !XNextEvent(dpy, &ev))
-        if (handler[ev.type])
-            handler[ev.type](&ev); /* call handler */
-}
-
-void
-runAutostart(void)
+	XEvent ev;
+	/* main event loop */
+	XSync(dpy, False);
+	while (running && !XNextEvent(dpy, &ev))
+		if (handler[ev.type])
+			handler[ev.type](&ev); /* call handler */
+}
+
+//void
+//runautostart(void)
+//{
+//	char *pathpfx;
+//	char *path;
+//	char *xdgdatahome;
+//	char *home;
+//	struct stat sb;
+//
+//	if ((home = getenv("HOME")) == NULL)
+//		/* this is almost impossible */
+//		return;
+//
+//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+//	 * otherwise use ~/.local/share/dwm as autostart script directory
+//	 */
+//	xdgdatahome = getenv("XDG_DATA_HOME");
+//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+//
+//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	} else {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+//		                     + strlen(dwmdir) + 3);
+//
+//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* check if the autostart script directory exists */
+//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+//		/* the XDG conformant path does not exist or is no directory
+//		 * so we try ~/.dwm instead
+//		 */
+//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+//		if(pathpfx_new == NULL) {
+//			free(pathpfx);
+//			return;
+//		}
+//		pathpfx = pathpfx_new;
+//
+//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* try the blocking script first */
+//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(path);
+//
+//	/* now the non-blocking script */
+//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(strcat(path, " &"));
+//
+//	free(pathpfx);
+//	free(path);
+//}
+
+void
+runautostart(void)
 {
     system("killall -q dwmblocks; dwmblocks &");
 }
@@ -1725,44 +1807,44 @@ runAutostart(void)
 void
 scan(void)
 {
-    unsigned int i, num;
-    Window d1, d2, *wins = NULL;
-    XWindowAttributes wa;
-
-    if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
-        for (i = 0; i < num; i++) {
-            if (!XGetWindowAttributes(dpy, wins[i], &wa)
-                    || wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
-                continue;
-            if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
-                manage(wins[i], &wa);
-        }
-        for (i = 0; i < num; i++) { /* now the transients */
-            if (!XGetWindowAttributes(dpy, wins[i], &wa))
-                continue;
-            if (XGetTransientForHint(dpy, wins[i], &d1)
-                    && (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
-                manage(wins[i], &wa);
-        }
-        if (wins)
-            XFree(wins);
-    }
+	unsigned int i, num;
+	Window d1, d2, *wins = NULL;
+	XWindowAttributes wa;
+
+	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
+		for (i = 0; i < num; i++) {
+			if (!XGetWindowAttributes(dpy, wins[i], &wa)
+			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
+				continue;
+			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
+				manage(wins[i], &wa);
+		}
+		for (i = 0; i < num; i++) { /* now the transients */
+			if (!XGetWindowAttributes(dpy, wins[i], &wa))
+				continue;
+			if (XGetTransientForHint(dpy, wins[i], &d1)
+			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
+				manage(wins[i], &wa);
+		}
+		if (wins)
+			XFree(wins);
+	}
 }
 
 void
 sendmon(Client *c, Monitor *m)
 {
-    if (c->mon == m)
-        return;
-    unfocus(c, 1);
-    detach(c);
-    detachstack(c);
-    c->mon = m;
-    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-    attach(c);
-    attachstack(c);
-    focus(NULL);
-    arrange(NULL);
+	if (c->mon == m)
+		return;
+	unfocus(c, 1);
+	detach(c);
+	detachstack(c);
+	c->mon = m;
+	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+	attach(c);
+	attachstack(c);
+	focus(NULL);
+	arrange(NULL);
 }
 
 void
@@ -1787,318 +1869,616 @@ sendmonview(Client *c, Monitor *m)
 void
 setclientstate(Client *c, long state)
 {
-    long data[] = { state, None };
+	long data[] = { state, None };
 
-    XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-            PropModeReplace, (unsigned char *)data, 2);
+	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
+		PropModeReplace, (unsigned char *)data, 2);
 }
 
 int
 sendevent(Client *c, Atom proto)
 {
-    int n;
-    Atom *protocols;
-    int exists = 0;
-    XEvent ev;
-
-    if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
-        while (!exists && n--)
-            exists = protocols[n] == proto;
-        XFree(protocols);
-    }
-    if (exists) {
-        ev.type = ClientMessage;
-        ev.xclient.window = c->win;
-        ev.xclient.message_type = wmatom[WMProtocols];
-        ev.xclient.format = 32;
-        ev.xclient.data.l[0] = proto;
-        ev.xclient.data.l[1] = CurrentTime;
-        XSendEvent(dpy, c->win, False, NoEventMask, &ev);
-    }
-    return exists;
+	int n;
+	Atom *protocols;
+	int exists = 0;
+	XEvent ev;
+
+	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
+		while (!exists && n--)
+			exists = protocols[n] == proto;
+		XFree(protocols);
+	}
+	if (exists) {
+		ev.type = ClientMessage;
+		ev.xclient.window = c->win;
+		ev.xclient.message_type = wmatom[WMProtocols];
+		ev.xclient.format = 32;
+		ev.xclient.data.l[0] = proto;
+		ev.xclient.data.l[1] = CurrentTime;
+		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
+	}
+	return exists;
 }
 
 void
 setfocus(Client *c)
 {
-    if (!c->neverfocus) {
-        XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
-        XChangeProperty(dpy, root, netatom[NetActiveWindow],
-                XA_WINDOW, 32, PropModeReplace,
-                (unsigned char *) &(c->win), 1);
-    }
-    sendevent(c, wmatom[WMTakeFocus]);
+	if (!c->neverfocus) {
+		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
+		XChangeProperty(dpy, root, netatom[NetActiveWindow],
+			XA_WINDOW, 32, PropModeReplace,
+			(unsigned char *) &(c->win), 1);
+	}
+	sendevent(c, wmatom[WMTakeFocus]);
 }
 
 void
 setfullscreen(Client *c, int fullscreen)
 {
-    if (fullscreen && !c->isfullscreen) {
-        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-                PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-        c->isfullscreen = 1;
-        c->oldstate = c->isfloating;
-        c->oldbw = c->bw;
-        c->bw = 0;
-        c->isfloating = 1;
-        resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
-        XRaiseWindow(dpy, c->win);
-    } else if (!fullscreen && c->isfullscreen){
-        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-                PropModeReplace, (unsigned char*)0, 0);
-        c->isfullscreen = 0;
-        c->isfloating = c->oldstate;
-        c->bw = c->oldbw;
-        c->x = c->oldx;
-        c->y = c->oldy;
-        c->w = c->oldw;
-        c->h = c->oldh;
-        resizeclient(c, c->x, c->y, c->w, c->h);
-        arrange(c->mon);
-    }
+	if (fullscreen && !c->isfullscreen) {
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+		c->isfullscreen = 1;
+		c->oldstate = c->isfloating;
+		c->oldbw = c->bw;
+		c->bw = 0;
+		c->isfloating = 1;
+		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+		XRaiseWindow(dpy, c->win);
+	} else if (!fullscreen && c->isfullscreen){
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)0, 0);
+		c->isfullscreen = 0;
+		c->isfloating = c->oldstate;
+		c->bw = c->oldbw;
+		c->x = c->oldx;
+		c->y = c->oldy;
+		c->w = c->oldw;
+		c->h = c->oldh;
+		resizeclient(c, c->x, c->y, c->w, c->h);
+		arrange(c->mon);
+	}
+}
+
+void
+	 setsticky(Client *c, int sticky)
+	 {
+
+		 if(sticky && !c->issticky) {
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+			 c->issticky = 1;
+		 } else if(!sticky && c->issticky){
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *)0, 0);
+			 c->issticky = 0;
+			 arrange(c->mon);
+		 }
+	 }
+
+
+void
+setlayout(const Arg *arg)
+{
+	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+		selmon->sellt ^= 1;
+	if (arg && arg->v)
+		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+	if (selmon->sel)
+		arrange(selmon);
+	else
+		drawbar(selmon);
+}
+
+//void
+//shiftview(const Arg *arg) {
+//	Arg shifted;
+//
+//	if(arg->i > 0) /* left circular shift */
+//		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+//		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+//
+//	else /* right circular shift */
+//		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+//		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+//
+//	view(&shifted);
+//}
+//
+//void
+//shifttag(const Arg *arg) {
+//	Arg shifted;
+//	Client *c;
+//
+//	if (!selmon->sel)
+//		return;
+//	c = selmon->sel;
+//
+//	if (arg->i > 0) /* left circular shift */
+//		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+//			^ (c->tags >> (LENGTH(tags) - arg->i));
+//	else /* right circular shift */
+//		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+//			^ (c->tags << (LENGTH(tags) + arg->i));
+//
+//	toggletag(&shifted);
+//}
+
+// https://github.com/ornfelt/dwm/blob/bkp/shiftview.c
+// Or this (used below):
+// https://dwm.suckless.org/patches/shift-tools/shift-tools-scratchpads.c
+
+/* Sends a window to the next/prev tag */
+void
+shifttag(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i)) & ~SPTAGMASK;
+	tag(&shifted);
+}
+/* Sends a window to the next/prev tag that has a client, else it moves it to the next/prev one. */
+void
+shifttagclients(const Arg *arg)
+{
+
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	for (c = selmon->clients; c; c = c->next)
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	else		/* right circular shift */
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	tag(&shifted);
+}
+/* Navigate to the next/prev tag */
+void
+shiftview(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (arg->i > 0) {/* left circular shift */
+		shifted.ui = (shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i));
+		shifted.ui &= ~SPTAGMASK;
+	} else {	/* right circular shift */
+		shifted.ui = (shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i));
+		shifted.ui &= ~SPTAGMASK;
+	}
+	view(&shifted);
+}
+/* Navigate to the next/prev tag that has a client, else moves it to the next/prev tag */
+void
+shiftviewclients(const Arg *arg)
+{
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	for (c = selmon->clients; c; c = c->next)
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+
+
+	if (arg->i > 0)	/* left circular shift */
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	else		/* right circular shift */
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			shifted.ui &= ~SPTAGMASK;
+		} while (tagmask && !(shifted.ui & tagmask));
+	view(&shifted);
 }
+/* move the current active window to the next/prev tag and view it. More like following the window */
+void
+shiftboth(const Arg *arg)
+{
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
 
-int
-stackpos(const Arg *arg)
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+	tag(&shifted);
+	view(&shifted);
+}
+//helper function for shiftswaptags found on:
+//https://github.com/moizifty/DWM-Build/blob/65379c62640788881486401a0d8c79333751b02f/config.h#L48
+// modified to work with scratchpad
+void
+swaptags(const Arg *arg)
 {
-    int n, i;
-    Client *c, *l;
+	Client *c;
+	unsigned int newtag = arg->ui & TAGMASK;
+	unsigned int curtag = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
 
-    if(!selmon->clients)
-        return -1;
+	if (newtag == curtag || !curtag || (curtag & (curtag-1)))
+		return;
 
-    if(arg->i == PREVSEL) {
-        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
-        if(!l)
-            return -1;
-        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return i;
-    }
-    else if(ISINC(arg->i)) {
-        if(!selmon->sel)
-            return -1;
-        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return MOD(i + GETINC(arg->i), n);
-    }
-    else if(arg->i < 0) {
-        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return MAX(i + arg->i, 0);
-    }
-    else
-        return arg->i;
-}
+	for (c = selmon->clients; c != NULL; c = c->next) {
+		if ((c->tags & newtag) || (c->tags & curtag))
+			c->tags ^= curtag ^ newtag;
 
+		if (!c->tags)
+			c->tags = newtag;
+	}
+
+	//move to the swaped tag
+	//selmon->tagset[selmon->seltags] = newtag;
+
+	focus(NULL);
+	arrange(selmon);
+}
+/* swaps "tags" (all the clients) with the next/prev tag. */
 void
-setlayout(const Arg *arg)
+shiftswaptags(const Arg *arg)
 {
-    if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-        selmon->sellt ^= 1;
-    if (arg && arg->v)
-        selmon->lt[selmon->sellt] = (Layout *)arg->v;
-    strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
-    if (selmon->sel)
-        arrange(selmon);
-    else
-        drawbar(selmon);
+	Arg shifted;
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+
+	if (arg->i > 0)	/* left circular shift */
+		shifted.ui = ((shifted.ui << arg->i) | (shifted.ui >> (LENGTH(tags) - arg->i))) & ~SPTAGMASK;
+	else		/* right circular shift */
+		shifted.ui = ((shifted.ui >> (- arg->i) | shifted.ui << (LENGTH(tags) + arg->i))) & ~SPTAGMASK;
+	swaptags(&shifted);
+	// uncomment if you also want to "go" (view) the tag where the the clients are going
+	//view(&shifted);
+}
+
+void
+setcfact(const Arg *arg) {
+	float f;
+	Client *c;
+
+	c = selmon->sel;
+
+	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f + c->cfact;
+	if(arg->f == 0.0)
+		f = 1.0;
+	else if(f < 0.25 || f > 4.0)
+		return;
+	c->cfact = f;
+	arrange(selmon);
 }
 
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
 {
-    float f;
+	float f;
 
-    if (!arg || !selmon->lt[selmon->sellt]->arrange)
-        return;
-    f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-    if (f < 0.05 || f > 0.95)
-        return;
-    selmon->mfact = f;
-    arrange(selmon);
+	if (!arg || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+	if (f < 0.05 || f > 0.95)
+		return;
+	selmon->mfact = f;
+	arrange(selmon);
 }
 
 void
 setup(void)
 {
-    int i;
-    XSetWindowAttributes wa;
-    Atom utf8string;
-    struct sigaction sa;
-
-    /* do not transform children into zombies when they terminate */
-    sigemptyset(&sa.sa_mask);
-    sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
-    sa.sa_handler = SIG_IGN;
-    sigaction(SIGCHLD, &sa, NULL);
-
-    /* clean up any zombies (inherited from .xinitrc etc) immediately */
-    while (waitpid(-1, NULL, WNOHANG) > 0);
-
-    signal(SIGHUP, sighup);
-    signal(SIGTERM, sigterm);
-
-    /* init screen */
-    screen = DefaultScreen(dpy);
-    sw = DisplayWidth(dpy, screen);
-    sh = DisplayHeight(dpy, screen);
-    root = RootWindow(dpy, screen);
-    drw = drw_create(dpy, screen, root, sw, sh);
-    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-        die("no fonts could be loaded.");
-    lrpad = drw->fonts->h;
-    bh = drw->fonts->h + 2;
-    updategeom();
-    /* init atoms */
-    utf8string = XInternAtom(dpy, "UTF8_STRING", False);
-    wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
-    wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-    wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
-    wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
-    netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
-    netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-    netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-    netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
-    netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
-    netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
-    netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
-    netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
-    netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
-    /* init cursors */
-    cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
-    cursor[CurResize] = drw_cur_create(drw, XC_sizing);
-    cursor[CurMove] = drw_cur_create(drw, XC_fleur);
-    /* init appearance */
-    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
-    scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
-    scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-
-    for (i = 0; i < LENGTH(colors); i++)
-        scheme[i] = drw_scm_create(drw, colors[i], 3);
-    /* init bars */
-    updatebars();
-    updatestatus();
-    /* supporting window for NetWMCheck */
-    wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
-    XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-    XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-            PropModeReplace, (unsigned char *) "dwm", 3);
-    XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-    /* EWMH support per view */
-    XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-            PropModeReplace, (unsigned char *) netatom, NetLast);
-    XDeleteProperty(dpy, root, netatom[NetClientList]);
-    /* select events */
-    wa.cursor = cursor[CurNormal]->cursor;
-    wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-        |ButtonPressMask|PointerMotionMask|EnterWindowMask
-        |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
-    XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
-    XSelectInput(dpy, root, wa.event_mask);
-    grabkeys();
-    focus(NULL);
+	int i;
+	XSetWindowAttributes wa;
+	Atom utf8string;
+	struct sigaction sa;
+
+	/* do not transform children into zombies when they terminate */
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
+	sa.sa_handler = SIG_IGN;
+	sigaction(SIGCHLD, &sa, NULL);
+
+	/* clean up any zombies (inherited from .xinitrc etc) immediately */
+	while (waitpid(-1, NULL, WNOHANG) > 0);
+
+	/* init screen */
+	screen = DefaultScreen(dpy);
+	sw = DisplayWidth(dpy, screen);
+	sh = DisplayHeight(dpy, screen);
+	root = RootWindow(dpy, screen);
+	drw = drw_create(dpy, screen, root, sw, sh);
+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+		die("no fonts could be loaded.");
+	lrpad = drw->fonts->h;
+	bh = drw->fonts->h + 2;
+	updategeom();
+	/* init atoms */
+	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
+	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
+	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
+	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
+	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
+	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+	/* init cursors */
+	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
+	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+	/* init appearance */
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+	for (i = 0; i < LENGTH(colors); i++)
+		scheme[i] = drw_scm_create(drw, colors[i], 3);
+	/* init bars */
+	updatebars();
+	updatestatus();
+	/* supporting window for NetWMCheck */
+	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
+		PropModeReplace, (unsigned char *) "dwm", 3);
+	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	/* EWMH support per view */
+	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
+		PropModeReplace, (unsigned char *) netatom, NetLast);
+	XDeleteProperty(dpy, root, netatom[NetClientList]);
+	/* select events */
+	wa.cursor = cursor[CurNormal]->cursor;
+	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
+		|ButtonPressMask|PointerMotionMask|EnterWindowMask
+		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
+	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
+	XSelectInput(dpy, root, wa.event_mask);
+	grabkeys();
+	focus(NULL);
 }
 
 void
 seturgent(Client *c, int urg)
 {
-    XWMHints *wmh;
+	XWMHints *wmh;
 
-    c->isurgent = urg;
-    if (!(wmh = XGetWMHints(dpy, c->win)))
-        return;
-    wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
-    XSetWMHints(dpy, c->win, wmh);
-    XFree(wmh);
+	c->isurgent = urg;
+	if (!(wmh = XGetWMHints(dpy, c->win)))
+		return;
+	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
+	XSetWMHints(dpy, c->win, wmh);
+	XFree(wmh);
 }
 
 void
 showhide(Client *c)
 {
-    if (!c)
-        return;
-    if (ISVISIBLE(c)) {
-        if ((c->tags & SPTAGMASK) && c->isfloating) {
-            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
-        }
-        /* show clients top down */
-        XMoveWindow(dpy, c->win, c->x, c->y);
-        if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-            resize(c, c->x, c->y, c->w, c->h, 0);
-        showhide(c->snext);
-    } else {
-        /* hide clients bottom up */
-        showhide(c->snext);
-        XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
-    }
+	if (!c)
+		return;
+	if (ISVISIBLE(c)) {
+		if ((c->tags & SPTAGMASK) && c->isfloating) {
+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+		}
+		/* show clients top down */
+		XMoveWindow(dpy, c->win, c->x, c->y);
+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+			resize(c, c->x, c->y, c->w, c->h, 0);
+		showhide(c->snext);
+	} else {
+		/* hide clients bottom up */
+		showhide(c->snext);
+		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+	}
 }
 
 void
-sighup(int unused)
+sigstatusbar(const Arg *arg)
 {
-    Arg a = {.i = 1};
-    quit(&a);
+	union sigval sv;
+
+	if (!statussig)
+		return;
+	sv.sival_int = arg->i;
+	if ((statuspid = getstatusbarpid()) <= 0)
+		return;
+
+	sigqueue(statuspid, SIGRTMIN+statussig, sv);
 }
 
 void
-sigterm(int unused)
+spawn(const Arg *arg)
 {
-    Arg a = {.i = 0};
-    quit(&a);
+	struct sigaction sa;
+
+	if (arg->v == dmenucmd)
+		dmenumon[0] = '0' + selmon->num;
+	if (fork() == 0) {
+		if (dpy)
+			close(ConnectionNumber(dpy));
+		setsid();
+
+		sigemptyset(&sa.sa_mask);
+		sa.sa_flags = 0;
+		sa.sa_handler = SIG_DFL;
+		sigaction(SIGCHLD, &sa, NULL);
+
+		execvp(((char **)arg->v)[0], (char **)arg->v);
+		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
+	}
 }
 
-#ifndef __OpenBSD__
-void sigdwmblocks(const Arg *arg)
+int
+stackpos(const Arg *arg) {
+	int n, i;
+	Client *c, *l;
+
+	if(!selmon->clients)
+		return -1;
+
+	if(arg->i == PREVSEL) {
+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+		if(!l)
+			return -1;
+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return i;
+	}
+	else if(ISINC(arg->i)) {
+		if(!selmon->sel)
+			return -1;
+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MOD(i + GETINC(arg->i), n);
+	}
+	else if(arg->i < 0) {
+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MAX(i + arg->i, 0);
+	}
+	else
+		return arg->i;
+}
+
+//void
+//tag(const Arg *arg)
+//{
+//    if (selmon->sel && arg->ui & TAGMASK) {
+//        if (mons && mons->next) {
+//            // Moving to even tag, selected mon != first mon
+//            if ((arg->ui & 341) == 0 && selmon != mons) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//                // Moving to odd tag, selected mon == first mon
+//            } else if ((arg->ui & 341) > 0 && selmon == mons) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//            } else {
+//                tagnextmon(arg);
+//            }
+//        } else {
+//            if (selmon->sel && arg->ui & TAGMASK) {
+//                selmon->sel->tags = arg->ui & TAGMASK;
+//                focus(NULL);
+//                arrange(selmon);
+//            }
+//        }
+//    }
+//}
+
+void
+tag(const Arg *arg)
 {
-    union sigval sv;
-    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
-    if (!dwmblockspid)
-        if (getdwmblockspid() == -1)
-            return;
+    if (!(selmon->sel && arg->ui & TAGMASK))
+        return;
 
-    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
-        if (errno == ESRCH) {
-            if (!getdwmblockspid())
-                sigqueue(dwmblockspid, SIGUSR1, sv);
+    if (mons && mons->next) {
+        // Moving to even tag, selected mon != first mon
+        if ((arg->ui & 341) == 0 && selmon != mons) {
+            selmon->sel->tags = arg->ui & TAGMASK;
         }
+        // Moving to odd tag, selected mon == first mon
+        else if ((arg->ui & 341) > 0 && selmon == mons) {
+            selmon->sel->tags = arg->ui & TAGMASK;
+        } else {
+            tagnextmon(arg);
+            return;
+        }
+    } else {
+        selmon->sel->tags = arg->ui & TAGMASK;
     }
+
+    focus(NULL);
+    arrange(selmon);
 }
-#endif
 
 void
-spawn(const Arg *arg)
+tagview(const Arg *arg)
 {
-    struct sigaction sa;
-    if (fork() == 0) {
-        if (dpy)
-            close(ConnectionNumber(dpy));
-        setsid();
+    if (selmon->sel && arg->ui & TAGMASK) {
+        if (mons && mons->next) {
+            // If first monitor and moving to even tag (second mon)
+            if ((arg->ui & 341) == 0 && selmon == mons) {
+                tagnthmonview(&((Arg) { .i = 1 }));
+                tagnewmon(arg);
+                return;
+            } else if ((arg->ui & 341) > 0 && selmon != mons) {
+                tagnthmonview(&((Arg) { .i = 0 }));
+                tagnewmon(arg);
+                return;
+            }
+        }
+        selmon->sel->tags = arg->ui & TAGMASK;
+        focus(NULL);
+        arrange(selmon);
+        view(arg);
+    }
+}
 
-        sigemptyset(&sa.sa_mask);
-        sa.sa_flags = 0;
-        sa.sa_handler = SIG_DFL;
-        sigaction(SIGCHLD, &sa, NULL);
+void
+tagmon(const Arg *arg)
+{
+	if (!selmon->sel || !mons->next)
+		return;
+	sendmon(selmon->sel, dirtomon(arg->i));
+}
 
-        execvp(((char **)arg->v)[0], (char **)arg->v);
-        die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
-    }
+void
+tagmonview(const Arg *arg)
+{
+    if (!selmon->sel || !mons->next)
+        return;
+    sendmonview(selmon->sel, dirtomon(arg->i));
 }
 
 void
-tag(const Arg *arg)
+tagnextmon(const Arg *arg)
 {
-    if (selmon->sel && arg->ui & TAGMASK) {
-        selmon->sel->tags = arg->ui & TAGMASK;
+    Client *sel;
+    Monitor *newmon;
+
+    if (!selmon->sel || !mons->next)
+        return;
+    sel = selmon->sel;
+    newmon = dirtomon(1);
+    sendmon(sel, newmon);
+    if (sel && arg->ui & TAGMASK) {
+        sel->tags = arg->ui & TAGMASK;
         focus(NULL);
-        arrange(selmon);
+        arrange(newmon);
     }
 }
 
 void
-tagview(const Arg *arg)
+tagnewmon(const Arg *arg)
 {
     if (selmon->sel && arg->ui & TAGMASK) {
         selmon->sel->tags = arg->ui & TAGMASK;
@@ -2109,439 +2489,515 @@ tagview(const Arg *arg)
 }
 
 void
-tagmon(const Arg *arg)
+tagnthmon(const Arg *arg)
 {
     if (!selmon->sel || !mons->next)
         return;
-    sendmon(selmon->sel, dirtomon(arg->i));
+    sendmon(selmon->sel, numtomon(arg->i));
 }
 
 void
-tagmonview(const Arg *arg)
+tagnthmonview(const Arg *arg)
 {
     if (!selmon->sel || !mons->next)
         return;
-    sendmonview(selmon->sel, dirtomon(arg->i));
+    sendmonview(selmon->sel, numtomon(arg->i));
 }
 
 void
 togglebar(const Arg *arg)
 {
-    selmon->showbar = !selmon->showbar;
-    updatebarpos(selmon);
-    XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
-    arrange(selmon);
+	selmon->showbar = !selmon->showbar;
+	updatebarpos(selmon);
+	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+	arrange(selmon);
+}
+
+void
+togglebars(const Arg *arg)
+{
+    Monitor *m;
+    for (m = mons; m; m = m->next) {
+        m->showbar = !m->showbar;
+        updatebarpos(m);
+        XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+        arrange(m);
+    }
 }
 
 void
 togglefloating(const Arg *arg)
 {
-    if (!selmon->sel)
-        return;
-    if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
-        return;
-    selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-    if (selmon->sel->isfloating) {
-        /* selmon->sel->bw = 0; */
-        /* configure(selmon->sel); */
-        /* restore last known float dimensions */
-        resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
-                selmon->sel->sfw, selmon->sel->sfh, False);
-    } else {
-        /* save last known float dimensions */
-        selmon->sel->sfx = selmon->sel->x;
-        selmon->sel->sfy = selmon->sel->y;
-        selmon->sel->sfw = selmon->sel->w;
-        selmon->sel->sfh = selmon->sel->h;
+	if (!selmon->sel)
+		return;
+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+		return;
+	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+
+	if (selmon->sel->isfloating)
+		/* restore last known float dimensions */
+		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
+		       selmon->sel->sfw, selmon->sel->sfh, False);
+	else {
+		/* save last known float dimensions */
+		selmon->sel->sfx = selmon->sel->x;
+		selmon->sel->sfy = selmon->sel->y;
+		selmon->sel->sfw = selmon->sel->w;
+		selmon->sel->sfh = selmon->sel->h;
+	}
+
+ 	//if (selmon->sel->isfloating)
+ 	//	resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+ 	//		//selmon->sel->w, selmon->sel->h, 0);
+ 	//		900, 600, 0);
+
+    if (!selmon->sel->sfx) {
+        selmon->sel->x = selmon->sel->mon->mx + (selmon->sel->mon->mw - WIDTH(selmon->sel)) / 2;
+        selmon->sel->y = selmon->sel->mon->my + (selmon->sel->mon->mh - HEIGHT(selmon->sel)) / 2;
     }
-    arrange(selmon);
+
+	arrange(selmon);
 }
 
 void
 togglefullscr(const Arg *arg)
 {
-    if(selmon->sel)
-        setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+  if(selmon->sel)
+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
 }
 
 void
 togglesticky(const Arg *arg)
 {
-    if (!selmon->sel)
-        return;
-    selmon->sel->issticky = !selmon->sel->issticky;
-    arrange(selmon);
+	if (!selmon->sel)
+		return;
+	setsticky(selmon->sel, !selmon->sel->issticky);
+	arrange(selmon);
 }
 
 void
 togglescratch(const Arg *arg)
 {
-    Client *c;
-    unsigned int found = 0;
-    unsigned int scratchtag = SPTAG(arg->ui);
-    Arg sparg = {.v = scratchpads[arg->ui].cmd};
-
-    for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
-    if (found) {
-        unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
-        if (newtagset) {
-            selmon->tagset[selmon->seltags] = newtagset;
-            focus(NULL);
-            arrange(selmon);
-        }
-        if (ISVISIBLE(c)) {
-            focus(c);
-            restack(selmon);
-        }
-    } else {
-        selmon->tagset[selmon->seltags] |= scratchtag;
-        spawn(&sparg);
-    }
+	Client *c;
+	unsigned int found = 0;
+	unsigned int scratchtag = SPTAG(arg->ui);
+	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+
+	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+	if (found) {
+		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+		if (newtagset) {
+			selmon->tagset[selmon->seltags] = newtagset;
+			focus(NULL);
+			arrange(selmon);
+		}
+		if (ISVISIBLE(c)) {
+			focus(c);
+			restack(selmon);
+		}
+	} else {
+		selmon->tagset[selmon->seltags] |= scratchtag;
+		spawn(&sparg);
+	}
 }
 
 void
 toggletag(const Arg *arg)
 {
-    unsigned int newtags;
+	unsigned int newtags;
 
-    if (!selmon->sel)
-        return;
-    newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
-    if (newtags) {
-        selmon->sel->tags = newtags;
-        focus(NULL);
-        arrange(selmon);
-    }
+	if (!selmon->sel)
+		return;
+	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
+	if (newtags) {
+		selmon->sel->tags = newtags;
+		focus(NULL);
+		arrange(selmon);
+	}
 }
 
 void
 toggleview(const Arg *arg)
 {
-    unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
 
-    if (newtagset) {
-        selmon->tagset[selmon->seltags] = newtagset;
-        focus(NULL);
-        arrange(selmon);
-    }
+	if (newtagset) {
+		selmon->tagset[selmon->seltags] = newtagset;
+		focus(NULL);
+		arrange(selmon);
+	}
 }
 
 void
 unfocus(Client *c, int setfocus)
 {
-    if (!c)
-        return;
-    grabbuttons(c, 0);
-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-    if (setfocus) {
-        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-    }
+	if (!c)
+		return;
+	grabbuttons(c, 0);
+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+	if (setfocus) {
+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	}
 }
 
 void
 unmanage(Client *c, int destroyed)
 {
-    Monitor *m = c->mon;
-    XWindowChanges wc;
-
-    if (c->swallowing) {
-        unswallow(c);
-        return;
-    }
-
-    Client *s = swallowingclient(c->win);
-    if (s) {
-        free(s->swallowing);
-        s->swallowing = NULL;
-        arrange(m);
-        focus(NULL);
-        return;
-    }
-
-    detach(c);
-    detachstack(c);
-    if (!destroyed) {
-        wc.border_width = c->oldbw;
-        XGrabServer(dpy); /* avoid race conditions */
-        XSetErrorHandler(xerrordummy);
-        XSelectInput(dpy, c->win, NoEventMask);
-        XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
-        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-        setclientstate(c, WithdrawnState);
-        XSync(dpy, False);
-        XSetErrorHandler(xerror);
-        XUngrabServer(dpy);
-    }
-    free(c);
-
-    if (!s) {
-        arrange(m);
-        focus(NULL);
-        updateclientlist();
-    }
+	Monitor *m = c->mon;
+	XWindowChanges wc;
+
+	if (c->swallowing) {
+		unswallow(c);
+		return;
+	}
+
+	Client *s = swallowingclient(c->win);
+	if (s) {
+		free(s->swallowing);
+		s->swallowing = NULL;
+		arrange(m);
+		focus(NULL);
+		return;
+	}
+
+	detach(c);
+	detachstack(c);
+	if (!destroyed) {
+		wc.border_width = c->oldbw;
+		XGrabServer(dpy); /* avoid race conditions */
+		XSetErrorHandler(xerrordummy);
+		XSelectInput(dpy, c->win, NoEventMask);
+		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+		setclientstate(c, WithdrawnState);
+		XSync(dpy, False);
+		XSetErrorHandler(xerror);
+		XUngrabServer(dpy);
+	}
+	free(c);
+
+	if (!s) {
+		arrange(m);
+		focus(NULL);
+		updateclientlist();
+	}
 }
 
 void
 unmapnotify(XEvent *e)
 {
-    Client *c;
-    XUnmapEvent *ev = &e->xunmap;
+	Client *c;
+	XUnmapEvent *ev = &e->xunmap;
 
-    if ((c = wintoclient(ev->window))) {
-        if (ev->send_event)
-            setclientstate(c, WithdrawnState);
-        else
-            unmanage(c, 0);
-    }
+	if ((c = wintoclient(ev->window))) {
+		if (ev->send_event)
+			setclientstate(c, WithdrawnState);
+		else
+			unmanage(c, 0);
+	}
 }
 
 void
 updatebars(void)
 {
-    Monitor *m;
-    XSetWindowAttributes wa = {
-        .override_redirect = True,
-        .background_pixmap = ParentRelative,
-        .event_mask = ButtonPressMask|ExposureMask
-    };
-    XClassHint ch = {"dwm", "dwm"};
-    for (m = mons; m; m = m->next) {
-        if (m->barwin)
-            continue;
-        m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
-                CopyFromParent, DefaultVisual(dpy, screen),
-                CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
-        XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
-        XMapRaised(dpy, m->barwin);
-        XSetClassHint(dpy, m->barwin, &ch);
-    }
+	Monitor *m;
+	XSetWindowAttributes wa = {
+		.override_redirect = True,
+		.background_pixmap = ParentRelative,
+		.event_mask = ButtonPressMask|ExposureMask
+	};
+	XClassHint ch = {"dwm", "dwm"};
+	for (m = mons; m; m = m->next) {
+		if (m->barwin)
+			continue;
+		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+				CopyFromParent, DefaultVisual(dpy, screen),
+				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+		XMapRaised(dpy, m->barwin);
+		XSetClassHint(dpy, m->barwin, &ch);
+	}
 }
 
 void
 updatebarpos(Monitor *m)
 {
-    m->wy = m->my;
-    m->wh = m->mh;
-    if (m->showbar) {
-        m->wh -= bh;
-        m->by = m->topbar ? m->wy : m->wy + m->wh;
-        m->wy = m->topbar ? m->wy + bh : m->wy;
-    } else
-        m->by = -bh;
+	m->wy = m->my;
+	m->wh = m->mh;
+	if (m->showbar) {
+		m->wh -= bh;
+		m->by = m->topbar ? m->wy : m->wy + m->wh;
+		m->wy = m->topbar ? m->wy + bh : m->wy;
+	} else
+		m->by = -bh;
 }
 
 void
 updateclientlist(void)
 {
-    Client *c;
-    Monitor *m;
+	Client *c;
+	Monitor *m;
 
-    XDeleteProperty(dpy, root, netatom[NetClientList]);
-    for (m = mons; m; m = m->next)
-        for (c = m->clients; c; c = c->next)
-            XChangeProperty(dpy, root, netatom[NetClientList],
-                    XA_WINDOW, 32, PropModeAppend,
-                    (unsigned char *) &(c->win), 1);
+	XDeleteProperty(dpy, root, netatom[NetClientList]);
+	for (m = mons; m; m = m->next)
+		for (c = m->clients; c; c = c->next)
+			XChangeProperty(dpy, root, netatom[NetClientList],
+				XA_WINDOW, 32, PropModeAppend,
+				(unsigned char *) &(c->win), 1);
 }
 
 int
 updategeom(void)
 {
-    int dirty = 0;
+	int dirty = 0;
 
 #ifdef XINERAMA
-    if (XineramaIsActive(dpy)) {
+	if (XineramaIsActive(dpy)) {
         int i, j, n, nn;
-        Client *c;
-        Monitor *m;
+        Client *c, *next_client;
+        Monitor *m, *primary, *secondary, *current_monitor;
         XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
         XineramaScreenInfo *unique = NULL;
 
-        for (n = 0, m = mons; m; m = m->next, n++);
-        /* only consider unique geometries as separate screens */
-        unique = ecalloc(nn, sizeof(XineramaScreenInfo));
-        for (i = 0, j = 0; i < nn; i++)
-            if (isuniquegeom(unique, j, &info[i]))
-                memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
-        XFree(info);
-        nn = j;
-        if (n <= nn) { /* new monitors available */
-            for (i = 0; i < (nn - n); i++) {
-                for (m = mons; m && m->next; m = m->next);
-                if (m)
-                    m->next = createmon();
-                else
-                    mons = createmon();
-            }
-            for (i = 0, m = mons; i < nn && m; m = m->next, i++)
-                if (i >= n
-                        || unique[i].x_org != m->mx || unique[i].y_org != m->my
-                        || unique[i].width != m->mw || unique[i].height != m->mh)
-                {
-                    dirty = 1;
-                    m->num = i;
-                    m->mx = m->wx = unique[i].x_org;
-                    m->my = m->wy = unique[i].y_org;
-                    m->mw = m->ww = unique[i].width;
-                    m->mh = m->wh = unique[i].height;
-                    updatebarpos(m);
+		for (n = 0, m = mons; m; m = m->next, n++);
+		/* only consider unique geometries as separate screens */
+		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
+		for (i = 0, j = 0; i < nn; i++)
+			if (isuniquegeom(unique, j, &info[i]))
+				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
+		XFree(info);
+		nn = j;
+
+		/* new monitors if nn > n */
+		for (i = n; i < nn; i++) {
+			for (m = mons; m && m->next; m = m->next);
+			if (m)
+				m->next = createmon();
+			else
+				mons = createmon();
+		}
+
+        /* Logic for moving clients */
+        if (nn == 2) {
+            /* Case with exactly two monitors: Move even-tagged clients */
+            primary = mons;         /* First monitor */
+            secondary = mons->next; /* Second monitor */
+
+            if (primary && secondary) {
+                for (c = primary->clients; c; c = next_client) {
+                    next_client = c->next;
+
+                    /* Check if the client belongs to an even tag */
+                    if (c->tags & 0b010101010) { /* Even tags: 2, 4, 6, 8 */
+                        detach(c);               /* Detach from primary monitor */
+                        detachstack(c);
+
+                        c->mon = secondary;     /* Assign to secondary monitor */
+                        attach(c);              /* Attach to secondary monitor */
+                        attachstack(c);
+                    }
                 }
-        } else { /* less monitors available nn < n */
-            for (i = nn; i < n; i++) {
-                for (m = mons; m && m->next; m = m->next);
-                while ((c = m->clients)) {
-                    dirty = 1;
-                    m->clients = c->next;
+            }
+        } else if (nn > 2) {
+            /* Case with more than two monitors: Move clients cyclically */
+            for (m = mons; m; m = m->next) {
+                current_monitor = m; /* Start with the current monitor */
+
+                for (c = current_monitor->clients; c; c = next_client) {
+                    next_client = c->next;
+
+                    /* Determine the next monitor cyclically */
+                    Monitor *next_monitor = current_monitor->next ? current_monitor->next : mons;
+
+                    detach(c);               /* Detach client from current monitor */
                     detachstack(c);
-                    c->mon = mons;
-                    attach(c);
+
+                    c->mon = next_monitor;   /* Assign client to the next monitor */
+                    attach(c);               /* Attach to the next monitor */
                     attachstack(c);
+
+                    current_monitor = next_monitor; /* Update current monitor */
                 }
-                if (m == selmon)
-                    selmon = mons;
-                cleanupmon(m);
             }
         }
-        free(unique);
-    } else
+
+		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
+			if (i >= n
+			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
+			|| unique[i].width != m->mw || unique[i].height != m->mh)
+			{
+				dirty = 1;
+				m->num = i;
+				m->mx = m->wx = unique[i].x_org;
+				m->my = m->wy = unique[i].y_org;
+				m->mw = m->ww = unique[i].width;
+				m->mh = m->wh = unique[i].height;
+				updatebarpos(m);
+			}
+		/* removed monitors if n > nn */
+		for (i = nn; i < n; i++) {
+			for (m = mons; m && m->next; m = m->next);
+			while ((c = m->clients)) {
+				dirty = 1;
+				m->clients = c->next;
+				detachstack(c);
+				c->mon = mons;
+				attach(c);
+				attachstack(c);
+			}
+			if (m == selmon)
+				selmon = mons;
+			cleanupmon(m);
+		}
+		free(unique);
+	} else
 #endif /* XINERAMA */
-    { /* default monitor setup */
-        if (!mons)
-            mons = createmon();
-        if (mons->mw != sw || mons->mh != sh) {
-            dirty = 1;
-            mons->mw = mons->ww = sw;
-            mons->mh = mons->wh = sh;
-            updatebarpos(mons);
-        }
-    }
-    if (dirty) {
-        selmon = mons;
-        selmon = wintomon(root);
-    }
-    return dirty;
+	{ /* default monitor setup */
+		if (!mons)
+			mons = createmon();
+		if (mons->mw != sw || mons->mh != sh) {
+			dirty = 1;
+			mons->mw = mons->ww = sw;
+			mons->mh = mons->wh = sh;
+			updatebarpos(mons);
+		}
+	}
+	if (dirty) {
+		selmon = mons;
+		selmon = wintomon(root);
+	}
+	return dirty;
 }
 
 void
 updatenumlockmask(void)
 {
-    unsigned int i, j;
-    XModifierKeymap *modmap;
+	unsigned int i, j;
+	XModifierKeymap *modmap;
 
-    numlockmask = 0;
-    modmap = XGetModifierMapping(dpy);
-    for (i = 0; i < 8; i++)
-        for (j = 0; j < modmap->max_keypermod; j++)
-            if (modmap->modifiermap[i * modmap->max_keypermod + j]
-                    == XKeysymToKeycode(dpy, XK_Num_Lock))
-                numlockmask = (1 << i);
-    XFreeModifiermap(modmap);
+	numlockmask = 0;
+	modmap = XGetModifierMapping(dpy);
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < modmap->max_keypermod; j++)
+			if (modmap->modifiermap[i * modmap->max_keypermod + j]
+				== XKeysymToKeycode(dpy, XK_Num_Lock))
+				numlockmask = (1 << i);
+	XFreeModifiermap(modmap);
 }
 
 void
 updatesizehints(Client *c)
 {
-    long msize;
-    XSizeHints size;
-
-    if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
-        /* size is uninitialized, ensure that size.flags aren't used */
-        size.flags = PSize;
-    if (size.flags & PBaseSize) {
-        c->basew = size.base_width;
-        c->baseh = size.base_height;
-    } else if (size.flags & PMinSize) {
-        c->basew = size.min_width;
-        c->baseh = size.min_height;
-    } else
-        c->basew = c->baseh = 0;
-    if (size.flags & PResizeInc) {
-        c->incw = size.width_inc;
-        c->inch = size.height_inc;
-    } else
-        c->incw = c->inch = 0;
-    if (size.flags & PMaxSize) {
-        c->maxw = size.max_width;
-        c->maxh = size.max_height;
-    } else
-        c->maxw = c->maxh = 0;
-    if (size.flags & PMinSize) {
-        c->minw = size.min_width;
-        c->minh = size.min_height;
-    } else if (size.flags & PBaseSize) {
-        c->minw = size.base_width;
-        c->minh = size.base_height;
-    } else
-        c->minw = c->minh = 0;
-    if (size.flags & PAspect) {
-        c->mina = (float)size.min_aspect.y / size.min_aspect.x;
-        c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
-    } else
-        c->maxa = c->mina = 0.0;
-    c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
-    c->hintsvalid = 1;
+	long msize;
+	XSizeHints size;
+
+	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
+		/* size is uninitialized, ensure that size.flags aren't used */
+		size.flags = PSize;
+	if (size.flags & PBaseSize) {
+		c->basew = size.base_width;
+		c->baseh = size.base_height;
+	} else if (size.flags & PMinSize) {
+		c->basew = size.min_width;
+		c->baseh = size.min_height;
+	} else
+		c->basew = c->baseh = 0;
+	if (size.flags & PResizeInc) {
+		c->incw = size.width_inc;
+		c->inch = size.height_inc;
+	} else
+		c->incw = c->inch = 0;
+	if (size.flags & PMaxSize) {
+		c->maxw = size.max_width;
+		c->maxh = size.max_height;
+	} else
+		c->maxw = c->maxh = 0;
+	if (size.flags & PMinSize) {
+		c->minw = size.min_width;
+		c->minh = size.min_height;
+	} else if (size.flags & PBaseSize) {
+		c->minw = size.base_width;
+		c->minh = size.base_height;
+	} else
+		c->minw = c->minh = 0;
+	if (size.flags & PAspect) {
+		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
+		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
+	} else
+		c->maxa = c->mina = 0.0;
+	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
+	c->hintsvalid = 1;
 }
 
 void
 updatestatus(void)
 {
-    Monitor* m;
-    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
-        strcpy(stext, "dwm-"VERSION);
-    else
-        copyvalidchars(stext, rawstext);
-    /* drawbar(selmon); */
-    for(m = mons; m; m = m->next)
-        drawbar(m);
+	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+		strcpy(stext, "dwm-"VERSION);
+	drawbar(selmon);
 }
 
 void
 updatetitle(Client *c)
 {
-    if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
-        gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-    if (c->name[0] == '\0') /* hack to mark broken clients */
-        strcpy(c->name, broken);
+	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
+		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
+	if (c->name[0] == '\0') /* hack to mark broken clients */
+		strcpy(c->name, broken);
 }
 
 void
 updatewindowtype(Client *c)
 {
-    Atom state = getatomprop(c, netatom[NetWMState]);
-    Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
+	Atom state = getatomprop(c, netatom[NetWMState]);
+	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
 
-    if (state == netatom[NetWMFullscreen])
-        setfullscreen(c, 1);
-    if (wtype == netatom[NetWMWindowTypeDialog])
-        c->isfloating = 1;
+	if (state == netatom[NetWMFullscreen])
+		setfullscreen(c, 1);
+	if (state == netatom[NetWMSticky]) {
+		setsticky(c, 1);
+	}
+	if (wtype == netatom[NetWMWindowTypeDialog])
+		c->isfloating = 1;
 }
 
 void
 updatewmhints(Client *c)
 {
-    XWMHints *wmh;
+	XWMHints *wmh;
 
-    if ((wmh = XGetWMHints(dpy, c->win))) {
-        if (c == selmon->sel && wmh->flags & XUrgencyHint) {
-            wmh->flags &= ~XUrgencyHint;
-            XSetWMHints(dpy, c->win, wmh);
-        } else
-            c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
-        if (wmh->flags & InputHint)
-            c->neverfocus = !wmh->input;
-        else
-            c->neverfocus = 0;
-        XFree(wmh);
-    }
+	if ((wmh = XGetWMHints(dpy, c->win))) {
+		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+			wmh->flags &= ~XUrgencyHint;
+			XSetWMHints(dpy, c->win, wmh);
+		} else
+			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+		if (wmh->flags & InputHint)
+			c->neverfocus = !wmh->input;
+		else
+			c->neverfocus = 0;
+		XFree(wmh);
+	}
 }
 
 void
 view(const Arg *arg)
 {
-    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
-        view(&((Arg) { .ui = 0 }));
-        return;
+    if (mons && mons->next) {
+        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+            return;
+
+        // GENIUS 101010101
+        if ((arg->ui & 341) == 0)
+            focusnthmon(&((Arg) { .i = 1 }));
+        else
+            focusnthmon(&((Arg) { .i = 0 }));
+    } else {
+        if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) { 
+            view(&((Arg) { .ui = 0 })); 
+            return; 
+        } 
     }
 
     selmon->seltags ^= 1; /* toggle sel tagset */
@@ -2554,135 +3010,161 @@ view(const Arg *arg)
 pid_t
 winpid(Window w)
 {
-    pid_t result = 0;
 
-    xcb_res_client_id_spec_t spec = {0};
-    spec.client = w;
-    spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+	pid_t result = 0;
 
-    xcb_generic_error_t *e = NULL;
-    xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
-    xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+#ifdef __linux__
+	xcb_res_client_id_spec_t spec = {0};
+	spec.client = w;
+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
 
-    if (!r)
-        return (pid_t)0;
+	xcb_generic_error_t *e = NULL;
+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
 
-    xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
-    for (; i.rem; xcb_res_client_id_value_next(&i)) {
-        spec = i.data->spec;
-        if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
-            uint32_t *t = xcb_res_client_id_value_value(i.data);
-            result = *t;
-            break;
-        }
-    }
+	if (!r)
+		return (pid_t)0;
+
+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+		spec = i.data->spec;
+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+			uint32_t *t = xcb_res_client_id_value_value(i.data);
+			result = *t;
+			break;
+		}
+	}
+
+	free(r);
+
+	if (result == (pid_t)-1)
+		result = 0;
+
+#endif /* __linux__ */
 
-    free(r);
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
 
-    if (result == (pid_t)-1)
-        result = 0;
-    return result;
+#endif /* __OpenBSD__ */
+	return result;
 }
 
 pid_t
 getparentprocess(pid_t p)
 {
-    unsigned int v = 0;
+	unsigned int v = 0;
+
+#ifdef __linux__
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
 
-#if defined(__linux__)
-    FILE *f;
-    char buf[256];
-    snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+	if (!(f = fopen(buf, "r")))
+		return 0;
 
-    if (!(f = fopen(buf, "r")))
-        return (pid_t)0;
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+#endif /* __linux__*/
 
-    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
-        v = (pid_t)0;
-    fclose(f);
-#elif defined(__FreeBSD__)
-    struct kinfo_proc *proc = kinfo_getproc(p);
-    if (!proc)
-        return (pid_t)0;
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
 
-    v = proc->ki_ppid;
-    free(proc);
-#endif
-    return (pid_t)v;
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
+
+	return (pid_t)v;
 }
 
 int
 isdescprocess(pid_t p, pid_t c)
 {
-    while (p != c && c != 0)
-        c = getparentprocess(c);
+	while (p != c && c != 0)
+		c = getparentprocess(c);
 
-    return (int)c;
+	return (int)c;
 }
 
 Client *
 termforwin(const Client *w)
 {
-    Client *c;
-    Monitor *m;
+	Client *c;
+	Monitor *m;
 
-    if (!w->pid || w->isterminal)
-        return NULL;
+	if (!w->pid || w->isterminal)
+		return NULL;
 
-    for (m = mons; m; m = m->next) {
-        for (c = m->clients; c; c = c->next) {
-            if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
-                return c;
-        }
-    }
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+				return c;
+		}
+	}
 
-    return NULL;
+	return NULL;
 }
 
 Client *
 swallowingclient(Window w)
 {
-    Client *c;
-    Monitor *m;
+	Client *c;
+	Monitor *m;
 
-    for (m = mons; m; m = m->next) {
-        for (c = m->clients; c; c = c->next) {
-            if (c->swallowing && c->swallowing->win == w)
-                return c;
-        }
-    }
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->swallowing && c->swallowing->win == w)
+				return c;
+		}
+	}
 
-    return NULL;
+	return NULL;
 }
 
 Client *
 wintoclient(Window w)
 {
-    Client *c;
-    Monitor *m;
+	Client *c;
+	Monitor *m;
 
-    for (m = mons; m; m = m->next)
-        for (c = m->clients; c; c = c->next)
-            if (c->win == w)
-                return c;
-    return NULL;
+	for (m = mons; m; m = m->next)
+		for (c = m->clients; c; c = c->next)
+			if (c->win == w)
+				return c;
+	return NULL;
 }
 
 Monitor *
 wintomon(Window w)
 {
-    int x, y;
-    Client *c;
-    Monitor *m;
+	int x, y;
+	Client *c;
+	Monitor *m;
 
-    if (w == root && getrootptr(&x, &y))
-        return recttomon(x, y, 1, 1);
-    for (m = mons; m; m = m->next)
-        if (w == m->barwin)
-            return m;
-    if ((c = wintoclient(w)))
-        return c->mon;
-    return selmon;
+	if (w == root && getrootptr(&x, &y))
+		return recttomon(x, y, 1, 1);
+	for (m = mons; m; m = m->next)
+		if (w == m->barwin)
+			return m;
+	if ((c = wintoclient(w)))
+		return c->mon;
+	return selmon;
 }
 
 /* There's no way to check accesses to destroyed windows, thus those cases are
@@ -2691,25 +3173,25 @@ wintomon(Window w)
 int
 xerror(Display *dpy, XErrorEvent *ee)
 {
-    if (ee->error_code == BadWindow
-            || (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
-            || (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
-            || (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
-            || (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
-            || (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
-            || (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
-            || (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
-            || (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
-        return 0;
-    fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-            ee->request_code, ee->error_code);
-    return xerrorxlib(dpy, ee); /* may call exit */
+	if (ee->error_code == BadWindow
+	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
+	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
+	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
+	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
+	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
+		return 0;
+	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
+		ee->request_code, ee->error_code);
+	return xerrorxlib(dpy, ee); /* may call exit */
 }
 
 int
 xerrordummy(Display *dpy, XErrorEvent *ee)
 {
-    return 0;
+	return 0;
 }
 
 /* Startup Error handler to check if another window manager
@@ -2717,107 +3199,103 @@ xerrordummy(Display *dpy, XErrorEvent *ee)
 int
 xerrorstart(Display *dpy, XErrorEvent *ee)
 {
-    die("dwm: another window manager is already running");
-    return -1;
+	die("dwm: another window manager is already running");
+	return -1;
 }
 
 void
 zoom(const Arg *arg)
 {
-    Client *c = selmon->sel;
+	Client *c = selmon->sel;
 
-    if (!selmon->lt[selmon->sellt]->arrange
-            || (selmon->sel && selmon->sel->isfloating))
-        return;
-    if (c == nexttiled(selmon->clients))
-        if (!c || !(c = nexttiled(c->next)))
-            return;
-    pop(c);
+	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
+		return;
+	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
+		return;
+	pop(c);
 }
 
 void
 resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
 {
-    char *sdst = NULL;
-    int *idst = NULL;
-    float *fdst = NULL;
-
-    sdst = dst;
-    idst = dst;
-    fdst = dst;
-
-    char fullname[256];
-    char *type;
-    XrmValue ret;
-
-    snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
-    fullname[sizeof(fullname) - 1] = '\0';
-
-    XrmGetResource(db, fullname, "*", &type, &ret);
-    if (!(ret.addr == NULL || strncmp("String", type, 64)))
-    {
-        switch (rtype) {
-            case STRING:
-                strcpy(sdst, ret.addr);
-                break;
-            case INTEGER:
-                *idst = strtoul(ret.addr, NULL, 10);
-                break;
-            case FLOAT:
-                *fdst = strtof(ret.addr, NULL);
-                break;
-        }
-    }
+	char *sdst = NULL;
+	int *idst = NULL;
+	float *fdst = NULL;
+
+	sdst = dst;
+	idst = dst;
+	fdst = dst;
+
+	char fullname[256];
+	char *type;
+	XrmValue ret;
+
+	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
+	fullname[sizeof(fullname) - 1] = '\0';
+
+	XrmGetResource(db, fullname, "*", &type, &ret);
+	if (!(ret.addr == NULL || strncmp("String", type, 64)))
+	{
+		switch (rtype) {
+		case STRING:
+			strcpy(sdst, ret.addr);
+			break;
+		case INTEGER:
+			*idst = strtoul(ret.addr, NULL, 10);
+			break;
+		case FLOAT:
+			*fdst = strtof(ret.addr, NULL);
+			break;
+		}
+	}
 }
 
 void
 load_xresources(void)
 {
-    Display *display;
-    char *resm;
-    XrmDatabase db;
-    ResourcePref *p;
+	Display *display;
+	char *resm;
+	XrmDatabase db;
+	ResourcePref *p;
 
-    display = XOpenDisplay(NULL);
-    resm = XResourceManagerString(display);
-    if (!resm)
-        return;
+	display = XOpenDisplay(NULL);
+	resm = XResourceManagerString(display);
+	if (!resm)
+		return;
 
-    db = XrmGetStringDatabase(resm);
-    for (p = resources; p < resources + LENGTH(resources); p++)
-        resource_load(db, p->name, p->type, p->dst);
-    XCloseDisplay(display);
+	db = XrmGetStringDatabase(resm);
+	for (p = resources; p < resources + LENGTH(resources); p++)
+		resource_load(db, p->name, p->type, p->dst);
+	XCloseDisplay(display);
 }
 
 int
 main(int argc, char *argv[])
 {
-    if (argc == 2 && !strcmp("-v", argv[1]))
-        die("dwm-"VERSION);
-    else if (argc != 1)
-        die("usage: dwm [-v]");
-    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-        fputs("warning: no locale support\n", stderr);
-    if (!(dpy = XOpenDisplay(NULL)))
-        die("dwm: cannot open display");
-    if (!(xcon = XGetXCBConnection(dpy)))
-        die("dwm: cannot get xcb connection\n");
-    checkotherwm();
-    XrmInitialize();
-    load_xresources();
-    setup();
+	if (argc == 2 && !strcmp("-v", argv[1]))
+		die("dwm-"VERSION);
+	else if (argc != 1)
+		die("usage: dwm [-v]");
+	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+		fputs("warning: no locale support\n", stderr);
+	if (!(dpy = XOpenDisplay(NULL)))
+		die("dwm: cannot open display");
+	if (!(xcon = XGetXCBConnection(dpy)))
+		die("dwm: cannot get xcb connection\n");
+	checkotherwm();
+	XrmInitialize();
+	load_xresources();
+	setup();
 #ifdef __OpenBSD__
-    if (pledge("stdio rpath proc exec", NULL) == -1)
-        die("pledge");
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+		die("pledge");
 #endif /* __OpenBSD__ */
-    scan();
-    runAutostart();
-    /* runautostart(); */
-    enablegaps = 1;
+	scan();
+	runautostart();
     arrange(selmon);
-    run();
-    if(restart) execvp(argv[0], argv);
-    cleanup();
-    XCloseDisplay(dpy);
-    return EXIT_SUCCESS;
+	run();
+	cleanup();
+	XCloseDisplay(dpy);
+	return EXIT_SUCCESS;
 }
+
diff --git a/dwm.png b/dwm.png
new file mode 100644
index 0000000..b1f9ba7
Binary files /dev/null and b/dwm.png differ
diff --git a/gen_diffs.sh b/gen_diffs.sh
new file mode 100755
index 0000000..2d35555
--- /dev/null
+++ b/gen_diffs.sh
@@ -0,0 +1,11 @@
+#! /usr/bin/bash
+
+if ! git rev-parse --verify upstream/master >/dev/null 2>&1; then
+    echo "Error: 'upstream/master' does not exist. Please add it..."
+    exit 1
+fi
+
+git diff upstream/master...master > diff_upstream.diff
+git diff origin/bkp -- . ":(exclude)*.diff" ":(exclude)config.def.h" ":(exclude).gitignore" ":(exclude)patches/**" ":(exclude)patches_git/**" > diff_bkp.diff
+git diff origin/new -- . ":(exclude)*.diff" ":(exclude)config.def.h" ":(exclude).gitignore" ":(exclude)patches/**" ":(exclude)patches_git/**" > diff_new.diff
+
diff --git a/shiftview.c b/shiftview.c
deleted file mode 100644
index 7905a6d..0000000
--- a/shiftview.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/** Function to shift the current view to the left/right
- *
- * @param: "arg->i" stores the number of tags to shift right (positive value)
- *          or left (negative value)
- */
-void
-shiftview(const Arg *arg)
-{
-    Arg shifted;
-    Client *c;
-    unsigned int tagmask = 0;
-
-    for (c = selmon->clients; c; c = c->next)
-        if (!(c->tags & SPTAGMASK))
-            tagmask = tagmask | c->tags;
-
-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
-    if (arg->i > 0) /* left circular shift */
-        do {
-            shifted.ui = (shifted.ui << arg->i)
-                | (shifted.ui >> (LENGTH(tags) - arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-    else /* right circular shift */
-        do {
-            shifted.ui = (shifted.ui >> (- arg->i)
-                    | shifted.ui << (LENGTH(tags) + arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-
-    view(&shifted);
-}
-
-void
-shifttag(const Arg *arg)
-{
-    Arg a;
-    Client *c;
-    unsigned visible = 0;
-    int i = arg->i;
-    int count = 0;
-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
-
-    do {
-        if(i > 0) // left circular shift
-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
-
-        else // right circular shift
-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
-
-        // Check if tag is visible
-        for (c = selmon->clients; c && !visible; c = c->next)
-            if (nextseltags & c->tags) {
-                visible = 1;
-                break;
-            }
-        i += arg->i;
-    } while (!visible && ++count < 10);
-
-    if (count < 10) {
-        a.i = nextseltags;
-        tag(&a);
-    }
-}
diff --git a/test.c b/test.c
deleted file mode 100644
index 50e4cba..0000000
--- a/test.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-
-int
-main()
-{
-    char s[1000];
-    int i, alphabets=0, digits=0, specialchars=0;
-    /* printf("Enter string"); */
-    /* gets(s); */
-
-    FILE *ptr;
-    char ch;
-    ptr = fopen("/home/jonas/test.txt", "r");
-    if (ptr == NULL) printf("Fail...");
-    do{
-        ch = fgetc(ptr);
-        /* printf("%c", ch); */
-        /* printf("%c %d \n", ch, ch); */
-        printf("%d\n", ch);
-        /* printf("%d", ch); */
-    } while (ch != EOF);
-    fclose(ptr);
-
-    /* for(int i = 0;s[i]; i++){ */
-    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
-    /*         alphabets++; */
-    /*     else if (s[i]>48 && s[i] <=57) digits++; */
-    /*     else specialchars++; */
-
-    /* } */
-    /* printf("Alphas = %d}n", alphabets); */
-    /* printf("Digits = %d\n", digits); */
-    /* printf("Spec chars = %d", specialchars); */
-
-    return 0;
-}
diff --git a/transient.c b/transient.c
index 802b66a..040adb5 100644
--- a/transient.c
+++ b/transient.c
@@ -6,37 +6,37 @@
 #include <X11/Xutil.h>
 
 int main(void) {
-    Display *d;
-    Window r, f, t = None;
-    XSizeHints h;
-    XEvent e;
+	Display *d;
+	Window r, f, t = None;
+	XSizeHints h;
+	XEvent e;
 
-    d = XOpenDisplay(NULL);
-    if (!d)
-        exit(1);
-    r = DefaultRootWindow(d);
+	d = XOpenDisplay(NULL);
+	if (!d)
+		exit(1);
+	r = DefaultRootWindow(d);
 
-    f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
-    h.min_width = h.max_width = h.min_height = h.max_height = 400;
-    h.flags = PMinSize | PMaxSize;
-    XSetWMNormalHints(d, f, &h);
-    XStoreName(d, f, "floating");
-    XMapWindow(d, f);
+	f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
+	h.min_width = h.max_width = h.min_height = h.max_height = 400;
+	h.flags = PMinSize | PMaxSize;
+	XSetWMNormalHints(d, f, &h);
+	XStoreName(d, f, "floating");
+	XMapWindow(d, f);
 
-    XSelectInput(d, f, ExposureMask);
-    while (1) {
-        XNextEvent(d, &e);
+	XSelectInput(d, f, ExposureMask);
+	while (1) {
+		XNextEvent(d, &e);
 
-        if (t == None) {
-            sleep(5);
-            t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
-            XSetTransientForHint(d, t, f);
-            XStoreName(d, t, "transient");
-            XMapWindow(d, t);
-            XSelectInput(d, t, ExposureMask);
-        }
-    }
+		if (t == None) {
+			sleep(5);
+			t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
+			XSetTransientForHint(d, t, f);
+			XStoreName(d, t, "transient");
+			XMapWindow(d, t);
+			XSelectInput(d, t, ExposureMask);
+		}
+	}
 
-    XCloseDisplay(d);
-    exit(0);
+	XCloseDisplay(d);
+	exit(0);
 }
diff --git a/util.c b/util.c
index c8b1dcd..8e26a51 100644
--- a/util.c
+++ b/util.c
@@ -7,29 +7,31 @@
 
 #include "util.h"
 
-void *
-ecalloc(size_t nmemb, size_t size)
+void
+die(const char *fmt, ...)
 {
-    void *p;
-
-    if (!(p = calloc(nmemb, size)))
-        die("calloc:");
-    return p;
-}
-
-void die(const char *fmt, ...) {
-    va_list ap;
+	va_list ap;
 	int saved_errno;
 
 	saved_errno = errno;
 
-    va_start(ap, fmt);
-    vfprintf(stderr, fmt, ap);
-    va_end(ap);
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
 
 	if (fmt[0] && fmt[strlen(fmt)-1] == ':')
 		fprintf(stderr, " %s", strerror(saved_errno));
 	fputc('\n', stderr);
 
-    exit(1);
+	exit(1);
+}
+
+void *
+ecalloc(size_t nmemb, size_t size)
+{
+	void *p;
+
+	if (!(p = calloc(nmemb, size)))
+		die("calloc:");
+	return p;
 }
diff --git a/vanitygaps.c b/vanitygaps.c
index 7b64fd2..5acce38 100644
--- a/vanitygaps.c
+++ b/vanitygaps.c
@@ -1,53 +1,60 @@
 /* Key binding functions */
 static void defaultgaps(const Arg *arg);
 static void incrgaps(const Arg *arg);
-/* static void incrigaps(const Arg *arg); */
-/* static void incrogaps(const Arg *arg); */
-/* static void incrohgaps(const Arg *arg); */
-/* static void incrovgaps(const Arg *arg); */
-/* static void incrihgaps(const Arg *arg); */
-/* static void incrivgaps(const Arg *arg); */
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
 static void togglegaps(const Arg *arg);
 static void togglebgaps(const Arg *arg);
-
-/* Layouts */
+/* Layouts (delete the ones you do not need) */
 static void bstack(Monitor *m);
+static void bstackhoriz(Monitor *m);
 static void centeredmaster(Monitor *m);
 static void centeredfloatingmaster(Monitor *m);
 static void deck(Monitor *m);
 static void dwindle(Monitor *m);
 static void fibonacci(Monitor *m, int s);
+static void grid(Monitor *m);
+static void nrowgrid(Monitor *m);
 static void spiral(Monitor *m);
 static void tile(Monitor *m);
-
 /* Internals */
 static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
 static void setgaps(int oh, int ov, int ih, int iv);
 
 /* Settings */
+#if !PERTAG_PATCH
 static int enablegaps = 1;
+#endif // PERTAG_PATCH
 
-static void
+void
 setgaps(int oh, int ov, int ih, int iv)
 {
-    if (oh < 0) oh = 0;
-    if (ov < 0) ov = 0;
-    if (ih < 0) ih = 0;
-    if (iv < 0) iv = 0;
-
-    selmon->gappoh = oh;
-    selmon->gappov = ov;
-    selmon->gappih = ih;
-    selmon->gappiv = iv;
-    arrange(selmon);
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
 }
 
-static void
+void
 togglegaps(const Arg *arg)
 {
-    enablegaps = !enablegaps;
-    /* arrange(NULL); */
-    arrange(selmon);
+	#if PERTAG_PATCH
+	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	enablegaps = !enablegaps;
+	#endif // PERTAG_PATCH
+	arrange(NULL);
 }
 
 static void
@@ -57,135 +64,143 @@ togglebgaps(const Arg *arg)
     arrange(NULL);
 }
 
-static void
+void
 defaultgaps(const Arg *arg)
 {
-    setgaps(gappoh, gappov, gappih, gappiv);
+	setgaps(gappoh, gappov, gappih, gappiv);
 }
 
-static void
+void
 incrgaps(const Arg *arg)
 {
-    setgaps(
-            selmon->gappoh + arg->i,
-            selmon->gappov + arg->i,
-            selmon->gappih + arg->i,
-            selmon->gappiv + arg->i
-           );
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
 }
 
-/* static void */
-/* incrigaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih + arg->i, */
-/* 		selmon->gappiv + arg->i */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrogaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh + arg->i, */
-/* 		selmon->gappov + arg->i, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrohgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh + arg->i, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrovgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov + arg->i, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrihgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih + arg->i, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrivgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv + arg->i */
-/* 	); */
-/* } */
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
 
-static void
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
 getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
 {
-    unsigned int n, oe, ie;
-    oe = ie = enablegaps;
-    Client *c;
+	unsigned int n, oe, ie;
+	#if PERTAG_PATCH
+	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	oe = ie = enablegaps;
+	#endif // PERTAG_PATCH
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (smartgaps && n == 1) {
+		oe = 0; // outer gaps disabled when only one client
+	}
 
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-    /* if (smartgaps && n == 1) { */
     if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
         oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+        if (TAGMASK == (1 << 8)){
+            setgaps(gappoh, gappov, gappih, gappiv);
+        }
     }
 
-    if (TAGMASK == (1 << 8)){
-        setgaps(gappoh, gappov, gappih, gappiv);
-    }
-
-    *oh = m->gappoh*oe; // outer horizontal gap
-    *ov = m->gappov*oe; // outer vertical gap
-    *ih = m->gappih*ie; // inner horizontal gap
-    *iv = m->gappiv*ie; // inner vertical gap
-    *nc = n;            // number of clients
+	*oh = m->gappoh*oe; // outer horizontal gap
+	*ov = m->gappov*oe; // outer vertical gap
+	*ih = m->gappih*ie; // inner horizontal gap
+	*iv = m->gappiv*ie; // inner vertical gap
+	*nc = n;            // number of clients
 }
 
 void
 getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
 {
-    unsigned int n;
-    float mfacts, sfacts;
-    int mtotal = 0, stotal = 0;
-    Client *c;
-
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-    mfacts = MIN(n, m->nmaster);
-    sfacts = n - m->nmaster;
-
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
-        if (n < m->nmaster)
-            mtotal += msize / mfacts;
-        else
-            stotal += ssize / sfacts;
-
-    *mf = mfacts; // total factor of master area
-    *sf = sfacts; // total factor of stack area
-    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
-    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
+	unsigned int n;
+	float mfacts = 0, sfacts = 0;
+	int mtotal = 0, stotal = 0;
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mtotal += msize * (c->cfact / mfacts);
+		else
+			stotal += ssize * (c->cfact / sfacts);
+
+	*mf = mfacts; // total factor of master area
+	*sf = sfacts; // total factor of stack area
+	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
 }
 
 /***
@@ -196,360 +211,627 @@ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *s
  * Bottomstack layout + gaps
  * https://dwm.suckless.org/patches/bottomstack/
  */
-
 static void
 bstack(Monitor *m)
 {
-    unsigned int i, n;
-    int mx = 0, my = 0, mh = 0, mw = 0;
-    int sx = 0, sy = 0, sh = 0, sw = 0;
-    float mfacts, sfacts;
-    int mrest, srest;
-    Client *c;
-
-    int oh, ov, ih, iv;
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    sx = mx = m->wx + ov;
-    sy = my = m->wy + oh;
-    sh = mh = m->wh - 2*oh;
-    mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
-    sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
-
-    if (m->nmaster && n > m->nmaster) {
-        sh = (mh - ih) * (1 - m->mfact);
-        mh = (mh - ih) * m->mfact;
-        sx = mx;
-        sy = my + mh + ih;
-    }
-
-    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sx = mx;
+		sy = my + mh + ih;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+	}
+}
 
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
-        if (i < m->nmaster) {
-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
-            mx += WIDTH(c) + iv;
-        } else {
-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
-            sx += WIDTH(c) + iv;
-        }
-    }
+static void
+bstackhoriz(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh;
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+	}
+
+	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+	}
 }
 
 /*
  * Centred master layout + gaps
  * https://dwm.suckless.org/patches/centeredmaster/
  */
-
 void
 centeredmaster(Monitor *m)
 {
-    unsigned int i, n;
-    int mx = 0, my = 0, mh = 0, mw = 0;
-    int lx = 0, ly = 0, lw = 0, lh = 0;
-    int rx = 0, ry = 0, rw = 0, rh = 0;
-    float mfacts = 0, lfacts = 0, rfacts = 0;
-    int mtotal = 0, ltotal = 0, rtotal = 0;
-    int mrest = 0, lrest = 0, rrest = 0;
-    Client *c;
-
-    int oh, ov, ih, iv;
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    /* initialize areas */
-    mx = m->wx + ov;
-    my = m->wy + oh;
-    mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
-    mw = m->ww - 2*ov;
-    lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
-    rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
-
-    if (m->nmaster && n > m->nmaster) {
-        /* go mfact box in the center if more than nmaster clients */
-        if (n - m->nmaster > 1) {
-            /* ||<-S->|<---M--->|<-S->|| */
-            mw = (m->ww - 2*ov - 2*iv) * m->mfact;
-            lw = (m->ww - mw - 2*ov - 2*iv) / 2;
-            mx += lw + iv;
-        } else {
-            /* ||<---M--->|<-S->|| */
-            mw = (mw - iv) * m->mfact;
-            lw = m->ww - mw - iv - 2*ov;
-        }
-        rw = lw;
-        lx = m->wx + ov;
-        ly = m->wy + oh;
-        rx = mx + mw + iv;
-        ry = m->wy + oh;
-    }
-
-    /* calculate facts */
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
-        if (!m->nmaster || n < m->nmaster)
-            mfacts += 1;
-        else if ((n - m->nmaster) % 2)
-            lfacts += 1; // total factor of left hand stack area
-        else
-            rfacts += 1; // total factor of right hand stack area
-    }
-
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
-        if (!m->nmaster || n < m->nmaster)
-            mtotal += mh / mfacts;
-        else if ((n - m->nmaster) % 2)
-            ltotal += lh / lfacts;
-        else
-            rtotal += rh / rfacts;
-
-    mrest = mh - mtotal;
-    lrest = lh - ltotal;
-    rrest = rh - rtotal;
-
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
-        if (!m->nmaster || i < m->nmaster) {
-            /* nmaster clients are stacked vertically, in the center of the screen */
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-            my += HEIGHT(c) + ih;
-        } else {
-            /* stack clients are stacked vertically */
-            if ((i - m->nmaster) % 2 ) {
-                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
-                ly += HEIGHT(c) + ih;
-            } else {
-                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
-                ry += HEIGHT(c) + ih;
-            }
-        }
-    }
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int lx = 0, ly = 0, lw = 0, lh = 0;
+	int rx = 0, ry = 0, rw = 0, rh = 0;
+	float mfacts = 0, lfacts = 0, rfacts = 0;
+	int mtotal = 0, ltotal = 0, rtotal = 0;
+	int mrest = 0, lrest = 0, rrest = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* initialize areas */
+	mx = m->wx + ov;
+	my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+	mw = m->ww - 2*ov;
+	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+
+	if (m->nmaster && n > m->nmaster) {
+		/* go mfact box in the center if more than nmaster clients */
+		if (n - m->nmaster > 1) {
+			/* ||<-S->|<---M--->|<-S->|| */
+			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+			mx += lw + iv;
+		} else {
+			/* ||<---M--->|<-S->|| */
+			mw = (mw - iv) * m->mfact;
+			lw = 0;
+			rw = m->ww - mw - iv - 2*ov;
+		}
+		lx = m->wx + ov;
+		ly = m->wy + oh;
+		rx = mx + mw + iv;
+		ry = m->wy + oh;
+	}
+
+	/* calculate facts */
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+		if (!m->nmaster || n < m->nmaster)
+			mfacts += c->cfact;
+		else if ((n - m->nmaster) % 2)
+			lfacts += c->cfact; // total factor of left hand stack area
+		else
+			rfacts += c->cfact; // total factor of right hand stack area
+	}
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (!m->nmaster || n < m->nmaster)
+			mtotal += mh * (c->cfact / mfacts);
+		else if ((n - m->nmaster) % 2)
+			ltotal += lh * (c->cfact / lfacts);
+		else
+			rtotal += rh * (c->cfact / rfacts);
+
+	mrest = mh - mtotal;
+	lrest = lh - ltotal;
+	rrest = rh - rtotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (!m->nmaster || i < m->nmaster) {
+			/* nmaster clients are stacked vertically, in the center of the screen */
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			/* stack clients are stacked vertically */
+			if ((i - m->nmaster) % 2 ) {
+				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+				ly += HEIGHT(c) + ih;
+			} else {
+				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+				ry += HEIGHT(c) + ih;
+			}
+		}
+	}
 }
 
 void
 centeredfloatingmaster(Monitor *m)
 {
-    unsigned int i, n;
-    float mfacts, sfacts;
-    int mrest, srest;
-    int mx = 0, my = 0, mh = 0, mw = 0;
-    int sx = 0, sy = 0, sh = 0, sw = 0;
-    Client *c;
-
-    float mivf = 1.0; // master inner vertical gap factor
-    int oh, ov, ih, iv;
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    sx = mx = m->wx + ov;
-    sy = my = m->wy + oh;
-    sh = mh = m->wh - 2*oh;
-    mw = m->ww - 2*ov - iv*(n - 1);
-    sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
-
-    if (m->nmaster && n > m->nmaster) {
-        mivf = 0.8;
-        /* go mfact box in the center if more than nmaster clients */
-        if (m->ww > m->wh) {
-            mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
-            mh = m->wh * 0.9 - 2*oh;
-        } else {
-            mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
-            mh = m->wh * m->mfact;
-        }
-        mx = m->wx + (m->ww - mw) / 2;
-        my = m->wy + (m->wh - mh) / 2;
-
-        sx = m->wx + ov;
-        sy = m->wy + oh;
-        sh = m->wh - 2*oh;
-    }
-
-    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
-
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-        if (i < m->nmaster) {
-            /* nmaster clients are stacked horizontally, in the center of the screen */
-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
-            mx += WIDTH(c) + iv*mivf;
-        } else {
-            /* stack clients are stacked horizontally */
-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
-            sx += WIDTH(c) + iv;
-        }
+	unsigned int i, n;
+	float mfacts, sfacts;
+	float mivf = 1.0; // master inner vertical gap factor
+	int oh, ov, ih, iv, mrest, srest;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv*(n - 1);
+	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		mivf = 0.8;
+		/* go mfact box in the center if more than nmaster clients */
+		if (m->ww > m->wh) {
+			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * 0.9;
+		} else {
+			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * m->mfact;
+		}
+		mx = m->wx + (m->ww - mw) / 2;
+		my = m->wy + (m->wh - mh - 2*oh) / 2;
+
+		sx = m->wx + ov;
+		sy = m->wy + oh;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			/* nmaster clients are stacked horizontally, in the center of the screen */
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv*mivf;
+		} else {
+			/* stack clients are stacked horizontally */
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
 }
 
 /*
  * Deck layout + gaps
  * https://dwm.suckless.org/patches/deck/
  */
-
-static void
+void
 deck(Monitor *m)
 {
-    unsigned int i, n;
-    int mx = 0, my = 0, mh = 0, mw = 0;
-    int sx = 0, sy = 0, sh = 0, sw = 0;
-    float mfacts, sfacts;
-    int mrest, srest;
-    Client *c;
-
-    int oh, ov, ih, iv;
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    sx = mx = m->wx + ov;
-    sy = my = m->wy + oh;
-    sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
-    sw = mw = m->ww - 2*ov;
-
-    if (m->nmaster && n > m->nmaster) {
-        sw = (mw - iv) * (1 - m->mfact);
-        mw = (mw - iv) * m->mfact;
-        sx = mx + mw + iv;
-        sh = m->wh - 2*oh;
-    }
-
-    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
-
-    if (n - m->nmaster > 0) /* override layout symbol */
-        snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
-
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-        if (i < m->nmaster) {
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-            my += HEIGHT(c) + ih;
-        } else {
-            resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
-        }
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	if (n - m->nmaster > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+		}
 }
 
 /*
  * Fibonacci layout + gaps
  * https://dwm.suckless.org/patches/fibonacci/
  */
-
-static void
+void
 fibonacci(Monitor *m, int s)
 {
-    unsigned int i, n;
-    int nx, ny, nw, nh;
-    int oh, ov, ih, iv;
-    Client *c;
-
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    nx = m->wx + ov;
-    ny = oh;
-    nw = m->ww - 2*ov;
-    nh = m->wh - 2*oh;
-
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
-        if ((i % 2 && nh / 2 > 2*c->bw)
-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
-            if (i < n - 1) {
-                if (i % 2)
-                    nh = (nh - ih) / 2;
-                else
-                    nw = (nw - iv) / 2;
-
-                if ((i % 4) == 2 && !s)
-                    nx += nw + iv;
-                else if ((i % 4) == 3 && !s)
-                    ny += nh + ih;
-            }
-            if ((i % 4) == 0) {
-                if (s)
-                    ny += nh + ih;
-                else
-                    ny -= nh + ih;
-            }
-            else if ((i % 4) == 1)
-                nx += nw + iv;
-            else if ((i % 4) == 2)
-                ny += nh + ih;
-            else if ((i % 4) == 3) {
-                if (s)
-                    nx += nw + iv;
-                else
-                    nx -= nw + iv;
-            }
-            if (i == 0)	{
-                if (n != 1)
-                    nw = (m->ww - 2*ov - iv) * m->mfact;
-                ny = m->wy + oh;
-            }
-            else if (i == 1)
-                nw = m->ww - nw - iv - 2*ov;
-            i++;
-        }
-
-        resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
-    }
+	unsigned int i, n;
+	int nx, ny, nw, nh;
+	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	nx = m->wx + ov;
+	ny = m->wy + oh;
+	nw = m->ww - 2*ov;
+	nh = m->wh - 2*oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
+
+				if ((i % 4) == 2 && !s)
+					nx += nw + iv;
+				else if ((i % 4) == 3 && !s)
+					ny += nh + ih;
+			}
+
+			if ((i % 4) == 0) {
+				if (s) {
+					ny += nh + ih;
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
+					ny -= nh + ih;
+				}
+			}
+			else if ((i % 4) == 1) {
+				nx += nw + iv;
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
+				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
+			else if ((i % 4) == 3) {
+				if (s) {
+					nx += nw + iv;
+					nw -= wrest;
+				} else {
+					nw -= wrest;
+					nx -= nw + iv;
+					nh += hrest;
+				}
+			}
+			if (i == 0)	{
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
+				ny = m->wy + oh;
+			}
+			else if (i == 1)
+				nw = m->ww - nw - iv - 2*ov;
+			i++;
+		}
+
+		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+	}
 }
 
-static void
+void
 dwindle(Monitor *m)
 {
-    fibonacci(m, 1);
+	fibonacci(m, 1);
 }
 
-static void
+void
 spiral(Monitor *m)
 {
-    fibonacci(m, 0);
+	fibonacci(m, 0);
 }
 
 /*
- * Default tile layout + gaps
+ * Gappless grid layout + gaps (ironically)
+ * https://dwm.suckless.org/patches/gaplessgrid/
+ */
+void
+gaplessgrid(Monitor *m)
+{
+	unsigned int i, n;
+	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* grid dimensions */
+	for (cols = 0; cols <= n/2; cols++)
+		if (cols*cols >= n)
+			break;
+	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+		cols = 2;
+	rows = n/cols;
+	cn = rn = 0; // reset column no, row no, client count
+
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	x = m->wx + ov;
+	y = m->wy + oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+		if (i/rows + 1 > cols - n%cols) {
+			rows = n/cols + 1;
+			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+		}
+		resize(c,
+			x,
+			y + rn*(ch + ih) + MIN(rn, rrest),
+			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+			0);
+		rn++;
+		if (rn >= rows) {
+			rn = 0;
+			x += cw + ih + (cn < crest ? 1 : 0);
+			cn++;
+		}
+	}
+}
+
+/*
+ * Gridmode layout + gaps
+ * https://dwm.suckless.org/patches/gridmode/
+ */
+void
+grid(Monitor *m)
+{
+	unsigned int i, n;
+	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* grid dimensions */
+	for (rows = 0; rows <= n/2; rows++)
+		if (rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		cc = i / rows;
+		cr = i % rows;
+		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+	}
+}
+
+/*
+ * Horizontal grid layout + gaps
+ * https://dwm.suckless.org/patches/horizgrid/
+ */
+void
+horizgrid(Monitor *m) {
+	Client *c;
+	unsigned int n, i;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	int ntop, nbottom = 1;
+	float mfacts = 0, sfacts = 0;
+	int mrest, srest, mtotal = 0, stotal = 0;
+
+	/* Count windows */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	if (n <= 2)
+		ntop = n;
+	else {
+		ntop = n / 2;
+		nbottom = n - ntop;
+	}
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	sw = mw = m->ww - 2*ov;
+
+	if (n > ntop) {
+		sh = (mh - ih) / 2;
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		mw = m->ww - 2*ov - iv * (ntop - 1);
+		sw = m->ww - 2*ov - iv * (nbottom - 1);
+	}
+
+	/* calculate facts */
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mtotal += mh * (c->cfact / mfacts);
+		else
+			stotal += sw * (c->cfact / sfacts);
+
+	mrest = mh - mtotal;
+	srest = sw - stotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * nrowgrid layout + gaps
+ * https://dwm.suckless.org/patches/nrowgrid/
  */
+void
+nrowgrid(Monitor *m)
+{
+	unsigned int n;
+	int ri = 0, ci = 0;  /* counters */
+	int oh, ov, ih, iv;                         /* vanitygap settings */
+	unsigned int cx, cy, cw, ch;                /* client geometry */
+	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+	unsigned int cols, rows = m->nmaster + 1;
+	Client *c;
+
+	/* count clients */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* nothing to do here */
+	if (n == 0)
+		return;
+
+	/* force 2 clients to always split vertically */
+	if (FORCE_VSPLIT && n == 2)
+		rows = 1;
+
+	/* never allow empty rows */
+	if (n < rows)
+		rows = n;
+
+	/* define first row */
+	cols = n / rows;
+	uc = cols;
+	cy = m->wy + oh;
+	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+	uh = ch;
+
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+		if (ci == cols) {
+			uw = 0;
+			ci = 0;
+			ri++;
+
+			/* next row */
+			cols = (n - uc) / (rows - ri);
+			uc += cols;
+			cy = m->wy + oh + uh + ih;
+			uh += ch + ih;
+		}
+
+		cx = m->wx + ov + uw;
+		cw = (m->ww - 2*ov - uw) / (cols - ci);
+		uw += cw + iv;
+
+		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+	}
+}
 
+/*
+ * Default tile layout + gaps
+ */
 static void
 tile(Monitor *m)
 {
-    unsigned int i, n;
-    int mx = 0, my = 0, mh = 0, mw = 0;
-    int sx = 0, sy = 0, sh = 0, sw = 0;
-    float mfacts, sfacts;
-    int mrest, srest;
-    Client *c;
-
-    int oh, ov, ih, iv;
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
-    if (n == 0)
-        return;
-
-    sx = mx = m->wx + ov;
-    sy = my = m->wy + oh;
-    mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
-    sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
-    sw = mw = m->ww - 2*ov;
-
-    if (m->nmaster && n > m->nmaster) {
-        sw = (mw - iv) * (1 - m->mfact);
-        mw = (mw - iv) * m->mfact;
-        sx = mx + mw + iv;
-    }
-
-    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
-
-    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-        if (i < m->nmaster) {
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-            my += HEIGHT(c) + ih;
-        } else {
-            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
-            sy += HEIGHT(c) + ih;
-        }
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
 }
