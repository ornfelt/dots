diff --git a/LICENSE b/LICENSE
index 1e1b5a4..995172f 100644
--- a/LICENSE
+++ b/LICENSE
@@ -17,7 +17,7 @@ MIT/X Consortium License
 © 2015-2016 Quentin Rameau <quinq@fifth.space>
 © 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
 © 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
-© 2019-2020 Luke Smith <luke@lukesmith.xyz>
+© 2020-2022 Chris Down <chris@chrisdown.name>
 
 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
diff --git a/Makefile b/Makefile
index 63569d7..ffa69b4 100644
--- a/Makefile
+++ b/Makefile
@@ -13,16 +13,19 @@ all: dwm
 
 ${OBJ}: config.h config.mk
 
+config.h:
+	cp config.def.h $@
+
 dwm: ${OBJ}
 	${CC} -o $@ ${OBJ} ${LDFLAGS}
 
 clean:
-	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
+	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
 
 dist: clean
 	mkdir -p dwm-${VERSION}
-	cp -R LICENSE Makefile README config.mk\
-		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
+	cp -R LICENSE Makefile README config.def.h config.mk\
+		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
 	gzip dwm-${VERSION}.tar
 	rm -rf dwm-${VERSION}
@@ -34,7 +37,6 @@ install: all
 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
-	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
 
 uninstall:
 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
diff --git a/README b/README
index 482b545..95d4fd0 100644
--- a/README
+++ b/README
@@ -1,13 +1,5 @@
-See patches in dir 'patches'.
-
-I also continously add fixes from suckless git log:
-https://git.suckless.org/
-https://dwm.suckless.org/
-
-============================
 dwm - dynamic window manager
 ============================
-
 dwm is an extremely fast, small, and dynamic window manager for X.
 
 
diff --git a/changes.diff b/changes.diff
deleted file mode 100644
index c47ac32..0000000
--- a/changes.diff
+++ /dev/null
@@ -1,9560 +0,0 @@
-diff --git a/.gitignore b/.gitignore
-new file mode 100644
-index 0000000..d42c9e0
---- /dev/null
-+++ b/.gitignore
-@@ -0,0 +1,54 @@
-+# Prerequisites
-+*.d
-+
-+# Object files
-+*.o
-+*.ko
-+*.obj
-+*.elf
-+
-+# Linker output
-+*.ilk
-+*.map
-+*.exp
-+
-+# Precompiled Headers
-+*.gch
-+*.pch
-+
-+# Libraries
-+*.lib
-+*.a
-+*.la
-+*.lo
-+
-+# Shared objects (inc. Windows DLLs)
-+*.dll
-+*.so
-+*.so.*
-+*.dylib
-+
-+# Executables
-+*.exe
-+*.out
-+*.app
-+*.i*86
-+*.x86_64
-+*.hex
-+
-+# Debug files
-+*.dSYM/
-+*.su
-+*.idb
-+*.pdb
-+
-+# Kernel Module Compile Results
-+*.mod*
-+*.cmd
-+.tmp_versions/
-+modules.order
-+Module.symvers
-+Mkfile.old
-+dkms.conf
-+a.out
-+dwm
-diff --git a/LICENSE b/LICENSE
-deleted file mode 100644
-index 995172f..0000000
---- a/LICENSE
-+++ /dev/null
-@@ -1,38 +0,0 @@
--MIT/X Consortium License
--
--© 2006-2019 Anselm R Garbe <anselm@garbe.ca>
--© 2006-2009 Jukka Salmi <jukka at salmi dot ch>
--© 2006-2007 Sander van Dijk <a dot h dot vandijk at gmail dot com>
--© 2007-2011 Peter Hartlich <sgkkr at hartlich dot com>
--© 2007-2009 Szabolcs Nagy <nszabolcs at gmail dot com>
--© 2007-2009 Christof Musik <christof at sendfax dot de>
--© 2007-2009 Premysl Hruby <dfenze at gmail dot com>
--© 2007-2008 Enno Gottox Boland <gottox at s01 dot de>
--© 2008 Martin Hurton <martin dot hurton at gmail dot com>
--© 2008 Neale Pickett <neale dot woozle dot org>
--© 2009 Mate Nagy <mnagy at port70 dot net>
--© 2010-2016 Hiltjo Posthuma <hiltjo@codemadness.org>
--© 2010-2012 Connor Lane Smith <cls@lubutu.com>
--© 2011 Christoph Lohmann <20h@r-36.net>
--© 2015-2016 Quentin Rameau <quinq@fifth.space>
--© 2015-2016 Eric Pruitt <eric.pruitt@gmail.com>
--© 2016-2017 Markus Teich <markus.teich@stusta.mhn.de>
--© 2020-2022 Chris Down <chris@chrisdown.name>
--
--Permission is hereby granted, free of charge, to any person obtaining a
--copy of this software and associated documentation files (the "Software"),
--to deal in the Software without restriction, including without limitation
--the rights to use, copy, modify, merge, publish, distribute, sublicense,
--and/or sell copies of the Software, and to permit persons to whom the
--Software is furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in
--all copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
--THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--DEALINGS IN THE SOFTWARE.
-diff --git a/Makefile b/Makefile
-index ffa69b4..63569d7 100644
---- a/Makefile
-+++ b/Makefile
-@@ -13,19 +13,16 @@ all: dwm
- 
- ${OBJ}: config.h config.mk
- 
--config.h:
--	cp config.def.h $@
--
- dwm: ${OBJ}
- 	${CC} -o $@ ${OBJ} ${LDFLAGS}
- 
- clean:
--	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
-+	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz *.orig *.rej
- 
- dist: clean
- 	mkdir -p dwm-${VERSION}
--	cp -R LICENSE Makefile README config.def.h config.mk\
--		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
-+	cp -R LICENSE Makefile README config.mk\
-+		dwm.1 drw.h util.h ${SRC} transient.c dwm-${VERSION}
- 	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
- 	gzip dwm-${VERSION}.tar
- 	rm -rf dwm-${VERSION}
-@@ -37,6 +34,7 @@ install: all
- 	mkdir -p ${DESTDIR}${MANPREFIX}/man1
- 	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
- 	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
-+	mkdir -p ${DESTDIR}${PREFIX}/share/dwm
- 
- uninstall:
- 	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
-diff --git a/README b/README
-index 95d4fd0..c4f2539 100644
---- a/README
-+++ b/README
-@@ -1,3 +1,34 @@
-+MY DWM PATCHES:
-+https://dwm.suckless.org/patches/noborder/
-+https://dwm.suckless.org/patches/notitle/dwm-notitle-20210715-138b405.diff
-+
-+Added with modifications:
-+https://dwm.suckless.org/patches/autostart/dwm-autostart-20210120-cb3f58a.diff
-+https://dwm.suckless.org/patches/scratchpads/dwm-scratchpads-20200414-728d397b.diff
-+https://dwm.suckless.org/patches/focusonclick/dwm-focusonclick-20200110-61bb8b2.diff
-+https://dwm.suckless.org/patches/save_floats/
-+https://dwm.suckless.org/patches/status2d/dwm-status2d-20200508-60bb3df.diff (modified)
-+
-+Luke patches:
-+https://dwm.suckless.org/patches/sticky/dwm-sticky-20160911-ab9571b.diff
-+https://dwm.suckless.org/patches/actualfullscreen/dwm-actualfullscreen-20211013-cb3f58a.diff
-+https://dwm.suckless.org/patches/tagshift/dwm-tagshift-6.3.diff
-+https://dwm.suckless.org/patches/statuscmd/dwm-statuscmd-20210405-67d76bd.diff
-+https://dwm.suckless.org/patches/swallow/dwm-swallow-6.3.diff
-+https://dwm.suckless.org/patches/xresources/dwm-xresources-20210827-138b405.diff
-+https://dwm.suckless.org/patches/hide_vacant_tags/dwm-hide_vacant_tags-6.3.diff
-+https://dwm.suckless.org/patches/stacker/dwm-stacker-6.2.diff
-+https://dwm.suckless.org/patches/scratchpad/
-+https://dwm.suckless.org/patches/vanitygaps/dwm-vanitygaps-6.2.diff
-+Also see:
-+https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.4_combo.diff
-+or:
-+https://dwm.suckless.org/patches/vanitygaps/dwm-cfacts-vanitygaps-6.2.diff
-+
-+I've added the patches to patches dir (although im not 100% sure that those are the exact patches used, they are mostly based on the description below)
-+
-+I also continously add fixes from suckless git log.
-+
- dwm - dynamic window manager
- ============================
- dwm is an extremely fast, small, and dynamic window manager for X.
-diff --git a/config.def.h b/config.def.h
-deleted file mode 100644
-index 9efa774..0000000
---- a/config.def.h
-+++ /dev/null
-@@ -1,116 +0,0 @@
--/* See LICENSE file for copyright and license details. */
--
--/* appearance */
--static const unsigned int borderpx  = 1;        /* border pixel of windows */
--static const unsigned int snap      = 32;       /* snap pixel */
--static const int showbar            = 1;        /* 0 means no bar */
--static const int topbar             = 1;        /* 0 means bottom bar */
--static const char *fonts[]          = { "monospace:size=10" };
--static const char dmenufont[]       = "monospace:size=10";
--static const char col_gray1[]       = "#222222";
--static const char col_gray2[]       = "#444444";
--static const char col_gray3[]       = "#bbbbbb";
--static const char col_gray4[]       = "#eeeeee";
--static const char col_cyan[]        = "#005577";
--static const char *colors[][3]      = {
--	/*               fg         bg         border   */
--	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
--	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
--};
--
--/* tagging */
--static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
--
--static const Rule rules[] = {
--	/* xprop(1):
--	 *	WM_CLASS(STRING) = instance, class
--	 *	WM_NAME(STRING) = title
--	 */
--	/* class      instance    title       tags mask     isfloating   monitor */
--	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
--	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
--};
--
--/* layout(s) */
--static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
--static const int nmaster     = 1;    /* number of clients in master area */
--static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
--static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
--
--static const Layout layouts[] = {
--	/* symbol     arrange function */
--	{ "[]=",      tile },    /* first entry is default */
--	{ "><>",      NULL },    /* no layout function means floating behavior */
--	{ "[M]",      monocle },
--};
--
--/* key definitions */
--#define MODKEY Mod1Mask
--#define TAGKEYS(KEY,TAG) \
--	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
--	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
--	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
--	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
--
--/* helper for spawning shell commands in the pre dwm-5.0 fashion */
--#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
--
--/* commands */
--static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
--static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
--static const char *termcmd[]  = { "st", NULL };
--
--static const Key keys[] = {
--	/* modifier                     key        function        argument */
--	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
--	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
--	{ MODKEY,                       XK_b,      togglebar,      {0} },
--	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
--	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
--	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
--	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
--	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
--	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
--	{ MODKEY,                       XK_Return, zoom,           {0} },
--	{ MODKEY,                       XK_Tab,    view,           {0} },
--	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
--	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
--	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
--	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
--	{ MODKEY,                       XK_space,  setlayout,      {0} },
--	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
--	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
--	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
--	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
--	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
--	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
--	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
--	TAGKEYS(                        XK_1,                      0)
--	TAGKEYS(                        XK_2,                      1)
--	TAGKEYS(                        XK_3,                      2)
--	TAGKEYS(                        XK_4,                      3)
--	TAGKEYS(                        XK_5,                      4)
--	TAGKEYS(                        XK_6,                      5)
--	TAGKEYS(                        XK_7,                      6)
--	TAGKEYS(                        XK_8,                      7)
--	TAGKEYS(                        XK_9,                      8)
--	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
--};
--
--/* button definitions */
--/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
--static const Button buttons[] = {
--	/* click                event mask      button          function        argument */
--	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
--	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
--	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
--	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
--	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
--	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
--	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
--	{ ClkTagBar,            0,              Button1,        view,           {0} },
--	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
--	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
--	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
--};
--
-diff --git a/config.h b/config.h
-new file mode 100644
-index 0000000..97e540a
---- /dev/null
-+++ b/config.h
-@@ -0,0 +1,356 @@
-+/* See LICENSE file for copyright and license details. */
-+
-+/* Constants */
-+/* #define TERMINAL "st" */
-+/* #define TERMCLASS "St" */
-+/* #define TERMINAL "urxvt" */
-+/* #define TERMCLASS "Urxvt" */
-+/* #define TERMINAL "alacritty" */
-+/* #define TERMCLASS "alacritty" */
-+#define TERMINAL "wezterm"
-+#define TERMCLASS "wezterm"
-+#define SECTERMINAL "st"
-+
-+#define FILES "thunar"
-+//#define FILEX "ranger"
-+#define FILEX "yazi"
-+
-+/* appearance */
-+static unsigned int borderpx    = 3;        /* border pixel of windows */
-+static const unsigned int gappx = 10;       /* default gap between windows in pixels */
-+static unsigned int snap        = 32;       /* snap pixel */
-+static unsigned int gappih      = 20;       /* horiz inner gap between windows */
-+static unsigned int gappiv      = 20;       /* vert inner gap between windows */
-+static unsigned int gappoh      = 20;       /* horiz outer gap between windows and screen edge */
-+static unsigned int gappov      = 20;       /* vert outer gap between windows and screen edge */
-+static int swallowfloating      = 0;        /* 1 means swallow floating windows by default */
-+static int smartgaps            = 0;        /* 1 means no outer gap when there is only one window */
-+static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
-+static int showbar              = 1;        /* 0 means no bar */
-+static int topbar               = 1;        /* 0 means bottom bar */
-+/* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
-+/* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
-+static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
-+static char normbgcolor[]       = "#222222";
-+static char normbordercolor[]   = "#444444";
-+static char normfgcolor[]       = "#bbbbbb";
-+static char selfgcolor[]        = "#eeeeee";
-+static char selbordercolor[]    = "#770000";
-+static char selbgcolor[]        = "#005577";
-+static const char col1[]        = "#98971a";
-+static const char col21[]       = "#fb4934";
-+static const char col22[]       = "#ebdbb2";
-+static const char col23[]       = "#458588";
-+static const char col24[]       = "#ebdbb2";
-+static const char col3[]        = "#fabd2f";
-+static const char col4[]        = "#83a598";
-+static const char col5[]        = "#d3869b";
-+static const char col6[]        = "#8ec07c";
-+static char *colors[][3]        = {
-+    /*               fg              bg              border   */
-+    [SchemeNorm] = { normfgcolor,   normbgcolor,    normbordercolor },
-+    [SchemeSel]  = { selfgcolor,    selbgcolor,     selbordercolor },
-+};
-+
-+typedef struct {
-+    const char *name;
-+    const void *cmd;
-+} Sp;
-+const char *spcmd1[] = {"st", "-n", "spterm", "-g", "30x30", "-e", "python3", NULL };
-+const char *spcmd2[] = {"st", "-n", "spcalc", "-g", "30x30", NULL };
-+/* const char *spcmd2[] = {"st", "-n", "spcalc", "-f", "monospace:size=16", "-g", "50x20", "-e", "bc", "-lq", NULL }; */
-+static Sp scratchpads[] = {
-+    /* name          cmd  */
-+    {"spterm",      spcmd1},
-+    {"spcalc",      spcmd2},
-+};
-+
-+/* tagging */
-+static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-+/* static const char *tags[] = { "", "", "", "", "", "", "", "", "" }; */
-+
-+static const Rule rules[] = {
-+    /* xprop(1):
-+     *    WM_CLASS(STRING) = instance, class
-+     *    WM_NAME(STRING) = title
-+     */
-+    /* class        instance                title               tags mask       isfloating   isterminal noswallow   monitor */
-+    /* { "Gimp",       NULL,                   NULL,               1 << 8,         0,           0,         0,          -1 }, */
-+    { TERMCLASS,    NULL,                   NULL,               0,              0,           1,         0,          -1 },
-+    { NULL,         NULL,                   "Event Tester",     0,              0,           0,         1,          -1 },
-+    { NULL,         "spterm",               NULL,               SPTAG(0),       1,           1,         1,          -1 },
-+    { NULL,         "spcalc",               NULL,               SPTAG(1),       1,           1,         0,          -1 },
-+    { NULL,         "gnome-calculator",     NULL,               0,              1,           0,         0,          -1 },
-+    { NULL,         "gnome-calendar",       NULL,               0,              1,           0,         0,          -1 },
-+    { NULL,         "yad",                  NULL,               0,              1,           0,         0,          -1 },
-+    { NULL,         "nm-connection-editor", NULL,               0,              1,           0,         0,          -1 },
-+};
-+
-+/* layout(s) */
-+static float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
-+static int nmaster     = 1;    /* number of clients in master area */
-+static int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
-+
-+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
-+#include "vanitygaps.c"
-+static const Layout layouts[] = {
-+    /* symbol       arrange function */
-+    { "[@]",        spiral },                   /* Default: Fibonacci spiral */
-+    { "[]=",        tile },                     /* Master on left, slaves on right */
-+    { "TTT",        bstack },                   /* Master on top, slaves on bottom */
-+    { "[\\]",       dwindle },                  /* Decreasing in size right and leftward */
-+    { "[D]",        deck },                     /* Master on left, slaves in monocle-like mode on right */
-+    { "[M]",        monocle },                  /* All windows on top of eachother */
-+    { "|M|",        centeredmaster },           /* Master in middle, slaves on sides */
-+    { ">M>",        centeredfloatingmaster },   /* Same but master floats */
-+    { "><>",        NULL },                     /* no layout function means floating behavior */
-+    { NULL,         NULL },
-+};
-+
-+/* key definitions */
-+#define MODKEY Mod4Mask
-+#define MODKEY1 Mod1Mask
-+#define TAGKEYS(KEY,TAG) \
-+{ MODKEY,                       KEY,      view,         {.ui = 1 << TAG} }, \
-+{ MODKEY|ControlMask,           KEY,      tag,          {.ui = 1 << TAG} }, \
-+{ MODKEY|ShiftMask,             KEY,      tagview,      {.ui = 1 << TAG} }, \
-+{ MODKEY|ControlMask|ShiftMask, KEY,      toggleview,   {.ui = 1 << TAG} },
-+/* { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,    {.ui = 1 << TAG} }, */
-+#define STACKKEYS(MOD,ACTION) \
-+{ MOD,                  XK_j,    ACTION##stack,    {.i = INC(+1) } }, \
-+{ MOD,                  XK_k,    ACTION##stack,    {.i = INC(-1) } }, \
-+{ MOD|ControlMask,      XK_j,    ACTION##stack,    {.i = -1 } }, \
-+{ MOD|ControlMask,      XK_k,    ACTION##stack,    {.i = 0 } }, \
-+/* { MOD,                  XK_h,    ACTION##stack,    {.i = INC(+1) } }, \ */
-+/* { MOD,                  XK_l,    ACTION##stack,    {.i = INC(-1) } }, \ */
-+
-+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-+
-+/* commands */
-+static const char *termcmd[]  = { TERMINAL, NULL };
-+
-+/*
-+ * Xresources preferences to load at startup
-+ */
-+ResourcePref resources[] = {
-+    { "color0",             STRING,     &normbordercolor },
-+    { "foreground",         STRING,     &selbordercolor },
-+    /* { "color8",             STRING,     &selbordercolor }, */
-+    { "color0",             STRING,     &normbgcolor },
-+    { "foreground",         STRING,     &normfgcolor },
-+    { "color0",             STRING,     &selfgcolor },
-+    { "foreground",         STRING,     &selbgcolor },
-+    { "borderpx",           INTEGER,    &borderpx },
-+    { "snap",               INTEGER,    &snap },
-+    { "showbar",            INTEGER,    &showbar },
-+    { "topbar",             INTEGER,    &topbar },
-+    { "nmaster",            INTEGER,    &nmaster },
-+    { "resizehints",        INTEGER,    &resizehints },
-+    { "mfact",              FLOAT,      &mfact },
-+    { "gappih",             INTEGER,    &gappih },
-+    { "gappiv",             INTEGER,    &gappiv },
-+    { "gappoh",             INTEGER,    &gappoh },
-+    { "gappov",             INTEGER,    &gappov },
-+    { "swallowfloating",    INTEGER,    &swallowfloating },
-+    { "smartgaps",          INTEGER,    &smartgaps },
-+};
-+
-+#include <X11/XF86keysym.h>
-+#include "shiftview.c"
-+
-+static const Key keys[] = {
-+    /*  modifier                    key                 function            argument */
-+        STACKKEYS(MODKEY,                               focus)
-+        STACKKEYS(MODKEY|ShiftMask,                     push)
-+        { MODKEY,                   XK_grave,           spawn,              SHCMD("dmenu_run -fn 'Linux Libertine Mono'") },
-+        TAGKEYS(                    XK_1,               0)
-+        TAGKEYS(                    XK_2,               1)
-+        TAGKEYS(                    XK_3,               2)
-+        TAGKEYS(                    XK_4,               3)
-+        TAGKEYS(                    XK_5,               4)
-+        TAGKEYS(                    XK_6,               5)
-+        TAGKEYS(                    XK_7,               6)
-+        TAGKEYS(                    XK_8,               7)
-+        TAGKEYS(                    XK_9,               8)
-+        { MODKEY,                   XK_0,               view,               {.ui = ~0 } },
-+        { MODKEY|ShiftMask,         XK_0,               tag,                {.ui = ~0 } },
-+
-+        /* Layouts */
-+        { MODKEY|ShiftMask,         XK_less,            togglesticky,       {0} },
-+        { MODKEY,                   XK_less,            setlayout,          {.v = &layouts[0]} }, /* Fibonacci spiral */
-+        { MODKEY,                   XK_s,               setlayout,          {.v = &layouts[2]} }, /* centeredmaster */
-+        { MODKEY|ControlMask,       XK_t,               setlayout,          {.v = &layouts[1]} }, /* tile */
-+        { MODKEY|ControlMask,       XK_y,               setlayout,          {.v = &layouts[3]} }, /* dwindle */
-+        { MODKEY|ControlMask,       XK_u,               setlayout,          {.v = &layouts[4]} }, /* bstack */
-+        { MODKEY|ControlMask,       XK_i,               setlayout,          {.v = &layouts[5]} }, /* deck*/
-+        { MODKEY|ControlMask,       XK_o,               setlayout,          {.v = &layouts[6]} }, /* monocle */
-+        { MODKEY|ControlMask,       XK_p,               setlayout,          {.v = &layouts[7]} }, /* centeredfloatingmaster */
-+        { MODKEY|ControlMask,       XK_aring,           setlayout,          {.v = &layouts[8]} },
-+        { MODKEY,                   XK_f,               togglefullscr,      {0} },
-+        { MODKEY,                   XK_space,           togglefloating,     {0} },
-+        { MODKEY|ShiftMask,         XK_space,           zoom,               {0} },
-+        { MODKEY,                   XK_y,               setmfact,           {.f = -0.05} },
-+        { MODKEY,                   XK_o,               setmfact,           {.f = +0.05} },
-+        { MODKEY|ShiftMask,         XK_u,               incnmaster,         {.i = +1 } },
-+        { MODKEY|ShiftMask,         XK_i,               incnmaster,         {.i = -1 } },
-+        { MODKEY|ShiftMask,         XK_y,               shifttag,           { .i = +1 } },
-+        { MODKEY|ShiftMask,         XK_o,               shifttag,           { .i = -1 } },
-+        { MODKEY,                   XK_x,               defaultgaps,        {0} },
-+        { MODKEY,                   XK_z,               togglegaps,         {0} },
-+        { MODKEY|ControlMask,       XK_z,               togglebgaps,        {0} },
-+        { MODKEY,                   XK_plus,            incrgaps,           {.i = +3 } },
-+        { MODKEY,                   XK_minus,           incrgaps,           {.i = -3 } },
-+        { MODKEY|ShiftMask,         XK_plus,            incrgaps,           {.i = +1 } },
-+        { MODKEY|ShiftMask,         XK_minus,           incrgaps,           {.i = -1 } },
-+        { MODKEY1,                  XK_Tab,             shiftview,          { .i = +1 } },
-+        { MODKEY1|ShiftMask,        XK_Tab,             shiftview,          { .i = -1 } },
-+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
-+        /* { MODKEY,                   XK_Tab,             view,               {0} }, */
-+        { MODKEY,                   XK_q,               killclient,         {0} },
-+        { MODKEY|ShiftMask,         XK_p,               togglebar,          {0} },
-+        { MODKEY|ControlMask|ShiftMask,     XK_p,       togglebar,          {0} },
-+        { MODKEY,                   XK_h,               focusmon,           { .i = -1 } },
-+        { MODKEY|ShiftMask,         XK_h,               tagmonview,         { .i = -1 } },
-+        { MODKEY|ControlMask,       XK_h,               tagmon,             { .i = -1 } },
-+        { MODKEY,                   XK_l,               focusmon,           { .i = +1 } },
-+        { MODKEY|ShiftMask,         XK_l,               tagmonview,         { .i = +1 } },
-+        { MODKEY|ControlMask,       XK_l,               tagmon,             { .i = +1 } },
-+        { MODKEY,                   XK_Left,            focusmon,           { .i = -1 } },
-+        { MODKEY|ShiftMask,         XK_Left,            tagmon,             { .i = -1 } },
-+        { MODKEY,                   XK_Right,           focusmon,           { .i = +1 } },
-+        { MODKEY|ShiftMask,         XK_Right,           tagmon,             { .i = +1 } },
-+        { MODKEY,                   XK_apostrophe,      togglescratch,      { .ui = 0 } },
-+        { MODKEY|ShiftMask,         XK_apostrophe,      togglescratch,      { .ui = 1 } },
-+        /* { MODKEY,                   XK_semicolon,       shiftview,          { .i = 1 } }, */
-+        /* { MODKEY|ShiftMask,         XK_semicolon,       shifttag,           { .i = 1 } }, */
-+
-+        { MODKEY|ShiftMask,         XK_x,               spawn,              SHCMD("i3lock") },
-+        { MODKEY|ControlMask,       XK_x,               spawn,              SHCMD("i3lock -i ~/Downloads/lock-wallpaper.png")},
-+        { MODKEY,                   XK_w,               spawn,              SHCMD(TERMINAL " -e " FILEX " " "~/") },
-+        { MODKEY,                   XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/file_explorer_wd.sh " TERMINAL " " FILEX) },
-+        { MODKEY|ShiftMask,         XK_e,               spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.config/polybar/forest/scripts/powermenu.sh") },
-+        { MODKEY|ShiftMask,         XK_s,               spawn,              SHCMD("import png:- | xclip -selection clipboard -t image/png") },
-+        { MODKEY|ControlMask,       XK_s,               spawn,              SHCMD("~/.local/bin/my_scripts/tesseract_ocr.sh") },
-+        { MODKEY,                   XK_d,               spawn,              SHCMD("rofi -show run -theme ~/.config/rofi/themes/gruvbox/gruvbox-dark.rasi") },
-+        { MODKEY,                   XK_r,               spawn,              SHCMD("dmenu_run -i -l 20") },
-+        { MODKEY|ShiftMask,         XK_r,               spawn,              SHCMD("rofi -show run -theme ~/.config/polybar/forest/scripts/rofi/launcher.rasi") },
-+        { MODKEY,                   XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_copy.sh") },
-+        { MODKEY|ShiftMask,         XK_t,               spawn,              SHCMD("~/.local/bin/my_scripts/script_helper.sh " TERMINAL) },
-+        { MODKEY|ShiftMask,         XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh new " TERMINAL) },
-+        { MODKEY|ShiftMask,         XK_d,               spawn,              SHCMD("~/.local/bin/my_scripts/code_helper.sh old " TERMINAL) },
-+        { MODKEY,                   XK_g,               spawn,              SHCMD("~/.local/bin/my_scripts/fzf_open.sh " TERMINAL)},
-+        { MODKEY,                   XK_c,               spawn,              SHCMD("~/.local/bin/my_scripts/term_calc.sh " TERMINAL) },
-+        { MODKEY|ControlMask,       XK_c,               spawn,              SHCMD("yad --calendar --no-buttons") },
-+        { MODKEY,                   XK_b,               spawn,              SHCMD(TERMINAL " -e htop") },
-+        { MODKEY|ShiftMask,         XK_b,               spawn,              SHCMD(TERMINAL " -e bashtop") },
-+        { MODKEY|ControlMask,       XK_b,               spawn,              SHCMD(TERMINAL " -e ytop") },
-+        { MODKEY,                   XK_p,               spawn,              SHCMD("~/.local/bin/my_scripts/xrandr_helper.sh") },
-+        { MODKEY,                   XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/nautilus_wd.sh") },
-+        { MODKEY|ShiftMask,         XK_n,               spawn,              SHCMD(FILES) },
-+        { MODKEY|ControlMask,       XK_n,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 1 " TERMINAL) },
-+        { MODKEY,                   XK_m,               spawn,              SHCMD("nm-connection-editor") },
-+        { MODKEY|ShiftMask,         XK_m,               spawn,              SHCMD("spotify") },
-+        { MODKEY|ControlMask,       XK_m,               spawn,              SHCMD("~/.local/bin/my_scripts/open_notes.sh 2 " TERMINAL) },
-+        { MODKEY|ShiftMask,         XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend.sh")},
-+        { MODKEY|ControlMask,       XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/alert_exit.sh && ~/.local/bin/my_scripts/suspend_mute.sh")},
-+        { MODKEY|ShiftMask,         XK_period,          spawn,              SHCMD("i3lock && ~/.local/bin/my_scripts/alert_exit.sh && systemctl suspend")},
-+        { MODKEY,                   XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/clip_history.sh greenclip") },
-+        { MODKEY|ShiftMask,         XK_v,               spawn,              SHCMD("~/.local/bin/my_scripts/qr_clip.sh") },
-+        { MODKEY,                   XK_comma,           spawn,              SHCMD("~/.local/bin/my_scripts/progrm_helper.sh " TERMINAL) },
-+        { MODKEY,                   XK_period,          spawn,              SHCMD("~/.local/bin/my_scripts/emojipick/emojipick") },
-+        { MODKEY,                   XK_a,               spawn,              SHCMD("~/.local/bin/my_scripts/tmux_attach.sh " TERMINAL) },
-+        { MODKEY|ShiftMask,         XK_a,               spawn,              SHCMD("picom-trans -c -5")},
-+        { MODKEY|ControlMask,       XK_a,               spawn,              SHCMD("picom-trans -c +5")},
-+        { MODKEY,                   XK_section,         spawn,              SHCMD("~/.local/bin/my_scripts/loadEww.sh") },
-+        /* { MODKEY,                   XK_BackSpace,       spawn,              SHCMD("sysact") }, */
-+        /* { MODKEY|ShiftMask,         XK_BackSpace,       spawn,              SHCMD("sysact") }, */
-+        { MODKEY,                   XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " TERMINAL) },
-+        { MODKEY|ShiftMask,         XK_Return,          spawn,              {.v = termcmd } },
-+        { MODKEY|ControlMask,       XK_Return,          spawn,              SHCMD("~/.local/bin/my_scripts/term_wd.sh " SECTERMINAL) },
-+
-+        /* { MODKEY,                   XK_bracketleft,     spawn,              SHCMD("mpc seek -10") }, */
-+        /* { MODKEY|ShiftMask,         XK_bracketleft,     spawn,              SHCMD("mpc seek -60") }, */
-+        /* { MODKEY,                   XK_bracketright,    spawn,              SHCMD("mpc seek +10") }, */
-+        /* { MODKEY|ShiftMask,         XK_bracketright,    spawn,              SHCMD("mpc seek +60") }, */
-+        /* { MODKEY,                   XK_Page_Up,         shiftview,          { .i = -1 } }, */
-+        /* { MODKEY|ShiftMask,         XK_Page_Up,         shifttag,           { .i = -1 } }, */
-+        /* { MODKEY,                   XK_Page_Down,       shiftview,          { .i = +1 } }, */
-+        /* { MODKEY|ShiftMask,         XK_Page_Down,       shifttag,           { .i = +1 } }, */
-+        /* { MODKEY,                   XK_backslash,       view,               {0} }, */
-+        /* { MODKEY,                   XK_F1,              spawn,              SHCMD("groff -mom /usr/local/share/dwm/larbs.mom -Tpdf | zathura -") }, */
-+
-+        { 0,                        XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh dwm " TERMINAL) },
-+        { ShiftMask,                XK_F1,              spawn,              SHCMD("~/.local/bin/my_scripts/show_keys.sh vim " TERMINAL) },
-+        /* { MODKEY,                   XK_F2,              spawn,              SHCMD("tutorialvids") }, */
-+        /* { MODKEY,                   XK_F3,              spawn,              SHCMD("displayselect") }, */
-+        /* { MODKEY,                   XK_F4,              spawn,              SHCMD(TERMINAL " -e pulsemixer; kill -44 $(pidof dwmblocks)") }, */
-+        /* { MODKEY,                   XK_F5,              xrdb,               {.v = NULL } }, */
-+        /* { MODKEY,                   XK_F6,              spawn,              SHCMD("torwrap") }, */
-+        /* { MODKEY,                   XK_F7,              spawn,              SHCMD("td-toggle") }, */
-+        /* { MODKEY,                   XK_F8,              spawn,              SHCMD("mw -Y") }, */
-+        /* { MODKEY,                   XK_F9,              spawn,              SHCMD("dmenumount") }, */
-+        { 0,                        XK_F10,             spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
-+        { 0,                        XK_F11,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
-+        { 0,                        XK_F12,             spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
-+        { 0,                        XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_select.sh") },
-+        { ShiftMask,                XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot.sh") },
-+        { ControlMask,              XK_Print,           spawn,              SHCMD("~/.local/bin/my_scripts/screenshot_ocr.sh") },
-+
-+        /* { MODKEY, XK_Insert,                            spawn,              SHCMD("xdotool type $(grep -v '^#' ~/.local/share/larbs/snippets | dmenu -i -l 50 | cut -d' ' -f1)") }, */
-+        { 0, XF86XK_AudioMute,                          spawn,              SHCMD("pactl set-sink-mute @DEFAULT_SINK@ toggle ; kill -44 $(pidof dwmblocks)") },
-+        { 0, XF86XK_AudioRaiseVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ +5%; kill -44 $(pidof dwmblocks)") },
-+        { 0, XF86XK_AudioLowerVolume,                   spawn,              SHCMD("pactl set-sink-volume @DEFAULT_SINK@ -5%; kill -44 $(pidof dwmblocks)") },
-+        { 0, XF86XK_MonBrightnessUp,                    spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh +10") },
-+        { 0, XF86XK_MonBrightnessDown,                  spawn,              SHCMD("~/.local/bin/my_scripts/brightness.sh -10") },
-+        /* { 0, XF86XK_AudioPrev,                          spawn,              SHCMD("mpc prev") }, */
-+        /* { 0, XF86XK_AudioNext,                          spawn,              SHCMD("mpc next") }, */
-+        /* { 0, XF86XK_AudioPause,                         spawn,              SHCMD("mpc pause") }, */
-+        /* { 0, XF86XK_AudioPlay,                          spawn,              SHCMD("mpc play") }, */
-+        /* { 0, XF86XK_AudioStop,                          spawn,              SHCMD("mpc stop") }, */
-+        /* { 0, XF86XK_AudioRewind,                        spawn,              SHCMD("mpc seek -10") }, */
-+        /* { 0, XF86XK_AudioForward,                       spawn,              SHCMD("mpc seek +10") }, */
-+        /* { 0, XF86XK_AudioMedia,                         spawn,              SHCMD(TERMINAL " -e ncmpcpp") }, */
-+        /* { 0, XF86XK_AudioMicMute,                       spawn,              SHCMD("pactl set-source-mute @DEFAULT_SOURCE@ toggle") }, */
-+        /* { 0, XF86XK_PowerOff,                           spawn,              SHCMD("sysact") }, */
-+        /* { 0, XF86XK_Calculator,                         spawn,              SHCMD(TERMINAL " -e bc -l") }, */
-+        /* { 0, XF86XK_Sleep,                              spawn,              SHCMD("sudo -A zzz") }, */
-+        /* { 0, XF86XK_WWW,                                spawn,              SHCMD("$BROWSER") }, */
-+        /* { 0, XF86XK_DOS,                                spawn,              SHCMD(TERMINAL) }, */
-+        /* { 0, XF86XK_ScreenSaver,                        spawn,              SHCMD("slock & xset dpms force off; mpc pause; pauseallmpv") }, */
-+        /* { 0, XF86XK_TaskPane,                           spawn,              SHCMD(TERMINAL " -e htop") }, */
-+        /* { 0, XF86XK_Mail,                               spawn,              SHCMD(TERMINAL " -e neomutt ; pkill -RTMIN+12 dwmblocks") }, */
-+        /* { 0, XF86XK_MyComputer,                         spawn,              SHCMD(TERMINAL " -e lf /") }, */
-+        /* { 0, XF86XK_Battery,                            spawn,              SHCMD("") }, */
-+        /* { 0, XF86XK_Launch1,                            spawn,              SHCMD("xset dpms force off") }, */
-+        /* { 0, XF86XK_TouchpadToggle,                     spawn,              SHCMD("(synclient | grep 'TouchpadOff.*1' && synclient TouchpadOff=0) || synclient TouchpadOff=1") }, */
-+        /* { 0, XF86XK_TouchpadOff,                        spawn,              SHCMD("synclient TouchpadOff=1") }, */
-+        /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
-+};
-+
-+/* button definitions */
-+/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
-+static const Button buttons[] = {
-+    /* click                event mask      button          function        argument */
-+#ifndef __OpenBSD__
-+    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
-+    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
-+    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
-+    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
-+    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
-+    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
-+#endif
-+    { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
-+    { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
-+    { ClkClientWin,         MODKEY,         Button2,        defaultgaps,    {0} },
-+    { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
-+    { ClkClientWin,         MODKEY,         Button4,        incrgaps,       {.i = +1} },
-+    { ClkClientWin,         MODKEY,         Button5,        incrgaps,       {.i = -1} },
-+    { ClkTagBar,            0,              Button1,        view,           {0} },
-+    { ClkTagBar,            0,              Button3,        toggleview,     {0} },
-+    { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-+    { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
-+    { ClkTagBar,            0,              Button4,        shiftview,      {.i = -1} },
-+    { ClkTagBar,            0,              Button5,        shiftview,      {.i = 1} },
-+    { ClkRootWin,           0,              Button2,        togglebar,      {0} },
-+};
-diff --git a/config.mk b/config.mk
-index 8efca9a..1fc4bf1 100644
---- a/config.mk
-+++ b/config.mk
-@@ -19,11 +19,10 @@ FREETYPELIBS = -lfontconfig -lXft
- FREETYPEINC = /usr/include/freetype2
- # OpenBSD (uncomment)
- #FREETYPEINC = ${X11INC}/freetype2
--#MANPREFIX = ${PREFIX}/man
- 
- # includes and libs
- INCS = -I${X11INC} -I${FREETYPEINC}
--LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
-+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
- 
- # flags
- CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
-diff --git a/drw.c b/drw.c
-index c41e6af..d43d8c2 100644
---- a/drw.c
-+++ b/drw.c
-@@ -13,6 +13,7 @@
- static int
- utf8decode(const char *s_in, long *u, int *err)
- {
-+
- 	static const unsigned char lens[] = {
- 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
- 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
-@@ -26,63 +27,63 @@ utf8decode(const char *s_in, long *u, int *err)
- 
- 	const unsigned char *s = (const unsigned char *)s_in;
- 	int len = lens[*s >> 3];
--	*u = UTF_INVALID;
-+
-+    *u = UTF_INVALID;
- 	*err = 1;
- 	if (len == 0)
--		return 1;
-+        return 1;
- 
- 	long cp = s[0] & leading_mask[len - 1];
- 	for (int i = 1; i < len; ++i) {
- 		if (s[i] == '\0' || (s[i] & 0xC0) != 0x80)
- 			return i;
- 		cp = (cp << 6) | (s[i] & 0x3F);
--	}
-+    }
- 	/* out of range, surrogate, overlong encoding */
- 	if (cp > 0x10FFFF || (cp >> 11) == 0x1B || cp < overlong[len - 1])
- 		return len;
- 
- 	*err = 0;
- 	*u = cp;
--	return len;
-+    return len;
- }
- 
- Drw *
- drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
- {
--	Drw *drw = ecalloc(1, sizeof(Drw));
--
--	drw->dpy = dpy;
--	drw->screen = screen;
--	drw->root = root;
--	drw->w = w;
--	drw->h = h;
--	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
--	drw->gc = XCreateGC(dpy, root, 0, NULL);
--	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
--
--	return drw;
-+    Drw *drw = ecalloc(1, sizeof(Drw));
-+
-+    drw->dpy = dpy;
-+    drw->screen = screen;
-+    drw->root = root;
-+    drw->w = w;
-+    drw->h = h;
-+    drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
-+    drw->gc = XCreateGC(dpy, root, 0, NULL);
-+    XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
-+
-+    return drw;
- }
- 
- void
- drw_resize(Drw *drw, unsigned int w, unsigned int h)
- {
--	if (!drw)
--		return;
--
--	drw->w = w;
--	drw->h = h;
--	if (drw->drawable)
--		XFreePixmap(drw->dpy, drw->drawable);
--	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
-+    if (!drw)
-+        return;
-+
-+    drw->w = w;
-+    drw->h = h;
-+    if (drw->drawable)
-+        XFreePixmap(drw->dpy, drw->drawable);
-+    drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
- }
- 
- void
- drw_free(Drw *drw)
- {
--	XFreePixmap(drw->dpy, drw->drawable);
--	XFreeGC(drw->dpy, drw->gc);
--	drw_fontset_free(drw->fonts);
--	free(drw);
-+    XFreePixmap(drw->dpy, drw->drawable);
-+    XFreeGC(drw->dpy, drw->gc);
-+    free(drw);
- }
- 
- /* This function is an implementation detail. Library users should use
-@@ -91,134 +92,136 @@ drw_free(Drw *drw)
- static Fnt *
- xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
- {
--	Fnt *font;
--	XftFont *xfont = NULL;
--	FcPattern *pattern = NULL;
--
--	if (fontname) {
--		/* Using the pattern found at font->xfont->pattern does not yield the
--		 * same substitution results as using the pattern returned by
--		 * FcNameParse; using the latter results in the desired fallback
--		 * behaviour whereas the former just results in missing-character
--		 * rectangles being drawn, at least with some fonts. */
--		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
--			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
--			return NULL;
--		}
--		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
--			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
--			XftFontClose(drw->dpy, xfont);
--			return NULL;
--		}
--	} else if (fontpattern) {
--		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
--			fprintf(stderr, "error, cannot load font from pattern.\n");
--			return NULL;
--		}
--	} else {
--		die("no font specified.");
--	}
--
--	font = ecalloc(1, sizeof(Fnt));
--	font->xfont = xfont;
--	font->pattern = pattern;
--	font->h = xfont->ascent + xfont->descent;
--	font->dpy = drw->dpy;
--
--	return font;
-+    Fnt *font;
-+    XftFont *xfont = NULL;
-+    FcPattern *pattern = NULL;
-+
-+    if (fontname) {
-+        /* Using the pattern found at font->xfont->pattern does not yield the
-+         * same substitution results as using the pattern returned by
-+         * FcNameParse; using the latter results in the desired fallback
-+         * behaviour whereas the former just results in missing-character
-+         * rectangles being drawn, at least with some fonts. */
-+        if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-+            fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
-+            return NULL;
-+        }
-+        if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-+            fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
-+            XftFontClose(drw->dpy, xfont);
-+            return NULL;
-+        }
-+    } else if (fontpattern) {
-+        if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-+            fprintf(stderr, "error, cannot load font from pattern.\n");
-+            return NULL;
-+        }
-+    } else {
-+        die("no font specified.");
-+    }
-+
-+    font = ecalloc(1, sizeof(Fnt));
-+    font->xfont = xfont;
-+    font->pattern = pattern;
-+    font->h = xfont->ascent + xfont->descent;
-+    font->dpy = drw->dpy;
-+
-+    return font;
- }
- 
- static void
- xfont_free(Fnt *font)
- {
--	if (!font)
--		return;
--	if (font->pattern)
--		FcPatternDestroy(font->pattern);
--	XftFontClose(font->dpy, font->xfont);
--	free(font);
-+    if (!font)
-+        return;
-+    if (font->pattern)
-+        FcPatternDestroy(font->pattern);
-+    XftFontClose(font->dpy, font->xfont);
-+    free(font);
- }
- 
- Fnt*
- drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
- {
--	Fnt *cur, *ret = NULL;
--	size_t i;
--
--	if (!drw || !fonts)
--		return NULL;
--
--	for (i = 1; i <= fontcount; i++) {
--		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
--			cur->next = ret;
--			ret = cur;
--		}
--	}
--	return (drw->fonts = ret);
-+    Fnt *cur, *ret = NULL;
-+    size_t i;
-+
-+    if (!drw || !fonts)
-+        return NULL;
-+
-+    for (i = 1; i <= fontcount; i++) {
-+        if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
-+            cur->next = ret;
-+            ret = cur;
-+        }
-+    }
-+    return (drw->fonts = ret);
- }
- 
- void
- drw_fontset_free(Fnt *font)
- {
--	if (font) {
--		drw_fontset_free(font->next);
--		xfont_free(font);
--	}
-+    if (font) {
-+        drw_fontset_free(font->next);
-+        xfont_free(font);
-+    }
- }
- 
- void
- drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
- {
--	if (!drw || !dest || !clrname)
--		return;
-+    if (!drw || !dest || !clrname)
-+        return;
-+
-+    if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
-+                DefaultColormap(drw->dpy, drw->screen),
-+                clrname, dest))
-+        die("error, cannot allocate color '%s'", clrname);
- 
--	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
--	                       DefaultColormap(drw->dpy, drw->screen),
--	                       clrname, dest))
--		die("error, cannot allocate color '%s'", clrname);
-+    dest->pixel |= 0xff << 24;
- }
- 
- /* Wrapper to create color schemes. The caller has to call free(3) on the
-  * returned color scheme when done using it. */
- Clr *
--drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
-+drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
- {
--	size_t i;
--	Clr *ret;
-+    size_t i;
-+    Clr *ret;
- 
--	/* need at least two colors for a scheme */
--	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
--		return NULL;
-+    /* need at least two colors for a scheme */
-+    if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
-+        return NULL;
- 
--	for (i = 0; i < clrcount; i++)
--		drw_clr_create(drw, &ret[i], clrnames[i]);
--	return ret;
-+    for (i = 0; i < clrcount; i++)
-+        drw_clr_create(drw, &ret[i], clrnames[i]);
-+    return ret;
- }
- 
- void
- drw_setfontset(Drw *drw, Fnt *set)
- {
--	if (drw)
--		drw->fonts = set;
-+    if (drw)
-+        drw->fonts = set;
- }
- 
- void
- drw_setscheme(Drw *drw, Clr *scm)
- {
--	if (drw)
--		drw->scheme = scm;
-+    if (drw)
-+        drw->scheme = scm;
- }
- 
- void
- drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
- {
--	if (!drw || !drw->scheme)
--		return;
--	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
--	if (filled)
--		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
--	else
--		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
-+    if (!drw || !drw->scheme)
-+        return;
-+    XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
-+    if (filled)
-+        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-+    else
-+        XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
- }
- 
- int
-@@ -226,51 +229,52 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
- {
- 	int ty, ellipsis_x = 0;
- 	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len, hash, h0, h1;
--	XftDraw *d = NULL;
--	Fnt *usedfont, *curfont, *nextfont;
--	int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
--	long utf8codepoint = 0;
--	const char *utf8str;
--	FcCharSet *fccharset;
--	FcPattern *fcpattern;
--	FcPattern *match;
--	XftResult result;
-+    XftDraw *d = NULL;
-+    Fnt *usedfont, *curfont, *nextfont;
-+    int utf8strlen, utf8charlen, utf8err, render = x || y || w || h;
-+    long utf8codepoint = 0;
-+    const char *utf8str;
-+    FcCharSet *fccharset;
-+    FcPattern *fcpattern;
-+    FcPattern *match;
-+    XftResult result;
- 	int charexists = 0, overflow = 0;
- 	/* keep track of a couple codepoints for which we have no match. */
- 	static unsigned int nomatches[128], ellipsis_width, invalid_width;
- 	static const char invalid[] = "�";
- 
--	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
--		return 0;
-+    if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
-+        return 0;
- 
--	if (!render) {
--		w = invert ? invert : ~invert;
--	} else {
--		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
--		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-+    if (!render) {
-+        w = invert ? invert : ~invert;
-+    } else {
-+        XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
-+        XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
- 		if (w < lpad)
- 			return x + w;
--		d = XftDrawCreate(drw->dpy, drw->drawable,
--		                  DefaultVisual(drw->dpy, drw->screen),
--		                  DefaultColormap(drw->dpy, drw->screen));
--		x += lpad;
--		w -= lpad;
--	}
--
--	usedfont = drw->fonts;
-+        d = XftDrawCreate(drw->dpy, drw->drawable,
-+                DefaultVisual(drw->dpy, drw->screen),
-+                DefaultColormap(drw->dpy, drw->screen));
-+        x += lpad;
-+        w -= lpad;
-+    }
-+
-+    usedfont = drw->fonts;
- 	if (!ellipsis_width && render)
- 		ellipsis_width = drw_fontset_getwidth(drw, "...");
- 	if (!invalid_width && render)
- 		invalid_width = drw_fontset_getwidth(drw, invalid);
--	while (1) {
--		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
--		utf8str = text;
--		nextfont = NULL;
--		while (*text) {
--			utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
--			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
--				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
--				if (charexists) {
-+    while (1) {
-+        utf8strlen = 0;
-+        ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
-+        utf8str = text;
-+        nextfont = NULL;
-+        while (*text) {
-+            utf8charlen = utf8decode(text, &utf8codepoint, &utf8err);
-+            for (curfont = drw->fonts; curfont; curfont = curfont->next) {
-+                charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
-+                if (charexists) {
- 					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
- 					if (ew + ellipsis_width <= w) {
- 						/* keep track where the ellipsis still fits */
-@@ -289,31 +293,31 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
- 						else
- 							utf8strlen = ellipsis_len;
- 					} else if (curfont == usedfont) {
--						text += utf8charlen;
-+                        text += utf8charlen;
- 						utf8strlen += utf8err ? 0 : utf8charlen;
- 						ew += utf8err ? 0 : tmpw;
--					} else {
--						nextfont = curfont;
--					}
--					break;
--				}
--			}
--
--			if (overflow || !charexists || nextfont || utf8err)
--				break;
--			else
--				charexists = 0;
--		}
--
--		if (utf8strlen) {
-+                    } else {
-+                        nextfont = curfont;
-+                    }
-+                    break;
-+                }
-+            }
-+
-+            if (overflow || !charexists || nextfont || utf8err)
-+                break;
-+            else
-+                charexists = 0;
-+        }
-+
-+        if (utf8strlen) {
- 			if (render) {
- 				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
- 				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
- 				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
--			}
-+            }
- 			x += ew;
- 			w -= ew;
--		}
-+        }
- 		if (utf8err && (!render || invalid_width < w)) {
- 			if (render)
- 				drw_text(drw, x, y, w, h, 0, invalid, invert);
-@@ -323,15 +327,15 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
- 		if (render && overflow)
- 			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
- 
--		if (!*text || overflow) {
--			break;
--		} else if (nextfont) {
--			charexists = 0;
--			usedfont = nextfont;
--		} else {
--			/* Regardless of whether or not a fallback font is found, the
--			 * character must be drawn. */
--			charexists = 1;
-+        if (!*text || overflow) {
-+            break;
-+        } else if (nextfont) {
-+            charexists = 0;
-+            usedfont = nextfont;
-+        } else {
-+            /* Regardless of whether or not a fallback font is found, the
-+             * character must be drawn. */
-+            charexists = 1;
- 
- 			hash = (unsigned int)utf8codepoint;
- 			hash = ((hash >> 16) ^ hash) * 0x21F0AAAD;
-@@ -342,62 +346,63 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
- 			if (nomatches[h0] == utf8codepoint || nomatches[h1] == utf8codepoint)
- 				goto no_match;
- 
--			fccharset = FcCharSetCreate();
--			FcCharSetAddChar(fccharset, utf8codepoint);
--
--			if (!drw->fonts->pattern) {
--				/* Refer to the comment in xfont_create for more information. */
--				die("the first font in the cache must be loaded from a font string.");
--			}
--
--			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
--			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
--			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
--
--			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
--			FcDefaultSubstitute(fcpattern);
--			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
--
--			FcCharSetDestroy(fccharset);
--			FcPatternDestroy(fcpattern);
--
--			if (match) {
--				usedfont = xfont_create(drw, NULL, match);
--				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
--					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
--						; /* NOP */
--					curfont->next = usedfont;
--				} else {
--					xfont_free(usedfont);
--					nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
-+            fccharset = FcCharSetCreate();
-+            FcCharSetAddChar(fccharset, utf8codepoint);
-+
-+            if (!drw->fonts->pattern) {
-+                /* Refer to the comment in xfont_create for more information. */
-+                die("the first font in the cache must be loaded from a font string.");
-+            }
-+
-+            fcpattern = FcPatternDuplicate(drw->fonts->pattern);
-+            FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
-+            FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
-+            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
-+
-+            FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
-+            FcDefaultSubstitute(fcpattern);
-+            match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
-+
-+            FcCharSetDestroy(fccharset);
-+            FcPatternDestroy(fcpattern);
-+
-+            if (match) {
-+                usedfont = xfont_create(drw, NULL, match);
-+                if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
-+                    for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
-+                        ; /* NOP */
-+                    curfont->next = usedfont;
-+                } else {
-+                    xfont_free(usedfont);
-+                    nomatches[nomatches[h0] ? h1 : h0] = utf8codepoint;
- no_match:
--					usedfont = drw->fonts;
--				}
--			}
--		}
--	}
--	if (d)
--		XftDrawDestroy(d);
--
--	return x + (render ? w : 0);
-+                    usedfont = drw->fonts;
-+                }
-+            }
-+        }
-+    }
-+    if (d)
-+        XftDrawDestroy(d);
-+
-+    return x + (render ? w : 0);
- }
- 
- void
- drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
- {
--	if (!drw)
--		return;
-+    if (!drw)
-+        return;
- 
--	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
--	XSync(drw->dpy, False);
-+    XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
-+    XSync(drw->dpy, False);
- }
- 
- unsigned int
- drw_fontset_getwidth(Drw *drw, const char *text)
- {
--	if (!drw || !drw->fonts || !text)
--		return 0;
--	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
-+    if (!drw || !drw->fonts || !text)
-+        return 0;
-+    return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
- }
- 
- unsigned int
-@@ -412,37 +417,37 @@ drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
- void
- drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
- {
--	XGlyphInfo ext;
-+    XGlyphInfo ext;
- 
--	if (!font || !text)
--		return;
-+    if (!font || !text)
-+        return;
- 
--	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
--	if (w)
--		*w = ext.xOff;
--	if (h)
--		*h = font->h;
-+    XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-+    if (w)
-+        *w = ext.xOff;
-+    if (h)
-+        *h = font->h;
- }
- 
- Cur *
- drw_cur_create(Drw *drw, int shape)
- {
--	Cur *cur;
-+    Cur *cur;
- 
--	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
--		return NULL;
-+    if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
-+        return NULL;
- 
--	cur->cursor = XCreateFontCursor(drw->dpy, shape);
-+    cur->cursor = XCreateFontCursor(drw->dpy, shape);
- 
--	return cur;
-+    return cur;
- }
- 
- void
- drw_cur_free(Drw *drw, Cur *cursor)
- {
--	if (!cursor)
--		return;
-+    if (!cursor)
-+        return;
- 
--	XFreeCursor(drw->dpy, cursor->cursor);
--	free(cursor);
-+    XFreeCursor(drw->dpy, cursor->cursor);
-+    free(cursor);
- }
-diff --git a/drw.h b/drw.h
-index 6471431..ea76849 100644
---- a/drw.h
-+++ b/drw.h
-@@ -1,29 +1,29 @@
- /* See LICENSE file for copyright and license details. */
- 
- typedef struct {
--	Cursor cursor;
-+    Cursor cursor;
- } Cur;
- 
- typedef struct Fnt {
--	Display *dpy;
--	unsigned int h;
--	XftFont *xfont;
--	FcPattern *pattern;
--	struct Fnt *next;
-+    Display *dpy;
-+    unsigned int h;
-+    XftFont *xfont;
-+    FcPattern *pattern;
-+    struct Fnt *next;
- } Fnt;
- 
- enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
- typedef XftColor Clr;
- 
- typedef struct {
--	unsigned int w, h;
--	Display *dpy;
--	int screen;
--	Window root;
--	Drawable drawable;
--	GC gc;
--	Clr *scheme;
--	Fnt *fonts;
-+    unsigned int w, h;
-+    Display *dpy;
-+    int screen;
-+    Window root;
-+    Drawable drawable;
-+    GC gc;
-+    Clr *scheme;
-+    Fnt *fonts;
- } Drw;
- 
- /* Drawable abstraction */
-@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
- 
- /* Colorscheme abstraction */
- void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
--Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
-+Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
- 
- /* Cursor abstraction */
- Cur *drw_cur_create(Drw *drw, int shape);
-diff --git a/dwm.1 b/dwm.1
-index ddc8321..7feba78 100644
---- a/dwm.1
-+++ b/dwm.1
-@@ -1,21 +1,16 @@
- .TH DWM 1 dwm\-VERSION
- .SH NAME
--dwm \- dynamic window manager
-+dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
- .SH SYNOPSIS
- .B dwm
- .RB [ \-v ]
- .SH DESCRIPTION
--dwm is a dynamic window manager for X. It manages windows in tiled, monocle
--and floating layouts. Either layout can be applied dynamically, optimising the
--environment for the application in use and the task performed.
-+dwm is a dynamic window manager for X.
- .P
--In tiled layouts windows are managed in a master and stacking area. The master
--area on the left contains one window by default, and the stacking area on the
--right contains all other windows. The number of master area windows can be
--adjusted from zero to an arbitrary number. In monocle layout all windows are
--maximised to the screen size. In floating layout windows can be resized and
--moved freely. Dialog windows are always managed floating, regardless of the
--layout applied.
-+dwm "orders" windows based on recency and primacy, while dwm layouts may
-+change, the most recent "master" window is shown in the most prominent
-+position. There are bindings for cycling through and promoting windows to the
-+master position.
- .P
- Windows are grouped by tags. Each window can be tagged with one or multiple
- tags. Selecting certain tags displays all windows with these tags.
-@@ -30,10 +25,19 @@ top left corner.  The tags which are applied to one or more windows are
- indicated with an empty square in the top left corner.
- .P
- dwm draws a small border around windows to indicate the focus state.
-+.P
-+.I
-+libxft-bgra
-+should be installed for this build of dwm. Arch users may install it via the
-+AUR. Color characters and emoji are enabled, but these will cause crashes
-+without the fix
-+.I
-+libxft-bgra
-+offers.
- .SH OPTIONS
- .TP
- .B \-v
--prints version information to stderr, then exits.
-+prints version information to standard output, then exits.
- .SH USAGE
- .SS Status bar
- .TP
-@@ -42,119 +46,168 @@ is read and displayed in the status text area. It can be set with the
- .BR xsetroot (1)
- command.
- .TP
--.B Button1
-+.B Left click
- click on a tag label to display all windows with that tag, click on the layout
- label toggles between tiled and floating layout.
- .TP
--.B Button3
-+.B Right click
- click on a tag label adds/removes all windows with that tag to/from the view.
- .TP
--.B Mod1\-Button1
-+.B Super\-Left click
- click on a tag label applies that tag to the focused window.
- .TP
--.B Mod1\-Button3
-+.B Super\-Right click
- click on a tag label adds/removes that tag to/from the focused window.
- .SS Keyboard commands
- .TP
--.B Mod1\-Shift\-Return
--Start
-+.B Super\-Return
-+Start terminal,
- .BR st(1).
- .TP
--.B Mod1\-p
-+.B Super\-d
- Spawn
- .BR dmenu(1)
- for launching other programs.
- .TP
--.B Mod1\-,
--Focus previous screen, if any.
--.TP
--.B Mod1\-.
--Focus next screen, if any.
-+.B Super\-b
-+Toggles bar on and off.
- .TP
--.B Mod1\-Shift\-,
--Send focused window to previous screen, if any.
-+.B Super\-q
-+Close focused window.
- .TP
--.B Mod1\-Shift\-.
--Send focused window to next screen, if any.
-+.B Super\-t/T
-+Sets tiled/bstack layouts.
- .TP
--.B Mod1\-b
--Toggles bar on and off.
-+.B Super\-f
-+Toggle fullscreen window.
- .TP
--.B Mod1\-t
--Sets tiled layout.
-+.B Super\-F
-+Toggle floating layout.
- .TP
--.B Mod1\-f
--Sets floating layout.
-+.B Super\-y/Y
-+Sets Fibonacci spiral/dwinde layouts.
- .TP
--.B Mod1\-m
--Sets monocle layout.
-+.B Super\-u/U
-+Sets centered master layout.
- .TP
--.B Mod1\-space
--Toggles between current and previous layout.
-+.B Super\-i/I
-+Sets centered master or floating master layouts.
- .TP
--.B Mod1\-j
--Focus next window.
-+.B Super\-space
-+Zooms/cycles focused window to/from master area.
- .TP
--.B Mod1\-k
--Focus previous window.
-+.B Super\-j/k
-+Focus next/previous window.
- .TP
--.B Mod1\-i
--Increase number of windows in master area.
-+.B Super\-Shift\-j/k
-+Move selected window down/up in stack.
- .TP
--.B Mod1\-d
--Decrease number of windows in master area.
-+.B Super\-o/O
-+Increase/decrease number of windows in master area.
- .TP
--.B Mod1\-l
-+.B Super\-l
- Increase master area size.
- .TP
--.B Mod1\-h
-+.B Super\-h
- Decrease master area size.
- .TP
--.B Mod1\-Return
--Zooms/cycles focused window to/from master area (tiled layouts only).
--.TP
--.B Mod1\-Shift\-c
--Close focused window.
--.TP
--.B Mod1\-Shift\-space
-+.B Super\-Shift\-space
- Toggle focused window between tiled and floating state.
- .TP
--.B Mod1\-Tab
-+.B Super\-Tab
- Toggles to the previously selected tags.
- .TP
--.B Mod1\-Shift\-[1..n]
-+.B Super\-g
-+Moves to the previous tag.
-+.TP
-+.B Super\-Shift\-g
-+Moves selected window to the previous tag.
-+.TP
-+.B Super\-;
-+Moves to the next tag.
-+.TP
-+.B Super\-Shift\-;
-+Moves selected window to the next tag.
-+.TP
-+.B Super\-PageUp
-+Moves to the previous tag.
-+.TP
-+.B Super\-Shift\-PageUp
-+Moves selected window to the previous tag.
-+.TP
-+.B Super\-Pagedown
-+Moves to the next tag.
-+.TP
-+.B Super\-Shift\-PageDown
-+Moves selected window to the next tag.
-+.TP
-+.B Super\-a
-+Toggle gaps.
-+.TP
-+.B Super\-z
-+Increase gaps between windows.
-+.TP
-+.B Super\-x
-+Decrease gaps between windows.
-+.TP
-+.B Super\-Shift\-[1..n]
- Apply nth tag to focused window.
- .TP
--.B Mod1\-Shift\-0
-+.B Super\-Shift\-0
- Apply all tags to focused window.
- .TP
--.B Mod1\-Control\-Shift\-[1..n]
-+.B Super\-Control\-Shift\-[1..n]
- Add/remove nth tag to/from focused window.
- .TP
--.B Mod1\-[1..n]
-+.B Super\-[1..n]
- View all windows with nth tag.
- .TP
--.B Mod1\-0
-+.B Super\-0
- View all windows with any tag.
- .TP
--.B Mod1\-Control\-[1..n]
-+.B Super\-Control\-[1..n]
- Add/remove all windows with nth tag to/from the view.
- .TP
--.B Mod1\-Shift\-q
-+.B Super\-Shift\-q
- Quit dwm.
-+.TP
-+.B Mod1\-Control\-Shift\-q
-+Menu to refresh/quit/reboot/shutdown.
- .SS Mouse commands
- .TP
--.B Mod1\-Button1
-+.B Super\-Left click
- Move focused window while dragging. Tiled windows will be toggled to the floating state.
- .TP
--.B Mod1\-Button2
-+.B Super\-Middle click
- Toggles focused window between floating and tiled state.
- .TP
--.B Mod1\-Button3
-+.B Super\-Right click
- Resize focused window while dragging. Tiled windows will be toggled to the floating state.
-+.SH FILES
-+The files containing programs to be started along with dwm are searched for in
-+the following directories:
-+.IP "1. $XDG_DATA_HOME/dwm"
-+.IP "2. $HOME/.local/share/dwm"
-+.IP "3. $HOME/.dwm"
-+.P
-+The first existing directory is scanned for any of the autostart files below.
-+.TP 15
-+autostart.sh
-+This file is started as a shell background process before dwm enters its handler
-+loop.
-+.TP 15
-+autostart_blocking.sh
-+This file is started before any autostart.sh; dwm waits for its termination.
- .SH CUSTOMIZATION
- dwm is customized by creating a custom config.h and (re)compiling the source
- code. This keeps it fast, secure and simple.
-+.SH SIGNALS
-+.TP
-+.B SIGHUP - 1
-+Restart the dwm process.
-+.TP
-+.B SIGTERM - 15
-+Cleanly terminate the dwm process.
- .SH SEE ALSO
- .BR dmenu (1),
- .BR st (1)
-diff --git a/dwm.c b/dwm.c
-index 1443802..9086e16 100644
---- a/dwm.c
-+++ b/dwm.c
-@@ -36,10 +36,13 @@
- #include <X11/Xlib.h>
- #include <X11/Xproto.h>
- #include <X11/Xutil.h>
-+#include <X11/Xresource.h>
- #ifdef XINERAMA
- #include <X11/extensions/Xinerama.h>
- #endif /* XINERAMA */
- #include <X11/Xft/Xft.h>
-+#include <X11/Xlib-xcb.h>
-+#include <xcb/res.h>
- 
- #include "drw.h"
- #include "util.h"
-@@ -47,99 +50,130 @@
- /* macros */
- #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
- #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
-+#define GETINC(X)               ((X) - 2000)
-+#define INC(X)                  ((X) + 2000)
- #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
--                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
--#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
-+        * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
-+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
-+#define PREVSEL                 3000
- #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
-+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
- #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
- #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
--#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-+#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
-+#define TAGMASK			((1 << NUMTAGS) - 1)
-+#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
-+#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
- #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
-+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
- 
- /* enums */
- enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
- enum { SchemeNorm, SchemeSel }; /* color schemes */
- enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
--       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
--       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
-+    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
-+    NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
- enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
--enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
--       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
-+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
-+    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
- 
- typedef union {
--	int i;
--	unsigned int ui;
--	float f;
--	const void *v;
-+    int i;
-+    unsigned int ui;
-+    float f;
-+    const void *v;
- } Arg;
- 
- typedef struct {
--	unsigned int click;
--	unsigned int mask;
--	unsigned int button;
--	void (*func)(const Arg *arg);
--	const Arg arg;
-+    unsigned int click;
-+    unsigned int mask;
-+    unsigned int button;
-+    void (*func)(const Arg *arg);
-+    const Arg arg;
- } Button;
- 
- typedef struct Monitor Monitor;
- typedef struct Client Client;
- struct Client {
--	char name[256];
--	float mina, maxa;
--	int x, y, w, h;
--	int oldx, oldy, oldw, oldh;
--	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
--	int bw, oldbw;
--	unsigned int tags;
--	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
--	Client *next;
--	Client *snext;
--	Monitor *mon;
--	Window win;
-+    char name[256];
-+    float mina, maxa;
-+    int x, y, w, h;
-+    int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
-+    int oldx, oldy, oldw, oldh;
-+    int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
-+    int bw, oldbw;
-+    unsigned int tags;
-+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
-+    pid_t pid;
-+    Client *next;
-+    Client *snext;
-+    Client *swallowing;
-+    Monitor *mon;
-+    Window win;
- };
- 
- typedef struct {
--	unsigned int mod;
--	KeySym keysym;
--	void (*func)(const Arg *);
--	const Arg arg;
-+    unsigned int mod;
-+    KeySym keysym;
-+    void (*func)(const Arg *);
-+    const Arg arg;
- } Key;
- 
- typedef struct {
--	const char *symbol;
--	void (*arrange)(Monitor *);
-+    const char *symbol;
-+    void (*arrange)(Monitor *);
- } Layout;
- 
- struct Monitor {
--	char ltsymbol[16];
--	float mfact;
--	int nmaster;
--	int num;
--	int by;               /* bar geometry */
--	int mx, my, mw, mh;   /* screen size */
--	int wx, wy, ww, wh;   /* window area  */
--	unsigned int seltags;
--	unsigned int sellt;
--	unsigned int tagset[2];
--	int showbar;
--	int topbar;
--	Client *clients;
--	Client *sel;
--	Client *stack;
--	Monitor *next;
--	Window barwin;
--	const Layout *lt[2];
-+    char ltsymbol[16];
-+    float mfact;
-+    int nmaster;
-+    int num;
-+    int by;               /* bar geometry */
-+    int mx, my, mw, mh;   /* screen size */
-+    int wx, wy, ww, wh;   /* window area  */
-+    int gappih;           /* horizontal gap between windows */
-+    int gappiv;           /* vertical gap between windows */
-+    int gappoh;           /* horizontal outer gaps */
-+    int gappov;           /* vertical outer gaps */
-+    unsigned int seltags;
-+    unsigned int sellt;
-+    unsigned int tagset[2];
-+    int showbar;
-+    int topbar;
-+    Client *clients;
-+    Client *sel;
-+    Client *stack;
-+    Monitor *next;
-+    Window barwin;
-+    const Layout *lt[2];
- };
- 
- typedef struct {
--	const char *class;
--	const char *instance;
--	const char *title;
--	unsigned int tags;
--	int isfloating;
--	int monitor;
-+    const char *class;
-+    const char *instance;
-+    const char *title;
-+    unsigned int tags;
-+    int isfloating;
-+    int isterminal;
-+    int noswallow;
-+    int monitor;
- } Rule;
- 
-+/* Xresources preferences */
-+enum resource_type {
-+    STRING = 0,
-+    INTEGER = 1,
-+    FLOAT = 2
-+};
-+
-+typedef struct {
-+    char *name;
-+    enum resource_type type;
-+    void *dst;
-+} ResourcePref;
-+
- /* function declarations */
- static void applyrules(Client *c);
- static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
-@@ -155,6 +189,7 @@ static void clientmessage(XEvent *e);
- static void configure(Client *c);
- static void configurenotify(XEvent *e);
- static void configurerequest(XEvent *e);
-+static void copyvalidchars(char *text, char *rawtext);
- static Monitor *createmon(void);
- static void destroynotify(XEvent *e);
- static void detach(Client *c);
-@@ -162,7 +197,7 @@ static void detachstack(Client *c);
- static Monitor *dirtomon(int dir);
- static void drawbar(Monitor *m);
- static void drawbars(void);
--static void enternotify(XEvent *e);
-+static int drawstatusbar(Monitor *m, int bh, char* text);
- static void expose(XEvent *e);
- static void focus(Client *c);
- static void focusin(XEvent *e);
-@@ -186,6 +221,7 @@ static void movemouse(const Arg *arg);
- static Client *nexttiled(Client *c);
- static void pop(Client *c);
- static void propertynotify(XEvent *e);
-+static void pushstack(const Arg *arg);
- static void quit(const Arg *arg);
- static Monitor *recttomon(int x, int y, int w, int h);
- static void resize(Client *c, int x, int y, int w, int h, int interact);
-@@ -193,9 +229,11 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
- static void resizemouse(const Arg *arg);
- static void restack(Monitor *m);
- static void run(void);
-+static void runAutostart(void);
- static void scan(void);
- static int sendevent(Client *c, Atom proto);
- static void sendmon(Client *c, Monitor *m);
-+static void sendmonview(Client *c, Monitor *m);
- static void setclientstate(Client *c, long state);
- static void setfocus(Client *c);
- static void setfullscreen(Client *c, int fullscreen);
-@@ -204,12 +242,23 @@ static void setmfact(const Arg *arg);
- static void setup(void);
- static void seturgent(Client *c, int urg);
- static void showhide(Client *c);
-+#ifndef __OpenBSD__
-+static int getdwmblockspid();
-+static void sigdwmblocks(const Arg *arg);
-+#endif
-+static void sighup(int unused);
-+static void sigterm(int unused);
- static void spawn(const Arg *arg);
-+static int stackpos(const Arg *arg);
- static void tag(const Arg *arg);
-+static void tagview(const Arg *arg);
- static void tagmon(const Arg *arg);
--static void tile(Monitor *m);
-+static void tagmonview(const Arg *arg);
- static void togglebar(const Arg *arg);
- static void togglefloating(const Arg *arg);
-+static void togglescratch(const Arg *arg);
-+static void togglesticky(const Arg *arg);
-+static void togglefullscr(const Arg *arg);
- static void toggletag(const Arg *arg);
- static void toggleview(const Arg *arg);
- static void unfocus(Client *c, int setfocus);
-@@ -232,10 +281,22 @@ static int xerror(Display *dpy, XErrorEvent *ee);
- static int xerrordummy(Display *dpy, XErrorEvent *ee);
- static int xerrorstart(Display *dpy, XErrorEvent *ee);
- static void zoom(const Arg *arg);
-+static void load_xresources(void);
-+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
-+
-+static pid_t getparentprocess(pid_t p);
-+static int isdescprocess(pid_t p, pid_t c);
-+static Client *swallowingclient(Window w);
-+static Client *termforwin(const Client *c);
-+static pid_t winpid(Window w);
- 
- /* variables */
- static const char broken[] = "broken";
- static char stext[256];
-+/* static char stext[1024]; */
-+static char rawstext[256];
-+static int dwmblockssig;
-+pid_t dwmblockspid = 0;
- static int screen;
- static int sw, sh;           /* X display screen geometry width, height */
- static int bh;               /* bar height */
-@@ -243,22 +304,22 @@ static int lrpad;            /* sum of left and right padding for text */
- static int (*xerrorxlib)(Display *, XErrorEvent *);
- static unsigned int numlockmask = 0;
- static void (*handler[LASTEvent]) (XEvent *) = {
--	[ButtonPress] = buttonpress,
--	[ClientMessage] = clientmessage,
--	[ConfigureRequest] = configurerequest,
--	[ConfigureNotify] = configurenotify,
--	[DestroyNotify] = destroynotify,
--	[EnterNotify] = enternotify,
--	[Expose] = expose,
--	[FocusIn] = focusin,
--	[KeyPress] = keypress,
--	[MappingNotify] = mappingnotify,
--	[MapRequest] = maprequest,
--	[MotionNotify] = motionnotify,
--	[PropertyNotify] = propertynotify,
--	[UnmapNotify] = unmapnotify
-+    [ButtonPress] = buttonpress,
-+    [ClientMessage] = clientmessage,
-+    [ConfigureRequest] = configurerequest,
-+    [ConfigureNotify] = configurenotify,
-+    [DestroyNotify] = destroynotify,
-+    [Expose] = expose,
-+    [FocusIn] = focusin,
-+    [KeyPress] = keypress,
-+    [MappingNotify] = mappingnotify,
-+    [MapRequest] = maprequest,
-+    [MotionNotify] = motionnotify,
-+    [PropertyNotify] = propertynotify,
-+    [UnmapNotify] = unmapnotify
- };
- static Atom wmatom[WMLast], netatom[NetLast];
-+static int restart = 0;
- static int running = 1;
- static Cur *cursor[CurLast];
- static Clr **scheme;
-@@ -267,6 +328,8 @@ static Drw *drw;
- static Monitor *mons, *selmon;
- static Window root, wmcheckwin;
- 
-+static xcb_connection_t *xcon;
-+
- /* configuration, allows nested code to access above variables */
- #include "config.h"
- 
-@@ -277,1818 +340,2349 @@ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
- void
- applyrules(Client *c)
- {
--	const char *class, *instance;
--	unsigned int i;
--	const Rule *r;
--	Monitor *m;
--	XClassHint ch = { NULL, NULL };
--
--	/* rule matching */
--	c->isfloating = 0;
--	c->tags = 0;
--	XGetClassHint(dpy, c->win, &ch);
--	class    = ch.res_class ? ch.res_class : broken;
--	instance = ch.res_name  ? ch.res_name  : broken;
--
--	for (i = 0; i < LENGTH(rules); i++) {
--		r = &rules[i];
--		if ((!r->title || strstr(c->name, r->title))
--		&& (!r->class || strstr(class, r->class))
--		&& (!r->instance || strstr(instance, r->instance)))
--		{
--			c->isfloating = r->isfloating;
--			c->tags |= r->tags;
--			for (m = mons; m && m->num != r->monitor; m = m->next);
--			if (m)
--				c->mon = m;
--		}
--	}
--	if (ch.res_class)
--		XFree(ch.res_class);
--	if (ch.res_name)
--		XFree(ch.res_name);
--	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
-+    const char *class, *instance;
-+    unsigned int i;
-+    const Rule *r;
-+    Monitor *m;
-+    XClassHint ch = { NULL, NULL };
-+
-+    /* rule matching */
-+    c->isfloating = 0;
-+    c->tags = 0;
-+    XGetClassHint(dpy, c->win, &ch);
-+    class    = ch.res_class ? ch.res_class : broken;
-+    instance = ch.res_name  ? ch.res_name  : broken;
-+
-+    for (i = 0; i < LENGTH(rules); i++) {
-+        r = &rules[i];
-+        if ((!r->title || strstr(c->name, r->title))
-+                && (!r->class || strstr(class, r->class))
-+                && (!r->instance || strstr(instance, r->instance)))
-+        {
-+            c->isterminal = r->isterminal;
-+            c->isfloating = r->isfloating;
-+            c->noswallow  = r->noswallow;
-+            c->tags |= r->tags;
-+            if ((r->tags & SPTAGMASK) && r->isfloating) {
-+                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-+                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
-+            }
-+
-+            for (m = mons; m && m->num != r->monitor; m = m->next);
-+            if (m)
-+                c->mon = m;
-+        }
-+    }
-+    if (ch.res_class)
-+        XFree(ch.res_class);
-+    if (ch.res_name)
-+        XFree(ch.res_name);
-+    c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
- }
- 
- int
- applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
- {
--	int baseismin;
--	Monitor *m = c->mon;
--
--	/* set minimum possible */
--	*w = MAX(1, *w);
--	*h = MAX(1, *h);
--	if (interact) {
--		if (*x > sw)
--			*x = sw - WIDTH(c);
--		if (*y > sh)
--			*y = sh - HEIGHT(c);
--		if (*x + *w + 2 * c->bw < 0)
--			*x = 0;
--		if (*y + *h + 2 * c->bw < 0)
--			*y = 0;
--	} else {
--		if (*x >= m->wx + m->ww)
--			*x = m->wx + m->ww - WIDTH(c);
--		if (*y >= m->wy + m->wh)
--			*y = m->wy + m->wh - HEIGHT(c);
--		if (*x + *w + 2 * c->bw <= m->wx)
--			*x = m->wx;
--		if (*y + *h + 2 * c->bw <= m->wy)
--			*y = m->wy;
--	}
--	if (*h < bh)
--		*h = bh;
--	if (*w < bh)
--		*w = bh;
--	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
--		if (!c->hintsvalid)
--			updatesizehints(c);
--		/* see last two sentences in ICCCM 4.1.2.3 */
--		baseismin = c->basew == c->minw && c->baseh == c->minh;
--		if (!baseismin) { /* temporarily remove base dimensions */
--			*w -= c->basew;
--			*h -= c->baseh;
--		}
--		/* adjust for aspect limits */
--		if (c->mina > 0 && c->maxa > 0) {
--			if (c->maxa < (float)*w / *h)
--				*w = *h * c->maxa + 0.5;
--			else if (c->mina < (float)*h / *w)
--				*h = *w * c->mina + 0.5;
--		}
--		if (baseismin) { /* increment calculation requires this */
--			*w -= c->basew;
--			*h -= c->baseh;
--		}
--		/* adjust for increment value */
--		if (c->incw)
--			*w -= *w % c->incw;
--		if (c->inch)
--			*h -= *h % c->inch;
--		/* restore base dimensions */
--		*w = MAX(*w + c->basew, c->minw);
--		*h = MAX(*h + c->baseh, c->minh);
--		if (c->maxw)
--			*w = MIN(*w, c->maxw);
--		if (c->maxh)
--			*h = MIN(*h, c->maxh);
--	}
--	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
-+    int baseismin;
-+    Monitor *m = c->mon;
-+
-+    /* set minimum possible */
-+    *w = MAX(1, *w);
-+    *h = MAX(1, *h);
-+    if (interact) {
-+        if (*x > sw)
-+            *x = sw - WIDTH(c);
-+        if (*y > sh)
-+            *y = sh - HEIGHT(c);
-+        if (*x + *w + 2 * c->bw < 0)
-+            *x = 0;
-+        if (*y + *h + 2 * c->bw < 0)
-+            *y = 0;
-+    } else {
-+        if (*x >= m->wx + m->ww)
-+            *x = m->wx + m->ww - WIDTH(c);
-+        if (*y >= m->wy + m->wh)
-+            *y = m->wy + m->wh - HEIGHT(c);
-+        if (*x + *w + 2 * c->bw <= m->wx)
-+            *x = m->wx;
-+        if (*y + *h + 2 * c->bw <= m->wy)
-+            *y = m->wy;
-+    }
-+    if (*h < bh)
-+        *h = bh;
-+    if (*w < bh)
-+        *w = bh;
-+    if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
-+        if (!c->hintsvalid)
-+            updatesizehints(c);
-+        /* see last two sentences in ICCCM 4.1.2.3 */
-+        baseismin = c->basew == c->minw && c->baseh == c->minh;
-+        if (!baseismin) { /* temporarily remove base dimensions */
-+            *w -= c->basew;
-+            *h -= c->baseh;
-+        }
-+        /* adjust for aspect limits */
-+        if (c->mina > 0 && c->maxa > 0) {
-+            if (c->maxa < (float)*w / *h)
-+                *w = *h * c->maxa + 0.5;
-+            else if (c->mina < (float)*h / *w)
-+                *h = *w * c->mina + 0.5;
-+        }
-+        if (baseismin) { /* increment calculation requires this */
-+            *w -= c->basew;
-+            *h -= c->baseh;
-+        }
-+        /* adjust for increment value */
-+        if (c->incw)
-+            *w -= *w % c->incw;
-+        if (c->inch)
-+            *h -= *h % c->inch;
-+        /* restore base dimensions */
-+        *w = MAX(*w + c->basew, c->minw);
-+        *h = MAX(*h + c->baseh, c->minh);
-+        if (c->maxw)
-+            *w = MIN(*w, c->maxw);
-+        if (c->maxh)
-+            *h = MIN(*h, c->maxh);
-+    }
-+    return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
- }
- 
- void
- arrange(Monitor *m)
- {
--	if (m)
--		showhide(m->stack);
--	else for (m = mons; m; m = m->next)
--		showhide(m->stack);
--	if (m) {
--		arrangemon(m);
--		restack(m);
--	} else for (m = mons; m; m = m->next)
--		arrangemon(m);
-+    if (m)
-+        showhide(m->stack);
-+    else for (m = mons; m; m = m->next)
-+        showhide(m->stack);
-+    if (m) {
-+        arrangemon(m);
-+        restack(m);
-+    } else for (m = mons; m; m = m->next)
-+        arrangemon(m);
- }
- 
- void
- arrangemon(Monitor *m)
- {
--	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
--	if (m->lt[m->sellt]->arrange)
--		m->lt[m->sellt]->arrange(m);
-+    strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-+    if (m->lt[m->sellt]->arrange)
-+        m->lt[m->sellt]->arrange(m);
- }
- 
- void
- attach(Client *c)
- {
--	c->next = c->mon->clients;
--	c->mon->clients = c;
-+    c->next = c->mon->clients;
-+    c->mon->clients = c;
- }
- 
- void
- attachstack(Client *c)
- {
--	c->snext = c->mon->stack;
--	c->mon->stack = c;
-+    c->snext = c->mon->stack;
-+    c->mon->stack = c;
-+}
-+
-+void
-+swallow(Client *p, Client *c)
-+{
-+    if (c->noswallow || c->isterminal)
-+        return;
-+    if (!swallowfloating && c->isfloating)
-+        return;
-+
-+    detach(c);
-+    detachstack(c);
-+
-+    setclientstate(c, WithdrawnState);
-+    XUnmapWindow(dpy, p->win);
-+
-+    p->swallowing = c;
-+    c->mon = p->mon;
-+
-+    Window w = p->win;
-+    p->win = c->win;
-+    c->win = w;
-+    updatetitle(p);
-+
-+    XWindowChanges wc;
-+    wc.border_width = p->bw;
-+    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
-+    XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
-+    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
-+
-+    arrange(p->mon);
-+    configure(p);
-+    updateclientlist();
-+}
-+
-+void
-+unswallow(Client *c)
-+{
-+    c->win = c->swallowing->win;
-+
-+    free(c->swallowing);
-+    c->swallowing = NULL;
-+
-+    /* unfullscreen the client */
-+    setfullscreen(c, 0);
-+    updatetitle(c);
-+    arrange(c->mon);
-+    XMapWindow(dpy, c->win);
-+
-+    XWindowChanges wc;
-+    wc.border_width = c->bw;
-+    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
-+    XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-+    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-+
-+    setclientstate(c, NormalState);
-+    focus(NULL);
-+    arrange(c->mon);
- }
- 
- void
- buttonpress(XEvent *e)
- {
--	unsigned int i, x, click;
--	Arg arg = {0};
--	Client *c;
--	Monitor *m;
--	XButtonPressedEvent *ev = &e->xbutton;
--
--	click = ClkRootWin;
--	/* focus monitor if necessary */
--	if ((m = wintomon(ev->window)) && m != selmon) {
--		unfocus(selmon->sel, 1);
--		selmon = m;
--		focus(NULL);
--	}
--	if (ev->window == selmon->barwin) {
--		i = x = 0;
--		do
--			x += TEXTW(tags[i]);
--		while (ev->x >= x && ++i < LENGTH(tags));
--		if (i < LENGTH(tags)) {
--			click = ClkTagBar;
--			arg.ui = 1 << i;
--		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
--			click = ClkLtSymbol;
--		else if (ev->x > selmon->ww - (int)TEXTW(stext))
--			click = ClkStatusText;
--		else
--			click = ClkWinTitle;
--	} else if ((c = wintoclient(ev->window))) {
--		focus(c);
--		restack(selmon);
--		XAllowEvents(dpy, ReplayPointer, CurrentTime);
--		click = ClkClientWin;
--	}
--	for (i = 0; i < LENGTH(buttons); i++)
--		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
--		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
--			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
-+    unsigned int i, x, click, occ = 0;
-+    Arg arg = {0};
-+    Client *c;
-+    Monitor *m;
-+    XButtonPressedEvent *ev = &e->xbutton;
-+
-+    click = ClkRootWin;
-+    /* focus monitor if necessary */
-+    if ((m = wintomon(ev->window)) && m != selmon) {
-+        unfocus(selmon->sel, 1);
-+        selmon = m;
-+        focus(NULL);
-+    }
-+    if (ev->window == selmon->barwin) {
-+        i = x = 0;
-+        for (c = m->clients; c; c = c->next)
-+            occ |= c->tags == 255 ? 0 : c->tags;
-+        do {
-+            /* do not reserve space for vacant tags */
-+            if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-+                continue;
-+            x += TEXTW(tags[i]);
-+        } while (ev->x >= x && ++i < LENGTH(tags));
-+        if (i < LENGTH(tags)) {
-+            click = ClkTagBar;
-+            arg.ui = 1 << i;
-+        } else if (ev->x < x + TEXTW(selmon->ltsymbol))
-+            click = ClkLtSymbol;
-+        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
-+            click = ClkStatusText;
-+
-+            char *text = rawstext;
-+            int i = -1;
-+            char ch;
-+            dwmblockssig = 0;
-+            while (text[++i]) {
-+                if ((unsigned char)text[i] < ' ') {
-+                    ch = text[i];
-+                    text[i] = '\0';
-+                    x += TEXTW(text) - lrpad;
-+                    text[i] = ch;
-+                    text += i+1;
-+                    i = -1;
-+                    if (x >= ev->x) break;
-+                    dwmblockssig = ch;
-+                }
-+            }
-+        } else
-+            click = ClkWinTitle;
-+    } else if ((c = wintoclient(ev->window))) {
-+        focus(c);
-+        restack(selmon);
-+        XAllowEvents(dpy, ReplayPointer, CurrentTime);
-+        click = ClkClientWin;
-+    }
-+    for (i = 0; i < LENGTH(buttons); i++)
-+        if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
-+                && CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
-+            buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
- }
- 
- void
- checkotherwm(void)
- {
--	xerrorxlib = XSetErrorHandler(xerrorstart);
--	/* this causes an error if some other window manager is running */
--	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
--	XSync(dpy, False);
--	XSetErrorHandler(xerror);
--	XSync(dpy, False);
-+    xerrorxlib = XSetErrorHandler(xerrorstart);
-+    /* this causes an error if some other window manager is running */
-+    XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
-+    XSync(dpy, False);
-+    XSetErrorHandler(xerror);
-+    XSync(dpy, False);
- }
- 
- void
- cleanup(void)
- {
--	Arg a = {.ui = ~0};
--	Layout foo = { "", NULL };
--	Monitor *m;
--	size_t i;
--
--	view(&a);
--	selmon->lt[selmon->sellt] = &foo;
--	for (m = mons; m; m = m->next)
--		while (m->stack)
--			unmanage(m->stack, 0);
--	XUngrabKey(dpy, AnyKey, AnyModifier, root);
--	while (mons)
--		cleanupmon(mons);
--	for (i = 0; i < CurLast; i++)
--		drw_cur_free(drw, cursor[i]);
--	for (i = 0; i < LENGTH(colors); i++)
--		free(scheme[i]);
--	free(scheme);
--	XDestroyWindow(dpy, wmcheckwin);
--	drw_free(drw);
--	XSync(dpy, False);
--	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
--	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+    Arg a = {.ui = ~0};
-+    Layout foo = { "", NULL };
-+    Monitor *m;
-+    size_t i;
-+
-+    view(&a);
-+    selmon->lt[selmon->sellt] = &foo;
-+    for (m = mons; m; m = m->next)
-+        while (m->stack)
-+            unmanage(m->stack, 0);
-+    XUngrabKey(dpy, AnyKey, AnyModifier, root);
-+    while (mons)
-+        cleanupmon(mons);
-+    for (i = 0; i < CurLast; i++)
-+        drw_cur_free(drw, cursor[i]);
-+    /* for (i = 0; i < LENGTH(colors); i++) */
-+    for (i = 0; i < LENGTH(colors) + 1; i++)
-+        free(scheme[i]);
-+    free(scheme);
-+    XDestroyWindow(dpy, wmcheckwin);
-+    drw_free(drw);
-+    XSync(dpy, False);
-+    XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
-+    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
- }
- 
- void
- cleanupmon(Monitor *mon)
- {
--	Monitor *m;
-+    Monitor *m;
- 
--	if (mon == mons)
--		mons = mons->next;
--	else {
--		for (m = mons; m && m->next != mon; m = m->next);
--		m->next = mon->next;
--	}
--	XUnmapWindow(dpy, mon->barwin);
--	XDestroyWindow(dpy, mon->barwin);
--	free(mon);
-+    if (mon == mons)
-+        mons = mons->next;
-+    else {
-+        for (m = mons; m && m->next != mon; m = m->next);
-+        m->next = mon->next;
-+    }
-+    XUnmapWindow(dpy, mon->barwin);
-+    XDestroyWindow(dpy, mon->barwin);
-+    free(mon);
- }
- 
- void
- clientmessage(XEvent *e)
- {
--	XClientMessageEvent *cme = &e->xclient;
--	Client *c = wintoclient(cme->window);
-+    XClientMessageEvent *cme = &e->xclient;
-+    Client *c = wintoclient(cme->window);
- 
--	if (!c)
--		return;
--	if (cme->message_type == netatom[NetWMState]) {
--		if (cme->data.l[1] == netatom[NetWMFullscreen]
--		|| cme->data.l[2] == netatom[NetWMFullscreen])
--			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
--				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
--	} else if (cme->message_type == netatom[NetActiveWindow]) {
--		if (c != selmon->sel && !c->isurgent)
--			seturgent(c, 1);
--	}
-+    if (!c)
-+        return;
-+    if (cme->message_type == netatom[NetWMState]) {
-+        if (cme->data.l[1] == netatom[NetWMFullscreen]
-+                || cme->data.l[2] == netatom[NetWMFullscreen])
-+            setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-+                        || (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
-+    } else if (cme->message_type == netatom[NetActiveWindow]) {
-+        if (c != selmon->sel && !c->isurgent)
-+            seturgent(c, 1);
-+    }
- }
- 
- void
- configure(Client *c)
- {
--	XConfigureEvent ce;
-+    XConfigureEvent ce;
- 
--	ce.type = ConfigureNotify;
--	ce.display = dpy;
--	ce.event = c->win;
--	ce.window = c->win;
--	ce.x = c->x;
--	ce.y = c->y;
--	ce.width = c->w;
--	ce.height = c->h;
--	ce.border_width = c->bw;
--	ce.above = None;
--	ce.override_redirect = False;
--	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
-+    ce.type = ConfigureNotify;
-+    ce.display = dpy;
-+    ce.event = c->win;
-+    ce.window = c->win;
-+    ce.x = c->x;
-+    ce.y = c->y;
-+    ce.width = c->w;
-+    ce.height = c->h;
-+    ce.border_width = c->bw;
-+    ce.above = None;
-+    ce.override_redirect = False;
-+    XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
- }
- 
- void
- configurenotify(XEvent *e)
- {
--	Monitor *m;
--	Client *c;
--	XConfigureEvent *ev = &e->xconfigure;
--	int dirty;
--
--	/* TODO: updategeom handling sucks, needs to be simplified */
--	if (ev->window == root) {
--		dirty = (sw != ev->width || sh != ev->height);
--		sw = ev->width;
--		sh = ev->height;
--		if (updategeom() || dirty) {
--			drw_resize(drw, sw, bh);
--			updatebars();
--			for (m = mons; m; m = m->next) {
--				for (c = m->clients; c; c = c->next)
--					if (c->isfullscreen)
--						resizeclient(c, m->mx, m->my, m->mw, m->mh);
--				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
--			}
--			focus(NULL);
--			arrange(NULL);
--		}
--	}
-+    Monitor *m;
-+    Client *c;
-+    XConfigureEvent *ev = &e->xconfigure;
-+    int dirty;
-+
-+    /* TODO: updategeom handling sucks, needs to be simplified */
-+    if (ev->window == root) {
-+        dirty = (sw != ev->width || sh != ev->height);
-+        sw = ev->width;
-+        sh = ev->height;
-+        if (updategeom() || dirty) {
-+            drw_resize(drw, sw, bh);
-+            updatebars();
-+            for (m = mons; m; m = m->next) {
-+                for (c = m->clients; c; c = c->next)
-+                    if (c->isfullscreen)
-+                        resizeclient(c, m->mx, m->my, m->mw, m->mh);
-+                XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
-+            }
-+            focus(NULL);
-+            arrange(NULL);
-+        }
-+    }
- }
- 
- void
- configurerequest(XEvent *e)
- {
--	Client *c;
--	Monitor *m;
--	XConfigureRequestEvent *ev = &e->xconfigurerequest;
--	XWindowChanges wc;
--
--	if ((c = wintoclient(ev->window))) {
--		if (ev->value_mask & CWBorderWidth)
--			c->bw = ev->border_width;
--		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
--			m = c->mon;
--			if (ev->value_mask & CWX) {
--				c->oldx = c->x;
--				c->x = m->mx + ev->x;
--			}
--			if (ev->value_mask & CWY) {
--				c->oldy = c->y;
--				c->y = m->my + ev->y;
--			}
--			if (ev->value_mask & CWWidth) {
--				c->oldw = c->w;
--				c->w = ev->width;
--			}
--			if (ev->value_mask & CWHeight) {
--				c->oldh = c->h;
--				c->h = ev->height;
--			}
--			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
--				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
--			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
--				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
--			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
--				configure(c);
--			if (ISVISIBLE(c))
--				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
--		} else
--			configure(c);
--	} else {
--		wc.x = ev->x;
--		wc.y = ev->y;
--		wc.width = ev->width;
--		wc.height = ev->height;
--		wc.border_width = ev->border_width;
--		wc.sibling = ev->above;
--		wc.stack_mode = ev->detail;
--		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
--	}
--	XSync(dpy, False);
-+    Client *c;
-+    Monitor *m;
-+    XConfigureRequestEvent *ev = &e->xconfigurerequest;
-+    XWindowChanges wc;
-+
-+    if ((c = wintoclient(ev->window))) {
-+        if (ev->value_mask & CWBorderWidth)
-+            c->bw = ev->border_width;
-+        else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-+            m = c->mon;
-+            if (ev->value_mask & CWX) {
-+                c->oldx = c->x;
-+                c->x = m->mx + ev->x;
-+            }
-+            if (ev->value_mask & CWY) {
-+                c->oldy = c->y;
-+                c->y = m->my + ev->y;
-+            }
-+            if (ev->value_mask & CWWidth) {
-+                c->oldw = c->w;
-+                c->w = ev->width;
-+            }
-+            if (ev->value_mask & CWHeight) {
-+                c->oldh = c->h;
-+                c->h = ev->height;
-+            }
-+            if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
-+                c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
-+            if ((c->y + c->h) > m->my + m->mh && c->isfloating)
-+                c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
-+            if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
-+                configure(c);
-+            if (ISVISIBLE(c))
-+                XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-+        } else
-+            configure(c);
-+    } else {
-+        wc.x = ev->x;
-+        wc.y = ev->y;
-+        wc.width = ev->width;
-+        wc.height = ev->height;
-+        wc.border_width = ev->border_width;
-+        wc.sibling = ev->above;
-+        wc.stack_mode = ev->detail;
-+        XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
-+    }
-+    XSync(dpy, False);
-+}
-+
-+void
-+copyvalidchars(char *text, char *rawtext)
-+{
-+    int i = -1, j = 0;
-+
-+    while(rawtext[++i]) {
-+        if ((unsigned char)rawtext[i] >= ' ') {
-+            text[j++] = rawtext[i];
-+        }
-+    }
-+    text[j] = '\0';
- }
- 
- Monitor *
- createmon(void)
- {
--	Monitor *m;
-+    Monitor *m;
- 
--	m = ecalloc(1, sizeof(Monitor));
--	m->tagset[0] = m->tagset[1] = 1;
--	m->mfact = mfact;
--	m->nmaster = nmaster;
--	m->showbar = showbar;
--	m->topbar = topbar;
--	m->lt[0] = &layouts[0];
--	m->lt[1] = &layouts[1 % LENGTH(layouts)];
--	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
--	return m;
-+    m = ecalloc(1, sizeof(Monitor));
-+    m->tagset[0] = m->tagset[1] = 1;
-+    m->mfact = mfact;
-+    m->nmaster = nmaster;
-+    m->showbar = showbar;
-+    m->topbar = topbar;
-+    m->gappih = gappih;
-+    m->gappiv = gappiv;
-+    m->gappoh = gappoh;
-+    m->gappov = gappov;
-+    m->lt[0] = &layouts[0];
-+    m->lt[1] = &layouts[1 % LENGTH(layouts)];
-+    strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
-+    return m;
- }
- 
- void
- destroynotify(XEvent *e)
- {
--	Client *c;
--	XDestroyWindowEvent *ev = &e->xdestroywindow;
-+    Client *c;
-+    XDestroyWindowEvent *ev = &e->xdestroywindow;
-+
-+    if ((c = wintoclient(ev->window)))
-+        unmanage(c, 1);
- 
--	if ((c = wintoclient(ev->window)))
--		unmanage(c, 1);
-+    else if ((c = swallowingclient(ev->window)))
-+        unmanage(c->swallowing, 1);
- }
- 
- void
- detach(Client *c)
- {
--	Client **tc;
-+    Client **tc;
- 
--	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
--	*tc = c->next;
-+    for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
-+    *tc = c->next;
- }
- 
- void
- detachstack(Client *c)
- {
--	Client **tc, *t;
-+    Client **tc, *t;
- 
--	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
--	*tc = c->snext;
-+    for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
-+    *tc = c->snext;
- 
--	if (c == c->mon->sel) {
--		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
--		c->mon->sel = t;
--	}
-+    if (c == c->mon->sel) {
-+        for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
-+        c->mon->sel = t;
-+    }
- }
- 
- Monitor *
- dirtomon(int dir)
- {
--	Monitor *m = NULL;
-+    Monitor *m = NULL;
- 
--	if (dir > 0) {
--		if (!(m = selmon->next))
--			m = mons;
--	} else if (selmon == mons)
--		for (m = mons; m->next; m = m->next);
--	else
--		for (m = mons; m->next != selmon; m = m->next);
--	return m;
-+    if (dir > 0) {
-+        if (!(m = selmon->next))
-+            m = mons;
-+    } else if (selmon == mons)
-+        for (m = mons; m->next; m = m->next);
-+    else
-+        for (m = mons; m->next != selmon; m = m->next);
-+    return m;
- }
- 
--void
--drawbar(Monitor *m)
--{
--	int x, w, tw = 0;
--	int boxs = drw->fonts->h / 9;
--	int boxw = drw->fonts->h / 6 + 2;
--	unsigned int i, occ = 0, urg = 0;
--	Client *c;
--
--	if (!m->showbar)
--		return;
--
--	/* draw status first so it can be overdrawn by tags later */
--	if (m == selmon) { /* status is only drawn on selected monitor */
--		drw_setscheme(drw, scheme[SchemeNorm]);
--		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
--		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
--	}
--
--	for (c = m->clients; c; c = c->next) {
--		occ |= c->tags;
--		if (c->isurgent)
--			urg |= c->tags;
--	}
--	x = 0;
--	for (i = 0; i < LENGTH(tags); i++) {
--		w = TEXTW(tags[i]);
--		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
--		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
--		if (occ & 1 << i)
--			drw_rect(drw, x + boxs, boxs, boxw, boxw,
--				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
--				urg & 1 << i);
--		x += w;
--	}
--	w = TEXTW(m->ltsymbol);
--	drw_setscheme(drw, scheme[SchemeNorm]);
--	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
--
--	if ((w = m->ww - tw - x) > bh) {
--		if (m->sel) {
--			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
--			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
--			if (m->sel->isfloating)
--				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
--		} else {
--			drw_setscheme(drw, scheme[SchemeNorm]);
--			drw_rect(drw, x, 0, w, bh, 1, 1);
--		}
--	}
--	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
-+int
-+drawstatusbar(Monitor *m, int bh, char* stext)
-+{
-+    int ret, i, w, x, len;
-+    short isCode = 0;
-+    char *text;
-+    char *p;
-+    FILE *ptr;
-+    char ch;
-+    int hotbool = 0;
-+
-+    len = strlen(stext) + 1 ;
-+    if (!(text = (char*) malloc(sizeof(char)*len)))
-+        die("malloc");
-+    p = text;
-+    memcpy(text, stext, len);
-+
-+    /* compute width of the status text */
-+    w = 0;
-+    i = -1;
-+    while (text[++i]) {
-+        if (text[i] == '^') {
-+            if (!isCode) {
-+                isCode = 1;
-+                text[i] = '\0';
-+                w += TEXTW(text) - lrpad;
-+                text[i] = '^';
-+                if (text[++i] == 'f')
-+                    w += atoi(text + ++i);
-+            } else {
-+                isCode = 0;
-+                text = text + i + 1;
-+                i = -1;
-+            }
-+        }
-+    }
-+    if (!isCode)
-+        w += TEXTW(text) - lrpad;
-+    else
-+        isCode = 0;
-+    text = p;
-+
-+    w += 2; /* 1px padding on both sides */
-+    ret = x = m->ww - w;
-+
-+    drw_setscheme(drw, scheme[LENGTH(colors)]);
-+    drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-+    drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-+    drw_rect(drw, x, 0, w, bh, 1, 1);
-+    x++;
-+
-+    /* process status text */
-+    i = -1;
-+    drw_clr_create(drw, &drw->scheme[ColFg], col1);
-+
-+    while (text[++i]) {
-+        if (text[i] == '^' && !isCode) {
-+            isCode = 1;
-+
-+            text[i] = '\0';
-+            w = TEXTW(text) - lrpad;
-+            drw_text(drw, x, 0, w, bh, 0, text, 0);
-+            x += w;
-+
-+            while (text[++i] != '^') {
-+                if (text[i] == '2') {
-+                    // Check if weather is hot or not
-+                    ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
-+                    if (ptr == NULL) printf("Fail to read wr...");
-+                    do{
-+                        ch = fgetc(ptr);
-+                        // Check if contains + and 2 (= hot)
-+                        if (hotbool){
-+                            if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
-+                                drw_clr_create(drw, &drw->scheme[ColFg], col21);
-+                                break;
-+                            }else{
-+                                drw_clr_create(drw, &drw->scheme[ColFg], col22);
-+                                break;
-+                            }
-+                        }
-+
-+                        if (ch == '+'){
-+                            hotbool = 1;
-+                        }else if (ch == '-') {
-+                            drw_clr_create(drw, &drw->scheme[ColFg], col23);
-+                            break;
-+                        }
-+                        else{
-+                            drw_clr_create(drw, &drw->scheme[ColFg], col24);
-+                            break;
-+                        }
-+                    } while (ch != EOF);
-+                    fclose(ptr);
-+                } else if (text[i] == '3') {
-+                    drw_clr_create(drw, &drw->scheme[ColFg], col3);
-+                } else if (text[i] == '4') {
-+                    drw_clr_create(drw, &drw->scheme[ColFg], col4);
-+                } else if (text[i] == '5') {
-+                    drw_clr_create(drw, &drw->scheme[ColFg], col5);
-+                } else if (text[i] == '6') {
-+                    drw_clr_create(drw, &drw->scheme[ColFg], col6);
-+                }
-+            }
-+
-+            text = text + i + 1;
-+            i=-1;
-+            isCode = 0;
-+        }
-+    }
-+
-+    if (!isCode) {
-+        w = TEXTW(text) - lrpad;
-+        drw_text(drw, x, 0, w, bh, 0, text, 0);
-+    }
-+
-+    drw_setscheme(drw, scheme[SchemeNorm]);
-+    free(p);
-+
-+    return ret;
- }
- 
- void
--drawbars(void)
-+drawbar(Monitor *m)
- {
--	Monitor *m;
--
--	for (m = mons; m; m = m->next)
--		drawbar(m);
-+    if (!m->showbar) return;
-+    int x, w, tw = 0;
-+    int boxs = drw->fonts->h / 9;
-+    int boxw = drw->fonts->h / 6 + 2;
-+    unsigned int i, occ = 0, urg = 0;
-+    Client *c;
-+
-+    /* draw status first so it can be overdrawn by tags later */
-+    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
-+    if (m == selmon || 1) { 
-+        tw = m->ww - drawstatusbar(m, bh, stext);
-+    }
-+
-+    for (c = m->clients; c; c = c->next) {
-+        occ |= c->tags == 255 ? 0 : c->tags;
-+        if (c->isurgent)
-+            urg |= c->tags;
-+    }
-+    x = 0;
-+    for (i = 0; i < LENGTH(tags); i++) {
-+        /* do not draw vacant tags */
-+        if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-+            continue;
-+
-+        w = TEXTW(tags[i]);
-+        drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-+        drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-+        x += w;
-+    }
-+    w = TEXTW(m->ltsymbol);
-+    drw_setscheme(drw, scheme[SchemeNorm]);
-+    x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
-+
-+    if ((w = m->ww - tw - x) > bh) {
-+        drw_setscheme(drw, scheme[SchemeNorm]);
-+        drw_rect(drw, x, 0, w, bh, 1, 1);
-+    }
-+    drw_map(drw, m->barwin, 0, 0, m->ww, bh);
- }
- 
- void
--enternotify(XEvent *e)
-+drawbars(void)
- {
--	Client *c;
--	Monitor *m;
--	XCrossingEvent *ev = &e->xcrossing;
-+    Monitor *m;
- 
--	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
--		return;
--	c = wintoclient(ev->window);
--	m = c ? c->mon : wintomon(ev->window);
--	if (m != selmon) {
--		unfocus(selmon->sel, 1);
--		selmon = m;
--	} else if (!c || c == selmon->sel)
--		return;
--	focus(c);
-+    for (m = mons; m; m = m->next)
-+        drawbar(m);
- }
- 
- void
- expose(XEvent *e)
- {
--	Monitor *m;
--	XExposeEvent *ev = &e->xexpose;
-+    Monitor *m;
-+    XExposeEvent *ev = &e->xexpose;
- 
--	if (ev->count == 0 && (m = wintomon(ev->window)))
--		drawbar(m);
-+    if (ev->count == 0 && (m = wintomon(ev->window)))
-+        drawbar(m);
- }
- 
- void
- focus(Client *c)
- {
--	if (!c || !ISVISIBLE(c))
--		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
--	if (selmon->sel && selmon->sel != c)
--		unfocus(selmon->sel, 0);
--	if (c) {
--		if (c->mon != selmon)
--			selmon = c->mon;
--		if (c->isurgent)
--			seturgent(c, 0);
--		detachstack(c);
--		attachstack(c);
--		grabbuttons(c, 1);
--		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
--		setfocus(c);
--	} else {
--		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
--		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
--	}
--	selmon->sel = c;
--	drawbars();
-+    if (!c || !ISVISIBLE(c))
-+        for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-+    if (selmon->sel && selmon->sel != c)
-+        unfocus(selmon->sel, 0);
-+    if (c) {
-+        if (c->mon != selmon)
-+            selmon = c->mon;
-+        if (c->isurgent)
-+            seturgent(c, 0);
-+        detachstack(c);
-+        attachstack(c);
-+        grabbuttons(c, 1);
-+        XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-+        setfocus(c);
-+    } else {
-+        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-+        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+    }
-+    selmon->sel = c;
-+    drawbars();
- }
- 
- /* there are some broken focus acquiring clients needing extra handling */
- void
- focusin(XEvent *e)
- {
--	XFocusChangeEvent *ev = &e->xfocus;
-+    XFocusChangeEvent *ev = &e->xfocus;
- 
--	if (selmon->sel && ev->window != selmon->sel->win)
--		setfocus(selmon->sel);
-+    if (selmon->sel && ev->window != selmon->sel->win)
-+        setfocus(selmon->sel);
- }
- 
- void
- focusmon(const Arg *arg)
- {
--	Monitor *m;
-+    Monitor *m;
- 
--	if (!mons->next)
--		return;
--	if ((m = dirtomon(arg->i)) == selmon)
--		return;
--	unfocus(selmon->sel, 0);
--	selmon = m;
--	focus(NULL);
-+    if (!mons->next)
-+        return;
-+    if ((m = dirtomon(arg->i)) == selmon)
-+        return;
-+    unfocus(selmon->sel, 0);
-+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
-+    selmon = m;
-+    focus(NULL);
- }
- 
- void
- focusstack(const Arg *arg)
- {
--	Client *c = NULL, *i;
--
--	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
--		return;
--	if (arg->i > 0) {
--		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
--		if (!c)
--			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
--	} else {
--		for (i = selmon->clients; i != selmon->sel; i = i->next)
--			if (ISVISIBLE(i))
--				c = i;
--		if (!c)
--			for (; i; i = i->next)
--				if (ISVISIBLE(i))
--					c = i;
--	}
--	if (c) {
--		focus(c);
--		restack(selmon);
--	}
-+    int i = stackpos(arg);
-+    Client *c, *p;
-+
-+    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
-+        return;
-+
-+    for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
-+            i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
-+    focus(c ? c : p);
-+    restack(selmon);
- }
- 
- Atom
- getatomprop(Client *c, Atom prop)
- {
--	int di;
--	unsigned long dl;
--	unsigned char *p = NULL;
--	Atom da, atom = None;
-+    int di;
-+    unsigned long dl;
-+    unsigned char *p = NULL;
-+    Atom da, atom = None;
- 
--	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
--		&da, &di, &dl, &dl, &p) == Success && p) {
--		atom = *(Atom *)p;
--		XFree(p);
--	}
--	return atom;
-+    if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
-+                &da, &di, &dl, &dl, &p) == Success && p) {
-+        atom = *(Atom *)p;
-+        XFree(p);
-+    }
-+    return atom;
- }
- 
-+#ifndef __OpenBSD__
-+int getdwmblockspid()
-+{
-+    char buf[16];
-+    FILE *fp = popen("pidof -s dwmblocks", "r");
-+    fgets(buf, sizeof(buf), fp);
-+    pid_t pid = strtoul(buf, NULL, 10);
-+    pclose(fp);
-+    dwmblockspid = pid;
-+    return pid != 0 ? 0 : -1;
-+}
-+#endif
-+
- int
- getrootptr(int *x, int *y)
- {
--	int di;
--	unsigned int dui;
--	Window dummy;
-+    int di;
-+    unsigned int dui;
-+    Window dummy;
- 
--	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
-+    return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
- }
- 
- long
- getstate(Window w)
- {
--	int format;
--	long result = -1;
--	unsigned char *p = NULL;
--	unsigned long n, extra;
--	Atom real;
-+    int format;
-+    long result = -1;
-+    unsigned char *p = NULL;
-+    unsigned long n, extra;
-+    Atom real;
- 
--	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
--		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
--		return -1;
--	if (n != 0)
--		result = *p;
--	XFree(p);
--	return result;
-+    if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
-+                &real, &format, &n, &extra, (unsigned char **)&p) != Success)
-+        return -1;
-+    if (n != 0)
-+        result = *p;
-+    XFree(p);
-+    return result;
- }
- 
- int
- gettextprop(Window w, Atom atom, char *text, unsigned int size)
- {
--	char **list = NULL;
--	int n;
--	XTextProperty name;
--
--	if (!text || size == 0)
--		return 0;
--	text[0] = '\0';
--	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
--		return 0;
--	if (name.encoding == XA_STRING) {
--		strncpy(text, (char *)name.value, size - 1);
--	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
--		strncpy(text, *list, size - 1);
--		XFreeStringList(list);
--	}
--	text[size - 1] = '\0';
--	XFree(name.value);
--	return 1;
-+    char **list = NULL;
-+    int n;
-+    XTextProperty name;
-+
-+    if (!text || size == 0)
-+        return 0;
-+    text[0] = '\0';
-+    if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
-+        return 0;
-+    if (name.encoding == XA_STRING)
-+        strncpy(text, (char *)name.value, size - 1);
-+    else {
-+        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
-+            strncpy(text, *list, size - 1);
-+            XFreeStringList(list);
-+        }
-+    }
-+    text[size - 1] = '\0';
-+    XFree(name.value);
-+    return 1;
- }
- 
- void
- grabbuttons(Client *c, int focused)
- {
--	updatenumlockmask();
--	{
--		unsigned int i, j;
--		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
--		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
--		if (!focused)
--			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
--				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
--		for (i = 0; i < LENGTH(buttons); i++)
--			if (buttons[i].click == ClkClientWin)
--				for (j = 0; j < LENGTH(modifiers); j++)
--					XGrabButton(dpy, buttons[i].button,
--						buttons[i].mask | modifiers[j],
--						c->win, False, BUTTONMASK,
--						GrabModeAsync, GrabModeSync, None, None);
--	}
-+    updatenumlockmask();
-+    {
-+        unsigned int i, j;
-+        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-+        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-+        if (!focused)
-+            XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-+                    BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
-+        for (i = 0; i < LENGTH(buttons); i++)
-+            if (buttons[i].click == ClkClientWin)
-+                for (j = 0; j < LENGTH(modifiers); j++)
-+                    XGrabButton(dpy, buttons[i].button,
-+                            buttons[i].mask | modifiers[j],
-+                            c->win, False, BUTTONMASK,
-+                            GrabModeAsync, GrabModeSync, None, None);
-+    }
- }
- 
- void
- grabkeys(void)
- {
--	updatenumlockmask();
--	{
--		unsigned int i, j, k;
--		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
--		int start, end, skip;
--		KeySym *syms;
--
--		XUngrabKey(dpy, AnyKey, AnyModifier, root);
--		XDisplayKeycodes(dpy, &start, &end);
--		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
--		if (!syms)
--			return;
--		for (k = start; k <= end; k++)
--			for (i = 0; i < LENGTH(keys); i++)
--				/* skip modifier codes, we do that ourselves */
--				if (keys[i].keysym == syms[(k - start) * skip])
--					for (j = 0; j < LENGTH(modifiers); j++)
--						XGrabKey(dpy, k,
--							 keys[i].mod | modifiers[j],
--							 root, True,
--							 GrabModeAsync, GrabModeAsync);
--		XFree(syms);
--	}
-+    updatenumlockmask();
-+    {
-+        unsigned int i, j, k;
-+        unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-+        int start, end, skip;
-+        KeySym *syms;
-+
-+        XUngrabKey(dpy, AnyKey, AnyModifier, root);
-+        XDisplayKeycodes(dpy, &start, &end);
-+        syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
-+        if (!syms)
-+            return;
-+        for (k = start; k <= end; k++)
-+            for (i = 0; i < LENGTH(keys); i++)
-+                /* skip modifier codes, we do that ourselves */
-+                if (keys[i].keysym == syms[(k - start) * skip])
-+                    for (j = 0; j < LENGTH(modifiers); j++)
-+                        XGrabKey(dpy, k,
-+                                keys[i].mod | modifiers[j],
-+                                root, True,
-+                                GrabModeAsync, GrabModeAsync);
-+        XFree(syms);
-+    }
- }
- 
- void
- incnmaster(const Arg *arg)
- {
--	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
--	arrange(selmon);
-+    selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-+    arrange(selmon);
- }
- 
- #ifdef XINERAMA
--static int
--isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
-+static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
- {
--	while (n--)
--		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
--		&& unique[n].width == info->width && unique[n].height == info->height)
--			return 0;
--	return 1;
-+    while (n--)
-+        if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
-+                && unique[n].width == info->width && unique[n].height == info->height)
-+            return 0;
-+    return 1;
- }
- #endif /* XINERAMA */
- 
- void
- keypress(XEvent *e)
- {
--	unsigned int i;
--	KeySym keysym;
--	XKeyEvent *ev;
-+    unsigned int i;
-+    KeySym keysym;
-+    XKeyEvent *ev;
- 
--	ev = &e->xkey;
--	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
--	for (i = 0; i < LENGTH(keys); i++)
--		if (keysym == keys[i].keysym
--		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
--		&& keys[i].func)
--			keys[i].func(&(keys[i].arg));
-+    ev = &e->xkey;
-+    keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-+    for (i = 0; i < LENGTH(keys); i++)
-+        if (keysym == keys[i].keysym
-+                && CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
-+                && keys[i].func)
-+            keys[i].func(&(keys[i].arg));
- }
- 
- void
- killclient(const Arg *arg)
- {
--	if (!selmon->sel)
--		return;
--	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
--		XGrabServer(dpy);
--		XSetErrorHandler(xerrordummy);
--		XSetCloseDownMode(dpy, DestroyAll);
--		XKillClient(dpy, selmon->sel->win);
--		XSync(dpy, False);
--		XSetErrorHandler(xerror);
--		XUngrabServer(dpy);
--	}
-+    if (!selmon->sel)
-+        return;
-+    if (!sendevent(selmon->sel, wmatom[WMDelete])) {
-+        XGrabServer(dpy);
-+        XSetErrorHandler(xerrordummy);
-+        XSetCloseDownMode(dpy, DestroyAll);
-+        XKillClient(dpy, selmon->sel->win);
-+        XSync(dpy, False);
-+        XSetErrorHandler(xerror);
-+        XUngrabServer(dpy);
-+    }
- }
- 
- void
- manage(Window w, XWindowAttributes *wa)
- {
--	Client *c, *t = NULL;
--	Window trans = None;
--	XWindowChanges wc;
--
--	c = ecalloc(1, sizeof(Client));
--	c->win = w;
--	/* geometry */
--	c->x = c->oldx = wa->x;
--	c->y = c->oldy = wa->y;
--	c->w = c->oldw = wa->width;
--	c->h = c->oldh = wa->height;
--	c->oldbw = wa->border_width;
--
--	updatetitle(c);
--	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
--		c->mon = t->mon;
--		c->tags = t->tags;
--	} else {
--		c->mon = selmon;
--		applyrules(c);
--	}
--
--	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
--		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
--	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
--		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
--	c->x = MAX(c->x, c->mon->wx);
--	c->y = MAX(c->y, c->mon->wy);
--	c->bw = borderpx;
--
--	wc.border_width = c->bw;
--	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
--	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
--	configure(c); /* propagates border_width, if size doesn't change */
--	updatewindowtype(c);
--	updatesizehints(c);
--	updatewmhints(c);
--	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
--	grabbuttons(c, 0);
--	if (!c->isfloating)
--		c->isfloating = c->oldstate = trans != None || c->isfixed;
--	if (c->isfloating)
--		XRaiseWindow(dpy, c->win);
--	attach(c);
--	attachstack(c);
--	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
--		(unsigned char *) &(c->win), 1);
--	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
--	setclientstate(c, NormalState);
--	if (c->mon == selmon)
--		unfocus(selmon->sel, 0);
--	c->mon->sel = c;
--	arrange(c->mon);
--	XMapWindow(dpy, c->win);
--	focus(NULL);
-+    Client *c, *t = NULL, *term = NULL;
-+    Window trans = None;
-+    XWindowChanges wc;
-+
-+    c = ecalloc(1, sizeof(Client));
-+    c->win = w;
-+    c->pid = winpid(w);
-+    /* geometry */
-+    c->x = c->oldx = wa->x;
-+    c->y = c->oldy = wa->y;
-+    c->w = c->oldw = wa->width;
-+    c->h = c->oldh = wa->height;
-+    c->oldbw = wa->border_width;
-+
-+    updatetitle(c);
-+    if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
-+        c->mon = t->mon;
-+        c->tags = t->tags;
-+    } else {
-+        c->mon = selmon;
-+        applyrules(c);
-+        term = termforwin(c);
-+    }
-+
-+    if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
-+        c->x = c->mon->wx + c->mon->ww - WIDTH(c);
-+    if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
-+        c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
-+    c->x = MAX(c->x, c->mon->wx);
-+    c->y = MAX(c->y, c->mon->wy);
-+    c->bw = borderpx;
-+    /* if (c->isfloating) c->bw = 0; */
-+
-+    wc.border_width = c->bw;
-+    XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-+    XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
-+    configure(c); /* propagates border_width, if size doesn't change */
-+    updatewindowtype(c);
-+    updatewmhints(c);
-+    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
-+    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
-+    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
-+    c->sfx = c->x;
-+    c->sfy = c->y;
-+    c->sfw = c->w;
-+    c->sfh = c->h;
-+
-+    XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
-+    grabbuttons(c, 0);
-+    if (!c->isfloating)
-+        c->isfloating = c->oldstate = t || c->isfixed;
-+    if (c->isfloating) {
-+        XRaiseWindow(dpy, c->win);
-+        if (strcmp(c->name, "YAD") == 0) {
-+            c->x = 1488;
-+            c->y = 42;
-+            c->w = 405;
-+            c->h = 280;
-+        }
-+    }
-+    attach(c);
-+    attachstack(c);
-+    XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
-+            (unsigned char *) &(c->win), 1);
-+    XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
-+    setclientstate(c, NormalState);
-+    if (c->mon == selmon)
-+        unfocus(selmon->sel, 0);
-+    c->mon->sel = c;
-+    XMapWindow(dpy, c->win);
-+    if (term)
-+        swallow(term, c);
-+    arrange(c->mon);
-+    focus(NULL);
- }
- 
- void
- mappingnotify(XEvent *e)
- {
--	XMappingEvent *ev = &e->xmapping;
-+    XMappingEvent *ev = &e->xmapping;
- 
--	XRefreshKeyboardMapping(ev);
--	if (ev->request == MappingKeyboard)
--		grabkeys();
-+    XRefreshKeyboardMapping(ev);
-+    if (ev->request == MappingKeyboard)
-+        grabkeys();
- }
- 
- void
- maprequest(XEvent *e)
- {
--	static XWindowAttributes wa;
--	XMapRequestEvent *ev = &e->xmaprequest;
-+    static XWindowAttributes wa;
-+    XMapRequestEvent *ev = &e->xmaprequest;
- 
--	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
--		return;
--	if (!wintoclient(ev->window))
--		manage(ev->window, &wa);
-+    if (!XGetWindowAttributes(dpy, ev->window, &wa))
-+        return;
-+    if (wa.override_redirect)
-+        return;
-+    if (!wintoclient(ev->window))
-+        manage(ev->window, &wa);
- }
- 
- void
- monocle(Monitor *m)
- {
--	unsigned int n = 0;
--	Client *c;
-+    unsigned int n;
-+    int oh, ov, ih, iv;
-+    Client *c;
-+
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
- 
--	for (c = m->clients; c; c = c->next)
--		if (ISVISIBLE(c))
--			n++;
--	if (n > 0) /* override layout symbol */
--		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
--	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
--		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
-+    if (n > 0) /* override layout symbol */
-+        snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-+    for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-+        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
- }
- 
- void
- motionnotify(XEvent *e)
- {
--	static Monitor *mon = NULL;
--	Monitor *m;
--	XMotionEvent *ev = &e->xmotion;
-+    static Monitor *mon = NULL;
-+    Monitor *m;
-+    XMotionEvent *ev = &e->xmotion;
- 
--	if (ev->window != root)
--		return;
--	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
--		unfocus(selmon->sel, 1);
--		selmon = m;
--		focus(NULL);
--	}
--	mon = m;
-+    if (ev->window != root)
-+        return;
-+    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-+        unfocus(selmon->sel, 1);
-+        selmon = m;
-+        focus(NULL);
-+    }
-+    mon = m;
- }
- 
- void
- movemouse(const Arg *arg)
- {
--	int x, y, ocx, ocy, nx, ny;
--	Client *c;
--	Monitor *m;
--	XEvent ev;
--	Time lasttime = 0;
--
--	if (!(c = selmon->sel))
--		return;
--	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
--		return;
--	restack(selmon);
--	ocx = c->x;
--	ocy = c->y;
--	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
--		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
--		return;
--	if (!getrootptr(&x, &y))
--		return;
--	do {
--		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
--		switch(ev.type) {
--		case ConfigureRequest:
--		case Expose:
--		case MapRequest:
--			handler[ev.type](&ev);
--			break;
--		case MotionNotify:
--			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
--				continue;
--			lasttime = ev.xmotion.time;
--
--			nx = ocx + (ev.xmotion.x - x);
--			ny = ocy + (ev.xmotion.y - y);
--			if (abs(selmon->wx - nx) < snap)
--				nx = selmon->wx;
--			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
--				nx = selmon->wx + selmon->ww - WIDTH(c);
--			if (abs(selmon->wy - ny) < snap)
--				ny = selmon->wy;
--			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
--				ny = selmon->wy + selmon->wh - HEIGHT(c);
--			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
--			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
--				togglefloating(NULL);
--			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
--				resize(c, nx, ny, c->w, c->h, 1);
--			break;
--		}
--	} while (ev.type != ButtonRelease);
--	XUngrabPointer(dpy, CurrentTime);
--	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
--		sendmon(c, m);
--		selmon = m;
--		focus(NULL);
--	}
-+    int x, y, ocx, ocy, nx, ny;
-+    Client *c;
-+    Monitor *m;
-+    XEvent ev;
-+    Time lasttime = 0;
-+
-+    if (!(c = selmon->sel))
-+        return;
-+    if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
-+        return;
-+    restack(selmon);
-+    ocx = c->x;
-+    ocy = c->y;
-+    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-+                None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
-+        return;
-+    if (!getrootptr(&x, &y))
-+        return;
-+    do {
-+        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-+        switch(ev.type) {
-+            case ConfigureRequest:
-+            case Expose:
-+            case MapRequest:
-+                handler[ev.type](&ev);
-+                break;
-+            case MotionNotify:
-+                // Increase display rate when dragging  and resizing floats
-+                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
-+                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
-+                    continue;
-+                lasttime = ev.xmotion.time;
-+
-+                nx = ocx + (ev.xmotion.x - x);
-+                ny = ocy + (ev.xmotion.y - y);
-+                if (abs(selmon->wx - nx) < snap)
-+                    nx = selmon->wx;
-+                else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-+                    nx = selmon->wx + selmon->ww - WIDTH(c);
-+                if (abs(selmon->wy - ny) < snap)
-+                    ny = selmon->wy;
-+                else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-+                    ny = selmon->wy + selmon->wh - HEIGHT(c);
-+                if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-+                        && (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-+                    togglefloating(NULL);
-+                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-+                    resize(c, nx, ny, c->w, c->h, 1);
-+                break;
-+        }
-+    } while (ev.type != ButtonRelease);
-+    XUngrabPointer(dpy, CurrentTime);
-+    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-+        sendmon(c, m);
-+        selmon = m;
-+        focus(NULL);
-+    }
- }
- 
- Client *
- nexttiled(Client *c)
- {
--	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
--	return c;
-+    for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
-+    return c;
- }
- 
- void
- pop(Client *c)
- {
--	detach(c);
--	attach(c);
--	focus(c);
--	arrange(c->mon);
-+    detach(c);
-+    attach(c);
-+    focus(c);
-+    arrange(c->mon);
-+}
-+
-+void
-+pushstack(const Arg *arg)
-+{
-+    int i = stackpos(arg);
-+    Client *sel = selmon->sel, *c, *p;
-+
-+    if(i < 0 || !sel)
-+        return;
-+    else if(i == 0) {
-+        detach(sel);
-+        attach(sel);
-+    }
-+    else {
-+        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
-+            if(!(i -= (ISVISIBLE(c) && c != sel)))
-+                break;
-+        c = c ? c : p;
-+        detach(sel);
-+        sel->next = c->next;
-+        c->next = sel;
-+    }
-+    arrange(selmon);
- }
- 
- void
- propertynotify(XEvent *e)
- {
--	Client *c;
--	Window trans;
--	XPropertyEvent *ev = &e->xproperty;
--
--	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
--		updatestatus();
--	else if (ev->state == PropertyDelete)
--		return; /* ignore */
--	else if ((c = wintoclient(ev->window))) {
--		switch(ev->atom) {
--		default: break;
--		case XA_WM_TRANSIENT_FOR:
--			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
--				(c->isfloating = (wintoclient(trans)) != NULL))
--				arrange(c->mon);
--			break;
--		case XA_WM_NORMAL_HINTS:
--			c->hintsvalid = 0;
--			break;
--		case XA_WM_HINTS:
--			updatewmhints(c);
--			drawbars();
--			break;
--		}
--		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
--			updatetitle(c);
--			if (c == c->mon->sel)
--				drawbar(c->mon);
--		}
--		if (ev->atom == netatom[NetWMWindowType])
--			updatewindowtype(c);
--	}
-+    Client *c;
-+    Window trans;
-+    XPropertyEvent *ev = &e->xproperty;
-+
-+    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
-+        updatestatus();
-+    } else if (ev->state == PropertyDelete) {
-+        return; /* ignore */
-+    } else if ((c = wintoclient(ev->window))) {
-+        switch(ev->atom) {
-+            default: break;
-+            case XA_WM_TRANSIENT_FOR:
-+                     if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
-+                             (c->isfloating = (wintoclient(trans)) != NULL))
-+                         arrange(c->mon);
-+                     break;
-+            case XA_WM_NORMAL_HINTS:
-+                     c->hintsvalid = 0;
-+                     break;
-+            case XA_WM_HINTS:
-+                     updatewmhints(c);
-+                     drawbars();
-+                     break;
-+        }
-+        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
-+            updatetitle(c);
-+            if (c == c->mon->sel)
-+                drawbar(c->mon);
-+        }
-+
-+        if (ev->atom == netatom[NetWMWindowType])
-+            updatewindowtype(c);
-+    }
- }
- 
- void
- quit(const Arg *arg)
- {
--	running = 0;
-+    if(arg->i) restart = 1;
-+    running = 0;
- }
- 
- Monitor *
- recttomon(int x, int y, int w, int h)
- {
--	Monitor *m, *r = selmon;
--	int a, area = 0;
-+    Monitor *m, *r = selmon;
-+    int a, area = 0;
- 
--	for (m = mons; m; m = m->next)
--		if ((a = INTERSECT(x, y, w, h, m)) > area) {
--			area = a;
--			r = m;
--		}
--	return r;
-+    for (m = mons; m; m = m->next)
-+        if ((a = INTERSECT(x, y, w, h, m)) > area) {
-+            area = a;
-+            r = m;
-+        }
-+    return r;
- }
- 
- void
- resize(Client *c, int x, int y, int w, int h, int interact)
- {
--	if (applysizehints(c, &x, &y, &w, &h, interact))
--		resizeclient(c, x, y, w, h);
-+    if (applysizehints(c, &x, &y, &w, &h, interact))
-+        resizeclient(c, x, y, w, h);
- }
- 
- void
- resizeclient(Client *c, int x, int y, int w, int h)
- {
--	XWindowChanges wc;
-+    XWindowChanges wc;
-+
-+    c->oldx = c->x; c->x = wc.x = x;
-+    c->oldy = c->y; c->y = wc.y = y;
-+    c->oldw = c->w; c->w = wc.width = w;
-+    c->oldh = c->h; c->h = wc.height = h;
-+    wc.border_width = c->bw;
-+    // Don't show border if floating or if only 1 client
-+    if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
-+                || &monocle == c->mon->lt[c->mon->sellt]->arrange)
-+            && !c->isfullscreen) {
-+        /* && !c->isfullscreen && !c->isfloating) { */
-+        c->w = wc.width += c->bw * 2;
-+        c->h = wc.height += c->bw * 2;
-+        wc.border_width = 0;
-+    }
- 
--	c->oldx = c->x; c->x = wc.x = x;
--	c->oldy = c->y; c->y = wc.y = y;
--	c->oldw = c->w; c->w = wc.width = w;
--	c->oldh = c->h; c->h = wc.height = h;
--	wc.border_width = c->bw;
--	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
--	configure(c);
--	XSync(dpy, False);
-+    XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
-+    configure(c);
-+    XSync(dpy, False);
- }
- 
- void
- resizemouse(const Arg *arg)
- {
--	int ocx, ocy, nw, nh;
--	Client *c;
--	Monitor *m;
--	XEvent ev;
--	Time lasttime = 0;
--
--	if (!(c = selmon->sel))
--		return;
--	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
--		return;
--	restack(selmon);
--	ocx = c->x;
--	ocy = c->y;
--	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
--		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
--		return;
--	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
--	do {
--		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
--		switch(ev.type) {
--		case ConfigureRequest:
--		case Expose:
--		case MapRequest:
--			handler[ev.type](&ev);
--			break;
--		case MotionNotify:
--			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
--				continue;
--			lasttime = ev.xmotion.time;
--
--			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
--			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
--			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
--			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
--			{
--				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
--				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
--					togglefloating(NULL);
--			}
--			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
--				resize(c, c->x, c->y, nw, nh, 1);
--			break;
--		}
--	} while (ev.type != ButtonRelease);
--	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
--	XUngrabPointer(dpy, CurrentTime);
--	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
--	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
--		sendmon(c, m);
--		selmon = m;
--		focus(NULL);
--	}
-+    int ocx, ocy, nw, nh;
-+    Client *c;
-+    Monitor *m;
-+    XEvent ev;
-+    Time lasttime = 0;
-+
-+    if (!(c = selmon->sel))
-+        return;
-+    if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
-+        return;
-+    restack(selmon);
-+    ocx = c->x;
-+    ocy = c->y;
-+    if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-+                None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
-+        return;
-+    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-+    do {
-+        XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-+        switch(ev.type) {
-+            case ConfigureRequest:
-+            case Expose:
-+            case MapRequest:
-+                handler[ev.type](&ev);
-+                break;
-+            case MotionNotify:
-+                if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-+                    continue;
-+                lasttime = ev.xmotion.time;
-+
-+                nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
-+                nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
-+                if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
-+                        && c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
-+                {
-+                    if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-+                            && (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
-+                        togglefloating(NULL);
-+                }
-+                if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-+                    resize(c, c->x, c->y, nw, nh, 1);
-+                break;
-+        }
-+    } while (ev.type != ButtonRelease);
-+    XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-+    XUngrabPointer(dpy, CurrentTime);
-+    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-+    if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-+        sendmon(c, m);
-+        selmon = m;
-+        focus(NULL);
-+    }
- }
- 
- void
- restack(Monitor *m)
- {
--	Client *c;
--	XEvent ev;
--	XWindowChanges wc;
--
--	drawbar(m);
--	if (!m->sel)
--		return;
--	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
--		XRaiseWindow(dpy, m->sel->win);
--	if (m->lt[m->sellt]->arrange) {
--		wc.stack_mode = Below;
--		wc.sibling = m->barwin;
--		for (c = m->stack; c; c = c->snext)
--			if (!c->isfloating && ISVISIBLE(c)) {
--				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
--				wc.sibling = c->win;
--			}
--	}
--	XSync(dpy, False);
--	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-+    Client *c;
-+    XEvent ev;
-+    XWindowChanges wc;
-+
-+    drawbar(m);
-+    if (!m->sel)
-+        return;
-+    if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
-+        XRaiseWindow(dpy, m->sel->win);
-+    if (m->lt[m->sellt]->arrange) {
-+        wc.stack_mode = Below;
-+        wc.sibling = m->barwin;
-+        for (c = m->stack; c; c = c->snext)
-+            if (!c->isfloating && ISVISIBLE(c)) {
-+                XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
-+                wc.sibling = c->win;
-+            }
-+    }
-+    XSync(dpy, False);
-+    while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
- }
- 
- void
- run(void)
- {
--	XEvent ev;
--	/* main event loop */
--	XSync(dpy, False);
--	while (running && !XNextEvent(dpy, &ev))
--		if (handler[ev.type])
--			handler[ev.type](&ev); /* call handler */
-+    XEvent ev;
-+    /* main event loop */
-+    XSync(dpy, False);
-+    while (running && !XNextEvent(dpy, &ev))
-+        if (handler[ev.type])
-+            handler[ev.type](&ev); /* call handler */
-+}
-+
-+void
-+runAutostart(void)
-+{
-+    system("killall -q dwmblocks; dwmblocks &");
- }
- 
- void
- scan(void)
- {
--	unsigned int i, num;
--	Window d1, d2, *wins = NULL;
--	XWindowAttributes wa;
--
--	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
--		for (i = 0; i < num; i++) {
--			if (!XGetWindowAttributes(dpy, wins[i], &wa)
--			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
--				continue;
--			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
--				manage(wins[i], &wa);
--		}
--		for (i = 0; i < num; i++) { /* now the transients */
--			if (!XGetWindowAttributes(dpy, wins[i], &wa))
--				continue;
--			if (XGetTransientForHint(dpy, wins[i], &d1)
--			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
--				manage(wins[i], &wa);
--		}
--		if (wins)
--			XFree(wins);
--	}
-+    unsigned int i, num;
-+    Window d1, d2, *wins = NULL;
-+    XWindowAttributes wa;
-+
-+    if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
-+        for (i = 0; i < num; i++) {
-+            if (!XGetWindowAttributes(dpy, wins[i], &wa)
-+                    || wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
-+                continue;
-+            if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
-+                manage(wins[i], &wa);
-+        }
-+        for (i = 0; i < num; i++) { /* now the transients */
-+            if (!XGetWindowAttributes(dpy, wins[i], &wa))
-+                continue;
-+            if (XGetTransientForHint(dpy, wins[i], &d1)
-+                    && (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
-+                manage(wins[i], &wa);
-+        }
-+        if (wins)
-+            XFree(wins);
-+    }
- }
- 
- void
- sendmon(Client *c, Monitor *m)
- {
--	if (c->mon == m)
--		return;
--	unfocus(c, 1);
--	detach(c);
--	detachstack(c);
--	c->mon = m;
--	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
--	attach(c);
--	attachstack(c);
--	focus(NULL);
--	arrange(NULL);
-+    if (c->mon == m)
-+        return;
-+    unfocus(c, 1);
-+    detach(c);
-+    detachstack(c);
-+    c->mon = m;
-+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-+    attach(c);
-+    attachstack(c);
-+    focus(NULL);
-+    arrange(NULL);
-+}
-+
-+void
-+sendmonview(Client *c, Monitor *m)
-+{
-+    if (c->mon == m)
-+        return;
-+    unfocus(c, 1);
-+    detach(c);
-+    detachstack(c);
-+    arrange(c->mon);
-+    c->mon = m;
-+    c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-+    attach(c);
-+    attachstack(c);
-+    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
-+    arrange(m);
-+    focus(c);
-+    restack(m);
- }
- 
- void
- setclientstate(Client *c, long state)
- {
--	long data[] = { state, None };
-+    long data[] = { state, None };
- 
--	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
--		PropModeReplace, (unsigned char *)data, 2);
-+    XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-+            PropModeReplace, (unsigned char *)data, 2);
- }
- 
- int
- sendevent(Client *c, Atom proto)
- {
--	int n;
--	Atom *protocols;
--	int exists = 0;
--	XEvent ev;
--
--	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
--		while (!exists && n--)
--			exists = protocols[n] == proto;
--		XFree(protocols);
--	}
--	if (exists) {
--		ev.type = ClientMessage;
--		ev.xclient.window = c->win;
--		ev.xclient.message_type = wmatom[WMProtocols];
--		ev.xclient.format = 32;
--		ev.xclient.data.l[0] = proto;
--		ev.xclient.data.l[1] = CurrentTime;
--		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
--	}
--	return exists;
-+    int n;
-+    Atom *protocols;
-+    int exists = 0;
-+    XEvent ev;
-+
-+    if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
-+        while (!exists && n--)
-+            exists = protocols[n] == proto;
-+        XFree(protocols);
-+    }
-+    if (exists) {
-+        ev.type = ClientMessage;
-+        ev.xclient.window = c->win;
-+        ev.xclient.message_type = wmatom[WMProtocols];
-+        ev.xclient.format = 32;
-+        ev.xclient.data.l[0] = proto;
-+        ev.xclient.data.l[1] = CurrentTime;
-+        XSendEvent(dpy, c->win, False, NoEventMask, &ev);
-+    }
-+    return exists;
- }
- 
- void
- setfocus(Client *c)
- {
--	if (!c->neverfocus) {
--		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
--		XChangeProperty(dpy, root, netatom[NetActiveWindow],
--			XA_WINDOW, 32, PropModeReplace,
--			(unsigned char *) &(c->win), 1);
--	}
--	sendevent(c, wmatom[WMTakeFocus]);
-+    if (!c->neverfocus) {
-+        XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
-+        XChangeProperty(dpy, root, netatom[NetActiveWindow],
-+                XA_WINDOW, 32, PropModeReplace,
-+                (unsigned char *) &(c->win), 1);
-+    }
-+    sendevent(c, wmatom[WMTakeFocus]);
- }
- 
- void
- setfullscreen(Client *c, int fullscreen)
- {
--	if (fullscreen && !c->isfullscreen) {
--		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
--			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
--		c->isfullscreen = 1;
--		c->oldstate = c->isfloating;
--		c->oldbw = c->bw;
--		c->bw = 0;
--		c->isfloating = 1;
--		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
--		XRaiseWindow(dpy, c->win);
--	} else if (!fullscreen && c->isfullscreen){
--		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
--			PropModeReplace, (unsigned char*)0, 0);
--		c->isfullscreen = 0;
--		c->isfloating = c->oldstate;
--		c->bw = c->oldbw;
--		c->x = c->oldx;
--		c->y = c->oldy;
--		c->w = c->oldw;
--		c->h = c->oldh;
--		resizeclient(c, c->x, c->y, c->w, c->h);
--		arrange(c->mon);
--	}
-+    if (fullscreen && !c->isfullscreen) {
-+        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-+                PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-+        c->isfullscreen = 1;
-+        c->oldstate = c->isfloating;
-+        c->oldbw = c->bw;
-+        c->bw = 0;
-+        c->isfloating = 1;
-+        resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
-+        XRaiseWindow(dpy, c->win);
-+    } else if (!fullscreen && c->isfullscreen){
-+        XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-+                PropModeReplace, (unsigned char*)0, 0);
-+        c->isfullscreen = 0;
-+        c->isfloating = c->oldstate;
-+        c->bw = c->oldbw;
-+        c->x = c->oldx;
-+        c->y = c->oldy;
-+        c->w = c->oldw;
-+        c->h = c->oldh;
-+        resizeclient(c, c->x, c->y, c->w, c->h);
-+        arrange(c->mon);
-+    }
-+}
-+
-+int
-+stackpos(const Arg *arg)
-+{
-+    int n, i;
-+    Client *c, *l;
-+
-+    if(!selmon->clients)
-+        return -1;
-+
-+    if(arg->i == PREVSEL) {
-+        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
-+        if(!l)
-+            return -1;
-+        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+        return i;
-+    }
-+    else if(ISINC(arg->i)) {
-+        if(!selmon->sel)
-+            return -1;
-+        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+        return MOD(i + GETINC(arg->i), n);
-+    }
-+    else if(arg->i < 0) {
-+        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+        return MAX(i + arg->i, 0);
-+    }
-+    else
-+        return arg->i;
- }
- 
- void
- setlayout(const Arg *arg)
- {
--	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
--		selmon->sellt ^= 1;
--	if (arg && arg->v)
--		selmon->lt[selmon->sellt] = (Layout *)arg->v;
--	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
--	if (selmon->sel)
--		arrange(selmon);
--	else
--		drawbar(selmon);
-+    if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-+        selmon->sellt ^= 1;
-+    if (arg && arg->v)
-+        selmon->lt[selmon->sellt] = (Layout *)arg->v;
-+    strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
-+    if (selmon->sel)
-+        arrange(selmon);
-+    else
-+        drawbar(selmon);
- }
- 
- /* arg > 1.0 will set mfact absolutely */
- void
- setmfact(const Arg *arg)
- {
--	float f;
-+    float f;
- 
--	if (!arg || !selmon->lt[selmon->sellt]->arrange)
--		return;
--	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
--	if (f < 0.05 || f > 0.95)
--		return;
--	selmon->mfact = f;
--	arrange(selmon);
-+    if (!arg || !selmon->lt[selmon->sellt]->arrange)
-+        return;
-+    f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-+    if (f < 0.05 || f > 0.95)
-+        return;
-+    selmon->mfact = f;
-+    arrange(selmon);
- }
- 
- void
- setup(void)
- {
--	int i;
--	XSetWindowAttributes wa;
--	Atom utf8string;
--	struct sigaction sa;
--
--	/* do not transform children into zombies when they terminate */
--	sigemptyset(&sa.sa_mask);
--	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
--	sa.sa_handler = SIG_IGN;
--	sigaction(SIGCHLD, &sa, NULL);
--
--	/* clean up any zombies (inherited from .xinitrc etc) immediately */
--	while (waitpid(-1, NULL, WNOHANG) > 0);
--
--	/* init screen */
--	screen = DefaultScreen(dpy);
--	sw = DisplayWidth(dpy, screen);
--	sh = DisplayHeight(dpy, screen);
--	root = RootWindow(dpy, screen);
--	drw = drw_create(dpy, screen, root, sw, sh);
--	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
--		die("no fonts could be loaded.");
--	lrpad = drw->fonts->h;
--	bh = drw->fonts->h + 2;
--	updategeom();
--	/* init atoms */
--	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
--	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
--	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
--	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
--	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
--	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
--	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
--	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
--	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
--	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
--	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
--	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
--	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
--	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
--	/* init cursors */
--	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
--	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
--	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
--	/* init appearance */
--	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
--	for (i = 0; i < LENGTH(colors); i++)
--		scheme[i] = drw_scm_create(drw, colors[i], 3);
--	/* init bars */
--	updatebars();
--	updatestatus();
--	/* supporting window for NetWMCheck */
--	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
--	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
--		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
--	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
--		PropModeReplace, (unsigned char *) "dwm", 3);
--	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
--		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
--	/* EWMH support per view */
--	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
--		PropModeReplace, (unsigned char *) netatom, NetLast);
--	XDeleteProperty(dpy, root, netatom[NetClientList]);
--	/* select events */
--	wa.cursor = cursor[CurNormal]->cursor;
--	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
--		|ButtonPressMask|PointerMotionMask|EnterWindowMask
--		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
--	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
--	XSelectInput(dpy, root, wa.event_mask);
--	grabkeys();
--	focus(NULL);
-+    int i;
-+    XSetWindowAttributes wa;
-+    Atom utf8string;
-+    struct sigaction sa;
-+
-+    /* do not transform children into zombies when they terminate */
-+    sigemptyset(&sa.sa_mask);
-+    sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
-+    sa.sa_handler = SIG_IGN;
-+    sigaction(SIGCHLD, &sa, NULL);
-+
-+    /* clean up any zombies (inherited from .xinitrc etc) immediately */
-+    while (waitpid(-1, NULL, WNOHANG) > 0);
-+
-+    signal(SIGHUP, sighup);
-+    signal(SIGTERM, sigterm);
-+
-+    /* init screen */
-+    screen = DefaultScreen(dpy);
-+    sw = DisplayWidth(dpy, screen);
-+    sh = DisplayHeight(dpy, screen);
-+    root = RootWindow(dpy, screen);
-+    drw = drw_create(dpy, screen, root, sw, sh);
-+    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-+        die("no fonts could be loaded.");
-+    lrpad = drw->fonts->h;
-+    bh = drw->fonts->h + 2;
-+    updategeom();
-+    /* init atoms */
-+    utf8string = XInternAtom(dpy, "UTF8_STRING", False);
-+    wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
-+    wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-+    wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
-+    wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
-+    netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
-+    netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-+    netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-+    netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
-+    netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
-+    netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
-+    netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
-+    netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
-+    netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
-+    /* init cursors */
-+    cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
-+    cursor[CurResize] = drw_cur_create(drw, XC_sizing);
-+    cursor[CurMove] = drw_cur_create(drw, XC_fleur);
-+    /* init appearance */
-+    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
-+    scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
-+    scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-+
-+    for (i = 0; i < LENGTH(colors); i++)
-+        scheme[i] = drw_scm_create(drw, colors[i], 3);
-+    /* init bars */
-+    updatebars();
-+    updatestatus();
-+    /* supporting window for NetWMCheck */
-+    wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
-+    XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-+            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-+    XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-+            PropModeReplace, (unsigned char *) "dwm", 3);
-+    XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-+            PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-+    /* EWMH support per view */
-+    XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-+            PropModeReplace, (unsigned char *) netatom, NetLast);
-+    XDeleteProperty(dpy, root, netatom[NetClientList]);
-+    /* select events */
-+    wa.cursor = cursor[CurNormal]->cursor;
-+    wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-+        |ButtonPressMask|PointerMotionMask|EnterWindowMask
-+        |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
-+    XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
-+    XSelectInput(dpy, root, wa.event_mask);
-+    grabkeys();
-+    focus(NULL);
- }
- 
- void
- seturgent(Client *c, int urg)
- {
--	XWMHints *wmh;
-+    XWMHints *wmh;
- 
--	c->isurgent = urg;
--	if (!(wmh = XGetWMHints(dpy, c->win)))
--		return;
--	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
--	XSetWMHints(dpy, c->win, wmh);
--	XFree(wmh);
-+    c->isurgent = urg;
-+    if (!(wmh = XGetWMHints(dpy, c->win)))
-+        return;
-+    wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
-+    XSetWMHints(dpy, c->win, wmh);
-+    XFree(wmh);
- }
- 
- void
- showhide(Client *c)
- {
--	if (!c)
--		return;
--	if (ISVISIBLE(c)) {
--		/* show clients top down */
--		XMoveWindow(dpy, c->win, c->x, c->y);
--		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
--			resize(c, c->x, c->y, c->w, c->h, 0);
--		showhide(c->snext);
--	} else {
--		/* hide clients bottom up */
--		showhide(c->snext);
--		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
--	}
-+    if (!c)
-+        return;
-+    if (ISVISIBLE(c)) {
-+        if ((c->tags & SPTAGMASK) && c->isfloating) {
-+            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-+            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
-+        }
-+        /* show clients top down */
-+        XMoveWindow(dpy, c->win, c->x, c->y);
-+        if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-+            resize(c, c->x, c->y, c->w, c->h, 0);
-+        showhide(c->snext);
-+    } else {
-+        /* hide clients bottom up */
-+        showhide(c->snext);
-+        XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
-+    }
- }
- 
- void
--spawn(const Arg *arg)
-+sighup(int unused)
- {
--	struct sigaction sa;
-+    Arg a = {.i = 1};
-+    quit(&a);
-+}
- 
--	if (arg->v == dmenucmd)
--		dmenumon[0] = '0' + selmon->num;
--	if (fork() == 0) {
--		if (dpy)
--			close(ConnectionNumber(dpy));
--		setsid();
-+void
-+sigterm(int unused)
-+{
-+    Arg a = {.i = 0};
-+    quit(&a);
-+}
- 
--		sigemptyset(&sa.sa_mask);
--		sa.sa_flags = 0;
--		sa.sa_handler = SIG_DFL;
--		sigaction(SIGCHLD, &sa, NULL);
-+#ifndef __OpenBSD__
-+void sigdwmblocks(const Arg *arg)
-+{
-+    union sigval sv;
-+    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
-+    if (!dwmblockspid)
-+        if (getdwmblockspid() == -1)
-+            return;
- 
--		execvp(((char **)arg->v)[0], (char **)arg->v);
--		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
--	}
-+    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
-+        if (errno == ESRCH) {
-+            if (!getdwmblockspid())
-+                sigqueue(dwmblockspid, SIGUSR1, sv);
-+        }
-+    }
- }
-+#endif
- 
- void
--tag(const Arg *arg)
-+spawn(const Arg *arg)
- {
--	if (selmon->sel && arg->ui & TAGMASK) {
--		selmon->sel->tags = arg->ui & TAGMASK;
--		focus(NULL);
--		arrange(selmon);
--	}
-+    struct sigaction sa;
-+    if (fork() == 0) {
-+        if (dpy)
-+            close(ConnectionNumber(dpy));
-+        setsid();
-+
-+        sigemptyset(&sa.sa_mask);
-+        sa.sa_flags = 0;
-+        sa.sa_handler = SIG_DFL;
-+        sigaction(SIGCHLD, &sa, NULL);
-+
-+        execvp(((char **)arg->v)[0], (char **)arg->v);
-+        die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
-+    }
- }
- 
- void
--tagmon(const Arg *arg)
-+tag(const Arg *arg)
- {
--	if (!selmon->sel || !mons->next)
--		return;
--	sendmon(selmon->sel, dirtomon(arg->i));
-+    if (selmon->sel && arg->ui & TAGMASK) {
-+        selmon->sel->tags = arg->ui & TAGMASK;
-+        focus(NULL);
-+        arrange(selmon);
-+    }
- }
- 
- void
--tile(Monitor *m)
-+tagview(const Arg *arg)
- {
--	unsigned int i, n, h, mw, my, ty;
--	Client *c;
-+    if (selmon->sel && arg->ui & TAGMASK) {
-+        selmon->sel->tags = arg->ui & TAGMASK;
-+        focus(NULL);
-+        arrange(selmon);
-+        view(arg);
-+    }
-+}
- 
--	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
--	if (n == 0)
--		return;
-+void
-+tagmon(const Arg *arg)
-+{
-+    if (!selmon->sel || !mons->next)
-+        return;
-+    sendmon(selmon->sel, dirtomon(arg->i));
-+}
- 
--	if (n > m->nmaster)
--		mw = m->nmaster ? m->ww * m->mfact : 0;
--	else
--		mw = m->ww;
--	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
--		if (i < m->nmaster) {
--			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
--			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
--			if (my + HEIGHT(c) < m->wh)
--				my += HEIGHT(c);
--		} else {
--			h = (m->wh - ty) / (n - i);
--			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
--			if (ty + HEIGHT(c) < m->wh)
--				ty += HEIGHT(c);
--		}
-+void
-+tagmonview(const Arg *arg)
-+{
-+    if (!selmon->sel || !mons->next)
-+        return;
-+    sendmonview(selmon->sel, dirtomon(arg->i));
- }
- 
- void
- togglebar(const Arg *arg)
- {
--	selmon->showbar = !selmon->showbar;
--	updatebarpos(selmon);
--	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
--	arrange(selmon);
-+    selmon->showbar = !selmon->showbar;
-+    updatebarpos(selmon);
-+    XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
-+    arrange(selmon);
- }
- 
- void
- togglefloating(const Arg *arg)
- {
--	if (!selmon->sel)
--		return;
--	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
--		return;
--	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
--	if (selmon->sel->isfloating)
--		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
--			selmon->sel->w, selmon->sel->h, 0);
--	arrange(selmon);
-+    if (!selmon->sel)
-+        return;
-+    if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
-+        return;
-+    selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-+    if (selmon->sel->isfloating) {
-+        /* selmon->sel->bw = 0; */
-+        /* configure(selmon->sel); */
-+        /* restore last known float dimensions */
-+        resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
-+                selmon->sel->sfw, selmon->sel->sfh, False);
-+    } else {
-+        /* save last known float dimensions */
-+        selmon->sel->sfx = selmon->sel->x;
-+        selmon->sel->sfy = selmon->sel->y;
-+        selmon->sel->sfw = selmon->sel->w;
-+        selmon->sel->sfh = selmon->sel->h;
-+    }
-+    arrange(selmon);
-+}
-+
-+void
-+togglefullscr(const Arg *arg)
-+{
-+    if(selmon->sel)
-+        setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
-+}
-+
-+void
-+togglesticky(const Arg *arg)
-+{
-+    if (!selmon->sel)
-+        return;
-+    selmon->sel->issticky = !selmon->sel->issticky;
-+    arrange(selmon);
-+}
-+
-+void
-+togglescratch(const Arg *arg)
-+{
-+    Client *c;
-+    unsigned int found = 0;
-+    unsigned int scratchtag = SPTAG(arg->ui);
-+    Arg sparg = {.v = scratchpads[arg->ui].cmd};
-+
-+    for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
-+    if (found) {
-+        unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
-+        if (newtagset) {
-+            selmon->tagset[selmon->seltags] = newtagset;
-+            focus(NULL);
-+            arrange(selmon);
-+        }
-+        if (ISVISIBLE(c)) {
-+            focus(c);
-+            restack(selmon);
-+        }
-+    } else {
-+        selmon->tagset[selmon->seltags] |= scratchtag;
-+        spawn(&sparg);
-+    }
- }
- 
- void
- toggletag(const Arg *arg)
- {
--	unsigned int newtags;
-+    unsigned int newtags;
- 
--	if (!selmon->sel)
--		return;
--	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
--	if (newtags) {
--		selmon->sel->tags = newtags;
--		focus(NULL);
--		arrange(selmon);
--	}
-+    if (!selmon->sel)
-+        return;
-+    newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
-+    if (newtags) {
-+        selmon->sel->tags = newtags;
-+        focus(NULL);
-+        arrange(selmon);
-+    }
- }
- 
- void
- toggleview(const Arg *arg)
- {
--	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-+    unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
- 
--	if (newtagset) {
--		selmon->tagset[selmon->seltags] = newtagset;
--		focus(NULL);
--		arrange(selmon);
--	}
-+    if (newtagset) {
-+        selmon->tagset[selmon->seltags] = newtagset;
-+        focus(NULL);
-+        arrange(selmon);
-+    }
- }
- 
- void
- unfocus(Client *c, int setfocus)
- {
--	if (!c)
--		return;
--	grabbuttons(c, 0);
--	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
--	if (setfocus) {
--		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
--		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
--	}
-+    if (!c)
-+        return;
-+    grabbuttons(c, 0);
-+    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-+    if (setfocus) {
-+        XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-+        XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+    }
- }
- 
- void
- unmanage(Client *c, int destroyed)
- {
--	Monitor *m = c->mon;
--	XWindowChanges wc;
--
--	detach(c);
--	detachstack(c);
--	if (!destroyed) {
--		wc.border_width = c->oldbw;
--		XGrabServer(dpy); /* avoid race conditions */
--		XSetErrorHandler(xerrordummy);
--		XSelectInput(dpy, c->win, NoEventMask);
--		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
--		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
--		setclientstate(c, WithdrawnState);
--		XSync(dpy, False);
--		XSetErrorHandler(xerror);
--		XUngrabServer(dpy);
--	}
--	free(c);
--	focus(NULL);
--	updateclientlist();
--	arrange(m);
-+    Monitor *m = c->mon;
-+    XWindowChanges wc;
-+
-+    if (c->swallowing) {
-+        unswallow(c);
-+        return;
-+    }
-+
-+    Client *s = swallowingclient(c->win);
-+    if (s) {
-+        free(s->swallowing);
-+        s->swallowing = NULL;
-+        arrange(m);
-+        focus(NULL);
-+        return;
-+    }
-+
-+    detach(c);
-+    detachstack(c);
-+    if (!destroyed) {
-+        wc.border_width = c->oldbw;
-+        XGrabServer(dpy); /* avoid race conditions */
-+        XSetErrorHandler(xerrordummy);
-+        XSelectInput(dpy, c->win, NoEventMask);
-+        XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
-+        XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-+        setclientstate(c, WithdrawnState);
-+        XSync(dpy, False);
-+        XSetErrorHandler(xerror);
-+        XUngrabServer(dpy);
-+    }
-+    free(c);
-+
-+    if (!s) {
-+        arrange(m);
-+        focus(NULL);
-+        updateclientlist();
-+    }
- }
- 
- void
- unmapnotify(XEvent *e)
- {
--	Client *c;
--	XUnmapEvent *ev = &e->xunmap;
-+    Client *c;
-+    XUnmapEvent *ev = &e->xunmap;
- 
--	if ((c = wintoclient(ev->window))) {
--		if (ev->send_event)
--			setclientstate(c, WithdrawnState);
--		else
--			unmanage(c, 0);
--	}
-+    if ((c = wintoclient(ev->window))) {
-+        if (ev->send_event)
-+            setclientstate(c, WithdrawnState);
-+        else
-+            unmanage(c, 0);
-+    }
- }
- 
- void
- updatebars(void)
- {
--	Monitor *m;
--	XSetWindowAttributes wa = {
--		.override_redirect = True,
--		.background_pixmap = ParentRelative,
--		.event_mask = ButtonPressMask|ExposureMask
--	};
--	XClassHint ch = {"dwm", "dwm"};
--	for (m = mons; m; m = m->next) {
--		if (m->barwin)
--			continue;
--		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
--				CopyFromParent, DefaultVisual(dpy, screen),
--				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
--		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
--		XMapRaised(dpy, m->barwin);
--		XSetClassHint(dpy, m->barwin, &ch);
--	}
-+    Monitor *m;
-+    XSetWindowAttributes wa = {
-+        .override_redirect = True,
-+        .background_pixmap = ParentRelative,
-+        .event_mask = ButtonPressMask|ExposureMask
-+    };
-+    XClassHint ch = {"dwm", "dwm"};
-+    for (m = mons; m; m = m->next) {
-+        if (m->barwin)
-+            continue;
-+        m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
-+                CopyFromParent, DefaultVisual(dpy, screen),
-+                CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
-+        XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
-+        XMapRaised(dpy, m->barwin);
-+        XSetClassHint(dpy, m->barwin, &ch);
-+    }
- }
- 
- void
- updatebarpos(Monitor *m)
- {
--	m->wy = m->my;
--	m->wh = m->mh;
--	if (m->showbar) {
--		m->wh -= bh;
--		m->by = m->topbar ? m->wy : m->wy + m->wh;
--		m->wy = m->topbar ? m->wy + bh : m->wy;
--	} else
--		m->by = -bh;
-+    m->wy = m->my;
-+    m->wh = m->mh;
-+    if (m->showbar) {
-+        m->wh -= bh;
-+        m->by = m->topbar ? m->wy : m->wy + m->wh;
-+        m->wy = m->topbar ? m->wy + bh : m->wy;
-+    } else
-+        m->by = -bh;
- }
- 
- void
- updateclientlist(void)
- {
--	Client *c;
--	Monitor *m;
-+    Client *c;
-+    Monitor *m;
- 
--	XDeleteProperty(dpy, root, netatom[NetClientList]);
--	for (m = mons; m; m = m->next)
--		for (c = m->clients; c; c = c->next)
--			XChangeProperty(dpy, root, netatom[NetClientList],
--				XA_WINDOW, 32, PropModeAppend,
--				(unsigned char *) &(c->win), 1);
-+    XDeleteProperty(dpy, root, netatom[NetClientList]);
-+    for (m = mons; m; m = m->next)
-+        for (c = m->clients; c; c = c->next)
-+            XChangeProperty(dpy, root, netatom[NetClientList],
-+                    XA_WINDOW, 32, PropModeAppend,
-+                    (unsigned char *) &(c->win), 1);
- }
- 
- int
- updategeom(void)
- {
--	int dirty = 0;
-+    int dirty = 0;
- 
- #ifdef XINERAMA
--	if (XineramaIsActive(dpy)) {
--		int i, j, n, nn;
--		Client *c;
--		Monitor *m;
--		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
--		XineramaScreenInfo *unique = NULL;
--
--		for (n = 0, m = mons; m; m = m->next, n++);
--		/* only consider unique geometries as separate screens */
--		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
--		for (i = 0, j = 0; i < nn; i++)
--			if (isuniquegeom(unique, j, &info[i]))
--				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
--		XFree(info);
--		nn = j;
--
--		/* new monitors if nn > n */
--		for (i = n; i < nn; i++) {
--			for (m = mons; m && m->next; m = m->next);
--			if (m)
--				m->next = createmon();
--			else
--				mons = createmon();
--		}
--		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
--			if (i >= n
--			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
--			|| unique[i].width != m->mw || unique[i].height != m->mh)
--			{
--				dirty = 1;
--				m->num = i;
--				m->mx = m->wx = unique[i].x_org;
--				m->my = m->wy = unique[i].y_org;
--				m->mw = m->ww = unique[i].width;
--				m->mh = m->wh = unique[i].height;
--				updatebarpos(m);
--			}
--		/* removed monitors if n > nn */
--		for (i = nn; i < n; i++) {
--			for (m = mons; m && m->next; m = m->next);
--			while ((c = m->clients)) {
--				dirty = 1;
--				m->clients = c->next;
--				detachstack(c);
--				c->mon = mons;
--				attach(c);
--				attachstack(c);
--			}
--			if (m == selmon)
--				selmon = mons;
--			cleanupmon(m);
--		}
--		free(unique);
--	} else
-+    if (XineramaIsActive(dpy)) {
-+        int i, j, n, nn;
-+        Client *c;
-+        Monitor *m;
-+        XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
-+        XineramaScreenInfo *unique = NULL;
-+
-+        for (n = 0, m = mons; m; m = m->next, n++);
-+        /* only consider unique geometries as separate screens */
-+        unique = ecalloc(nn, sizeof(XineramaScreenInfo));
-+        for (i = 0, j = 0; i < nn; i++)
-+            if (isuniquegeom(unique, j, &info[i]))
-+                memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
-+        XFree(info);
-+        nn = j;
-+        if (n <= nn) { /* new monitors available */
-+            for (i = 0; i < (nn - n); i++) {
-+                for (m = mons; m && m->next; m = m->next);
-+                if (m)
-+                    m->next = createmon();
-+                else
-+                    mons = createmon();
-+            }
-+            for (i = 0, m = mons; i < nn && m; m = m->next, i++)
-+                if (i >= n
-+                        || unique[i].x_org != m->mx || unique[i].y_org != m->my
-+                        || unique[i].width != m->mw || unique[i].height != m->mh)
-+                {
-+                    dirty = 1;
-+                    m->num = i;
-+                    m->mx = m->wx = unique[i].x_org;
-+                    m->my = m->wy = unique[i].y_org;
-+                    m->mw = m->ww = unique[i].width;
-+                    m->mh = m->wh = unique[i].height;
-+                    updatebarpos(m);
-+                }
-+        } else { /* less monitors available nn < n */
-+            for (i = nn; i < n; i++) {
-+                for (m = mons; m && m->next; m = m->next);
-+                while ((c = m->clients)) {
-+                    dirty = 1;
-+                    m->clients = c->next;
-+                    detachstack(c);
-+                    c->mon = mons;
-+                    attach(c);
-+                    attachstack(c);
-+                }
-+                if (m == selmon)
-+                    selmon = mons;
-+                cleanupmon(m);
-+            }
-+        }
-+        free(unique);
-+    } else
- #endif /* XINERAMA */
--	{ /* default monitor setup */
--		if (!mons)
--			mons = createmon();
--		if (mons->mw != sw || mons->mh != sh) {
--			dirty = 1;
--			mons->mw = mons->ww = sw;
--			mons->mh = mons->wh = sh;
--			updatebarpos(mons);
--		}
--	}
--	if (dirty) {
--		selmon = mons;
--		selmon = wintomon(root);
--	}
--	return dirty;
-+    { /* default monitor setup */
-+        if (!mons)
-+            mons = createmon();
-+        if (mons->mw != sw || mons->mh != sh) {
-+            dirty = 1;
-+            mons->mw = mons->ww = sw;
-+            mons->mh = mons->wh = sh;
-+            updatebarpos(mons);
-+        }
-+    }
-+    if (dirty) {
-+        selmon = mons;
-+        selmon = wintomon(root);
-+    }
-+    return dirty;
- }
- 
- void
- updatenumlockmask(void)
- {
--	unsigned int i, j;
--	XModifierKeymap *modmap;
-+    unsigned int i, j;
-+    XModifierKeymap *modmap;
- 
--	numlockmask = 0;
--	modmap = XGetModifierMapping(dpy);
--	for (i = 0; i < 8; i++)
--		for (j = 0; j < modmap->max_keypermod; j++)
--			if (modmap->modifiermap[i * modmap->max_keypermod + j]
--				== XKeysymToKeycode(dpy, XK_Num_Lock))
--				numlockmask = (1 << i);
--	XFreeModifiermap(modmap);
-+    numlockmask = 0;
-+    modmap = XGetModifierMapping(dpy);
-+    for (i = 0; i < 8; i++)
-+        for (j = 0; j < modmap->max_keypermod; j++)
-+            if (modmap->modifiermap[i * modmap->max_keypermod + j]
-+                    == XKeysymToKeycode(dpy, XK_Num_Lock))
-+                numlockmask = (1 << i);
-+    XFreeModifiermap(modmap);
- }
- 
- void
- updatesizehints(Client *c)
- {
--	long msize;
--	XSizeHints size;
--
--	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
--		/* size is uninitialized, ensure that size.flags aren't used */
--		size.flags = PSize;
--	if (size.flags & PBaseSize) {
--		c->basew = size.base_width;
--		c->baseh = size.base_height;
--	} else if (size.flags & PMinSize) {
--		c->basew = size.min_width;
--		c->baseh = size.min_height;
--	} else
--		c->basew = c->baseh = 0;
--	if (size.flags & PResizeInc) {
--		c->incw = size.width_inc;
--		c->inch = size.height_inc;
--	} else
--		c->incw = c->inch = 0;
--	if (size.flags & PMaxSize) {
--		c->maxw = size.max_width;
--		c->maxh = size.max_height;
--	} else
--		c->maxw = c->maxh = 0;
--	if (size.flags & PMinSize) {
--		c->minw = size.min_width;
--		c->minh = size.min_height;
--	} else if (size.flags & PBaseSize) {
--		c->minw = size.base_width;
--		c->minh = size.base_height;
--	} else
--		c->minw = c->minh = 0;
--	if (size.flags & PAspect) {
--		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
--		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
--	} else
--		c->maxa = c->mina = 0.0;
--	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
--	c->hintsvalid = 1;
-+    long msize;
-+    XSizeHints size;
-+
-+    if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
-+        /* size is uninitialized, ensure that size.flags aren't used */
-+        size.flags = PSize;
-+    if (size.flags & PBaseSize) {
-+        c->basew = size.base_width;
-+        c->baseh = size.base_height;
-+    } else if (size.flags & PMinSize) {
-+        c->basew = size.min_width;
-+        c->baseh = size.min_height;
-+    } else
-+        c->basew = c->baseh = 0;
-+    if (size.flags & PResizeInc) {
-+        c->incw = size.width_inc;
-+        c->inch = size.height_inc;
-+    } else
-+        c->incw = c->inch = 0;
-+    if (size.flags & PMaxSize) {
-+        c->maxw = size.max_width;
-+        c->maxh = size.max_height;
-+    } else
-+        c->maxw = c->maxh = 0;
-+    if (size.flags & PMinSize) {
-+        c->minw = size.min_width;
-+        c->minh = size.min_height;
-+    } else if (size.flags & PBaseSize) {
-+        c->minw = size.base_width;
-+        c->minh = size.base_height;
-+    } else
-+        c->minw = c->minh = 0;
-+    if (size.flags & PAspect) {
-+        c->mina = (float)size.min_aspect.y / size.min_aspect.x;
-+        c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
-+    } else
-+        c->maxa = c->mina = 0.0;
-+    c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
-+    c->hintsvalid = 1;
- }
- 
- void
- updatestatus(void)
- {
--	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
--		strcpy(stext, "dwm-"VERSION);
--	drawbar(selmon);
-+    Monitor* m;
-+    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
-+        strcpy(stext, "dwm-"VERSION);
-+    else
-+        copyvalidchars(stext, rawstext);
-+    /* drawbar(selmon); */
-+    for(m = mons; m; m = m->next)
-+        drawbar(m);
- }
- 
- void
- updatetitle(Client *c)
- {
--	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
--		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
--	if (c->name[0] == '\0') /* hack to mark broken clients */
--		strcpy(c->name, broken);
-+    if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
-+        gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-+    if (c->name[0] == '\0') /* hack to mark broken clients */
-+        strcpy(c->name, broken);
- }
- 
- void
- updatewindowtype(Client *c)
- {
--	Atom state = getatomprop(c, netatom[NetWMState]);
--	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
-+    Atom state = getatomprop(c, netatom[NetWMState]);
-+    Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
- 
--	if (state == netatom[NetWMFullscreen])
--		setfullscreen(c, 1);
--	if (wtype == netatom[NetWMWindowTypeDialog])
--		c->isfloating = 1;
-+    if (state == netatom[NetWMFullscreen])
-+        setfullscreen(c, 1);
-+    if (wtype == netatom[NetWMWindowTypeDialog])
-+        c->isfloating = 1;
- }
- 
- void
- updatewmhints(Client *c)
- {
--	XWMHints *wmh;
-+    XWMHints *wmh;
- 
--	if ((wmh = XGetWMHints(dpy, c->win))) {
--		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
--			wmh->flags &= ~XUrgencyHint;
--			XSetWMHints(dpy, c->win, wmh);
--		} else
--			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
--		if (wmh->flags & InputHint)
--			c->neverfocus = !wmh->input;
--		else
--			c->neverfocus = 0;
--		XFree(wmh);
--	}
-+    if ((wmh = XGetWMHints(dpy, c->win))) {
-+        if (c == selmon->sel && wmh->flags & XUrgencyHint) {
-+            wmh->flags &= ~XUrgencyHint;
-+            XSetWMHints(dpy, c->win, wmh);
-+        } else
-+            c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
-+        if (wmh->flags & InputHint)
-+            c->neverfocus = !wmh->input;
-+        else
-+            c->neverfocus = 0;
-+        XFree(wmh);
-+    }
- }
- 
- void
- view(const Arg *arg)
- {
--	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
--		return;
--	selmon->seltags ^= 1; /* toggle sel tagset */
--	if (arg->ui & TAGMASK)
--		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
--	focus(NULL);
--	arrange(selmon);
-+    if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags]) {
-+        view(&((Arg) { .ui = 0 }));
-+        return;
-+    }
-+
-+    selmon->seltags ^= 1; /* toggle sel tagset */
-+    if (arg->ui & TAGMASK)
-+        selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-+    focus(NULL);
-+    arrange(selmon);
-+}
-+
-+pid_t
-+winpid(Window w)
-+{
-+    pid_t result = 0;
-+
-+    xcb_res_client_id_spec_t spec = {0};
-+    spec.client = w;
-+    spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
-+
-+    xcb_generic_error_t *e = NULL;
-+    xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
-+    xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
-+
-+    if (!r)
-+        return (pid_t)0;
-+
-+    xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
-+    for (; i.rem; xcb_res_client_id_value_next(&i)) {
-+        spec = i.data->spec;
-+        if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
-+            uint32_t *t = xcb_res_client_id_value_value(i.data);
-+            result = *t;
-+            break;
-+        }
-+    }
-+
-+    free(r);
-+
-+    if (result == (pid_t)-1)
-+        result = 0;
-+    return result;
-+}
-+
-+pid_t
-+getparentprocess(pid_t p)
-+{
-+    unsigned int v = 0;
-+
-+#if defined(__linux__)
-+    FILE *f;
-+    char buf[256];
-+    snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
-+
-+    if (!(f = fopen(buf, "r")))
-+        return (pid_t)0;
-+
-+    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
-+        v = (pid_t)0;
-+    fclose(f);
-+#elif defined(__FreeBSD__)
-+    struct kinfo_proc *proc = kinfo_getproc(p);
-+    if (!proc)
-+        return (pid_t)0;
-+
-+    v = proc->ki_ppid;
-+    free(proc);
-+#endif
-+    return (pid_t)v;
-+}
-+
-+int
-+isdescprocess(pid_t p, pid_t c)
-+{
-+    while (p != c && c != 0)
-+        c = getparentprocess(c);
-+
-+    return (int)c;
-+}
-+
-+Client *
-+termforwin(const Client *w)
-+{
-+    Client *c;
-+    Monitor *m;
-+
-+    if (!w->pid || w->isterminal)
-+        return NULL;
-+
-+    for (m = mons; m; m = m->next) {
-+        for (c = m->clients; c; c = c->next) {
-+            if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
-+                return c;
-+        }
-+    }
-+
-+    return NULL;
-+}
-+
-+Client *
-+swallowingclient(Window w)
-+{
-+    Client *c;
-+    Monitor *m;
-+
-+    for (m = mons; m; m = m->next) {
-+        for (c = m->clients; c; c = c->next) {
-+            if (c->swallowing && c->swallowing->win == w)
-+                return c;
-+        }
-+    }
-+
-+    return NULL;
- }
- 
- Client *
- wintoclient(Window w)
- {
--	Client *c;
--	Monitor *m;
-+    Client *c;
-+    Monitor *m;
- 
--	for (m = mons; m; m = m->next)
--		for (c = m->clients; c; c = c->next)
--			if (c->win == w)
--				return c;
--	return NULL;
-+    for (m = mons; m; m = m->next)
-+        for (c = m->clients; c; c = c->next)
-+            if (c->win == w)
-+                return c;
-+    return NULL;
- }
- 
- Monitor *
- wintomon(Window w)
- {
--	int x, y;
--	Client *c;
--	Monitor *m;
-+    int x, y;
-+    Client *c;
-+    Monitor *m;
- 
--	if (w == root && getrootptr(&x, &y))
--		return recttomon(x, y, 1, 1);
--	for (m = mons; m; m = m->next)
--		if (w == m->barwin)
--			return m;
--	if ((c = wintoclient(w)))
--		return c->mon;
--	return selmon;
-+    if (w == root && getrootptr(&x, &y))
-+        return recttomon(x, y, 1, 1);
-+    for (m = mons; m; m = m->next)
-+        if (w == m->barwin)
-+            return m;
-+    if ((c = wintoclient(w)))
-+        return c->mon;
-+    return selmon;
- }
- 
- /* There's no way to check accesses to destroyed windows, thus those cases are
-@@ -2097,25 +2691,25 @@ wintomon(Window w)
- int
- xerror(Display *dpy, XErrorEvent *ee)
- {
--	if (ee->error_code == BadWindow
--	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
--	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
--	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
--	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
--	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
--	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
--	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
--	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
--		return 0;
--	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
--		ee->request_code, ee->error_code);
--	return xerrorxlib(dpy, ee); /* may call exit */
-+    if (ee->error_code == BadWindow
-+            || (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
-+            || (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
-+            || (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
-+            || (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
-+            || (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
-+            || (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
-+            || (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
-+            || (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
-+        return 0;
-+    fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-+            ee->request_code, ee->error_code);
-+    return xerrorxlib(dpy, ee); /* may call exit */
- }
- 
- int
- xerrordummy(Display *dpy, XErrorEvent *ee)
- {
--	return 0;
-+    return 0;
- }
- 
- /* Startup Error handler to check if another window manager
-@@ -2123,42 +2717,107 @@ xerrordummy(Display *dpy, XErrorEvent *ee)
- int
- xerrorstart(Display *dpy, XErrorEvent *ee)
- {
--	die("dwm: another window manager is already running");
--	return -1;
-+    die("dwm: another window manager is already running");
-+    return -1;
- }
- 
- void
- zoom(const Arg *arg)
- {
--	Client *c = selmon->sel;
-+    Client *c = selmon->sel;
-+
-+    if (!selmon->lt[selmon->sellt]->arrange
-+            || (selmon->sel && selmon->sel->isfloating))
-+        return;
-+    if (c == nexttiled(selmon->clients))
-+        if (!c || !(c = nexttiled(c->next)))
-+            return;
-+    pop(c);
-+}
-+
-+void
-+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
-+{
-+    char *sdst = NULL;
-+    int *idst = NULL;
-+    float *fdst = NULL;
-+
-+    sdst = dst;
-+    idst = dst;
-+    fdst = dst;
-+
-+    char fullname[256];
-+    char *type;
-+    XrmValue ret;
-+
-+    snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
-+    fullname[sizeof(fullname) - 1] = '\0';
-+
-+    XrmGetResource(db, fullname, "*", &type, &ret);
-+    if (!(ret.addr == NULL || strncmp("String", type, 64)))
-+    {
-+        switch (rtype) {
-+            case STRING:
-+                strcpy(sdst, ret.addr);
-+                break;
-+            case INTEGER:
-+                *idst = strtoul(ret.addr, NULL, 10);
-+                break;
-+            case FLOAT:
-+                *fdst = strtof(ret.addr, NULL);
-+                break;
-+        }
-+    }
-+}
-+
-+void
-+load_xresources(void)
-+{
-+    Display *display;
-+    char *resm;
-+    XrmDatabase db;
-+    ResourcePref *p;
-+
-+    display = XOpenDisplay(NULL);
-+    resm = XResourceManagerString(display);
-+    if (!resm)
-+        return;
- 
--	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
--		return;
--	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
--		return;
--	pop(c);
-+    db = XrmGetStringDatabase(resm);
-+    for (p = resources; p < resources + LENGTH(resources); p++)
-+        resource_load(db, p->name, p->type, p->dst);
-+    XCloseDisplay(display);
- }
- 
- int
- main(int argc, char *argv[])
- {
--	if (argc == 2 && !strcmp("-v", argv[1]))
--		die("dwm-"VERSION);
--	else if (argc != 1)
--		die("usage: dwm [-v]");
--	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
--		fputs("warning: no locale support\n", stderr);
--	if (!(dpy = XOpenDisplay(NULL)))
--		die("dwm: cannot open display");
--	checkotherwm();
--	setup();
-+    if (argc == 2 && !strcmp("-v", argv[1]))
-+        die("dwm-"VERSION);
-+    else if (argc != 1)
-+        die("usage: dwm [-v]");
-+    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-+        fputs("warning: no locale support\n", stderr);
-+    if (!(dpy = XOpenDisplay(NULL)))
-+        die("dwm: cannot open display");
-+    if (!(xcon = XGetXCBConnection(dpy)))
-+        die("dwm: cannot get xcb connection\n");
-+    checkotherwm();
-+    XrmInitialize();
-+    load_xresources();
-+    setup();
- #ifdef __OpenBSD__
--	if (pledge("stdio rpath proc exec", NULL) == -1)
--		die("pledge");
-+    if (pledge("stdio rpath proc exec", NULL) == -1)
-+        die("pledge");
- #endif /* __OpenBSD__ */
--	scan();
--	run();
--	cleanup();
--	XCloseDisplay(dpy);
--	return EXIT_SUCCESS;
-+    scan();
-+    runAutostart();
-+    /* runautostart(); */
-+    enablegaps = 1;
-+    arrange(selmon);
-+    run();
-+    if(restart) execvp(argv[0], argv);
-+    cleanup();
-+    XCloseDisplay(dpy);
-+    return EXIT_SUCCESS;
- }
-diff --git a/dwm.png b/dwm.png
-deleted file mode 100644
-index b1f9ba7..0000000
-Binary files a/dwm.png and /dev/null differ
-diff --git a/dwm_org.c b/dwm_org.c
-new file mode 100644
-index 0000000..0785fe3
---- /dev/null
-+++ b/dwm_org.c
-@@ -0,0 +1,2893 @@
-+/* See LICENSE file for copyright and license details.
-+ *
-+ * dynamic window manager is designed like any other X client as well. It is
-+ * driven through handling X events. In contrast to other X clients, a window
-+ * manager selects for SubstructureRedirectMask on the root window, to receive
-+ * events about window (dis-)appearance. Only one X connection at a time is
-+ * allowed to select for this event mask.
-+ *
-+ * The event handlers of dwm are organized in an array which is accessed
-+ * whenever a new event has been fetched. This allows event dispatching
-+ * in O(1) time.
-+ *
-+ * Each child of the root window is called a client, except windows which have
-+ * set the override_redirect flag. Clients are organized in a linked client
-+ * list on each monitor, the focus history is remembered through a stack list
-+ * on each monitor. Each client contains a bit array to indicate the tags of a
-+ * client.
-+ *
-+ * Keys and tagging rules are organized as arrays and defined in config.h.
-+ *
-+ * To understand everything else, start reading main().
-+ */
-+#include <errno.h>
-+#include <locale.h>
-+#include <signal.h>
-+#include <stdarg.h>
-+#include <stdio.h>
-+#include <stdlib.h>
-+#include <string.h>
-+#include <unistd.h>
-+#include <assert.h>
-+#include <sys/types.h>
-+#include <sys/stat.h>
-+#include <sys/wait.h>
-+#include <X11/cursorfont.h>
-+#include <X11/keysym.h>
-+#include <X11/Xatom.h>
-+#include <X11/Xlib.h>
-+#include <X11/Xproto.h>
-+#include <X11/Xutil.h>
-+#include <X11/Xresource.h>
-+#ifdef XINERAMA
-+#include <X11/extensions/Xinerama.h>
-+#endif /* XINERAMA */
-+#include <X11/Xft/Xft.h>
-+#include <X11/Xlib-xcb.h>
-+#include <xcb/res.h>
-+
-+#include "drw.h"
-+#include "util.h"
-+
-+/* macros */
-+#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
-+#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
-+#define GETINC(X)               ((X) - 2000)
-+#define INC(X)                  ((X) + 2000)
-+#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
-+                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-+#define ISINC(X)                ((X) > 1000 && (X) < 3000)
-+#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
-+#define PREVSEL                 3000
-+#define LENGTH(X)               (sizeof X / sizeof X[0])
-+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
-+#define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
-+#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
-+#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-+#define NUMTAGS			(LENGTH(tags) + LENGTH(scratchpads))
-+#define TAGMASK			((1 << NUMTAGS) - 1)
-+#define SPTAG(i)		((1 << LENGTH(tags)) << (i))
-+#define SPTAGMASK		(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
-+#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
-+#define TRUNC(X,A,B)            (MAX((A), MIN((X), (B))))
-+
-+/* enums */
-+enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-+enum { SchemeNorm, SchemeSel, SchemeWarn, SchemeUrgent }; /* color schemes */
-+enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-+       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
-+       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
-+enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
-+       ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
-+
-+typedef union {
-+	int i;
-+	unsigned int ui;
-+	float f;
-+	const void *v;
-+} Arg;
-+
-+typedef struct {
-+	unsigned int click;
-+	unsigned int mask;
-+	unsigned int button;
-+	void (*func)(const Arg *arg);
-+	const Arg arg;
-+} Button;
-+
-+typedef struct Monitor Monitor;
-+typedef struct Client Client;
-+struct Client {
-+	char name[256];
-+	float mina, maxa;
-+	int x, y, w, h;
-+	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
-+	int oldx, oldy, oldw, oldh;
-+	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
-+	int bw, oldbw;
-+	unsigned int tags;
-+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
-+	pid_t pid;
-+	Client *next;
-+	Client *snext;
-+	Client *swallowing;
-+	Monitor *mon;
-+	Window win;
-+};
-+
-+typedef struct {
-+	unsigned int mod;
-+	KeySym keysym;
-+	void (*func)(const Arg *);
-+	const Arg arg;
-+} Key;
-+
-+typedef struct {
-+	const char *symbol;
-+	void (*arrange)(Monitor *);
-+} Layout;
-+
-+struct Monitor {
-+	char ltsymbol[16];
-+	float mfact;
-+	int nmaster;
-+	int num;
-+	int by;               /* bar geometry */
-+	int mx, my, mw, mh;   /* screen size */
-+	int wx, wy, ww, wh;   /* window area  */
-+	int gappih;           /* horizontal gap between windows */
-+	int gappiv;           /* vertical gap between windows */
-+	int gappoh;           /* horizontal outer gaps */
-+	int gappov;           /* vertical outer gaps */
-+	int gappx;			/* gaps between windows */
-+	unsigned int seltags;
-+	unsigned int sellt;
-+	unsigned int tagset[2];
-+	int showbar;
-+	int topbar;
-+	Client *clients;
-+	Client *sel;
-+	Client *stack;
-+	Monitor *next;
-+	Window barwin;
-+	const Layout *lt[2];
-+};
-+
-+typedef struct {
-+	const char *class;
-+	const char *instance;
-+	const char *title;
-+	unsigned int tags;
-+	int isfloating;
-+	int isterminal;
-+	int noswallow;
-+	int monitor;
-+} Rule;
-+
-+/* Xresources preferences */
-+enum resource_type {
-+	STRING = 0,
-+	INTEGER = 1,
-+	FLOAT = 2
-+};
-+
-+typedef struct {
-+	char *name;
-+	enum resource_type type;
-+	void *dst;
-+} ResourcePref;
-+
-+/* function declarations */
-+static int colorincr;
-+static void applyrules(Client *c);
-+static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
-+static void arrange(Monitor *m);
-+static void arrangemon(Monitor *m);
-+static void attach(Client *c);
-+static void attachstack(Client *c);
-+static void buttonpress(XEvent *e);
-+static void checkotherwm(void);
-+static void cleanup(void);
-+static void cleanupmon(Monitor *mon);
-+static void clientmessage(XEvent *e);
-+static void configure(Client *c);
-+static void configurenotify(XEvent *e);
-+static void configurerequest(XEvent *e);
-+static void copyvalidchars(char *text, char *rawtext);
-+static Monitor *createmon(void);
-+static void destroynotify(XEvent *e);
-+static void detach(Client *c);
-+static void detachstack(Client *c);
-+static Monitor *dirtomon(int dir);
-+static void drawbar(Monitor *m);
-+static void drawbars(void);
-+static int drawstatusbar(Monitor *m, int bh, char* text);
-+static void enternotify(XEvent *e);
-+static void expose(XEvent *e);
-+static void focus(Client *c);
-+static void focusin(XEvent *e);
-+static void focusmon(const Arg *arg);
-+static void focusstack(const Arg *arg);
-+static Atom getatomprop(Client *c, Atom prop);
-+static int getrootptr(int *x, int *y);
-+static long getstate(Window w);
-+static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
-+static void grabbuttons(Client *c, int focused);
-+static void grabkeys(void);
-+static void incnmaster(const Arg *arg);
-+static void keypress(XEvent *e);
-+static void killclient(const Arg *arg);
-+static void manage(Window w, XWindowAttributes *wa);
-+static void mappingnotify(XEvent *e);
-+static void maprequest(XEvent *e);
-+static void monocle(Monitor *m);
-+static void motionnotify(XEvent *e);
-+static void movemouse(const Arg *arg);
-+static Client *nexttiled(Client *c);
-+static void pop(Client *);
-+static void propertynotify(XEvent *e);
-+static void pushstack(const Arg *arg);
-+static void quit(const Arg *arg);
-+static Monitor *recttomon(int x, int y, int w, int h);
-+static void resize(Client *c, int x, int y, int w, int h, int interact);
-+static void resizeclient(Client *c, int x, int y, int w, int h);
-+static void resizemouse(const Arg *arg);
-+static void restack(Monitor *m);
-+static void run(void);
-+static void runAutostart(void);
-+static void scan(void);
-+static int sendevent(Client *c, Atom proto);
-+static void sendmon(Client *c, Monitor *m);
-+static void setclientstate(Client *c, long state);
-+static void setfocus(Client *c);
-+static void setfullscreen(Client *c, int fullscreen);
-+static void setlayout(const Arg *arg);
-+static void setmfact(const Arg *arg);
-+static void setup(void);
-+static void seturgent(Client *c, int urg);
-+static void showhide(Client *c);
-+static void sigchld(int unused);
-+#ifndef __OpenBSD__
-+static int getdwmblockspid();
-+static void sigdwmblocks(const Arg *arg);
-+#endif
-+static void sighup(int unused);
-+static void sigterm(int unused);
-+static void spawn(const Arg *arg);
-+static int stackpos(const Arg *arg);
-+static void tag(const Arg *arg);
-+static void noviewontag(const Arg *arg);
-+static void tagmon(const Arg *arg);
-+static void togglebar(const Arg *arg);
-+static void togglefloating(const Arg *arg);
-+static void togglescratch(const Arg *arg);
-+static void togglesticky(const Arg *arg);
-+static void togglefullscr(const Arg *arg);
-+static void toggletag(const Arg *arg);
-+static void toggleview(const Arg *arg);
-+static void unfocus(Client *c, int setfocus);
-+static void unmanage(Client *c, int destroyed);
-+static void unmapnotify(XEvent *e);
-+static void updatebarpos(Monitor *m);
-+static void updatebars(void);
-+static void updateclientlist(void);
-+static int updategeom(void);
-+static void updatenumlockmask(void);
-+static void updatesizehints(Client *c);
-+static void updatestatus(void);
-+static void updatetitle(Client *c);
-+static void updatewindowtype(Client *c);
-+static void updatewmhints(Client *c);
-+static void view(const Arg *arg);
-+static Client *wintoclient(Window w);
-+static Monitor *wintomon(Window w);
-+static int xerror(Display *dpy, XErrorEvent *ee);
-+static int xerrordummy(Display *dpy, XErrorEvent *ee);
-+static int xerrorstart(Display *dpy, XErrorEvent *ee);
-+static void zoom(const Arg *arg);
-+static void load_xresources(void);
-+static void resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst);
-+
-+static pid_t getparentprocess(pid_t p);
-+static int isdescprocess(pid_t p, pid_t c);
-+static Client *swallowingclient(Window w);
-+static Client *termforwin(const Client *c);
-+static pid_t winpid(Window w);
-+
-+/* variables */
-+static const char broken[] = "broken";
-+static const char dwmdir[] = "dwm";
-+static const char localshare[] = ".local/share";
-+/* static char stext[256]; */
-+static char stext[1024];
-+static char rawstext[256];
-+static int dwmblockssig;
-+pid_t dwmblockspid = 0;
-+static int screen;
-+static int sw, sh;           /* X display screen geometry width, height */
-+static int bh, blw = 0;      /* bar geometry */
-+static int lrpad;            /* sum of left and right padding for text */
-+static int (*xerrorxlib)(Display *, XErrorEvent *);
-+static unsigned int numlockmask = 0;
-+static void (*handler[LASTEvent]) (XEvent *) = {
-+	[ButtonPress] = buttonpress,
-+	[ClientMessage] = clientmessage,
-+	[ConfigureRequest] = configurerequest,
-+	[ConfigureNotify] = configurenotify,
-+	[DestroyNotify] = destroynotify,
-+	[EnterNotify] = enternotify,
-+	[Expose] = expose,
-+	[FocusIn] = focusin,
-+	[KeyPress] = keypress,
-+	[MappingNotify] = mappingnotify,
-+	[MapRequest] = maprequest,
-+	[MotionNotify] = motionnotify,
-+	[PropertyNotify] = propertynotify,
-+	[UnmapNotify] = unmapnotify
-+};
-+static Atom wmatom[WMLast], netatom[NetLast];
-+static int restart = 0;
-+static int running = 1;
-+static Cur *cursor[CurLast];
-+static Clr **scheme;
-+static Display *dpy;
-+static Drw *drw;
-+static Monitor *mons, *selmon;
-+static Window root, wmcheckwin;
-+
-+static xcb_connection_t *xcon;
-+
-+/* configuration, allows nested code to access above variables */
-+#include "config.h"
-+
-+/* compile-time check if all tags fit into an unsigned int bit array. */
-+struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
-+
-+/* function implementations */
-+void
-+applyrules(Client *c)
-+{
-+	const char *class, *instance;
-+	unsigned int i;
-+	const Rule *r;
-+	Monitor *m;
-+	XClassHint ch = { NULL, NULL };
-+
-+	/* rule matching */
-+	c->isfloating = 0;
-+	c->tags = 0;
-+	XGetClassHint(dpy, c->win, &ch);
-+	class    = ch.res_class ? ch.res_class : broken;
-+	instance = ch.res_name  ? ch.res_name  : broken;
-+
-+	for (i = 0; i < LENGTH(rules); i++) {
-+		r = &rules[i];
-+		if ((!r->title || strstr(c->name, r->title))
-+		&& (!r->class || strstr(class, r->class))
-+		&& (!r->instance || strstr(instance, r->instance)))
-+		{
-+			c->isterminal = r->isterminal;
-+			c->isfloating = r->isfloating;
-+			c->noswallow  = r->noswallow;
-+			c->tags |= r->tags;
-+			if ((r->tags & SPTAGMASK) && r->isfloating) {
-+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
-+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
-+			}
-+
-+			for (m = mons; m && m->num != r->monitor; m = m->next);
-+			if (m)
-+				c->mon = m;
-+		}
-+	}
-+	if (ch.res_class)
-+		XFree(ch.res_class);
-+	if (ch.res_name)
-+		XFree(ch.res_name);
-+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
-+}
-+
-+int
-+applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
-+{
-+	int baseismin;
-+	Monitor *m = c->mon;
-+
-+	/* set minimum possible */
-+	*w = MAX(1, *w);
-+	*h = MAX(1, *h);
-+	if (interact) {
-+		if (*x > sw)
-+			*x = sw - WIDTH(c);
-+		if (*y > sh)
-+			*y = sh - HEIGHT(c);
-+		if (*x + *w + 2 * c->bw < 0)
-+			*x = 0;
-+		if (*y + *h + 2 * c->bw < 0)
-+			*y = 0;
-+	} else {
-+		if (*x >= m->wx + m->ww)
-+			*x = m->wx + m->ww - WIDTH(c);
-+		if (*y >= m->wy + m->wh)
-+			*y = m->wy + m->wh - HEIGHT(c);
-+		if (*x + *w + 2 * c->bw <= m->wx)
-+			*x = m->wx;
-+		if (*y + *h + 2 * c->bw <= m->wy)
-+			*y = m->wy;
-+	}
-+	if (*h < bh)
-+		*h = bh;
-+	if (*w < bh)
-+		*w = bh;
-+	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
-+		/* see last two sentences in ICCCM 4.1.2.3 */
-+		baseismin = c->basew == c->minw && c->baseh == c->minh;
-+		if (!baseismin) { /* temporarily remove base dimensions */
-+			*w -= c->basew;
-+			*h -= c->baseh;
-+		}
-+		/* adjust for aspect limits */
-+		if (c->mina > 0 && c->maxa > 0) {
-+			if (c->maxa < (float)*w / *h)
-+				*w = *h * c->maxa + 0.5;
-+			else if (c->mina < (float)*h / *w)
-+				*h = *w * c->mina + 0.5;
-+		}
-+		if (baseismin) { /* increment calculation requires this */
-+			*w -= c->basew;
-+			*h -= c->baseh;
-+		}
-+		/* adjust for increment value */
-+		if (c->incw)
-+			*w -= *w % c->incw;
-+		if (c->inch)
-+			*h -= *h % c->inch;
-+		/* restore base dimensions */
-+		*w = MAX(*w + c->basew, c->minw);
-+		*h = MAX(*h + c->baseh, c->minh);
-+		if (c->maxw)
-+			*w = MIN(*w, c->maxw);
-+		if (c->maxh)
-+			*h = MIN(*h, c->maxh);
-+	}
-+	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
-+}
-+
-+void
-+arrange(Monitor *m)
-+{
-+	if (m)
-+		showhide(m->stack);
-+	else for (m = mons; m; m = m->next)
-+		showhide(m->stack);
-+	if (m) {
-+		arrangemon(m);
-+		restack(m);
-+	} else for (m = mons; m; m = m->next)
-+		arrangemon(m);
-+}
-+
-+void
-+arrangemon(Monitor *m)
-+{
-+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-+	if (m->lt[m->sellt]->arrange)
-+		m->lt[m->sellt]->arrange(m);
-+}
-+
-+void
-+attach(Client *c)
-+{
-+	c->next = c->mon->clients;
-+	c->mon->clients = c;
-+}
-+
-+void
-+attachstack(Client *c)
-+{
-+	c->snext = c->mon->stack;
-+	c->mon->stack = c;
-+}
-+
-+void
-+swallow(Client *p, Client *c)
-+{
-+	if (c->noswallow || c->isterminal)
-+		return;
-+	if (!swallowfloating && c->isfloating)
-+		return;
-+
-+	detach(c);
-+	detachstack(c);
-+
-+	setclientstate(c, WithdrawnState);
-+	XUnmapWindow(dpy, p->win);
-+
-+	p->swallowing = c;
-+	c->mon = p->mon;
-+
-+	Window w = p->win;
-+	p->win = c->win;
-+	c->win = w;
-+	updatetitle(p);
-+
-+	XWindowChanges wc;
-+	wc.border_width = p->bw;
-+	XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
-+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
-+	XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
-+
-+	arrange(p->mon);
-+	configure(p);
-+	updateclientlist();
-+}
-+
-+void
-+unswallow(Client *c)
-+{
-+	c->win = c->swallowing->win;
-+
-+	free(c->swallowing);
-+	c->swallowing = NULL;
-+
-+	/* unfullscreen the client */
-+	setfullscreen(c, 0);
-+	updatetitle(c);
-+	arrange(c->mon);
-+	XMapWindow(dpy, c->win);
-+
-+	XWindowChanges wc;
-+	wc.border_width = c->bw;
-+	XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
-+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-+
-+	setclientstate(c, NormalState);
-+	focus(NULL);
-+	arrange(c->mon);
-+}
-+
-+void
-+buttonpress(XEvent *e)
-+{
-+	unsigned int i, x, click, occ = 0;
-+	Arg arg = {0};
-+	Client *c;
-+	Monitor *m;
-+	XButtonPressedEvent *ev = &e->xbutton;
-+
-+	click = ClkRootWin;
-+	/* focus monitor if necessary */
-+	if ((m = wintomon(ev->window)) && m != selmon) {
-+		unfocus(selmon->sel, 1);
-+		selmon = m;
-+		focus(NULL);
-+	}
-+	if (ev->window == selmon->barwin) {
-+		i = x = 0;
-+		for (c = m->clients; c; c = c->next)
-+			occ |= c->tags == 255 ? 0 : c->tags;
-+		do {
-+			/* do not reserve space for vacant tags */
-+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-+				continue;
-+			x += TEXTW(tags[i]);
-+		} while (ev->x >= x && ++i < LENGTH(tags));
-+		if (i < LENGTH(tags)) {
-+			click = ClkTagBar;
-+			arg.ui = 1 << i;
-+		} else if (ev->x < x + blw)
-+			click = ClkLtSymbol;
-+		else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
-+			click = ClkStatusText; 
-+
-+			char *text = rawstext;
-+			int i = -1;
-+			char ch;
-+			dwmblockssig = 0;
-+			while (text[++i]) {
-+				if ((unsigned char)text[i] < ' ') {
-+					ch = text[i];
-+					text[i] = '\0';
-+					x += TEXTW(text) - lrpad;
-+					text[i] = ch;
-+					text += i+1;
-+					i = -1;
-+					if (x >= ev->x) break;
-+					dwmblockssig = ch;
-+				}
-+			}
-+		} else
-+			click = ClkWinTitle;
-+			/* click = ClkStatusText; */
-+	} else if ((c = wintoclient(ev->window))) {
-+		focus(c);
-+		restack(selmon);
-+		XAllowEvents(dpy, ReplayPointer, CurrentTime);
-+		click = ClkClientWin;
-+	}
-+	for (i = 0; i < LENGTH(buttons); i++)
-+		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
-+		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
-+			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
-+}
-+
-+void
-+checkotherwm(void)
-+{
-+	xerrorxlib = XSetErrorHandler(xerrorstart);
-+	/* this causes an error if some other window manager is running */
-+	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
-+	XSync(dpy, False);
-+	XSetErrorHandler(xerror);
-+	XSync(dpy, False);
-+}
-+
-+void
-+cleanup(void)
-+{
-+	Arg a = {.ui = ~0};
-+	Layout foo = { "", NULL };
-+	Monitor *m;
-+	size_t i;
-+
-+	view(&a);
-+	selmon->lt[selmon->sellt] = &foo;
-+	for (m = mons; m; m = m->next)
-+		while (m->stack)
-+			unmanage(m->stack, 0);
-+	XUngrabKey(dpy, AnyKey, AnyModifier, root);
-+	while (mons)
-+		cleanupmon(mons);
-+	for (i = 0; i < CurLast; i++)
-+		drw_cur_free(drw, cursor[i]);
-+	/* for (i = 0; i < LENGTH(colors); i++) */
-+	for (i = 0; i < LENGTH(colors) + 1; i++)
-+		free(scheme[i]);
-+	XDestroyWindow(dpy, wmcheckwin);
-+	drw_free(drw);
-+	XSync(dpy, False);
-+	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
-+	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+}
-+
-+void
-+cleanupmon(Monitor *mon)
-+{
-+	Monitor *m;
-+
-+	if (mon == mons)
-+		mons = mons->next;
-+	else {
-+		for (m = mons; m && m->next != mon; m = m->next);
-+		m->next = mon->next;
-+	}
-+	XUnmapWindow(dpy, mon->barwin);
-+	XDestroyWindow(dpy, mon->barwin);
-+	free(mon);
-+}
-+
-+void
-+clientmessage(XEvent *e)
-+{
-+	XClientMessageEvent *cme = &e->xclient;
-+	Client *c = wintoclient(cme->window);
-+
-+	if (!c)
-+		return;
-+	if (cme->message_type == netatom[NetWMState]) {
-+		if (cme->data.l[1] == netatom[NetWMFullscreen]
-+		|| cme->data.l[2] == netatom[NetWMFullscreen])
-+			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
-+	} else if (cme->message_type == netatom[NetActiveWindow]) {
-+		if (c != selmon->sel && !c->isurgent)
-+			seturgent(c, 1);
-+	}
-+}
-+
-+void
-+configure(Client *c)
-+{
-+	XConfigureEvent ce;
-+
-+	ce.type = ConfigureNotify;
-+	ce.display = dpy;
-+	ce.event = c->win;
-+	ce.window = c->win;
-+	ce.x = c->x;
-+	ce.y = c->y;
-+	ce.width = c->w;
-+	ce.height = c->h;
-+	ce.border_width = c->bw;
-+	ce.above = None;
-+	ce.override_redirect = False;
-+	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
-+}
-+
-+void
-+configurenotify(XEvent *e)
-+{
-+	Monitor *m;
-+	Client *c;
-+	XConfigureEvent *ev = &e->xconfigure;
-+	int dirty;
-+
-+	/* TODO: updategeom handling sucks, needs to be simplified */
-+	if (ev->window == root) {
-+		dirty = (sw != ev->width || sh != ev->height);
-+		sw = ev->width;
-+		sh = ev->height;
-+		if (updategeom() || dirty) {
-+			drw_resize(drw, sw, bh);
-+			updatebars();
-+			for (m = mons; m; m = m->next) {
-+				for (c = m->clients; c; c = c->next)
-+					if (c->isfullscreen)
-+						resizeclient(c, m->mx, m->my, m->mw, m->mh);
-+				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
-+			}
-+			focus(NULL);
-+			arrange(NULL);
-+		}
-+	}
-+}
-+
-+void
-+configurerequest(XEvent *e)
-+{
-+	Client *c;
-+	Monitor *m;
-+	XConfigureRequestEvent *ev = &e->xconfigurerequest;
-+	XWindowChanges wc;
-+
-+	if ((c = wintoclient(ev->window))) {
-+		if (ev->value_mask & CWBorderWidth)
-+			c->bw = ev->border_width;
-+		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-+			m = c->mon;
-+			if (ev->value_mask & CWX) {
-+				c->oldx = c->x;
-+				c->x = m->mx + ev->x;
-+			}
-+			if (ev->value_mask & CWY) {
-+				c->oldy = c->y;
-+				c->y = m->my + ev->y;
-+			}
-+			if (ev->value_mask & CWWidth) {
-+				c->oldw = c->w;
-+				c->w = ev->width;
-+			}
-+			if (ev->value_mask & CWHeight) {
-+				c->oldh = c->h;
-+				c->h = ev->height;
-+			}
-+			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
-+				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
-+			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
-+				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
-+			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
-+				configure(c);
-+			if (ISVISIBLE(c))
-+				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-+		} else
-+			configure(c);
-+	} else {
-+		wc.x = ev->x;
-+		wc.y = ev->y;
-+		wc.width = ev->width;
-+		wc.height = ev->height;
-+		wc.border_width = ev->border_width;
-+		wc.sibling = ev->above;
-+		wc.stack_mode = ev->detail;
-+		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
-+	}
-+	XSync(dpy, False);
-+}
-+
-+void
-+copyvalidchars(char *text, char *rawtext)
-+{
-+	int i = -1, j = 0;
-+
-+	while(rawtext[++i]) {
-+		if ((unsigned char)rawtext[i] >= ' ') {
-+			text[j++] = rawtext[i];
-+		}
-+	}
-+	text[j] = '\0';
-+}
-+
-+Monitor *
-+createmon(void)
-+{
-+	Monitor *m;
-+
-+	m = ecalloc(1, sizeof(Monitor));
-+	m->tagset[0] = m->tagset[1] = 1;
-+	m->mfact = mfact;
-+	m->nmaster = nmaster;
-+	m->showbar = showbar;
-+	m->topbar = topbar;
-+	m->gappih = gappih;
-+	m->gappiv = gappiv;
-+	m->gappoh = gappoh;
-+	m->gappov = gappov;
-+	m->lt[0] = &layouts[0];
-+	m->lt[1] = &layouts[1 % LENGTH(layouts)];
-+	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
-+	return m;
-+}
-+
-+void
-+destroynotify(XEvent *e)
-+{
-+	Client *c;
-+	XDestroyWindowEvent *ev = &e->xdestroywindow;
-+
-+	if ((c = wintoclient(ev->window)))
-+		unmanage(c, 1);
-+
-+	else if ((c = swallowingclient(ev->window)))
-+		unmanage(c->swallowing, 1);
-+}
-+
-+void
-+detach(Client *c)
-+{
-+	Client **tc;
-+
-+	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
-+	*tc = c->next;
-+}
-+
-+void
-+detachstack(Client *c)
-+{
-+	Client **tc, *t;
-+
-+	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
-+	*tc = c->snext;
-+
-+	if (c == c->mon->sel) {
-+		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
-+		c->mon->sel = t;
-+	}
-+}
-+
-+Monitor *
-+dirtomon(int dir)
-+{
-+	Monitor *m = NULL;
-+
-+	if (dir > 0) {
-+		if (!(m = selmon->next))
-+			m = mons;
-+	} else if (selmon == mons)
-+		for (m = mons; m->next; m = m->next);
-+	else
-+		for (m = mons; m->next != selmon; m = m->next);
-+	return m;
-+}
-+
-+
-+char**
-+str_split(char* a_str, const char a_delim)
-+{
-+    char** result    = 0;
-+    size_t count     = 0;
-+    char* tmp        = a_str;
-+    char* last_comma = 0;
-+    char delim[2];
-+    delim[0] = a_delim;
-+    delim[1] = 0;
-+
-+    /* Count how many elements will be extracted. */
-+    while (*tmp)
-+    {
-+        if (a_delim == *tmp)
-+        {
-+            count++;
-+            last_comma = tmp;
-+        }
-+        tmp++;
-+    }
-+
-+    /* Add space for trailing token. */
-+    count += last_comma < (a_str + strlen(a_str) - 1);
-+
-+    /* Add space for terminating null string so caller
-+       knows where the list of returned strings ends. */
-+    count++;
-+
-+    result = malloc(sizeof(char*) * count);
-+
-+    if (result)
-+    {
-+        size_t idx  = 0;
-+        char* token = strtok(a_str, delim);
-+
-+        while (token)
-+        {
-+            assert(idx < count);
-+            *(result + idx++) = strdup(token);
-+            token = strtok(0, delim);
-+        }
-+        assert(idx == count - 1);
-+        *(result + idx) = 0;
-+    }
-+
-+    return result;
-+}
-+
-+
-+int
-+drawstatusbar(Monitor *m, int bh, char* stext) {
-+	int ret, i, w, x, len;
-+	short isCode = 0;
-+	char *text;
-+	char *p;
-+	colorincr = 0;
-+
-+	len = strlen(stext) + 1 ;
-+	if (!(text = (char*) malloc(sizeof(char)*len)))
-+		die("malloc");
-+	p = text;
-+	memcpy(text, stext, len);
-+
-+	/* compute width of the status text */
-+	w = 0;
-+	i = -1;
-+	while (text[++i]) {
-+		if (text[i] == '^') {
-+			if (!isCode) {
-+				isCode = 1;
-+				text[i] = '\0';
-+				w += TEXTW(text) - lrpad;
-+				text[i] = '^';
-+				if (text[++i] == 'f')
-+					w += atoi(text + ++i);
-+			} else {
-+				isCode = 0;
-+				text = text + i + 1;
-+				i = -1;
-+			}
-+		}
-+	}
-+	if (!isCode)
-+		w += TEXTW(text) - lrpad;
-+	else
-+		isCode = 0;
-+	text = p;
-+
-+	w += 2; /* 1px padding on both sides */
-+	ret = x = m->ww - w;
-+
-+	drw_setscheme(drw, scheme[LENGTH(colors)]);
-+	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-+	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-+	drw_rect(drw, x, 0, w, bh, 1, 1);
-+	x++;
-+
-+	/* process status text */
-+	i = -1;
-+
-+	while (text[++i]) {
-+		if (text[i] == '^' && !isCode) {
-+			isCode = 1;
-+
-+			text[i] = '\0';
-+			w = TEXTW(text) - lrpad;
-+			drw_text(drw, x, 0, w, bh, 0, text, 0);
-+			x += w;
-+
-+			while (text[++i] != '^') {
-+				if (text[i] == '1') {
-+					char col1[] = "#98971a";
-+					drw_clr_create(drw, &drw->scheme[ColFg], col1);
-+				} else if (text[i] == '2') {
-+					// Check if weather is hot or not
-+					FILE *ptr;
-+					char ch;
-+					ptr = fopen("/home/jonas/.local/share/weatherreport", "r");
-+					int hotbool = 0;
-+					if (ptr == NULL) printf("Fail to read wr...");
-+					do{
-+						ch = fgetc(ptr);
-+						// Check if contains + and 2 (= hot)
-+						if (hotbool){
-+							if (ch == '2' || ch == '3'){
-+								char col2[] = "#fb4934";
-+								drw_clr_create(drw, &drw->scheme[ColFg], col2);
-+								break;
-+							}else{
-+								char col2[] = "#ebdbb2";
-+								drw_clr_create(drw, &drw->scheme[ColFg], col2);
-+								break;
-+							}
-+						}
-+
-+						if (ch == '+'){
-+							hotbool = 1;
-+						}else if (ch == '-') {
-+							char col2[] = "#458588";
-+							drw_clr_create(drw, &drw->scheme[ColFg], col2);
-+							break;
-+						}
-+						else{
-+							char col2[] = "#ebdbb2";
-+							drw_clr_create(drw, &drw->scheme[ColFg], col2);
-+							break;
-+						}
-+					} while (ch != EOF);
-+					fclose(ptr);
-+				} else if (text[i] == '3') {
-+					char col3[] = "#fabd2f";
-+					drw_clr_create(drw, &drw->scheme[ColFg], col3);
-+				} else if (text[i] == '4') {
-+					char col4[] = "#83a598";
-+					drw_clr_create(drw, &drw->scheme[ColFg], col4);
-+				} else if (text[i] == '5') {
-+					char col5[] = "#d3869b";
-+					drw_clr_create(drw, &drw->scheme[ColFg], col5);
-+				} else if (text[i] == '6') {
-+					char col6[] = "#8ec07c";
-+					drw_clr_create(drw, &drw->scheme[ColFg], col6);
-+				}
-+			}
-+
-+			text = text + i + 1;
-+			i=-1;
-+			isCode = 0;
-+		}
-+	}
-+
-+	if (!isCode) {
-+		w = TEXTW(text) - lrpad;
-+		drw_text(drw, x, 0, w, bh, 0, text, 0);
-+	}
-+
-+	drw_setscheme(drw, scheme[SchemeNorm]);
-+	free(p);
-+
-+	return ret;
-+}
-+
-+void
-+drawbar(Monitor *m)
-+{
-+	int x, w, tw = 0;
-+	int boxs = drw->fonts->h / 9;
-+	int boxw = drw->fonts->h / 6 + 2;
-+	unsigned int i, occ = 0, urg = 0;
-+	char *ts = stext;
-+	char *tp = stext;
-+	int tx = 0;
-+	char ctmp;
-+	Client *c;
-+
-+	/* draw status first so it can be overdrawn by tags later */
-+	if (m == selmon) { /* status is only drawn on selected monitor */
-+		tw = m->ww - drawstatusbar(m, bh, stext);
-+		/* FILE *fp; */
-+		/* fp = fopen("/home/jonas/test.txt", "w"); */
-+		/* /1* fprintf(fp, stext); *1/ */
-+		/* fprintf(fp, stext); */
-+		/* fclose(fp); */
-+	}
-+
-+	for (c = m->clients; c; c = c->next) {
-+		occ |= c->tags == 255 ? 0 : c->tags;
-+		if (c->isurgent)
-+			urg |= c->tags;
-+	}
-+	x = 0;
-+	for (i = 0; i < LENGTH(tags); i++) {
-+		/* do not draw vacant tags */
-+		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-+		continue;
-+
-+		w = TEXTW(tags[i]);
-+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-+		x += w;
-+	}
-+	w = blw = TEXTW(m->ltsymbol);
-+	drw_setscheme(drw, scheme[SchemeNorm]);
-+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
-+
-+	if ((w = m->ww - tw - x) > bh) {
-+		drw_setscheme(drw, scheme[SchemeNorm]);
-+		drw_rect(drw, x, 0, w, bh, 1, 1);
-+	}
-+	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
-+}
-+
-+void
-+drawbars(void)
-+{
-+	Monitor *m;
-+
-+	for (m = mons; m; m = m->next)
-+		drawbar(m);
-+}
-+
-+void
-+enternotify(XEvent *e)
-+{
-+	Client *c;
-+	Monitor *m;
-+	XCrossingEvent *ev = &e->xcrossing;
-+
-+	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
-+		return;
-+	c = wintoclient(ev->window);
-+	m = c ? c->mon : wintomon(ev->window);
-+	if (m != selmon) {
-+		unfocus(selmon->sel, 1);
-+		selmon = m;
-+	} else if (!c || c == selmon->sel)
-+		return;
-+	focus(c);
-+}
-+
-+void
-+expose(XEvent *e)
-+{
-+	Monitor *m;
-+	XExposeEvent *ev = &e->xexpose;
-+
-+	if (ev->count == 0 && (m = wintomon(ev->window)))
-+		drawbar(m);
-+}
-+
-+void
-+focus(Client *c)
-+{
-+
-+	if (!c || !ISVISIBLE(c))
-+		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-+	if (selmon->sel && selmon->sel != c)
-+		unfocus(selmon->sel, 0);
-+	if (c) {
-+		if (c->mon != selmon)
-+			selmon = c->mon;
-+		if (c->isurgent)
-+			seturgent(c, 0);
-+		detachstack(c);
-+		attachstack(c);
-+		grabbuttons(c, 1);
-+		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-+		setfocus(c);
-+	} else {
-+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+	}
-+	selmon->sel = c;
-+	drawbars();
-+}
-+
-+/* there are some broken focus acquiring clients needing extra handling */
-+void
-+focusin(XEvent *e)
-+{
-+	XFocusChangeEvent *ev = &e->xfocus;
-+
-+	if (selmon->sel && ev->window != selmon->sel->win)
-+		setfocus(selmon->sel);
-+}
-+
-+void
-+focusmon(const Arg *arg)
-+{
-+	Monitor *m;
-+
-+	if (!mons->next)
-+		return;
-+	if ((m = dirtomon(arg->i)) == selmon)
-+		return;
-+	unfocus(selmon->sel, 0);
-+	selmon = m;
-+	focus(NULL);
-+}
-+
-+void
-+focusstack(const Arg *arg)
-+{
-+	int i = stackpos(arg);
-+	Client *c, *p;
-+
-+	if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
-+		return;
-+
-+	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
-+	    i -= ISVISIBLE(c) ? 1 : 0, p = c, c = c->next);
-+	focus(c ? c : p);
-+	restack(selmon);
-+}
-+
-+Atom
-+getatomprop(Client *c, Atom prop)
-+{
-+	int di;
-+	unsigned long dl;
-+	unsigned char *p = NULL;
-+	Atom da, atom = None;
-+
-+	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
-+		&da, &di, &dl, &dl, &p) == Success && p) {
-+		atom = *(Atom *)p;
-+		XFree(p);
-+	}
-+	return atom;
-+}
-+
-+#ifndef __OpenBSD__
-+int
-+getdwmblockspid()
-+{
-+	char buf[16];
-+	FILE *fp = popen("pidof -s dwmblocks", "r");
-+	fgets(buf, sizeof(buf), fp);
-+	pid_t pid = strtoul(buf, NULL, 10);
-+	pclose(fp);
-+	dwmblockspid = pid;
-+	return pid != 0 ? 0 : -1;
-+}
-+#endif
-+
-+int
-+getrootptr(int *x, int *y)
-+{
-+	int di;
-+	unsigned int dui;
-+	Window dummy;
-+
-+	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
-+}
-+
-+long
-+getstate(Window w)
-+{
-+	int format;
-+	long result = -1;
-+	unsigned char *p = NULL;
-+	unsigned long n, extra;
-+	Atom real;
-+
-+	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
-+		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
-+		return -1;
-+	if (n != 0)
-+		result = *p;
-+	XFree(p);
-+	return result;
-+}
-+
-+int
-+gettextprop(Window w, Atom atom, char *text, unsigned int size)
-+{
-+	char **list = NULL;
-+	int n;
-+	XTextProperty name;
-+
-+	if (!text || size == 0)
-+		return 0;
-+	text[0] = '\0';
-+	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
-+		return 0;
-+	if (name.encoding == XA_STRING)
-+		strncpy(text, (char *)name.value, size - 1);
-+	else {
-+		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
-+			strncpy(text, *list, size - 1);
-+			XFreeStringList(list);
-+		}
-+	}
-+	text[size - 1] = '\0';
-+	XFree(name.value);
-+	return 1;
-+}
-+
-+void
-+grabbuttons(Client *c, int focused)
-+{
-+	updatenumlockmask();
-+	{
-+		unsigned int i, j;
-+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-+		if (!focused)
-+			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-+				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
-+		for (i = 0; i < LENGTH(buttons); i++)
-+			if (buttons[i].click == ClkClientWin)
-+				for (j = 0; j < LENGTH(modifiers); j++)
-+					XGrabButton(dpy, buttons[i].button,
-+						buttons[i].mask | modifiers[j],
-+						c->win, False, BUTTONMASK,
-+						GrabModeAsync, GrabModeSync, None, None);
-+	}
-+}
-+
-+void
-+grabkeys(void)
-+{
-+	updatenumlockmask();
-+	{
-+		unsigned int i, j;
-+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-+		KeyCode code;
-+
-+		XUngrabKey(dpy, AnyKey, AnyModifier, root);
-+		for (i = 0; i < LENGTH(keys); i++)
-+			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
-+				for (j = 0; j < LENGTH(modifiers); j++)
-+					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
-+						True, GrabModeAsync, GrabModeAsync);
-+	}
-+}
-+
-+void
-+incnmaster(const Arg *arg)
-+{
-+	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-+	arrange(selmon);
-+}
-+
-+#ifdef XINERAMA
-+static int
-+isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
-+{
-+	while (n--)
-+		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
-+		&& unique[n].width == info->width && unique[n].height == info->height)
-+			return 0;
-+	return 1;
-+}
-+#endif /* XINERAMA */
-+
-+void
-+keypress(XEvent *e)
-+{
-+	unsigned int i;
-+	KeySym keysym;
-+	XKeyEvent *ev;
-+
-+	ev = &e->xkey;
-+	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-+	for (i = 0; i < LENGTH(keys); i++)
-+		if (keysym == keys[i].keysym
-+		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
-+		&& keys[i].func)
-+			keys[i].func(&(keys[i].arg));
-+}
-+
-+void
-+killclient(const Arg *arg)
-+{
-+	if (!selmon->sel)
-+		return;
-+	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
-+		XGrabServer(dpy);
-+		XSetErrorHandler(xerrordummy);
-+		XSetCloseDownMode(dpy, DestroyAll);
-+		XKillClient(dpy, selmon->sel->win);
-+		XSync(dpy, False);
-+		XSetErrorHandler(xerror);
-+		XUngrabServer(dpy);
-+	}
-+}
-+
-+void
-+manage(Window w, XWindowAttributes *wa)
-+{
-+	Client *c, *t = NULL, *term = NULL;
-+	Window trans = None;
-+	XWindowChanges wc;
-+
-+	c = ecalloc(1, sizeof(Client));
-+	c->win = w;
-+	c->pid = winpid(w);
-+	/* geometry */
-+	c->x = c->oldx = wa->x;
-+	c->y = c->oldy = wa->y;
-+	c->w = c->oldw = wa->width;
-+	c->h = c->oldh = wa->height;
-+	c->oldbw = wa->border_width;
-+
-+	updatetitle(c);
-+	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
-+		c->mon = t->mon;
-+		c->tags = t->tags;
-+	} else {
-+		c->mon = selmon;
-+		applyrules(c);
-+		term = termforwin(c);
-+	}
-+
-+	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
-+		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
-+	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
-+		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
-+	c->x = MAX(c->x, c->mon->mx);
-+	/* only fix client y-offset, if the client center might cover the bar */
-+	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
-+		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
-+	c->bw = borderpx;
-+
-+	wc.border_width = c->bw;
-+	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-+	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
-+	configure(c); /* propagates border_width, if size doesn't change */
-+	updatewindowtype(c);
-+	updatesizehints(c);
-+	updatewmhints(c);
-+	c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
-+	c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
-+	// These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
-+	c->sfx = c->x;
-+	c->sfy = c->y;
-+	c->sfw = c->w;
-+	c->sfh = c->h;
-+
-+	/* c->sfx = 1200; */
-+	/* c->sfy = 730; */
-+	/* c->sfw = 700; */
-+	/* c->sfh = 350; */
-+	//
-+	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
-+	grabbuttons(c, 0);
-+	if (!c->isfloating)
-+		c->isfloating = c->oldstate = trans != None || c->isfixed;
-+	if (c->isfloating){
-+		XRaiseWindow(dpy, c->win);
-+		// TODO (my own implementation of moving floats from rules)
-+		c->x = 1280;
-+		c->y = 33;
-+		c->w = 500;
-+		c->h = 350;
-+		c->bw = 0;
-+	}
-+	attach(c);
-+	attachstack(c);
-+	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
-+		(unsigned char *) &(c->win), 1);
-+	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
-+	setclientstate(c, NormalState);
-+	if (c->mon == selmon)
-+		unfocus(selmon->sel, 0);
-+	c->mon->sel = c;
-+	arrange(c->mon);
-+	XMapWindow(dpy, c->win);
-+	if (term)
-+		swallow(term, c);
-+	focus(NULL);
-+}
-+
-+void
-+mappingnotify(XEvent *e)
-+{
-+	XMappingEvent *ev = &e->xmapping;
-+
-+	XRefreshKeyboardMapping(ev);
-+	if (ev->request == MappingKeyboard)
-+		grabkeys();
-+}
-+
-+void
-+maprequest(XEvent *e)
-+{
-+	static XWindowAttributes wa;
-+	XMapRequestEvent *ev = &e->xmaprequest;
-+
-+	if (!XGetWindowAttributes(dpy, ev->window, &wa))
-+		return;
-+	if (wa.override_redirect)
-+		return;
-+	if (!wintoclient(ev->window))
-+		manage(ev->window, &wa);
-+}
-+
-+void
-+monocle(Monitor *m)
-+{
-+	unsigned int n;
-+	int oh, ov, ih, iv;
-+	Client *c;
-+
-+	getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+	if (n > 0) /* override layout symbol */
-+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-+		resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
-+}
-+
-+void
-+motionnotify(XEvent *e)
-+{
-+	static Monitor *mon = NULL;
-+	Monitor *m;
-+	XMotionEvent *ev = &e->xmotion;
-+
-+	if (ev->window != root)
-+		return;
-+	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-+		unfocus(selmon->sel, 1);
-+		selmon = m;
-+		focus(NULL);
-+	}
-+	mon = m;
-+}
-+
-+void
-+movemouse(const Arg *arg)
-+{
-+	int x, y, ocx, ocy, nx, ny;
-+	Client *c;
-+	Monitor *m;
-+	XEvent ev;
-+	Time lasttime = 0;
-+
-+	if (!(c = selmon->sel))
-+		return;
-+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
-+		return;
-+	restack(selmon);
-+	ocx = c->x;
-+	ocy = c->y;
-+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-+		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
-+		return;
-+	if (!getrootptr(&x, &y))
-+		return;
-+	do {
-+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-+		switch(ev.type) {
-+		case ConfigureRequest:
-+		case Expose:
-+		case MapRequest:
-+			handler[ev.type](&ev);
-+			break;
-+		case MotionNotify:
-+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-+				continue;
-+			lasttime = ev.xmotion.time;
-+
-+			nx = ocx + (ev.xmotion.x - x);
-+			ny = ocy + (ev.xmotion.y - y);
-+			if (abs(selmon->wx - nx) < snap)
-+				nx = selmon->wx;
-+			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-+				nx = selmon->wx + selmon->ww - WIDTH(c);
-+			if (abs(selmon->wy - ny) < snap)
-+				ny = selmon->wy;
-+			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-+				ny = selmon->wy + selmon->wh - HEIGHT(c);
-+			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-+			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-+				togglefloating(NULL);
-+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-+				resize(c, nx, ny, c->w, c->h, 1);
-+			break;
-+		}
-+	} while (ev.type != ButtonRelease);
-+	XUngrabPointer(dpy, CurrentTime);
-+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-+		sendmon(c, m);
-+		selmon = m;
-+		focus(NULL);
-+	}
-+}
-+
-+Client *
-+nexttiled(Client *c)
-+{
-+	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
-+	return c;
-+}
-+
-+void
-+pop(Client *c)
-+{
-+	detach(c);
-+	attach(c);
-+	focus(c);
-+	arrange(c->mon);
-+}
-+
-+void
-+pushstack(const Arg *arg) {
-+	int i = stackpos(arg);
-+	Client *sel = selmon->sel, *c, *p;
-+
-+	if(i < 0 || !sel)
-+		return;
-+	else if(i == 0) {
-+		detach(sel);
-+		attach(sel);
-+	}
-+	else {
-+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
-+			if(!(i -= (ISVISIBLE(c) && c != sel)))
-+				break;
-+		c = c ? c : p;
-+		detach(sel);
-+		sel->next = c->next;
-+		c->next = sel;
-+	}
-+	arrange(selmon);
-+}
-+
-+void
-+propertynotify(XEvent *e)
-+{
-+	Client *c;
-+	Window trans;
-+	XPropertyEvent *ev = &e->xproperty;
-+
-+	if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
-+		updatestatus();
-+	} else if (ev->state == PropertyDelete) {
-+		return; /* ignore */
-+	} else if ((c = wintoclient(ev->window))) {
-+		switch(ev->atom) {
-+		default: break;
-+		case XA_WM_TRANSIENT_FOR:
-+			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
-+				(c->isfloating = (wintoclient(trans)) != NULL))
-+				arrange(c->mon);
-+			break;
-+		case XA_WM_NORMAL_HINTS:
-+			updatesizehints(c);
-+			break;
-+		case XA_WM_HINTS:
-+			updatewmhints(c);
-+			drawbars();
-+			break;
-+		}
-+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
-+			updatetitle(c);
-+		if (ev->atom == netatom[NetWMWindowType])
-+			updatewindowtype(c);
-+	}
-+}
-+
-+void
-+quit(const Arg *arg)
-+{
-+	if(arg->i) restart = 1;
-+	running = 0;
-+}
-+
-+Monitor *
-+recttomon(int x, int y, int w, int h)
-+{
-+	Monitor *m, *r = selmon;
-+	int a, area = 0;
-+
-+	for (m = mons; m; m = m->next)
-+		if ((a = INTERSECT(x, y, w, h, m)) > area) {
-+			area = a;
-+			r = m;
-+		}
-+	return r;
-+}
-+
-+void
-+resize(Client *c, int x, int y, int w, int h, int interact)
-+{
-+	if (applysizehints(c, &x, &y, &w, &h, interact))
-+		resizeclient(c, x, y, w, h);
-+}
-+
-+void
-+resizeclient(Client *c, int x, int y, int w, int h)
-+{
-+	XWindowChanges wc;
-+
-+	c->oldx = c->x; c->x = wc.x = x;
-+	c->oldy = c->y; c->y = wc.y = y;
-+	c->oldw = c->w; c->w = wc.width = w;
-+	c->oldh = c->h; c->h = wc.height = h;
-+	wc.border_width = c->bw;
-+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
-+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
-+	    && !c->isfullscreen && !c->isfloating) {
-+		c->w = wc.width += c->bw * 2;
-+		c->h = wc.height += c->bw * 2;
-+		wc.border_width = 0;
-+	} else if (c->isfloating){
-+		wc.border_width = 0;
-+	}
-+	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
-+	configure(c);
-+	XSync(dpy, False);
-+}
-+
-+void
-+resizemouse(const Arg *arg)
-+{
-+	int ocx, ocy, nw, nh;
-+	Client *c;
-+	Monitor *m;
-+	XEvent ev;
-+	Time lasttime = 0;
-+
-+	if (!(c = selmon->sel))
-+		return;
-+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
-+		return;
-+	restack(selmon);
-+	ocx = c->x;
-+	ocy = c->y;
-+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-+		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
-+		return;
-+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-+	do {
-+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-+		switch(ev.type) {
-+		case ConfigureRequest:
-+		case Expose:
-+		case MapRequest:
-+			handler[ev.type](&ev);
-+			break;
-+		case MotionNotify:
-+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-+				continue;
-+			lasttime = ev.xmotion.time;
-+
-+			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
-+			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
-+			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
-+			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
-+			{
-+				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-+				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
-+					togglefloating(NULL);
-+			}
-+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-+				resize(c, c->x, c->y, nw, nh, 1);
-+			break;
-+		}
-+	} while (ev.type != ButtonRelease);
-+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-+	XUngrabPointer(dpy, CurrentTime);
-+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-+		sendmon(c, m);
-+		selmon = m;
-+		focus(NULL);
-+	}
-+}
-+
-+void
-+restack(Monitor *m)
-+{
-+	Client *c;
-+	XEvent ev;
-+	XWindowChanges wc;
-+
-+	drawbar(m);
-+	if (!m->sel)
-+		return;
-+	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
-+		XRaiseWindow(dpy, m->sel->win);
-+	if (m->lt[m->sellt]->arrange) {
-+		wc.stack_mode = Below;
-+		wc.sibling = m->barwin;
-+		for (c = m->stack; c; c = c->snext)
-+			if (!c->isfloating && ISVISIBLE(c)) {
-+				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
-+				wc.sibling = c->win;
-+			}
-+	}
-+	XSync(dpy, False);
-+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-+}
-+
-+void
-+run(void)
-+{
-+	XEvent ev;
-+	/* main event loop */
-+	XSync(dpy, False);
-+	while (running && !XNextEvent(dpy, &ev))
-+		if (handler[ev.type])
-+			handler[ev.type](&ev); /* call handler */
-+}
-+
-+void
-+runAutostart(void) {
-+	system("killall -q dwmblocks; dwmblocks &");
-+}
-+
-+void
-+scan(void)
-+{
-+	unsigned int i, num;
-+	Window d1, d2, *wins = NULL;
-+	XWindowAttributes wa;
-+
-+	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
-+		for (i = 0; i < num; i++) {
-+			if (!XGetWindowAttributes(dpy, wins[i], &wa)
-+			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
-+				continue;
-+			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
-+				manage(wins[i], &wa);
-+		}
-+		for (i = 0; i < num; i++) { /* now the transients */
-+			if (!XGetWindowAttributes(dpy, wins[i], &wa))
-+				continue;
-+			if (XGetTransientForHint(dpy, wins[i], &d1)
-+			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
-+				manage(wins[i], &wa);
-+		}
-+		if (wins)
-+			XFree(wins);
-+	}
-+}
-+
-+void
-+sendmon(Client *c, Monitor *m)
-+{
-+	if (c->mon == m)
-+		return;
-+	unfocus(c, 1);
-+	detach(c);
-+	detachstack(c);
-+	c->mon = m;
-+	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-+	attach(c);
-+	attachstack(c);
-+	focus(NULL);
-+	arrange(NULL);
-+}
-+
-+void
-+setclientstate(Client *c, long state)
-+{
-+	long data[] = { state, None };
-+
-+	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-+		PropModeReplace, (unsigned char *)data, 2);
-+}
-+
-+int
-+sendevent(Client *c, Atom proto)
-+{
-+	int n;
-+	Atom *protocols;
-+	int exists = 0;
-+	XEvent ev;
-+
-+	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
-+		while (!exists && n--)
-+			exists = protocols[n] == proto;
-+		XFree(protocols);
-+	}
-+	if (exists) {
-+		ev.type = ClientMessage;
-+		ev.xclient.window = c->win;
-+		ev.xclient.message_type = wmatom[WMProtocols];
-+		ev.xclient.format = 32;
-+		ev.xclient.data.l[0] = proto;
-+		ev.xclient.data.l[1] = CurrentTime;
-+		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
-+	}
-+	return exists;
-+}
-+
-+void
-+setfocus(Client *c)
-+{
-+	if (!c->neverfocus) {
-+		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
-+		XChangeProperty(dpy, root, netatom[NetActiveWindow],
-+			XA_WINDOW, 32, PropModeReplace,
-+			(unsigned char *) &(c->win), 1);
-+	}
-+	sendevent(c, wmatom[WMTakeFocus]);
-+}
-+
-+void
-+setfullscreen(Client *c, int fullscreen)
-+{
-+	if (fullscreen && !c->isfullscreen) {
-+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-+		c->isfullscreen = 1;
-+		c->oldstate = c->isfloating;
-+		c->oldbw = c->bw;
-+		c->bw = 0;
-+		c->isfloating = 1;
-+		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
-+		XRaiseWindow(dpy, c->win);
-+	} else if (!fullscreen && c->isfullscreen){
-+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-+			PropModeReplace, (unsigned char*)0, 0);
-+		c->isfullscreen = 0;
-+		c->isfloating = c->oldstate;
-+		c->bw = c->oldbw;
-+		c->x = c->oldx;
-+		c->y = c->oldy;
-+		c->w = c->oldw;
-+		c->h = c->oldh;
-+		resizeclient(c, c->x, c->y, c->w, c->h);
-+		arrange(c->mon);
-+	}
-+}
-+
-+int
-+stackpos(const Arg *arg) {
-+	int n, i;
-+	Client *c, *l;
-+
-+	if(!selmon->clients)
-+		return -1;
-+
-+	if(arg->i == PREVSEL) {
-+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
-+		if(!l)
-+			return -1;
-+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+		return i;
-+	}
-+	else if(ISINC(arg->i)) {
-+		if(!selmon->sel)
-+			return -1;
-+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+		return MOD(i + GETINC(arg->i), n);
-+	}
-+	else if(arg->i < 0) {
-+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-+		return MAX(i + arg->i, 0);
-+	}
-+	else
-+		return arg->i;
-+}
-+
-+void
-+setlayout(const Arg *arg)
-+{
-+	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-+		selmon->sellt ^= 1;
-+	if (arg && arg->v)
-+		selmon->lt[selmon->sellt] = (Layout *)arg->v;
-+	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
-+	if (selmon->sel)
-+		arrange(selmon);
-+	else
-+		drawbar(selmon);
-+}
-+
-+/* arg > 1.0 will set mfact absolutely */
-+void
-+setmfact(const Arg *arg)
-+{
-+	float f;
-+
-+	if (!arg || !selmon->lt[selmon->sellt]->arrange)
-+		return;
-+	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-+	if (f < 0.05 || f > 0.95)
-+		return;
-+	selmon->mfact = f;
-+	arrange(selmon);
-+}
-+
-+void
-+setup(void)
-+{
-+	int i;
-+	XSetWindowAttributes wa;
-+	Atom utf8string;
-+
-+	/* clean up any zombies immediately */
-+	sigchld(0);
-+
-+	signal(SIGHUP, sighup);
-+	signal(SIGTERM, sigterm);
-+
-+	/* init screen */
-+	screen = DefaultScreen(dpy);
-+	sw = DisplayWidth(dpy, screen);
-+	sh = DisplayHeight(dpy, screen);
-+	root = RootWindow(dpy, screen);
-+	drw = drw_create(dpy, screen, root, sw, sh);
-+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-+		die("no fonts could be loaded.");
-+	lrpad = drw->fonts->h;
-+	bh = drw->fonts->h + 2;
-+	updategeom();
-+	/* init atoms */
-+	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
-+	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
-+	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-+	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
-+	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
-+	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
-+	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-+	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-+	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
-+	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
-+	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
-+	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
-+	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
-+	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
-+	/* init cursors */
-+	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
-+	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
-+	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
-+	/* init appearance */
-+	/* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
-+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
-+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-+	for (i = 0; i < LENGTH(colors); i++)
-+		scheme[i] = drw_scm_create(drw, colors[i], 3);
-+	/* init bars */
-+	updatebars();
-+	updatestatus();
-+	/* supporting window for NetWMCheck */
-+	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
-+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-+		PropModeReplace, (unsigned char *) "dwm", 3);
-+	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-+	/* EWMH support per view */
-+	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-+		PropModeReplace, (unsigned char *) netatom, NetLast);
-+	XDeleteProperty(dpy, root, netatom[NetClientList]);
-+	/* select events */
-+	wa.cursor = cursor[CurNormal]->cursor;
-+	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-+		|ButtonPressMask|PointerMotionMask|EnterWindowMask
-+		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
-+	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
-+	XSelectInput(dpy, root, wa.event_mask);
-+	grabkeys();
-+	focus(NULL);
-+}
-+
-+
-+void
-+seturgent(Client *c, int urg)
-+{
-+	XWMHints *wmh;
-+
-+	c->isurgent = urg;
-+	if (!(wmh = XGetWMHints(dpy, c->win)))
-+		return;
-+	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
-+	XSetWMHints(dpy, c->win, wmh);
-+	XFree(wmh);
-+}
-+
-+void
-+showhide(Client *c)
-+{
-+	if (!c)
-+		return;
-+	if (ISVISIBLE(c)) {
-+		if ((c->tags & SPTAGMASK) && c->isfloating) {
-+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
-+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
-+		}
-+		/* show clients top down */
-+		XMoveWindow(dpy, c->win, c->x, c->y);
-+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-+			resize(c, c->x, c->y, c->w, c->h, 0);
-+		showhide(c->snext);
-+	} else {
-+		/* hide clients bottom up */
-+		showhide(c->snext);
-+		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
-+	}
-+}
-+
-+void
-+sigchld(int unused)
-+{
-+	if (signal(SIGCHLD, sigchld) == SIG_ERR)
-+		die("can't install SIGCHLD handler:");
-+	while (0 < waitpid(-1, NULL, WNOHANG));
-+}
-+
-+void
-+sighup(int unused)
-+{
-+	Arg a = {.i = 1};
-+	quit(&a);
-+}
-+
-+void
-+sigterm(int unused)
-+{
-+	Arg a = {.i = 0};
-+	quit(&a);
-+}
-+
-+#ifndef __OpenBSD__
-+void
-+sigdwmblocks(const Arg *arg)
-+{
-+	union sigval sv;
-+	sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
-+	if (!dwmblockspid)
-+		if (getdwmblockspid() == -1)
-+			return;
-+
-+	if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
-+		if (errno == ESRCH) {
-+			if (!getdwmblockspid())
-+				sigqueue(dwmblockspid, SIGUSR1, sv);
-+		}
-+	}
-+}
-+#endif
-+
-+void
-+spawn(const Arg *arg)
-+{
-+	if (fork() == 0) {
-+		if (dpy)
-+			close(ConnectionNumber(dpy));
-+		setsid();
-+		execvp(((char **)arg->v)[0], (char **)arg->v);
-+		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
-+		perror(" failed");
-+		exit(EXIT_SUCCESS);
-+	}
-+}
-+
-+void
-+tag(const Arg *arg)
-+{
-+	if (selmon->sel && arg->ui & TAGMASK) {
-+		selmon->sel->tags = arg->ui & TAGMASK;
-+		focus(NULL);
-+		arrange(selmon);
-+		view(arg);
-+	}
-+}
-+
-+void
-+noviewontag(const Arg *arg)
-+{
-+	if (selmon->sel && arg->ui & TAGMASK) {
-+		selmon->sel->tags = arg->ui & TAGMASK;
-+		focus(NULL);
-+		arrange(selmon);
-+	}
-+}
-+
-+void
-+tagmon(const Arg *arg)
-+{
-+	if (!selmon->sel || !mons->next)
-+		return;
-+	sendmon(selmon->sel, dirtomon(arg->i));
-+}
-+
-+void
-+togglebar(const Arg *arg)
-+{
-+	selmon->showbar = !selmon->showbar;
-+	updatebarpos(selmon);
-+	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
-+	arrange(selmon);
-+}
-+
-+void
-+togglefloating(const Arg *arg)
-+{
-+	if (!selmon->sel)
-+		return;
-+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
-+		return;
-+	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-+	if (selmon->sel->isfloating)
-+		/* resize(selmon->sel, selmon->sel->x, selmon->sel->y, */
-+		/* 	selmon->sel->w, selmon->sel->h, 0); */
-+		/* restore last known float dimensions */
-+		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
-+		       selmon->sel->sfw, selmon->sel->sfh, False);
-+	else {
-+		/* save last known float dimensions */
-+		selmon->sel->sfx = selmon->sel->x;
-+		selmon->sel->sfy = selmon->sel->y;
-+		selmon->sel->sfw = selmon->sel->w;
-+		selmon->sel->sfh = selmon->sel->h;
-+	}
-+	arrange(selmon);
-+}
-+
-+// Without save floats patch:
-+/* void */
-+/* togglefloating(const Arg *arg) */
-+/* { */
-+/* 	if (!selmon->sel) */
-+/* 		return; */
-+/* 	if (selmon->sel->isfullscreen) /1* no support for fullscreen windows *1/ */
-+/* 		return; */
-+/* 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed; */
-+/* 	if (selmon->sel->isfloating) */
-+/* 		resize(selmon->sel, selmon->sel->x, selmon->sel->y, */
-+/* 			selmon->sel->w, selmon->sel->h, 0); */
-+/* 	arrange(selmon); */
-+/* } */
-+
-+
-+void
-+togglefullscr(const Arg *arg)
-+{
-+  if(selmon->sel)
-+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
-+}
-+
-+void
-+togglesticky(const Arg *arg)
-+{
-+	if (!selmon->sel)
-+		return;
-+	selmon->sel->issticky = !selmon->sel->issticky;
-+	arrange(selmon);
-+}
-+
-+void
-+togglescratch(const Arg *arg)
-+{
-+	Client *c;
-+	unsigned int found = 0;
-+	unsigned int scratchtag = SPTAG(arg->ui);
-+	Arg sparg = {.v = scratchpads[arg->ui].cmd};
-+
-+	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
-+	if (found) {
-+		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
-+		if (newtagset) {
-+			selmon->tagset[selmon->seltags] = newtagset;
-+			focus(NULL);
-+			arrange(selmon);
-+		}
-+		if (ISVISIBLE(c)) {
-+			focus(c);
-+			restack(selmon);
-+		}
-+	} else {
-+		selmon->tagset[selmon->seltags] |= scratchtag;
-+		spawn(&sparg);
-+	}
-+}
-+
-+void
-+toggletag(const Arg *arg)
-+{
-+	unsigned int newtags;
-+
-+	if (!selmon->sel)
-+		return;
-+	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
-+	if (newtags) {
-+		selmon->sel->tags = newtags;
-+		focus(NULL);
-+		arrange(selmon);
-+	}
-+}
-+
-+void
-+toggleview(const Arg *arg)
-+{
-+	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-+
-+	if (newtagset) {
-+		selmon->tagset[selmon->seltags] = newtagset;
-+		focus(NULL);
-+		arrange(selmon);
-+	}
-+}
-+
-+void
-+unfocus(Client *c, int setfocus)
-+{
-+	if (!c)
-+		return;
-+	grabbuttons(c, 0);
-+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-+	if (setfocus) {
-+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-+	}
-+}
-+
-+void
-+unmanage(Client *c, int destroyed)
-+{
-+	Monitor *m = c->mon;
-+	XWindowChanges wc;
-+
-+	if (c->swallowing) {
-+		unswallow(c);
-+		return;
-+	}
-+
-+	Client *s = swallowingclient(c->win);
-+	if (s) {
-+		free(s->swallowing);
-+		s->swallowing = NULL;
-+		arrange(m);
-+        focus(NULL);
-+		return;
-+	}
-+
-+	detach(c);
-+	detachstack(c);
-+	if (!destroyed) {
-+		wc.border_width = c->oldbw;
-+		XGrabServer(dpy); /* avoid race conditions */
-+		XSetErrorHandler(xerrordummy);
-+		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
-+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-+		setclientstate(c, WithdrawnState);
-+		XSync(dpy, False);
-+		XSetErrorHandler(xerror);
-+		XUngrabServer(dpy);
-+	}
-+	free(c);
-+
-+	if (!s) {
-+		arrange(m);
-+		focus(NULL);
-+		updateclientlist();
-+	}
-+}
-+
-+void
-+unmapnotify(XEvent *e)
-+{
-+	Client *c;
-+	XUnmapEvent *ev = &e->xunmap;
-+
-+	if ((c = wintoclient(ev->window))) {
-+		if (ev->send_event)
-+			setclientstate(c, WithdrawnState);
-+		else
-+			unmanage(c, 0);
-+	}
-+}
-+
-+void
-+updatebars(void)
-+{
-+	Monitor *m;
-+	XSetWindowAttributes wa = {
-+		.override_redirect = True,
-+		.background_pixmap = ParentRelative,
-+		.event_mask = ButtonPressMask|ExposureMask
-+	};
-+	XClassHint ch = {"dwm", "dwm"};
-+	for (m = mons; m; m = m->next) {
-+		if (m->barwin)
-+			continue;
-+		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
-+				CopyFromParent, DefaultVisual(dpy, screen),
-+				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
-+		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
-+		XMapRaised(dpy, m->barwin);
-+		XSetClassHint(dpy, m->barwin, &ch);
-+	}
-+}
-+
-+void
-+updatebarpos(Monitor *m)
-+{
-+	m->wy = m->my;
-+	m->wh = m->mh;
-+	if (m->showbar) {
-+		m->wh -= bh;
-+		m->by = m->topbar ? m->wy : m->wy + m->wh;
-+		m->wy = m->topbar ? m->wy + bh : m->wy;
-+	} else
-+		m->by = -bh;
-+}
-+
-+void
-+updateclientlist()
-+{
-+	Client *c;
-+	Monitor *m;
-+
-+	XDeleteProperty(dpy, root, netatom[NetClientList]);
-+	for (m = mons; m; m = m->next)
-+		for (c = m->clients; c; c = c->next)
-+			XChangeProperty(dpy, root, netatom[NetClientList],
-+				XA_WINDOW, 32, PropModeAppend,
-+				(unsigned char *) &(c->win), 1);
-+}
-+
-+int
-+updategeom(void)
-+{
-+	int dirty = 0;
-+
-+#ifdef XINERAMA
-+	if (XineramaIsActive(dpy)) {
-+		int i, j, n, nn;
-+		Client *c;
-+		Monitor *m;
-+		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
-+		XineramaScreenInfo *unique = NULL;
-+
-+		for (n = 0, m = mons; m; m = m->next, n++);
-+		/* only consider unique geometries as separate screens */
-+		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
-+		for (i = 0, j = 0; i < nn; i++)
-+			if (isuniquegeom(unique, j, &info[i]))
-+				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
-+		XFree(info);
-+		nn = j;
-+		if (n <= nn) { /* new monitors available */
-+			for (i = 0; i < (nn - n); i++) {
-+				for (m = mons; m && m->next; m = m->next);
-+				if (m)
-+					m->next = createmon();
-+				else
-+					mons = createmon();
-+			}
-+			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
-+				if (i >= n
-+				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
-+				|| unique[i].width != m->mw || unique[i].height != m->mh)
-+				{
-+					dirty = 1;
-+					m->num = i;
-+					m->mx = m->wx = unique[i].x_org;
-+					m->my = m->wy = unique[i].y_org;
-+					m->mw = m->ww = unique[i].width;
-+					m->mh = m->wh = unique[i].height;
-+					updatebarpos(m);
-+				}
-+		} else { /* less monitors available nn < n */
-+			for (i = nn; i < n; i++) {
-+				for (m = mons; m && m->next; m = m->next);
-+				while ((c = m->clients)) {
-+					dirty = 1;
-+					m->clients = c->next;
-+					detachstack(c);
-+					c->mon = mons;
-+					attach(c);
-+					attachstack(c);
-+				}
-+				if (m == selmon)
-+					selmon = mons;
-+				cleanupmon(m);
-+			}
-+		}
-+		free(unique);
-+	} else
-+#endif /* XINERAMA */
-+	{ /* default monitor setup */
-+		if (!mons)
-+			mons = createmon();
-+		if (mons->mw != sw || mons->mh != sh) {
-+			dirty = 1;
-+			mons->mw = mons->ww = sw;
-+			mons->mh = mons->wh = sh;
-+			updatebarpos(mons);
-+		}
-+	}
-+	if (dirty) {
-+		selmon = mons;
-+		selmon = wintomon(root);
-+	}
-+	return dirty;
-+}
-+
-+void
-+updatenumlockmask(void)
-+{
-+	unsigned int i, j;
-+	XModifierKeymap *modmap;
-+
-+	numlockmask = 0;
-+	modmap = XGetModifierMapping(dpy);
-+	for (i = 0; i < 8; i++)
-+		for (j = 0; j < modmap->max_keypermod; j++)
-+			if (modmap->modifiermap[i * modmap->max_keypermod + j]
-+				== XKeysymToKeycode(dpy, XK_Num_Lock))
-+				numlockmask = (1 << i);
-+	XFreeModifiermap(modmap);
-+}
-+
-+void
-+updatesizehints(Client *c)
-+{
-+	long msize;
-+	XSizeHints size;
-+
-+	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
-+		/* size is uninitialized, ensure that size.flags aren't used */
-+		size.flags = PSize;
-+	if (size.flags & PBaseSize) {
-+		c->basew = size.base_width;
-+		c->baseh = size.base_height;
-+	} else if (size.flags & PMinSize) {
-+		c->basew = size.min_width;
-+		c->baseh = size.min_height;
-+	} else
-+		c->basew = c->baseh = 0;
-+	if (size.flags & PResizeInc) {
-+		c->incw = size.width_inc;
-+		c->inch = size.height_inc;
-+	} else
-+		c->incw = c->inch = 0;
-+	if (size.flags & PMaxSize) {
-+		c->maxw = size.max_width;
-+		c->maxh = size.max_height;
-+	} else
-+		c->maxw = c->maxh = 0;
-+	if (size.flags & PMinSize) {
-+		c->minw = size.min_width;
-+		c->minh = size.min_height;
-+	} else if (size.flags & PBaseSize) {
-+		c->minw = size.base_width;
-+		c->minh = size.base_height;
-+	} else
-+		c->minw = c->minh = 0;
-+	if (size.flags & PAspect) {
-+		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
-+		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
-+	} else
-+		c->maxa = c->mina = 0.0;
-+	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
-+}
-+
-+void
-+updatestatus(void)
-+{
-+	if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
-+		strcpy(stext, "dwm-"VERSION);
-+	else
-+		copyvalidchars(stext, rawstext);
-+	drawbar(selmon);
-+}
-+
-+void
-+updatetitle(Client *c)
-+{
-+	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
-+		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-+	if (c->name[0] == '\0') /* hack to mark broken clients */
-+		strcpy(c->name, broken);
-+}
-+
-+void
-+updatewindowtype(Client *c)
-+{
-+	Atom state = getatomprop(c, netatom[NetWMState]);
-+	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
-+
-+	if (state == netatom[NetWMFullscreen])
-+		setfullscreen(c, 1);
-+	if (wtype == netatom[NetWMWindowTypeDialog])
-+		c->isfloating = 1;
-+}
-+
-+void
-+updatewmhints(Client *c)
-+{
-+	XWMHints *wmh;
-+
-+	if ((wmh = XGetWMHints(dpy, c->win))) {
-+		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
-+			wmh->flags &= ~XUrgencyHint;
-+			XSetWMHints(dpy, c->win, wmh);
-+		} else
-+			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
-+		if (wmh->flags & InputHint)
-+			c->neverfocus = !wmh->input;
-+		else
-+			c->neverfocus = 0;
-+		XFree(wmh);
-+	}
-+}
-+
-+void
-+view(const Arg *arg)
-+{
-+	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-+		return;
-+
-+	/* if ((arg->ui & TAGMASK) == ( 1 << 8)){ */
-+	if ((arg->ui & TAGMASK) == (000000001)){
-+		enablegaps = 0;
-+		/* arrange(NULL); */
-+	}else{
-+		enablegaps = 1;
-+		/* arrange(NULL); */
-+	}
-+
-+	selmon->seltags ^= 1; /* toggle sel tagset */
-+	if (arg->ui & TAGMASK)
-+		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-+	focus(NULL);
-+	arrange(selmon);
-+}
-+
-+pid_t
-+winpid(Window w)
-+{
-+	pid_t result = 0;
-+
-+	xcb_res_client_id_spec_t spec = {0};
-+	spec.client = w;
-+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
-+
-+	xcb_generic_error_t *e = NULL;
-+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
-+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
-+
-+	if (!r)
-+		return (pid_t)0;
-+
-+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
-+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
-+		spec = i.data->spec;
-+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
-+			uint32_t *t = xcb_res_client_id_value_value(i.data);
-+			result = *t;
-+			break;
-+		}
-+	}
-+
-+	free(r);
-+
-+	if (result == (pid_t)-1)
-+		result = 0;
-+	return result;
-+}
-+
-+pid_t
-+getparentprocess(pid_t p)
-+{
-+	unsigned int v = 0;
-+
-+#if defined(__linux__)
-+	FILE *f;
-+	char buf[256];
-+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
-+
-+	if (!(f = fopen(buf, "r")))
-+		return (pid_t)0;
-+
-+	if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
-+		v = (pid_t)0;
-+	fclose(f);
-+#elif defined(__FreeBSD__)
-+	struct kinfo_proc *proc = kinfo_getproc(p);
-+	if (!proc)
-+		return (pid_t)0;
-+
-+	v = proc->ki_ppid;
-+	free(proc);
-+#endif
-+	return (pid_t)v;
-+}
-+
-+int
-+isdescprocess(pid_t p, pid_t c)
-+{
-+	while (p != c && c != 0)
-+		c = getparentprocess(c);
-+
-+	return (int)c;
-+}
-+
-+Client *
-+termforwin(const Client *w)
-+{
-+	Client *c;
-+	Monitor *m;
-+
-+	if (!w->pid || w->isterminal)
-+		return NULL;
-+
-+	for (m = mons; m; m = m->next) {
-+		for (c = m->clients; c; c = c->next) {
-+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
-+				return c;
-+		}
-+	}
-+
-+	return NULL;
-+}
-+
-+Client *
-+swallowingclient(Window w)
-+{
-+	Client *c;
-+	Monitor *m;
-+
-+	for (m = mons; m; m = m->next) {
-+		for (c = m->clients; c; c = c->next) {
-+			if (c->swallowing && c->swallowing->win == w)
-+				return c;
-+		}
-+	}
-+
-+	return NULL;
-+}
-+
-+Client *
-+wintoclient(Window w)
-+{
-+	Client *c;
-+	Monitor *m;
-+
-+	for (m = mons; m; m = m->next)
-+		for (c = m->clients; c; c = c->next)
-+			if (c->win == w)
-+				return c;
-+	return NULL;
-+}
-+
-+Monitor *
-+wintomon(Window w)
-+{
-+	int x, y;
-+	Client *c;
-+	Monitor *m;
-+
-+	if (w == root && getrootptr(&x, &y))
-+		return recttomon(x, y, 1, 1);
-+	for (m = mons; m; m = m->next)
-+		if (w == m->barwin)
-+			return m;
-+	if ((c = wintoclient(w)))
-+		return c->mon;
-+	return selmon;
-+}
-+
-+/* There's no way to check accesses to destroyed windows, thus those cases are
-+ * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
-+ * default error handler, which may call exit. */
-+int
-+xerror(Display *dpy, XErrorEvent *ee)
-+{
-+	if (ee->error_code == BadWindow
-+	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
-+	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
-+	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
-+	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
-+	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
-+	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
-+	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
-+	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
-+		return 0;
-+	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-+		ee->request_code, ee->error_code);
-+	return xerrorxlib(dpy, ee); /* may call exit */
-+}
-+
-+int
-+xerrordummy(Display *dpy, XErrorEvent *ee)
-+{
-+	return 0;
-+}
-+
-+/* Startup Error handler to check if another window manager
-+ * is already running. */
-+int
-+xerrorstart(Display *dpy, XErrorEvent *ee)
-+{
-+	die("dwm: another window manager is already running");
-+	return -1;
-+}
-+
-+void
-+zoom(const Arg *arg)
-+{
-+	Client *c = selmon->sel;
-+
-+	if (!selmon->lt[selmon->sellt]->arrange
-+	|| (selmon->sel && selmon->sel->isfloating))
-+		return;
-+	if (c == nexttiled(selmon->clients))
-+		if (!c || !(c = nexttiled(c->next)))
-+			return;
-+	pop(c);
-+}
-+
-+void
-+resource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)
-+{
-+	char *sdst = NULL;
-+	int *idst = NULL;
-+	float *fdst = NULL;
-+
-+	sdst = dst;
-+	idst = dst;
-+	fdst = dst;
-+
-+	char fullname[256];
-+	char *type;
-+	XrmValue ret;
-+
-+	snprintf(fullname, sizeof(fullname), "%s.%s", "dwm", name);
-+	fullname[sizeof(fullname) - 1] = '\0';
-+
-+	XrmGetResource(db, fullname, "*", &type, &ret);
-+	if (!(ret.addr == NULL || strncmp("String", type, 64)))
-+	{
-+		switch (rtype) {
-+		case STRING:
-+			strcpy(sdst, ret.addr);
-+			break;
-+		case INTEGER:
-+			*idst = strtoul(ret.addr, NULL, 10);
-+			break;
-+		case FLOAT:
-+			*fdst = strtof(ret.addr, NULL);
-+			break;
-+		}
-+	}
-+}
-+
-+void
-+load_xresources(void)
-+{
-+	Display *display;
-+	char *resm;
-+	XrmDatabase db;
-+	ResourcePref *p;
-+
-+	display = XOpenDisplay(NULL);
-+	resm = XResourceManagerString(display);
-+	if (!resm)
-+		return;
-+
-+	db = XrmGetStringDatabase(resm);
-+	for (p = resources; p < resources + LENGTH(resources); p++)
-+		resource_load(db, p->name, p->type, p->dst);
-+	XCloseDisplay(display);
-+}
-+
-+int
-+main(int argc, char *argv[])
-+{
-+	if (argc == 2 && !strcmp("-v", argv[1]))
-+		die("dwm-"VERSION);
-+	else if (argc != 1)
-+		die("usage: dwm [-v]");
-+	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-+		fputs("warning: no locale support\n", stderr);
-+	if (!(dpy = XOpenDisplay(NULL)))
-+		die("dwm: cannot open display");
-+	if (!(xcon = XGetXCBConnection(dpy)))
-+		die("dwm: cannot get xcb connection\n");
-+	checkotherwm();
-+	XrmInitialize();
-+	load_xresources();
-+	setup();
-+#ifdef __OpenBSD__
-+	if (pledge("stdio rpath proc exec", NULL) == -1)
-+		die("pledge");
-+#endif /* __OpenBSD__ */
-+	scan();
-+	runAutostart();
-+	/* runautostart(); */
-+	enablegaps = 0;
-+	arrange(NULL);
-+	run();
-+	if(restart) execvp(argv[0], argv);
-+	cleanup();
-+	XCloseDisplay(dpy);
-+	return EXIT_SUCCESS;
-+}
-diff --git a/shiftview.c b/shiftview.c
-new file mode 100644
-index 0000000..7905a6d
---- /dev/null
-+++ b/shiftview.c
-@@ -0,0 +1,64 @@
-+/** Function to shift the current view to the left/right
-+ *
-+ * @param: "arg->i" stores the number of tags to shift right (positive value)
-+ *          or left (negative value)
-+ */
-+void
-+shiftview(const Arg *arg)
-+{
-+    Arg shifted;
-+    Client *c;
-+    unsigned int tagmask = 0;
-+
-+    for (c = selmon->clients; c; c = c->next)
-+        if (!(c->tags & SPTAGMASK))
-+            tagmask = tagmask | c->tags;
-+
-+    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
-+    if (arg->i > 0) /* left circular shift */
-+        do {
-+            shifted.ui = (shifted.ui << arg->i)
-+                | (shifted.ui >> (LENGTH(tags) - arg->i));
-+            shifted.ui &= ~SPTAGMASK;
-+        } while (tagmask && !(shifted.ui & tagmask));
-+    else /* right circular shift */
-+        do {
-+            shifted.ui = (shifted.ui >> (- arg->i)
-+                    | shifted.ui << (LENGTH(tags) + arg->i));
-+            shifted.ui &= ~SPTAGMASK;
-+        } while (tagmask && !(shifted.ui & tagmask));
-+
-+    view(&shifted);
-+}
-+
-+void
-+shifttag(const Arg *arg)
-+{
-+    Arg a;
-+    Client *c;
-+    unsigned visible = 0;
-+    int i = arg->i;
-+    int count = 0;
-+    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
-+
-+    do {
-+        if(i > 0) // left circular shift
-+            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
-+
-+        else // right circular shift
-+            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
-+
-+        // Check if tag is visible
-+        for (c = selmon->clients; c && !visible; c = c->next)
-+            if (nextseltags & c->tags) {
-+                visible = 1;
-+                break;
-+            }
-+        i += arg->i;
-+    } while (!visible && ++count < 10);
-+
-+    if (count < 10) {
-+        a.i = nextseltags;
-+        tag(&a);
-+    }
-+}
-diff --git a/test.c b/test.c
-new file mode 100644
-index 0000000..50e4cba
---- /dev/null
-+++ b/test.c
-@@ -0,0 +1,37 @@
-+#include <stdio.h>
-+#include <string.h>
-+
-+int
-+main()
-+{
-+    char s[1000];
-+    int i, alphabets=0, digits=0, specialchars=0;
-+    /* printf("Enter string"); */
-+    /* gets(s); */
-+
-+    FILE *ptr;
-+    char ch;
-+    ptr = fopen("/home/jonas/test.txt", "r");
-+    if (ptr == NULL) printf("Fail...");
-+    do{
-+        ch = fgetc(ptr);
-+        /* printf("%c", ch); */
-+        /* printf("%c %d \n", ch, ch); */
-+        printf("%d\n", ch);
-+        /* printf("%d", ch); */
-+    } while (ch != EOF);
-+    fclose(ptr);
-+
-+    /* for(int i = 0;s[i]; i++){ */
-+    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
-+    /*         alphabets++; */
-+    /*     else if (s[i]>48 && s[i] <=57) digits++; */
-+    /*     else specialchars++; */
-+
-+    /* } */
-+    /* printf("Alphas = %d}n", alphabets); */
-+    /* printf("Digits = %d\n", digits); */
-+    /* printf("Spec chars = %d", specialchars); */
-+
-+    return 0;
-+}
-diff --git a/transient.c b/transient.c
-index 040adb5..802b66a 100644
---- a/transient.c
-+++ b/transient.c
-@@ -6,37 +6,37 @@
- #include <X11/Xutil.h>
- 
- int main(void) {
--	Display *d;
--	Window r, f, t = None;
--	XSizeHints h;
--	XEvent e;
-+    Display *d;
-+    Window r, f, t = None;
-+    XSizeHints h;
-+    XEvent e;
- 
--	d = XOpenDisplay(NULL);
--	if (!d)
--		exit(1);
--	r = DefaultRootWindow(d);
-+    d = XOpenDisplay(NULL);
-+    if (!d)
-+        exit(1);
-+    r = DefaultRootWindow(d);
- 
--	f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
--	h.min_width = h.max_width = h.min_height = h.max_height = 400;
--	h.flags = PMinSize | PMaxSize;
--	XSetWMNormalHints(d, f, &h);
--	XStoreName(d, f, "floating");
--	XMapWindow(d, f);
-+    f = XCreateSimpleWindow(d, r, 100, 100, 400, 400, 0, 0, 0);
-+    h.min_width = h.max_width = h.min_height = h.max_height = 400;
-+    h.flags = PMinSize | PMaxSize;
-+    XSetWMNormalHints(d, f, &h);
-+    XStoreName(d, f, "floating");
-+    XMapWindow(d, f);
- 
--	XSelectInput(d, f, ExposureMask);
--	while (1) {
--		XNextEvent(d, &e);
-+    XSelectInput(d, f, ExposureMask);
-+    while (1) {
-+        XNextEvent(d, &e);
- 
--		if (t == None) {
--			sleep(5);
--			t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
--			XSetTransientForHint(d, t, f);
--			XStoreName(d, t, "transient");
--			XMapWindow(d, t);
--			XSelectInput(d, t, ExposureMask);
--		}
--	}
-+        if (t == None) {
-+            sleep(5);
-+            t = XCreateSimpleWindow(d, r, 50, 50, 100, 100, 0, 0, 0);
-+            XSetTransientForHint(d, t, f);
-+            XStoreName(d, t, "transient");
-+            XMapWindow(d, t);
-+            XSelectInput(d, t, ExposureMask);
-+        }
-+    }
- 
--	XCloseDisplay(d);
--	exit(0);
-+    XCloseDisplay(d);
-+    exit(0);
- }
-diff --git a/util.c b/util.c
-index 8e26a51..c8b1dcd 100644
---- a/util.c
-+++ b/util.c
-@@ -7,31 +7,29 @@
- 
- #include "util.h"
- 
--void
--die(const char *fmt, ...)
-+void *
-+ecalloc(size_t nmemb, size_t size)
- {
--	va_list ap;
-+    void *p;
-+
-+    if (!(p = calloc(nmemb, size)))
-+        die("calloc:");
-+    return p;
-+}
-+
-+void die(const char *fmt, ...) {
-+    va_list ap;
- 	int saved_errno;
- 
- 	saved_errno = errno;
- 
--	va_start(ap, fmt);
--	vfprintf(stderr, fmt, ap);
--	va_end(ap);
-+    va_start(ap, fmt);
-+    vfprintf(stderr, fmt, ap);
-+    va_end(ap);
- 
- 	if (fmt[0] && fmt[strlen(fmt)-1] == ':')
- 		fprintf(stderr, " %s", strerror(saved_errno));
- 	fputc('\n', stderr);
- 
--	exit(1);
--}
--
--void *
--ecalloc(size_t nmemb, size_t size)
--{
--	void *p;
--
--	if (!(p = calloc(nmemb, size)))
--		die("calloc:");
--	return p;
-+    exit(1);
- }
-diff --git a/vanitygaps.c b/vanitygaps.c
-new file mode 100644
-index 0000000..7b64fd2
---- /dev/null
-+++ b/vanitygaps.c
-@@ -0,0 +1,555 @@
-+/* Key binding functions */
-+static void defaultgaps(const Arg *arg);
-+static void incrgaps(const Arg *arg);
-+/* static void incrigaps(const Arg *arg); */
-+/* static void incrogaps(const Arg *arg); */
-+/* static void incrohgaps(const Arg *arg); */
-+/* static void incrovgaps(const Arg *arg); */
-+/* static void incrihgaps(const Arg *arg); */
-+/* static void incrivgaps(const Arg *arg); */
-+static void togglegaps(const Arg *arg);
-+static void togglebgaps(const Arg *arg);
-+
-+/* Layouts */
-+static void bstack(Monitor *m);
-+static void centeredmaster(Monitor *m);
-+static void centeredfloatingmaster(Monitor *m);
-+static void deck(Monitor *m);
-+static void dwindle(Monitor *m);
-+static void fibonacci(Monitor *m, int s);
-+static void spiral(Monitor *m);
-+static void tile(Monitor *m);
-+
-+/* Internals */
-+static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
-+static void setgaps(int oh, int ov, int ih, int iv);
-+
-+/* Settings */
-+static int enablegaps = 1;
-+
-+static void
-+setgaps(int oh, int ov, int ih, int iv)
-+{
-+    if (oh < 0) oh = 0;
-+    if (ov < 0) ov = 0;
-+    if (ih < 0) ih = 0;
-+    if (iv < 0) iv = 0;
-+
-+    selmon->gappoh = oh;
-+    selmon->gappov = ov;
-+    selmon->gappih = ih;
-+    selmon->gappiv = iv;
-+    arrange(selmon);
-+}
-+
-+static void
-+togglegaps(const Arg *arg)
-+{
-+    enablegaps = !enablegaps;
-+    /* arrange(NULL); */
-+    arrange(selmon);
-+}
-+
-+static void
-+togglebgaps(const Arg *arg)
-+{
-+    browsergaps = !browsergaps;
-+    arrange(NULL);
-+}
-+
-+static void
-+defaultgaps(const Arg *arg)
-+{
-+    setgaps(gappoh, gappov, gappih, gappiv);
-+}
-+
-+static void
-+incrgaps(const Arg *arg)
-+{
-+    setgaps(
-+            selmon->gappoh + arg->i,
-+            selmon->gappov + arg->i,
-+            selmon->gappih + arg->i,
-+            selmon->gappiv + arg->i
-+           );
-+}
-+
-+/* static void */
-+/* incrigaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh, */
-+/* 		selmon->gappov, */
-+/* 		selmon->gappih + arg->i, */
-+/* 		selmon->gappiv + arg->i */
-+/* 	); */
-+/* } */
-+
-+/* static void */
-+/* incrogaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh + arg->i, */
-+/* 		selmon->gappov + arg->i, */
-+/* 		selmon->gappih, */
-+/* 		selmon->gappiv */
-+/* 	); */
-+/* } */
-+
-+/* static void */
-+/* incrohgaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh + arg->i, */
-+/* 		selmon->gappov, */
-+/* 		selmon->gappih, */
-+/* 		selmon->gappiv */
-+/* 	); */
-+/* } */
-+
-+/* static void */
-+/* incrovgaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh, */
-+/* 		selmon->gappov + arg->i, */
-+/* 		selmon->gappih, */
-+/* 		selmon->gappiv */
-+/* 	); */
-+/* } */
-+
-+/* static void */
-+/* incrihgaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh, */
-+/* 		selmon->gappov, */
-+/* 		selmon->gappih + arg->i, */
-+/* 		selmon->gappiv */
-+/* 	); */
-+/* } */
-+
-+/* static void */
-+/* incrivgaps(const Arg *arg) */
-+/* { */
-+/* 	setgaps( */
-+/* 		selmon->gappoh, */
-+/* 		selmon->gappov, */
-+/* 		selmon->gappih, */
-+/* 		selmon->gappiv + arg->i */
-+/* 	); */
-+/* } */
-+
-+static void
-+getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
-+{
-+    unsigned int n, oe, ie;
-+    oe = ie = enablegaps;
-+    Client *c;
-+
-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-+    /* if (smartgaps && n == 1) { */
-+    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
-+        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
-+    }
-+
-+    if (TAGMASK == (1 << 8)){
-+        setgaps(gappoh, gappov, gappih, gappiv);
-+    }
-+
-+    *oh = m->gappoh*oe; // outer horizontal gap
-+    *ov = m->gappov*oe; // outer vertical gap
-+    *ih = m->gappih*ie; // inner horizontal gap
-+    *iv = m->gappiv*ie; // inner vertical gap
-+    *nc = n;            // number of clients
-+}
-+
-+void
-+getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
-+{
-+    unsigned int n;
-+    float mfacts, sfacts;
-+    int mtotal = 0, stotal = 0;
-+    Client *c;
-+
-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-+    mfacts = MIN(n, m->nmaster);
-+    sfacts = n - m->nmaster;
-+
-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
-+        if (n < m->nmaster)
-+            mtotal += msize / mfacts;
-+        else
-+            stotal += ssize / sfacts;
-+
-+    *mf = mfacts; // total factor of master area
-+    *sf = sfacts; // total factor of stack area
-+    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
-+    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
-+}
-+
-+/***
-+ * Layouts
-+ */
-+
-+/*
-+ * Bottomstack layout + gaps
-+ * https://dwm.suckless.org/patches/bottomstack/
-+ */
-+
-+static void
-+bstack(Monitor *m)
-+{
-+    unsigned int i, n;
-+    int mx = 0, my = 0, mh = 0, mw = 0;
-+    int sx = 0, sy = 0, sh = 0, sw = 0;
-+    float mfacts, sfacts;
-+    int mrest, srest;
-+    Client *c;
-+
-+    int oh, ov, ih, iv;
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    sx = mx = m->wx + ov;
-+    sy = my = m->wy + oh;
-+    sh = mh = m->wh - 2*oh;
-+    mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
-+    sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
-+
-+    if (m->nmaster && n > m->nmaster) {
-+        sh = (mh - ih) * (1 - m->mfact);
-+        mh = (mh - ih) * m->mfact;
-+        sx = mx;
-+        sy = my + mh + ih;
-+    }
-+
-+    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
-+        if (i < m->nmaster) {
-+            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
-+            mx += WIDTH(c) + iv;
-+        } else {
-+            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
-+            sx += WIDTH(c) + iv;
-+        }
-+    }
-+}
-+
-+/*
-+ * Centred master layout + gaps
-+ * https://dwm.suckless.org/patches/centeredmaster/
-+ */
-+
-+void
-+centeredmaster(Monitor *m)
-+{
-+    unsigned int i, n;
-+    int mx = 0, my = 0, mh = 0, mw = 0;
-+    int lx = 0, ly = 0, lw = 0, lh = 0;
-+    int rx = 0, ry = 0, rw = 0, rh = 0;
-+    float mfacts = 0, lfacts = 0, rfacts = 0;
-+    int mtotal = 0, ltotal = 0, rtotal = 0;
-+    int mrest = 0, lrest = 0, rrest = 0;
-+    Client *c;
-+
-+    int oh, ov, ih, iv;
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    /* initialize areas */
-+    mx = m->wx + ov;
-+    my = m->wy + oh;
-+    mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
-+    mw = m->ww - 2*ov;
-+    lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
-+    rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
-+
-+    if (m->nmaster && n > m->nmaster) {
-+        /* go mfact box in the center if more than nmaster clients */
-+        if (n - m->nmaster > 1) {
-+            /* ||<-S->|<---M--->|<-S->|| */
-+            mw = (m->ww - 2*ov - 2*iv) * m->mfact;
-+            lw = (m->ww - mw - 2*ov - 2*iv) / 2;
-+            mx += lw + iv;
-+        } else {
-+            /* ||<---M--->|<-S->|| */
-+            mw = (mw - iv) * m->mfact;
-+            lw = m->ww - mw - iv - 2*ov;
-+        }
-+        rw = lw;
-+        lx = m->wx + ov;
-+        ly = m->wy + oh;
-+        rx = mx + mw + iv;
-+        ry = m->wy + oh;
-+    }
-+
-+    /* calculate facts */
-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
-+        if (!m->nmaster || n < m->nmaster)
-+            mfacts += 1;
-+        else if ((n - m->nmaster) % 2)
-+            lfacts += 1; // total factor of left hand stack area
-+        else
-+            rfacts += 1; // total factor of right hand stack area
-+    }
-+
-+    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
-+        if (!m->nmaster || n < m->nmaster)
-+            mtotal += mh / mfacts;
-+        else if ((n - m->nmaster) % 2)
-+            ltotal += lh / lfacts;
-+        else
-+            rtotal += rh / rfacts;
-+
-+    mrest = mh - mtotal;
-+    lrest = lh - ltotal;
-+    rrest = rh - rtotal;
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
-+        if (!m->nmaster || i < m->nmaster) {
-+            /* nmaster clients are stacked vertically, in the center of the screen */
-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-+            my += HEIGHT(c) + ih;
-+        } else {
-+            /* stack clients are stacked vertically */
-+            if ((i - m->nmaster) % 2 ) {
-+                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
-+                ly += HEIGHT(c) + ih;
-+            } else {
-+                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
-+                ry += HEIGHT(c) + ih;
-+            }
-+        }
-+    }
-+}
-+
-+void
-+centeredfloatingmaster(Monitor *m)
-+{
-+    unsigned int i, n;
-+    float mfacts, sfacts;
-+    int mrest, srest;
-+    int mx = 0, my = 0, mh = 0, mw = 0;
-+    int sx = 0, sy = 0, sh = 0, sw = 0;
-+    Client *c;
-+
-+    float mivf = 1.0; // master inner vertical gap factor
-+    int oh, ov, ih, iv;
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    sx = mx = m->wx + ov;
-+    sy = my = m->wy + oh;
-+    sh = mh = m->wh - 2*oh;
-+    mw = m->ww - 2*ov - iv*(n - 1);
-+    sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
-+
-+    if (m->nmaster && n > m->nmaster) {
-+        mivf = 0.8;
-+        /* go mfact box in the center if more than nmaster clients */
-+        if (m->ww > m->wh) {
-+            mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
-+            mh = m->wh * 0.9 - 2*oh;
-+        } else {
-+            mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
-+            mh = m->wh * m->mfact;
-+        }
-+        mx = m->wx + (m->ww - mw) / 2;
-+        my = m->wy + (m->wh - mh) / 2;
-+
-+        sx = m->wx + ov;
-+        sy = m->wy + oh;
-+        sh = m->wh - 2*oh;
-+    }
-+
-+    getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-+        if (i < m->nmaster) {
-+            /* nmaster clients are stacked horizontally, in the center of the screen */
-+            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
-+            mx += WIDTH(c) + iv*mivf;
-+        } else {
-+            /* stack clients are stacked horizontally */
-+            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
-+            sx += WIDTH(c) + iv;
-+        }
-+}
-+
-+/*
-+ * Deck layout + gaps
-+ * https://dwm.suckless.org/patches/deck/
-+ */
-+
-+static void
-+deck(Monitor *m)
-+{
-+    unsigned int i, n;
-+    int mx = 0, my = 0, mh = 0, mw = 0;
-+    int sx = 0, sy = 0, sh = 0, sw = 0;
-+    float mfacts, sfacts;
-+    int mrest, srest;
-+    Client *c;
-+
-+    int oh, ov, ih, iv;
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    sx = mx = m->wx + ov;
-+    sy = my = m->wy + oh;
-+    sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
-+    sw = mw = m->ww - 2*ov;
-+
-+    if (m->nmaster && n > m->nmaster) {
-+        sw = (mw - iv) * (1 - m->mfact);
-+        mw = (mw - iv) * m->mfact;
-+        sx = mx + mw + iv;
-+        sh = m->wh - 2*oh;
-+    }
-+
-+    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
-+
-+    if (n - m->nmaster > 0) /* override layout symbol */
-+        snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-+        if (i < m->nmaster) {
-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-+            my += HEIGHT(c) + ih;
-+        } else {
-+            resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
-+        }
-+}
-+
-+/*
-+ * Fibonacci layout + gaps
-+ * https://dwm.suckless.org/patches/fibonacci/
-+ */
-+
-+static void
-+fibonacci(Monitor *m, int s)
-+{
-+    unsigned int i, n;
-+    int nx, ny, nw, nh;
-+    int oh, ov, ih, iv;
-+    Client *c;
-+
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    nx = m->wx + ov;
-+    ny = oh;
-+    nw = m->ww - 2*ov;
-+    nh = m->wh - 2*oh;
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
-+        if ((i % 2 && nh / 2 > 2*c->bw)
-+                || (!(i % 2) && nw / 2 > 2*c->bw)) {
-+            if (i < n - 1) {
-+                if (i % 2)
-+                    nh = (nh - ih) / 2;
-+                else
-+                    nw = (nw - iv) / 2;
-+
-+                if ((i % 4) == 2 && !s)
-+                    nx += nw + iv;
-+                else if ((i % 4) == 3 && !s)
-+                    ny += nh + ih;
-+            }
-+            if ((i % 4) == 0) {
-+                if (s)
-+                    ny += nh + ih;
-+                else
-+                    ny -= nh + ih;
-+            }
-+            else if ((i % 4) == 1)
-+                nx += nw + iv;
-+            else if ((i % 4) == 2)
-+                ny += nh + ih;
-+            else if ((i % 4) == 3) {
-+                if (s)
-+                    nx += nw + iv;
-+                else
-+                    nx -= nw + iv;
-+            }
-+            if (i == 0)	{
-+                if (n != 1)
-+                    nw = (m->ww - 2*ov - iv) * m->mfact;
-+                ny = m->wy + oh;
-+            }
-+            else if (i == 1)
-+                nw = m->ww - nw - iv - 2*ov;
-+            i++;
-+        }
-+
-+        resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
-+    }
-+}
-+
-+static void
-+dwindle(Monitor *m)
-+{
-+    fibonacci(m, 1);
-+}
-+
-+static void
-+spiral(Monitor *m)
-+{
-+    fibonacci(m, 0);
-+}
-+
-+/*
-+ * Default tile layout + gaps
-+ */
-+
-+static void
-+tile(Monitor *m)
-+{
-+    unsigned int i, n;
-+    int mx = 0, my = 0, mh = 0, mw = 0;
-+    int sx = 0, sy = 0, sh = 0, sw = 0;
-+    float mfacts, sfacts;
-+    int mrest, srest;
-+    Client *c;
-+
-+    int oh, ov, ih, iv;
-+    getgaps(m, &oh, &ov, &ih, &iv, &n);
-+
-+    if (n == 0)
-+        return;
-+
-+    sx = mx = m->wx + ov;
-+    sy = my = m->wy + oh;
-+    mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
-+    sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
-+    sw = mw = m->ww - 2*ov;
-+
-+    if (m->nmaster && n > m->nmaster) {
-+        sw = (mw - iv) * (1 - m->mfact);
-+        mw = (mw - iv) * m->mfact;
-+        sx = mx + mw + iv;
-+    }
-+
-+    getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
-+
-+    for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-+        if (i < m->nmaster) {
-+            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
-+            my += HEIGHT(c) + ih;
-+        } else {
-+            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
-+            sy += HEIGHT(c) + ih;
-+        }
-+}
diff --git a/config.h b/config.h
index 342750a..ec7de9e 100644
--- a/config.h
+++ b/config.h
@@ -28,13 +28,15 @@ static int smartgaps            = 0;        /* 1 means no outer gap when there i
 static int browsergaps          = 0;        /* 0 means no outer gap when there is only one window and it is firefox */
 static int showbar              = 1;        /* 0 means no bar */
 static int topbar               = 1;        /* 0 means bottom bar */
+static const int focusonwheel       = 0;
 /* static char *fonts[]            = { "Linux Libertine Mono:size=12", "Mono:pixelsize=12:antialias=true:autohint=true", "FontAwesome:size=15","FontAwesome5Brands:size=13:antialias:true", "FontAwesome5Free:size=13:antialias:true", "FontAwesome5Free:style=Solid:size=13:antialias:true","JetBrainsMono Nerd Font:size=12:style=bold:antialias=true:autohint=true", "Nerd Font Complete Mono:size=13", "JoyPixels:pixelsize=10:antialias=true:autohint=true", "Inconsolata Nerd Font:size=15", "Nerd Font Complete Mono:size=13" }; */
 /* static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold:antialias=true:autohint=true", "JoyPixels:pixelsize=13:antialias=true:autohint=true" }; */
 static const char *fonts[]      = { "JetBrainsMono Nerd Font:size=11:style=bold" };
-static char normbgcolor[]       = "#222222";
-static char normbordercolor[]   = "#444444";
-static char normfgcolor[]       = "#bbbbbb";
-static char selfgcolor[]        = "#eeeeee";
+//static char normbgcolor[]       = "#222222";
+static char normbgcolor[]       = "#282828";
+static char normbordercolor[]   = "#ebdbb2";
+static char normfgcolor[]       = "#ebdbb2";
+static char selfgcolor[]        = "#ebdbb2";
 static char selbordercolor[]    = "#770000";
 static char selbgcolor[]        = "#005577";
 static const char col1[]        = "#98971a";
@@ -127,8 +129,13 @@ static const Layout layouts[] = {
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
+#define STATUSBAR "dwmblocks"
+
 /* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
 static const char *termcmd[]  = { TERMINAL, NULL };
+//static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn JetBrainsMono Nerd Font:size=11:style=bold", NULL };
 
 /*
  * Xresources preferences to load at startup
@@ -157,7 +164,6 @@ ResourcePref resources[] = {
 };
 
 #include <X11/XF86keysym.h>
-#include "shiftview.c"
 
 static const Key keys[] = {
     /*  modifier                    key                 function            argument */
@@ -328,17 +334,19 @@ static const Key keys[] = {
         /* { 0, XF86XK_TouchpadOn,                         spawn,              SHCMD("synclient TouchpadOff=0") }, */
 };
 
+#define STATUSBAR "dwmblocks"
+
 /* button definitions */
 /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin, or ClkRootWin */
 static const Button buttons[] = {
     /* click                event mask      button          function        argument */
 #ifndef __OpenBSD__
-    { ClkStatusText,        0,              Button1,        sigdwmblocks,   {.i = 1} },
-    { ClkStatusText,        0,              Button2,        sigdwmblocks,   {.i = 2} },
-    { ClkStatusText,        0,              Button3,        sigdwmblocks,   {.i = 3} },
-    { ClkStatusText,        0,              Button4,        sigdwmblocks,   {.i = 4} },
-    { ClkStatusText,        0,              Button5,        sigdwmblocks,   {.i = 5} },
-    { ClkStatusText,        ShiftMask,      Button1,        sigdwmblocks,   {.i = 6} },
+    { ClkStatusText,        0,              Button1,        sigstatusbar,   {.i = 1} },
+    { ClkStatusText,        0,              Button2,        sigstatusbar,   {.i = 2} },
+    { ClkStatusText,        0,              Button3,        sigstatusbar,   {.i = 3} },
+    { ClkStatusText,        0,              Button4,        sigstatusbar,   {.i = 4} },
+    { ClkStatusText,        0,              Button5,        sigstatusbar,   {.i = 5} },
+    { ClkStatusText,        ShiftMask,      Button1,        sigstatusbar,   {.i = 6} },
 #endif
     { ClkStatusText,        ShiftMask,      Button3,        spawn,          SHCMD(TERMINAL " -e nvim ~/.config/dwmblocks/config.h") },
     { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
diff --git a/config.mk b/config.mk
index 1fc4bf1..a933c0b 100644
--- a/config.mk
+++ b/config.mk
@@ -19,10 +19,12 @@ FREETYPELIBS = -lfontconfig -lXft
 FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
 #FREETYPEINC = ${X11INC}/freetype2
+#MANPREFIX = ${PREFIX}/man
+#KVMLIB = -lkvm
 
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
 
 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
diff --git a/drw.c b/drw.c
index d43d8c2..6be5dee 100644
--- a/drw.c
+++ b/drw.c
@@ -13,7 +13,6 @@
 static int
 utf8decode(const char *s_in, long *u, int *err)
 {
-
 	static const unsigned char lens[] = {
 		/* 0XXXX */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 		/* 10XXX */ 0, 0, 0, 0, 0, 0, 0, 0,  /* invalid */
@@ -27,7 +26,6 @@ utf8decode(const char *s_in, long *u, int *err)
 
 	const unsigned char *s = (const unsigned char *)s_in;
 	int len = lens[*s >> 3];
-
 	*u = UTF_INVALID;
 	*err = 1;
 	if (len == 0)
@@ -83,6 +81,7 @@ drw_free(Drw *drw)
 {
 	XFreePixmap(drw->dpy, drw->drawable);
 	XFreeGC(drw->dpy, drw->gc);
+	drw_fontset_free(drw->fonts);
 	free(drw);
 }
 
@@ -177,8 +176,6 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 	                       DefaultColormap(drw->dpy, drw->screen),
 	                       clrname, dest))
 		die("error, cannot allocate color '%s'", clrname);
-
-    dest->pixel |= 0xff << 24;
 }
 
 /* Wrapper to create color schemes. The caller has to call free(3) on the
@@ -266,7 +263,6 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 	if (!invalid_width && render)
 		invalid_width = drw_fontset_getwidth(drw, invalid);
 	while (1) {
-        utf8strlen = 0;
 		ew = ellipsis_len = utf8err = utf8charlen = utf8strlen = 0;
 		utf8str = text;
 		nextfont = NULL;
@@ -357,7 +353,6 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
 			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
 			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
-            FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
 
 			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
 			FcDefaultSubstitute(fcpattern);
diff --git a/dwm.1 b/dwm.1
index 7feba78..d04bec6 100644
--- a/dwm.1
+++ b/dwm.1
@@ -1,16 +1,21 @@
 .TH DWM 1 dwm\-VERSION
 .SH NAME
-dwm \- dynamic window manager (Luke Smith <https://lukesmith.xyz>'s build)
+dwm \- dynamic window manager
 .SH SYNOPSIS
 .B dwm
 .RB [ \-v ]
 .SH DESCRIPTION
-dwm is a dynamic window manager for X.
+dwm is a dynamic window manager for X. It manages windows in tiled, monocle
+and floating layouts. Either layout can be applied dynamically, optimising the
+environment for the application in use and the task performed.
 .P
-dwm "orders" windows based on recency and primacy, while dwm layouts may
-change, the most recent "master" window is shown in the most prominent
-position. There are bindings for cycling through and promoting windows to the
-master position.
+In tiled layouts windows are managed in a master and stacking area. The master
+area on the left contains one window by default, and the stacking area on the
+right contains all other windows. The number of master area windows can be
+adjusted from zero to an arbitrary number. In monocle layout all windows are
+maximised to the screen size. In floating layout windows can be resized and
+moved freely. Dialog windows are always managed floating, regardless of the
+layout applied.
 .P
 Windows are grouped by tags. Each window can be tagged with one or multiple
 tags. Selecting certain tags displays all windows with these tags.
@@ -26,18 +31,17 @@ indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
 .P
-.I
-libxft-bgra
-should be installed for this build of dwm. Arch users may install it via the
-AUR. Color characters and emoji are enabled, but these will cause crashes
-without the fix
-.I
-libxft-bgra
-offers.
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
-prints version information to standard output, then exits.
+prints version information to stderr, then exits.
 .SH USAGE
 .SS Status bar
 .TP
@@ -46,142 +50,118 @@ is read and displayed in the status text area. It can be set with the
 .BR xsetroot (1)
 command.
 .TP
-.B Left click
+.B Button1
 click on a tag label to display all windows with that tag, click on the layout
 label toggles between tiled and floating layout.
 .TP
-.B Right click
+.B Button3
 click on a tag label adds/removes all windows with that tag to/from the view.
 .TP
-.B Super\-Left click
+.B Mod1\-Button1
 click on a tag label applies that tag to the focused window.
 .TP
-.B Super\-Right click
+.B Mod1\-Button3
 click on a tag label adds/removes that tag to/from the focused window.
 .SS Keyboard commands
 .TP
-.B Super\-Return
-Start terminal,
+.B Mod1\-Shift\-Return
+Start
 .BR st(1).
 .TP
-.B Super\-d
+.B Mod1\-p
 Spawn
 .BR dmenu(1)
 for launching other programs.
 .TP
-.B Super\-b
-Toggles bar on and off.
+.B Mod1\-,
+Focus previous screen, if any.
 .TP
-.B Super\-q
-Close focused window.
+.B Mod1\-.
+Focus next screen, if any.
 .TP
-.B Super\-t/T
-Sets tiled/bstack layouts.
+.B Mod1\-Shift\-,
+Send focused window to previous screen, if any.
 .TP
-.B Super\-f
-Toggle fullscreen window.
+.B Mod1\-Shift\-.
+Send focused window to next screen, if any.
 .TP
-.B Super\-F
-Toggle floating layout.
+.B Mod1\-b
+Toggles bar on and off.
+.TP
+.B Mod1\-t
+Sets tiled layout.
 .TP
-.B Super\-y/Y
-Sets Fibonacci spiral/dwinde layouts.
+.B Mod1\-f
+Sets floating layout.
 .TP
-.B Super\-u/U
-Sets centered master layout.
+.B Mod1\-m
+Sets monocle layout.
 .TP
-.B Super\-i/I
-Sets centered master or floating master layouts.
+.B Mod1\-space
+Toggles between current and previous layout.
 .TP
-.B Super\-space
-Zooms/cycles focused window to/from master area.
+.B Mod1\-j
+Focus next window.
 .TP
-.B Super\-j/k
-Focus next/previous window.
+.B Mod1\-k
+Focus previous window.
 .TP
-.B Super\-Shift\-j/k
-Move selected window down/up in stack.
+.B Mod1\-i
+Increase number of windows in master area.
 .TP
-.B Super\-o/O
-Increase/decrease number of windows in master area.
+.B Mod1\-d
+Decrease number of windows in master area.
 .TP
-.B Super\-l
+.B Mod1\-l
 Increase master area size.
 .TP
-.B Super\-h
+.B Mod1\-h
 Decrease master area size.
 .TP
-.B Super\-Shift\-space
-Toggle focused window between tiled and floating state.
-.TP
-.B Super\-Tab
-Toggles to the previously selected tags.
-.TP
-.B Super\-g
-Moves to the previous tag.
-.TP
-.B Super\-Shift\-g
-Moves selected window to the previous tag.
-.TP
-.B Super\-;
-Moves to the next tag.
+.B Mod1\-Return
+Zooms/cycles focused window to/from master area (tiled layouts only).
 .TP
-.B Super\-Shift\-;
-Moves selected window to the next tag.
-.TP
-.B Super\-PageUp
-Moves to the previous tag.
-.TP
-.B Super\-Shift\-PageUp
-Moves selected window to the previous tag.
-.TP
-.B Super\-Pagedown
-Moves to the next tag.
-.TP
-.B Super\-Shift\-PageDown
-Moves selected window to the next tag.
+.B Mod1\-Shift\-c
+Close focused window.
 .TP
-.B Super\-a
-Toggle gaps.
+.B Mod1\-Shift\-f
+Toggle fullscreen for focused window.
 .TP
-.B Super\-z
-Increase gaps between windows.
+.B Mod1\-Shift\-space
+Toggle focused window between tiled and floating state.
 .TP
-.B Super\-x
-Decrease gaps between windows.
+.B Mod1\-Tab
+Toggles to the previously selected tags.
 .TP
-.B Super\-Shift\-[1..n]
+.B Mod1\-Shift\-[1..n]
 Apply nth tag to focused window.
 .TP
-.B Super\-Shift\-0
+.B Mod1\-Shift\-0
 Apply all tags to focused window.
 .TP
-.B Super\-Control\-Shift\-[1..n]
+.B Mod1\-Control\-Shift\-[1..n]
 Add/remove nth tag to/from focused window.
 .TP
-.B Super\-[1..n]
+.B Mod1\-[1..n]
 View all windows with nth tag.
 .TP
-.B Super\-0
+.B Mod1\-0
 View all windows with any tag.
 .TP
-.B Super\-Control\-[1..n]
+.B Mod1\-Control\-[1..n]
 Add/remove all windows with nth tag to/from the view.
 .TP
-.B Super\-Shift\-q
+.B Mod1\-Shift\-q
 Quit dwm.
-.TP
-.B Mod1\-Control\-Shift\-q
-Menu to refresh/quit/reboot/shutdown.
 .SS Mouse commands
 .TP
-.B Super\-Left click
+.B Mod1\-Button1
 Move focused window while dragging. Tiled windows will be toggled to the floating state.
 .TP
-.B Super\-Middle click
+.B Mod1\-Button2
 Toggles focused window between floating and tiled state.
 .TP
-.B Super\-Right click
+.B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
 .SH FILES
 The files containing programs to be started along with dwm are searched for in
@@ -201,13 +181,6 @@ This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
-.SH SIGNALS
-.TP
-.B SIGHUP - 1
-Restart the dwm process.
-.TP
-.B SIGTERM - 15
-Cleanly terminate the dwm process.
 .SH SEE ALSO
 .BR dmenu (1),
 .BR st (1)
diff --git a/dwm.c b/dwm.c
index 9086e16..6232799 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -43,6 +44,10 @@
 #include <X11/Xft/Xft.h>
 #include <X11/Xlib-xcb.h>
 #include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
 
 #include "drw.h"
 #include "util.h"
@@ -57,8 +62,8 @@
 #define ISINC(X)                ((X) > 1000 && (X) < 3000)
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]) || C->issticky)
 #define PREVSEL                 3000
-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define MOD(N,M)                ((N)%(M) < 0 ? (N)%(M) + (M) : (N)%(M))
+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
@@ -72,11 +77,11 @@
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
 enum { SchemeNorm, SchemeSel }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-    NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+       NetWMFullscreen, NetWMSticky, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
-    ClkRootWin, ClkLast, ClkWinTitle }; /* clicks */
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
 	int i;
@@ -98,13 +103,14 @@ typedef struct Client Client;
 struct Client {
 	char name[256];
 	float mina, maxa;
+	float cfact;
 	int x, y, w, h;
 	int sfx, sfy, sfw, sfh; /* stored float geometry, used on mode revert */
 	int oldx, oldy, oldw, oldh;
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
 	int bw, oldbw;
 	unsigned int tags;
-    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow, issticky;
+    int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, issticky, isterminal, noswallow;
     pid_t pid;
 	Client *next;
 	Client *snext;
@@ -189,7 +195,6 @@ static void clientmessage(XEvent *e);
 static void configure(Client *c);
 static void configurenotify(XEvent *e);
 static void configurerequest(XEvent *e);
-static void copyvalidchars(char *text, char *rawtext);
 static Monitor *createmon(void);
 static void destroynotify(XEvent *e);
 static void detach(Client *c);
@@ -206,6 +211,7 @@ static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
 static long getstate(Window w);
+static pid_t getstatusbarpid();
 static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
@@ -216,7 +222,6 @@ static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
 static void monocle(Monitor *m);
-static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *c);
@@ -229,7 +234,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
-static void runAutostart(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
@@ -237,17 +242,16 @@ static void sendmonview(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
+static void setsticky(Client *c, int sticky);
 static void setlayout(const Arg *arg);
+static void setcfact(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shiftview(const Arg *arg);
+static void shifttag(const Arg *arg);
 static void showhide(Client *c);
-#ifndef __OpenBSD__
-static int getdwmblockspid();
-static void sigdwmblocks(const Arg *arg);
-#endif
-static void sighup(int unused);
-static void sigterm(int unused);
+static void sigstatusbar(const Arg *arg);
 static void spawn(const Arg *arg);
 static int stackpos(const Arg *arg);
 static void tag(const Arg *arg);
@@ -291,12 +295,15 @@ static Client *termforwin(const Client *c);
 static pid_t winpid(Window w);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
-static char stext[256];
-/* static char stext[1024]; */
-static char rawstext[256];
-static int dwmblockssig;
-pid_t dwmblockspid = 0;
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
+static int statussig;
+static int statusw;
+static pid_t statuspid = -1;
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
@@ -314,12 +321,10 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[KeyPress] = keypress,
 	[MappingNotify] = mappingnotify,
 	[MapRequest] = maprequest,
-    [MotionNotify] = motionnotify,
 	[PropertyNotify] = propertynotify,
 	[UnmapNotify] = unmapnotify
 };
 static Atom wmatom[WMLast], netatom[NetLast];
-static int restart = 0;
 static int running = 1;
 static Cur *cursor[CurLast];
 static Clr **scheme;
@@ -360,12 +365,12 @@ applyrules(Client *c)
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
 			c->isterminal = r->isterminal;
-            c->isfloating = r->isfloating;
 			c->noswallow  = r->noswallow;
+			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
 			if ((r->tags & SPTAGMASK) && r->isfloating) {
-                c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-                c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
 			}
 
 			for (m = mons; m && m->num != r->monitor; m = m->next);
@@ -487,9 +492,10 @@ attachstack(Client *c)
 void
 swallow(Client *p, Client *c)
 {
+
 	if (c->noswallow || c->isterminal)
 		return;
-    if (!swallowfloating && c->isfloating)
+	if (c->noswallow && !swallowfloating && c->isfloating)
 		return;
 
 	detach(c);
@@ -505,13 +511,7 @@ swallow(Client *p, Client *c)
 	p->win = c->win;
 	c->win = w;
 	updatetitle(p);
-
-    XWindowChanges wc;
-    wc.border_width = p->bw;
-    XConfigureWindow(dpy, p->win, CWBorderWidth, &wc);
 	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
-    XSetWindowBorder(dpy, p->win, scheme[SchemeNorm][ColBorder].pixel);
-
 	arrange(p->mon);
 	configure(p);
 	updateclientlist();
@@ -530,13 +530,7 @@ unswallow(Client *c)
 	updatetitle(c);
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
-
-    XWindowChanges wc;
-    wc.border_width = c->bw;
-    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc);
 	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-    XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-
 	setclientstate(c, NormalState);
 	focus(NULL);
 	arrange(c->mon);
@@ -545,7 +539,7 @@ unswallow(Client *c)
 void
 buttonpress(XEvent *e)
 {
-    unsigned int i, x, click, occ = 0;
+	unsigned int i, x, click;
 	Arg arg = {0};
 	Client *c;
 	Monitor *m;
@@ -553,17 +547,19 @@ buttonpress(XEvent *e)
 
 	click = ClkRootWin;
 	/* focus monitor if necessary */
-    if ((m = wintomon(ev->window)) && m != selmon) {
+	if ((m = wintomon(ev->window)) && m != selmon
+	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
 		unfocus(selmon->sel, 1);
 		selmon = m;
 		focus(NULL);
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
+		unsigned int occ = 0;
 		for(c = m->clients; c; c=c->next)
-            occ |= c->tags == 255 ? 0 : c->tags;
+			occ |= c->tags == TAGMASK ? 0 : c->tags;
 		do {
-            /* do not reserve space for vacant tags */
+			/* Do not reserve space for vacant tags */
 			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
 				continue;
 			x += TEXTW(tags[i]);
@@ -573,30 +569,36 @@ buttonpress(XEvent *e)
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-        else if (ev->x > (x = selmon->ww - TEXTW(stext) + lrpad)) {
+        } else if (ev->x > selmon->ww - statusw) {
+            x = selmon->ww - statusw;
             click = ClkStatusText;
 
-            char *text = rawstext;
-            int i = -1;
-            char ch;
-            dwmblockssig = 0;
-            while (text[++i]) {
-                if ((unsigned char)text[i] < ' ') {
-                    ch = text[i];
-                    text[i] = '\0';
+			char *text, *s, ch;
+			statussig = 0;
+			for (text = s = stext; *s && x <= ev->x; s++) {
+				if ((unsigned char)(*s) < ' ') {
+					ch = *s;
+					*s = '\0';
 					x += TEXTW(text) - lrpad;
-                    text[i] = ch;
-                    text += i+1;
-                    i = -1;
-                    if (x >= ev->x) break;
-                    dwmblockssig = ch;
+					*s = ch;
+					text = s + 1;
+					if (x >= ev->x)
+						break;
+					statussig = ch;
+				} else if (*s == '^') {
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = '^';
+					if (*(++s) == 'f')
+						x += atoi(++s);
+					while (*(s++) != '^');
+					text = s;
+					s--;
 				}
 			}
-        } else
-            click = ClkWinTitle;
 	} else if ((c = wintoclient(ev->window))) {
+		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
 			focus(c);
-        restack(selmon);
 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
 		click = ClkClientWin;
 	}
@@ -635,7 +637,6 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-    /* for (i = 0; i < LENGTH(colors); i++) */
 	for (i = 0; i < LENGTH(colors) + 1; i++)
 		free(scheme[i]);
 	free(scheme);
@@ -675,6 +676,10 @@ clientmessage(XEvent *e)
 		|| cme->data.l[2] == netatom[NetWMFullscreen])
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+
+        if (cme->data.l[1] == netatom[NetWMSticky]
+                || cme->data.l[2] == netatom[NetWMSticky])
+            setsticky(c, (cme->data.l[0] == 1 || (cme->data.l[0] == 2 && !c->issticky)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -780,19 +785,6 @@ configurerequest(XEvent *e)
 	XSync(dpy, False);
 }
 
-void
-copyvalidchars(char *text, char *rawtext)
-{
-    int i = -1, j = 0;
-
-    while(rawtext[++i]) {
-        if ((unsigned char)rawtext[i] >= ' ') {
-            text[j++] = rawtext[i];
-        }
-    }
-    text[j] = '\0';
-}
-
 Monitor *
 createmon(void)
 {
@@ -936,7 +928,7 @@ drawstatusbar(Monitor *m, int bh, char* stext)
                     if (ptr == NULL) printf("Fail to read wr...");
                     do{
                         ch = fgetc(ptr);
-                        // Check if contains + and 2 (= hot)
+                        // Check if temp is above +20 (= hot)
                         if (hotbool){
                             if ((ch == '2' || ch == '3') && fgetc(ptr) <= '9'){
                                 drw_clr_create(drw, &drw->scheme[ColFg], col21);
@@ -990,30 +982,31 @@ drawstatusbar(Monitor *m, int bh, char* stext)
 void
 drawbar(Monitor *m)
 {
-    if (!m->showbar) return;
 	int x, w, tw = 0;
 	int boxs = drw->fonts->h / 9;
 	int boxw = drw->fonts->h / 6 + 2;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
+	if (!m->showbar)
+		return;
+
 	/* draw status first so it can be overdrawn by tags later */
-    /* if (m == selmon) { /1* status is only drawn on selected monitor *1/ */
+	//if (m == selmon) { /* status is only drawn on selected monitor */
     if (m == selmon || 1) { 
-        tw = m->ww - drawstatusbar(m, bh, stext);
+		tw = statusw = m->ww - drawstatusbar(m, bh, stext);
 	}
 
 	for (c = m->clients; c; c = c->next) {
-        occ |= c->tags == 255 ? 0 : c->tags;
+		occ |= c->tags == TAGMASK ? 0 : c->tags;
 		if (c->isurgent)
 			urg |= c->tags;
 	}
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
-        /* do not draw vacant tags */
+		/* Do not draw vacant tags */
 		if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
 			continue;
-
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
@@ -1094,7 +1087,6 @@ focusmon(const Arg *arg)
 	if ((m = dirtomon(arg->i)) == selmon)
 		return;
 	unfocus(selmon->sel, 0);
-    XWarpPointer(dpy, None, m->barwin, 0, 0, 0, 0, m->mw / 2, m->mh / 2);
 	selmon = m;
 	focus(NULL);
 }
@@ -1105,7 +1097,7 @@ focusstack(const Arg *arg)
 	int i = stackpos(arg);
 	Client *c, *p;
 
-    if (i < 0 || !selmon->sel || selmon->sel->isfullscreen)
+	if(i < 0)
 		return;
 
 	for(p = NULL, c = selmon->clients; c && (i || !ISVISIBLE(c));
@@ -1130,18 +1122,29 @@ getatomprop(Client *c, Atom prop)
 	return atom;
 }
 
-#ifndef __OpenBSD__
-int getdwmblockspid()
+pid_t
+getstatusbarpid()
 {
-    char buf[16];
-    FILE *fp = popen("pidof -s dwmblocks", "r");
+	char buf[32], *str = buf, *c;
+	FILE *fp;
+
+	if (statuspid > 0) {
+		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+		if ((fp = fopen(buf, "r"))) {
+			fgets(buf, sizeof(buf), fp);
+			while ((c = strchr(str, '/')))
+				str = c + 1;
+			fclose(fp);
+			if (!strcmp(str, STATUSBAR))
+				return statuspid;
+		}
+	}
+	if (!(fp = popen("pidof -s "STATUSBAR, "r")))
+		return -1;
 	fgets(buf, sizeof(buf), fp);
-    pid_t pid = strtoul(buf, NULL, 10);
 	pclose(fp);
-    dwmblockspid = pid;
-    return pid != 0 ? 0 : -1;
+	return strtoul(buf, NULL, 10);
 }
-#endif
 
 int
 getrootptr(int *x, int *y)
@@ -1183,14 +1186,12 @@ gettextprop(Window w, Atom atom, char *text, unsigned int size)
 	text[0] = '\0';
 	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
 		return 0;
-    if (name.encoding == XA_STRING)
+	if (name.encoding == XA_STRING) {
 		strncpy(text, (char *)name.value, size - 1);
-    else {
-        if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
 		strncpy(text, *list, size - 1);
 		XFreeStringList(list);
 	}
-    }
 	text[size - 1] = '\0';
 	XFree(name.value);
 	return 1;
@@ -1253,7 +1254,8 @@ incnmaster(const Arg *arg)
 }
 
 #ifdef XINERAMA
-static int isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+static int
+isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
 {
 	while (n--)
 		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
@@ -1311,6 +1313,7 @@ manage(Window w, XWindowAttributes *wa)
 	c->w = c->oldw = wa->width;
 	c->h = c->oldh = wa->height;
 	c->oldbw = wa->border_width;
+	c->cfact = 1.0;
 
 	updatetitle(c);
 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
@@ -1329,35 +1332,24 @@ manage(Window w, XWindowAttributes *wa)
 	c->x = MAX(c->x, c->mon->wx);
 	c->y = MAX(c->y, c->mon->wy);
 	c->bw = borderpx;
-    /* if (c->isfloating) c->bw = 0; */
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
 	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
+	updatesizehints(c);
 	updatewmhints(c);
-    c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
-    c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
-    // These 4 lines are for save floats patch: https://dwm.suckless.org/patches/save_floats/dwm-savefloats-20181212-b69c870.diff
 	c->sfx = c->x;
 	c->sfy = c->y;
 	c->sfw = c->w;
 	c->sfh = c->h;
-
 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
 	grabbuttons(c, 0);
 	if (!c->isfloating)
-        c->isfloating = c->oldstate = t || c->isfixed;
-    if (c->isfloating) {
+		c->isfloating = c->oldstate = trans != None || c->isfixed;
+	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
-        if (strcmp(c->name, "YAD") == 0) {
-            c->x = 1488;
-            c->y = 42;
-            c->w = 405;
-            c->h = 280;
-        }
-    }
 	attach(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
@@ -1367,10 +1359,10 @@ manage(Window w, XWindowAttributes *wa)
 	if (c->mon == selmon)
 		unfocus(selmon->sel, 0);
 	c->mon->sel = c;
+	arrange(c->mon);
 	XMapWindow(dpy, c->win);
 	if (term)
 		swallow(term, c);
-    arrange(c->mon);
 	focus(NULL);
 }
 
@@ -1390,9 +1382,7 @@ maprequest(XEvent *e)
 	static XWindowAttributes wa;
 	XMapRequestEvent *ev = &e->xmaprequest;
 
-    if (!XGetWindowAttributes(dpy, ev->window, &wa))
-        return;
-    if (wa.override_redirect)
+	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
 		return;
 	if (!wintoclient(ev->window))
 		manage(ev->window, &wa);
@@ -1401,33 +1391,16 @@ maprequest(XEvent *e)
 void
 monocle(Monitor *m)
 {
-    unsigned int n;
-    int oh, ov, ih, iv;
+	unsigned int n = 0;
 	Client *c;
 
-    getgaps(m, &oh, &ov, &ih, &iv, &n);
-
+	for (c = m->clients; c; c = c->next)
+		if (ISVISIBLE(c))
+			n++;
 	if (n > 0) /* override layout symbol */
 		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
 	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-        resize(c, m->wx + ov, m->wy + oh, m->ww - 2 * c->bw - 2 * ov, m->wh - 2 * c->bw - 2 * oh, 0);
-}
-
-void
-motionnotify(XEvent *e)
-{
-    static Monitor *mon = NULL;
-    Monitor *m;
-    XMotionEvent *ev = &e->xmotion;
-
-    if (ev->window != root)
-        return;
-    if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
-        unfocus(selmon->sel, 1);
-        selmon = m;
-        focus(NULL);
-    }
-    mon = m;
+		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
 }
 
 void
@@ -1460,9 +1433,7 @@ movemouse(const Arg *arg)
 			handler[ev.type](&ev);
 			break;
 		case MotionNotify:
-                // Increase display rate when dragging  and resizing floats
-                /* if ((ev.xmotion.time - lasttime) <= (1000 / 60)) */
-                if ((ev.xmotion.time - lasttime) <= (1000 / 120))
+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
 				continue;
 			lasttime = ev.xmotion.time;
 
@@ -1508,30 +1479,6 @@ pop(Client *c)
 	arrange(c->mon);
 }
 
-void
-pushstack(const Arg *arg)
-{
-    int i = stackpos(arg);
-    Client *sel = selmon->sel, *c, *p;
-
-    if(i < 0 || !sel)
-        return;
-    else if(i == 0) {
-        detach(sel);
-        attach(sel);
-    }
-    else {
-        for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
-            if(!(i -= (ISVISIBLE(c) && c != sel)))
-                break;
-        c = c ? c : p;
-        detach(sel);
-        sel->next = c->next;
-        c->next = sel;
-    }
-    arrange(selmon);
-}
-
 void
 propertynotify(XEvent *e)
 {
@@ -1539,11 +1486,11 @@ propertynotify(XEvent *e)
 	Window trans;
 	XPropertyEvent *ev = &e->xproperty;
 
-    if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
+	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
 		updatestatus();
-    } else if (ev->state == PropertyDelete) {
+	else if (ev->state == PropertyDelete)
 		return; /* ignore */
-    } else if ((c = wintoclient(ev->window))) {
+	else if ((c = wintoclient(ev->window))) {
 		switch(ev->atom) {
 		default: break;
 		case XA_WM_TRANSIENT_FOR:
@@ -1559,21 +1506,39 @@ propertynotify(XEvent *e)
 			drawbars();
 			break;
 		}
-        if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]){
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
 			updatetitle(c);
-            if (c == c->mon->sel)
-                drawbar(c->mon);
-        }
-
 		if (ev->atom == netatom[NetWMWindowType])
 			updatewindowtype(c);
 	}
 }
 
+void
+pushstack(const Arg *arg) {
+	int i = stackpos(arg);
+	Client *sel = selmon->sel, *c, *p;
+
+	if(i < 0)
+		return;
+	else if(i == 0) {
+		detach(sel);
+		attach(sel);
+	}
+	else {
+		for(p = NULL, c = selmon->clients; c; p = c, c = c->next)
+			if(!(i -= (ISVISIBLE(c) && c != sel)))
+				break;
+		c = c ? c : p;
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	arrange(selmon);
+}
+
 void
 quit(const Arg *arg)
 {
-    if(arg->i) restart = 1;
 	running = 0;
 }
 
@@ -1608,16 +1573,13 @@ resizeclient(Client *c, int x, int y, int w, int h)
 	c->oldw = c->w; c->w = wc.width = w;
 	c->oldh = c->h; c->h = wc.height = h;
 	wc.border_width = c->bw;
-    // Don't show border if floating or if only 1 client
 	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
 	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
-            && !c->isfullscreen) {
-        /* && !c->isfullscreen && !c->isfloating) { */
+	    && !c->isfullscreen && !c->isfloating) {
 		c->w = wc.width += c->bw * 2;
 		c->h = wc.height += c->bw * 2;
 		wc.border_width = 0;
 	}
-
 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
 	configure(c);
 	XSync(dpy, False);
@@ -1716,8 +1678,85 @@ run(void)
 			handler[ev.type](&ev); /* call handler */
 }
 
-void
-runAutostart(void)
+//void
+//runautostart(void)
+//{
+//	char *pathpfx;
+//	char *path;
+//	char *xdgdatahome;
+//	char *home;
+//	struct stat sb;
+//
+//	if ((home = getenv("HOME")) == NULL)
+//		/* this is almost impossible */
+//		return;
+//
+//	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+//	 * otherwise use ~/.local/share/dwm as autostart script directory
+//	 */
+//	xdgdatahome = getenv("XDG_DATA_HOME");
+//	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+//
+//		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	} else {
+//		/* space for path segments, separators and nul */
+//		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+//		                     + strlen(dwmdir) + 3);
+//
+//		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* check if the autostart script directory exists */
+//	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+//		/* the XDG conformant path does not exist or is no directory
+//		 * so we try ~/.dwm instead
+//		 */
+//		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+//		if(pathpfx_new == NULL) {
+//			free(pathpfx);
+//			return;
+//		}
+//		pathpfx = pathpfx_new;
+//
+//		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+//			free(pathpfx);
+//			return;
+//		}
+//	}
+//
+//	/* try the blocking script first */
+//	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+//	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(path);
+//
+//	/* now the non-blocking script */
+//	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+//		free(path);
+//		free(pathpfx);
+//	}
+//
+//	if (access(path, X_OK) == 0)
+//		system(strcat(path, " &"));
+//
+//	free(pathpfx);
+//	free(path);
+//}
+
+void
+runautostart(void)
 {
     system("killall -q dwmblocks; dwmblocks &");
 }
@@ -1858,37 +1897,23 @@ setfullscreen(Client *c, int fullscreen)
 	}
 }
 
-int
-stackpos(const Arg *arg)
+void
+	 setsticky(Client *c, int sticky)
 	 {
-    int n, i;
-    Client *c, *l;
 
-    if(!selmon->clients)
-        return -1;
-
-    if(arg->i == PREVSEL) {
-        for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
-        if(!l)
-            return -1;
-        for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return i;
-    }
-    else if(ISINC(arg->i)) {
-        if(!selmon->sel)
-            return -1;
-        for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return MOD(i + GETINC(arg->i), n);
-    }
-    else if(arg->i < 0) {
-        for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
-        return MAX(i + arg->i, 0);
+		 if(sticky && !c->issticky) {
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *) &netatom[NetWMSticky], 1);
+			 c->issticky = 1;
+		 } else if(!sticky && c->issticky){
+			 XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+					 PropModeReplace, (unsigned char *)0, 0);
+			 c->issticky = 0;
+			 arrange(c->mon);
 		 }
-    else
-        return arg->i;
 	 }
 
+
 void
 setlayout(const Arg *arg)
 {
@@ -1903,6 +1928,58 @@ setlayout(const Arg *arg)
 		drawbar(selmon);
 }
 
+void
+shiftview(const Arg *arg) {
+	Arg shifted;
+
+	if(arg->i > 0) /* left circular shift */
+		shifted.ui = (selmon->tagset[selmon->seltags] << arg->i)
+		   | (selmon->tagset[selmon->seltags] >> (LENGTH(tags) - arg->i));
+
+	else /* right circular shift */
+		shifted.ui = selmon->tagset[selmon->seltags] >> (- arg->i)
+		   | selmon->tagset[selmon->seltags] << (LENGTH(tags) + arg->i);
+
+	view(&shifted);
+}
+
+void
+shifttag(const Arg *arg) {
+	Arg shifted;
+	Client *c;
+
+	if (!selmon->sel)
+		return;
+	c = selmon->sel;
+
+	if (arg->i > 0) /* left circular shift */
+		shifted.ui = (c->tags ^ (c->tags << arg->i)) 
+			^ (c->tags >> (LENGTH(tags) - arg->i));
+	else /* right circular shift */
+		shifted.ui = (c->tags ^ (c->tags >> (-arg->i)))
+			^ (c->tags << (LENGTH(tags) + arg->i));
+
+	toggletag(&shifted);
+}
+
+void
+setcfact(const Arg *arg) {
+	float f;
+	Client *c;
+
+	c = selmon->sel;
+
+	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f + c->cfact;
+	if(arg->f == 0.0)
+		f = 1.0;
+	else if(f < 0.25 || f > 4.0)
+		return;
+	c->cfact = f;
+	arrange(selmon);
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -1935,9 +2012,6 @@ setup(void)
 	/* clean up any zombies (inherited from .xinitrc etc) immediately */
 	while (waitpid(-1, NULL, WNOHANG) > 0);
 
-    signal(SIGHUP, sighup);
-    signal(SIGTERM, sigterm);
-
 	/* init screen */
 	screen = DefaultScreen(dpy);
 	sw = DisplayWidth(dpy, screen);
@@ -1961,6 +2035,7 @@ setup(void)
 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	netatom[NetWMSticky] = XInternAtom(dpy, "_NET_WM_STATE_STICKY", False);
 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
@@ -1969,10 +2044,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-    /* scheme = ecalloc(LENGTH(colors), sizeof(Clr *)); */
 	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
 	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
@@ -2021,8 +2094,8 @@ showhide(Client *c)
 		return;
 	if (ISVISIBLE(c)) {
 		if ((c->tags & SPTAGMASK) && c->isfloating) {
-            c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2) + 730;
-            c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2) + 365;
+			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
 		}
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
@@ -2037,41 +2110,26 @@ showhide(Client *c)
 }
 
 void
-sighup(int unused)
-{
-    Arg a = {.i = 1};
-    quit(&a);
-}
-
-void
-sigterm(int unused)
-{
-    Arg a = {.i = 0};
-    quit(&a);
-}
-
-#ifndef __OpenBSD__
-void sigdwmblocks(const Arg *arg)
+sigstatusbar(const Arg *arg)
 {
 	union sigval sv;
-    sv.sival_int = 0 | (dwmblockssig << 8) | arg->i;
-    if (!dwmblockspid)
-        if (getdwmblockspid() == -1)
+
+	if (!statussig)
+		return;
+	sv.sival_int = arg->i;
+	if ((statuspid = getstatusbarpid()) <= 0)
 		return;
 
-    if (sigqueue(dwmblockspid, SIGUSR1, sv) == -1) {
-        if (errno == ESRCH) {
-            if (!getdwmblockspid())
-                sigqueue(dwmblockspid, SIGUSR1, sv);
+	sigqueue(statuspid, SIGRTMIN+statussig, sv);
 }
-    }
-}
-#endif
 
 void
 spawn(const Arg *arg)
 {
 	struct sigaction sa;
+
+	if (arg->v == dmenucmd)
+		dmenumon[0] = '0' + selmon->num;
 	if (fork() == 0) {
 		if (dpy)
 			close(ConnectionNumber(dpy));
@@ -2087,6 +2145,36 @@ spawn(const Arg *arg)
 	}
 }
 
+int
+stackpos(const Arg *arg) {
+	int n, i;
+	Client *c, *l;
+
+	if(!selmon->clients)
+		return -1;
+
+	if(arg->i == PREVSEL) {
+		for(l = selmon->stack; l && (!ISVISIBLE(l) || l == selmon->sel); l = l->snext);
+		if(!l)
+			return -1;
+		for(i = 0, c = selmon->clients; c != l; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return i;
+	}
+	else if(ISINC(arg->i)) {
+		if(!selmon->sel)
+			return -1;
+		for(i = 0, c = selmon->clients; c != selmon->sel; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		for(n = i; c; n += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MOD(i + GETINC(arg->i), n);
+	}
+	else if(arg->i < 0) {
+		for(i = 0, c = selmon->clients; c; i += ISVISIBLE(c) ? 1 : 0, c = c->next);
+		return MAX(i + arg->i, 0);
+	}
+	else
+		return arg->i;
+}
+
 void
 tag(const Arg *arg)
 {
@@ -2141,13 +2229,11 @@ togglefloating(const Arg *arg)
 	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
 		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-    if (selmon->sel->isfloating) {
-        /* selmon->sel->bw = 0; */
-        /* configure(selmon->sel); */
+	if (selmon->sel->isfloating)
 		/* restore last known float dimensions */
 		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
 		       selmon->sel->sfw, selmon->sel->sfh, False);
-    } else {
+	else {
 		/* save last known float dimensions */
 		selmon->sel->sfx = selmon->sel->x;
 		selmon->sel->sfy = selmon->sel->y;
@@ -2169,7 +2255,7 @@ togglesticky(const Arg *arg)
 {
 	if (!selmon->sel)
 		return;
-    selmon->sel->issticky = !selmon->sel->issticky;
+	setsticky(selmon->sel, !selmon->sel->issticky);
 	arrange(selmon);
 }
 
@@ -2366,8 +2452,9 @@ updategeom(void)
 				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
 		XFree(info);
 		nn = j;
-        if (n <= nn) { /* new monitors available */
-            for (i = 0; i < (nn - n); i++) {
+
+		/* new monitors if nn > n */
+		for (i = n; i < nn; i++) {
 			for (m = mons; m && m->next; m = m->next);
 			if (m)
 				m->next = createmon();
@@ -2387,7 +2474,7 @@ updategeom(void)
 				m->mh = m->wh = unique[i].height;
 				updatebarpos(m);
 			}
-        } else { /* less monitors available nn < n */
+		/* removed monitors if n > nn */
 		for (i = nn; i < n; i++) {
 			for (m = mons; m && m->next; m = m->next);
 			while ((c = m->clients)) {
@@ -2402,7 +2489,6 @@ updategeom(void)
 				selmon = mons;
 			cleanupmon(m);
 		}
-        }
 		free(unique);
 	} else
 #endif /* XINERAMA */
@@ -2486,14 +2572,9 @@ updatesizehints(Client *c)
 void
 updatestatus(void)
 {
-    Monitor* m;
-    if (!gettextprop(root, XA_WM_NAME, rawstext, sizeof(rawstext)))
+	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
 		strcpy(stext, "dwm-"VERSION);
-    else
-        copyvalidchars(stext, rawstext);
-    /* drawbar(selmon); */
-    for(m = mons; m; m = m->next)
-        drawbar(m);
+	drawbar(selmon);
 }
 
 void
@@ -2513,6 +2594,9 @@ updatewindowtype(Client *c)
 
 	if (state == netatom[NetWMFullscreen])
 		setfullscreen(c, 1);
+	if (state == netatom[NetWMSticky]) {
+		setsticky(c, 1);
+	}
 	if (wtype == netatom[NetWMWindowTypeDialog])
 		c->isfloating = 1;
 }
@@ -2554,8 +2638,10 @@ view(const Arg *arg)
 pid_t
 winpid(Window w)
 {
+
 	pid_t result = 0;
 
+#ifdef __linux__
 	xcb_res_client_id_spec_t spec = {0};
 	spec.client = w;
 	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
@@ -2581,6 +2667,24 @@ winpid(Window w)
 
 	if (result == (pid_t)-1)
 		result = 0;
+
+#endif /* __linux__ */
+
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
+
+#endif /* __OpenBSD__ */
 	return result;
 }
 
@@ -2589,25 +2693,31 @@ getparentprocess(pid_t p)
 {
 	unsigned int v = 0;
 
-#if defined(__linux__)
+#ifdef __linux__
 	FILE *f;
 	char buf[256];
 	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
 
 	if (!(f = fopen(buf, "r")))
-        return (pid_t)0;
+		return 0;
 
-    if (fscanf(f, "%*u %*s %*c %u", (unsigned *)&v) != 1)
-        v = (pid_t)0;
+	fscanf(f, "%*u %*s %*c %u", &v);
 	fclose(f);
-#elif defined(__FreeBSD__)
-    struct kinfo_proc *proc = kinfo_getproc(p);
-    if (!proc)
-        return (pid_t)0;
+#endif /* __linux__*/
+
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
+
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
 
-    v = proc->ki_ppid;
-    free(proc);
-#endif
 	return (pid_t)v;
 }
 
@@ -2726,11 +2836,9 @@ zoom(const Arg *arg)
 {
 	Client *c = selmon->sel;
 
-    if (!selmon->lt[selmon->sellt]->arrange
-            || (selmon->sel && selmon->sel->isfloating))
+	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
 		return;
-    if (c == nexttiled(selmon->clients))
-        if (!c || !(c = nexttiled(c->next)))
+	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
 		return;
 	pop(c);
 }
@@ -2807,17 +2915,15 @@ main(int argc, char *argv[])
 	load_xresources();
 	setup();
 #ifdef __OpenBSD__
-    if (pledge("stdio rpath proc exec", NULL) == -1)
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
-    runAutostart();
-    /* runautostart(); */
-    enablegaps = 1;
+	runautostart();
     arrange(selmon);
 	run();
-    if(restart) execvp(argv[0], argv);
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
diff --git a/dwm.png b/dwm.png
new file mode 100644
index 0000000..b1f9ba7
Binary files /dev/null and b/dwm.png differ
diff --git a/shiftview.c b/shiftview.c
deleted file mode 100644
index 7905a6d..0000000
--- a/shiftview.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/** Function to shift the current view to the left/right
- *
- * @param: "arg->i" stores the number of tags to shift right (positive value)
- *          or left (negative value)
- */
-void
-shiftview(const Arg *arg)
-{
-    Arg shifted;
-    Client *c;
-    unsigned int tagmask = 0;
-
-    for (c = selmon->clients; c; c = c->next)
-        if (!(c->tags & SPTAGMASK))
-            tagmask = tagmask | c->tags;
-
-    shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
-    if (arg->i > 0) /* left circular shift */
-        do {
-            shifted.ui = (shifted.ui << arg->i)
-                | (shifted.ui >> (LENGTH(tags) - arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-    else /* right circular shift */
-        do {
-            shifted.ui = (shifted.ui >> (- arg->i)
-                    | shifted.ui << (LENGTH(tags) + arg->i));
-            shifted.ui &= ~SPTAGMASK;
-        } while (tagmask && !(shifted.ui & tagmask));
-
-    view(&shifted);
-}
-
-void
-shifttag(const Arg *arg)
-{
-    Arg a;
-    Client *c;
-    unsigned visible = 0;
-    int i = arg->i;
-    int count = 0;
-    int nextseltags, curseltags = selmon->tagset[selmon->seltags];
-
-    do {
-        if(i > 0) // left circular shift
-            nextseltags = (curseltags << i) | (curseltags >> (LENGTH(tags) - i));
-
-        else // right circular shift
-            nextseltags = (curseltags >> - i) | (curseltags << (LENGTH(tags) + i));
-
-        // Check if tag is visible
-        for (c = selmon->clients; c && !visible; c = c->next)
-            if (nextseltags & c->tags) {
-                visible = 1;
-                break;
-            }
-        i += arg->i;
-    } while (!visible && ++count < 10);
-
-    if (count < 10) {
-        a.i = nextseltags;
-        tag(&a);
-    }
-}
diff --git a/test.c b/test.c
deleted file mode 100644
index 50e4cba..0000000
--- a/test.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-
-int
-main()
-{
-    char s[1000];
-    int i, alphabets=0, digits=0, specialchars=0;
-    /* printf("Enter string"); */
-    /* gets(s); */
-
-    FILE *ptr;
-    char ch;
-    ptr = fopen("/home/jonas/test.txt", "r");
-    if (ptr == NULL) printf("Fail...");
-    do{
-        ch = fgetc(ptr);
-        /* printf("%c", ch); */
-        /* printf("%c %d \n", ch, ch); */
-        printf("%d\n", ch);
-        /* printf("%d", ch); */
-    } while (ch != EOF);
-    fclose(ptr);
-
-    /* for(int i = 0;s[i]; i++){ */
-    /*     if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)) */
-    /*         alphabets++; */
-    /*     else if (s[i]>48 && s[i] <=57) digits++; */
-    /*     else specialchars++; */
-
-    /* } */
-    /* printf("Alphas = %d}n", alphabets); */
-    /* printf("Digits = %d\n", digits); */
-    /* printf("Spec chars = %d", specialchars); */
-
-    return 0;
-}
diff --git a/util.c b/util.c
index c8b1dcd..8e26a51 100644
--- a/util.c
+++ b/util.c
@@ -7,17 +7,9 @@
 
 #include "util.h"
 
-void *
-ecalloc(size_t nmemb, size_t size)
+void
+die(const char *fmt, ...)
 {
-    void *p;
-
-    if (!(p = calloc(nmemb, size)))
-        die("calloc:");
-    return p;
-}
-
-void die(const char *fmt, ...) {
 	va_list ap;
 	int saved_errno;
 
@@ -33,3 +25,13 @@ void die(const char *fmt, ...) {
 
 	exit(1);
 }
+
+void *
+ecalloc(size_t nmemb, size_t size)
+{
+	void *p;
+
+	if (!(p = calloc(nmemb, size)))
+		die("calloc:");
+	return p;
+}
diff --git a/vanitygaps.c b/vanitygaps.c
index 7b64fd2..5acce38 100644
--- a/vanitygaps.c
+++ b/vanitygaps.c
@@ -1,33 +1,37 @@
 /* Key binding functions */
 static void defaultgaps(const Arg *arg);
 static void incrgaps(const Arg *arg);
-/* static void incrigaps(const Arg *arg); */
-/* static void incrogaps(const Arg *arg); */
-/* static void incrohgaps(const Arg *arg); */
-/* static void incrovgaps(const Arg *arg); */
-/* static void incrihgaps(const Arg *arg); */
-/* static void incrivgaps(const Arg *arg); */
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
 static void togglegaps(const Arg *arg);
 static void togglebgaps(const Arg *arg);
-
-/* Layouts */
+/* Layouts (delete the ones you do not need) */
 static void bstack(Monitor *m);
+static void bstackhoriz(Monitor *m);
 static void centeredmaster(Monitor *m);
 static void centeredfloatingmaster(Monitor *m);
 static void deck(Monitor *m);
 static void dwindle(Monitor *m);
 static void fibonacci(Monitor *m, int s);
+static void grid(Monitor *m);
+static void nrowgrid(Monitor *m);
 static void spiral(Monitor *m);
 static void tile(Monitor *m);
-
 /* Internals */
 static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
 static void setgaps(int oh, int ov, int ih, int iv);
 
 /* Settings */
+#if !PERTAG_PATCH
 static int enablegaps = 1;
+#endif // PERTAG_PATCH
 
-static void
+void
 setgaps(int oh, int ov, int ih, int iv)
 {
 	if (oh < 0) oh = 0;
@@ -42,12 +46,15 @@ setgaps(int oh, int ov, int ih, int iv)
 	arrange(selmon);
 }
 
-static void
+void
 togglegaps(const Arg *arg)
 {
+	#if PERTAG_PATCH
+	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
 	enablegaps = !enablegaps;
-    /* arrange(NULL); */
-    arrange(selmon);
+	#endif // PERTAG_PATCH
+	arrange(NULL);
 }
 
 static void
@@ -57,13 +64,13 @@ togglebgaps(const Arg *arg)
     arrange(NULL);
 }
 
-static void
+void
 defaultgaps(const Arg *arg)
 {
 	setgaps(gappoh, gappov, gappih, gappiv);
 }
 
-static void
+void
 incrgaps(const Arg *arg)
 {
 	setgaps(
@@ -74,88 +81,94 @@ incrgaps(const Arg *arg)
 	);
 }
 
-/* static void */
-/* incrigaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih + arg->i, */
-/* 		selmon->gappiv + arg->i */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrogaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh + arg->i, */
-/* 		selmon->gappov + arg->i, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrohgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh + arg->i, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrovgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov + arg->i, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrihgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih + arg->i, */
-/* 		selmon->gappiv */
-/* 	); */
-/* } */
-
-/* static void */
-/* incrivgaps(const Arg *arg) */
-/* { */
-/* 	setgaps( */
-/* 		selmon->gappoh, */
-/* 		selmon->gappov, */
-/* 		selmon->gappih, */
-/* 		selmon->gappiv + arg->i */
-/* 	); */
-/* } */
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
 
-static void
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
 getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
 {
 	unsigned int n, oe, ie;
+	#if PERTAG_PATCH
+	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
 	oe = ie = enablegaps;
+	#endif // PERTAG_PATCH
 	Client *c;
 
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-    /* if (smartgaps && n == 1) { */
-    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
-        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
+	if (smartgaps && n == 1) {
+		oe = 0; // outer gaps disabled when only one client
 	}
 
+    if (n == 1 && strstr(nexttiled(m->clients)->name, "Mozilla Firefox") != NULL && !browsergaps) {
+        oe = 0; // outer gaps disabled when only one client (and it's Firefox)
         if (TAGMASK == (1 << 8)){
             setgaps(gappoh, gappov, gappih, gappiv);
         }
+    }
 
 	*oh = m->gappoh*oe; // outer horizontal gap
 	*ov = m->gappov*oe; // outer vertical gap
@@ -168,24 +181,26 @@ void
 getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
 {
 	unsigned int n;
-    float mfacts, sfacts;
+	float mfacts = 0, sfacts = 0;
 	int mtotal = 0, stotal = 0;
 	Client *c;
 
-    for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-    mfacts = MIN(n, m->nmaster);
-    sfacts = n - m->nmaster;
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
 
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
 		if (n < m->nmaster)
-            mtotal += msize / mfacts;
+			mtotal += msize * (c->cfact / mfacts);
 		else
-            stotal += ssize / sfacts;
+			stotal += ssize * (c->cfact / sfacts);
 
 	*mf = mfacts; // total factor of master area
 	*sf = sfacts; // total factor of stack area
-    *mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
-    *sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
+	*mr = msize - mtotal; // the remainder (rest) of pixels after a cfacts master split
+	*sr = ssize - stotal; // the remainder (rest) of pixels after a cfacts stack split
 }
 
 /***
@@ -196,20 +211,18 @@ getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *s
  * Bottomstack layout + gaps
  * https://dwm.suckless.org/patches/bottomstack/
  */
-
 static void
 bstack(Monitor *m)
 {
 	unsigned int i, n;
+	int oh, ov, ih, iv;
 	int mx = 0, my = 0, mh = 0, mw = 0;
 	int sx = 0, sy = 0, sh = 0, sw = 0;
 	float mfacts, sfacts;
 	int mrest, srest;
 	Client *c;
 
-    int oh, ov, ih, iv;
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
@@ -221,7 +234,7 @@ bstack(Monitor *m)
 
 	if (m->nmaster && n > m->nmaster) {
 		sh = (mh - ih) * (1 - m->mfact);
-        mh = (mh - ih) * m->mfact;
+		mh = mh - ih - sh;
 		sx = mx;
 		sy = my + mh + ih;
 	}
@@ -230,24 +243,66 @@ bstack(Monitor *m)
 
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
 		if (i < m->nmaster) {
-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
 			mx += WIDTH(c) + iv;
 		} else {
-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
 			sx += WIDTH(c) + iv;
 		}
 	}
 }
 
+static void
+bstackhoriz(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh;
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+	}
+
+	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+	}
+}
+
 /*
  * Centred master layout + gaps
  * https://dwm.suckless.org/patches/centeredmaster/
  */
-
 void
 centeredmaster(Monitor *m)
 {
 	unsigned int i, n;
+	int oh, ov, ih, iv;
 	int mx = 0, my = 0, mh = 0, mw = 0;
 	int lx = 0, ly = 0, lw = 0, lh = 0;
 	int rx = 0, ry = 0, rw = 0, rh = 0;
@@ -256,9 +311,7 @@ centeredmaster(Monitor *m)
 	int mrest = 0, lrest = 0, rrest = 0;
 	Client *c;
 
-    int oh, ov, ih, iv;
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
@@ -276,13 +329,14 @@ centeredmaster(Monitor *m)
 			/* ||<-S->|<---M--->|<-S->|| */
 			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
 			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
 			mx += lw + iv;
 		} else {
 			/* ||<---M--->|<-S->|| */
 			mw = (mw - iv) * m->mfact;
-            lw = m->ww - mw - iv - 2*ov;
+			lw = 0;
+			rw = m->ww - mw - iv - 2*ov;
 		}
-        rw = lw;
 		lx = m->wx + ov;
 		ly = m->wy + oh;
 		rx = mx + mw + iv;
@@ -292,20 +346,20 @@ centeredmaster(Monitor *m)
 	/* calculate facts */
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
 		if (!m->nmaster || n < m->nmaster)
-            mfacts += 1;
+			mfacts += c->cfact;
 		else if ((n - m->nmaster) % 2)
-            lfacts += 1; // total factor of left hand stack area
+			lfacts += c->cfact; // total factor of left hand stack area
 		else
-            rfacts += 1; // total factor of right hand stack area
+			rfacts += c->cfact; // total factor of right hand stack area
 	}
 
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
 		if (!m->nmaster || n < m->nmaster)
-            mtotal += mh / mfacts;
+			mtotal += mh * (c->cfact / mfacts);
 		else if ((n - m->nmaster) % 2)
-            ltotal += lh / lfacts;
+			ltotal += lh * (c->cfact / lfacts);
 		else
-            rtotal += rh / rfacts;
+			rtotal += rh * (c->cfact / rfacts);
 
 	mrest = mh - mtotal;
 	lrest = lh - ltotal;
@@ -314,15 +368,15 @@ centeredmaster(Monitor *m)
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
 		if (!m->nmaster || i < m->nmaster) {
 			/* nmaster clients are stacked vertically, in the center of the screen */
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
 			my += HEIGHT(c) + ih;
 		} else {
 			/* stack clients are stacked vertically */
 			if ((i - m->nmaster) % 2 ) {
-                resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+				resize(c, lx, ly, lw - (2*c->bw), lh * (c->cfact / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
 				ly += HEIGHT(c) + ih;
 			} else {
-                resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+				resize(c, rx, ry, rw - (2*c->bw), rh * (c->cfact / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
 				ry += HEIGHT(c) + ih;
 			}
 		}
@@ -334,15 +388,13 @@ centeredfloatingmaster(Monitor *m)
 {
 	unsigned int i, n;
 	float mfacts, sfacts;
-    int mrest, srest;
+	float mivf = 1.0; // master inner vertical gap factor
+	int oh, ov, ih, iv, mrest, srest;
 	int mx = 0, my = 0, mh = 0, mw = 0;
 	int sx = 0, sy = 0, sh = 0, sw = 0;
 	Client *c;
 
-    float mivf = 1.0; // master inner vertical gap factor
-    int oh, ov, ih, iv;
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
@@ -357,13 +409,13 @@ centeredfloatingmaster(Monitor *m)
 		/* go mfact box in the center if more than nmaster clients */
 		if (m->ww > m->wh) {
 			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
-            mh = m->wh * 0.9 - 2*oh;
+			mh = m->wh * 0.9;
 		} else {
 			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
 			mh = m->wh * m->mfact;
 		}
 		mx = m->wx + (m->ww - mw) / 2;
-        my = m->wy + (m->wh - mh) / 2;
+		my = m->wy + (m->wh - mh - 2*oh) / 2;
 
 		sx = m->wx + ov;
 		sy = m->wy + oh;
@@ -375,11 +427,11 @@ centeredfloatingmaster(Monitor *m)
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
 		if (i < m->nmaster) {
 			/* nmaster clients are stacked horizontally, in the center of the screen */
-            resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
 			mx += WIDTH(c) + iv*mivf;
 		} else {
 			/* stack clients are stacked horizontally */
-            resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
 			sx += WIDTH(c) + iv;
 		}
 }
@@ -388,20 +440,18 @@ centeredfloatingmaster(Monitor *m)
  * Deck layout + gaps
  * https://dwm.suckless.org/patches/deck/
  */
-
-static void
+void
 deck(Monitor *m)
 {
 	unsigned int i, n;
+	int oh, ov, ih, iv;
 	int mx = 0, my = 0, mh = 0, mw = 0;
 	int sx = 0, sy = 0, sh = 0, sw = 0;
 	float mfacts, sfacts;
 	int mrest, srest;
 	Client *c;
 
-    int oh, ov, ih, iv;
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
@@ -412,7 +462,7 @@ deck(Monitor *m)
 
 	if (m->nmaster && n > m->nmaster) {
 		sw = (mw - iv) * (1 - m->mfact);
-        mw = (mw - iv) * m->mfact;
+		mw = mw - iv - sw;
 		sx = mx + mw + iv;
 		sh = m->wh - 2*oh;
 	}
@@ -424,7 +474,7 @@ deck(Monitor *m)
 
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
 		if (i < m->nmaster) {
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
 			my += HEIGHT(c) + ih;
 		} else {
 			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
@@ -435,58 +485,82 @@ deck(Monitor *m)
  * Fibonacci layout + gaps
  * https://dwm.suckless.org/patches/fibonacci/
  */
-
-static void
+void
 fibonacci(Monitor *m, int s)
 {
 	unsigned int i, n;
 	int nx, ny, nw, nh;
 	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
 	Client *c;
 
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
 	nx = m->wx + ov;
-    ny = oh;
+	ny = m->wy + oh;
 	nw = m->ww - 2*ov;
 	nh = m->wh - 2*oh;
 
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
-        if ((i % 2 && nh / 2 > 2*c->bw)
-                || (!(i % 2) && nw / 2 > 2*c->bw)) {
-            if (i < n - 1) {
-                if (i % 2)
-                    nh = (nh - ih) / 2;
-                else
-                    nw = (nw - iv) / 2;
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
 
 				if ((i % 4) == 2 && !s)
 					nx += nw + iv;
 				else if ((i % 4) == 3 && !s)
 					ny += nh + ih;
 			}
+
 			if ((i % 4) == 0) {
-                if (s)
+				if (s) {
 					ny += nh + ih;
-                else
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
 					ny -= nh + ih;
 				}
-            else if ((i % 4) == 1)
+			}
+			else if ((i % 4) == 1) {
 				nx += nw + iv;
-            else if ((i % 4) == 2)
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
 				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
 			else if ((i % 4) == 3) {
-                if (s)
+				if (s) {
 					nx += nw + iv;
-                else
+					nw -= wrest;
+				} else {
+					nw -= wrest;
 					nx -= nw + iv;
+					nh += hrest;
+				}
 			}
 			if (i == 0)	{
-                if (n != 1)
-                    nw = (m->ww - 2*ov - iv) * m->mfact;
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
 				ny = m->wy + oh;
 			}
 			else if (i == 1)
@@ -498,35 +572,243 @@ fibonacci(Monitor *m, int s)
 	}
 }
 
-static void
+void
 dwindle(Monitor *m)
 {
 	fibonacci(m, 1);
 }
 
-static void
+void
 spiral(Monitor *m)
 {
 	fibonacci(m, 0);
 }
 
 /*
- * Default tile layout + gaps
+ * Gappless grid layout + gaps (ironically)
+ * https://dwm.suckless.org/patches/gaplessgrid/
+ */
+void
+gaplessgrid(Monitor *m)
+{
+	unsigned int i, n;
+	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* grid dimensions */
+	for (cols = 0; cols <= n/2; cols++)
+		if (cols*cols >= n)
+			break;
+	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+		cols = 2;
+	rows = n/cols;
+	cn = rn = 0; // reset column no, row no, client count
+
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	x = m->wx + ov;
+	y = m->wy + oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+		if (i/rows + 1 > cols - n%cols) {
+			rows = n/cols + 1;
+			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+		}
+		resize(c,
+			x,
+			y + rn*(ch + ih) + MIN(rn, rrest),
+			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+			0);
+		rn++;
+		if (rn >= rows) {
+			rn = 0;
+			x += cw + ih + (cn < crest ? 1 : 0);
+			cn++;
+		}
+	}
+}
+
+/*
+ * Gridmode layout + gaps
+ * https://dwm.suckless.org/patches/gridmode/
+ */
+void
+grid(Monitor *m)
+{
+	unsigned int i, n;
+	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* grid dimensions */
+	for (rows = 0; rows <= n/2; rows++)
+		if (rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		cc = i / rows;
+		cr = i % rows;
+		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+	}
+}
+
+/*
+ * Horizontal grid layout + gaps
+ * https://dwm.suckless.org/patches/horizgrid/
+ */
+void
+horizgrid(Monitor *m) {
+	Client *c;
+	unsigned int n, i;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	int ntop, nbottom = 1;
+	float mfacts = 0, sfacts = 0;
+	int mrest, srest, mtotal = 0, stotal = 0;
+
+	/* Count windows */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	if (n <= 2)
+		ntop = n;
+	else {
+		ntop = n / 2;
+		nbottom = n - ntop;
+	}
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	sw = mw = m->ww - 2*ov;
+
+	if (n > ntop) {
+		sh = (mh - ih) / 2;
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		mw = m->ww - 2*ov - iv * (ntop - 1);
+		sw = m->ww - 2*ov - iv * (nbottom - 1);
+	}
+
+	/* calculate facts */
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mfacts += c->cfact;
+		else
+			sfacts += c->cfact;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop)
+			mtotal += mh * (c->cfact / mfacts);
+		else
+			stotal += sw * (c->cfact / sfacts);
+
+	mrest = mh - mtotal;
+	srest = sw - stotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop) {
+			resize(c, mx, my, mw * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw * (c->cfact / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * nrowgrid layout + gaps
+ * https://dwm.suckless.org/patches/nrowgrid/
  */
+void
+nrowgrid(Monitor *m)
+{
+	unsigned int n;
+	int ri = 0, ci = 0;  /* counters */
+	int oh, ov, ih, iv;                         /* vanitygap settings */
+	unsigned int cx, cy, cw, ch;                /* client geometry */
+	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+	unsigned int cols, rows = m->nmaster + 1;
+	Client *c;
+
+	/* count clients */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* nothing to do here */
+	if (n == 0)
+		return;
+
+	/* force 2 clients to always split vertically */
+	if (FORCE_VSPLIT && n == 2)
+		rows = 1;
+
+	/* never allow empty rows */
+	if (n < rows)
+		rows = n;
+
+	/* define first row */
+	cols = n / rows;
+	uc = cols;
+	cy = m->wy + oh;
+	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+	uh = ch;
 
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+		if (ci == cols) {
+			uw = 0;
+			ci = 0;
+			ri++;
+
+			/* next row */
+			cols = (n - uc) / (rows - ri);
+			uc += cols;
+			cy = m->wy + oh + uh + ih;
+			uh += ch + ih;
+		}
+
+		cx = m->wx + ov + uw;
+		cw = (m->ww - 2*ov - uw) / (cols - ci);
+		uw += cw + iv;
+
+		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+	}
+}
+
+/*
+ * Default tile layout + gaps
+ */
 static void
 tile(Monitor *m)
 {
 	unsigned int i, n;
+	int oh, ov, ih, iv;
 	int mx = 0, my = 0, mh = 0, mw = 0;
 	int sx = 0, sy = 0, sh = 0, sw = 0;
 	float mfacts, sfacts;
 	int mrest, srest;
 	Client *c;
 
-    int oh, ov, ih, iv;
 	getgaps(m, &oh, &ov, &ih, &iv, &n);
-
 	if (n == 0)
 		return;
 
@@ -538,7 +820,7 @@ tile(Monitor *m)
 
 	if (m->nmaster && n > m->nmaster) {
 		sw = (mw - iv) * (1 - m->mfact);
-        mw = (mw - iv) * m->mfact;
+		mw = mw - iv - sw;
 		sx = mx + mw + iv;
 	}
 
@@ -546,10 +828,10 @@ tile(Monitor *m)
 
 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
 		if (i < m->nmaster) {
-            resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			resize(c, mx, my, mw - (2*c->bw), mh * (c->cfact / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
 			my += HEIGHT(c) + ih;
 		} else {
-            resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			resize(c, sx, sy, sw - (2*c->bw), sh * (c->cfact / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
 			sy += HEIGHT(c) + ih;
 		}
 }
