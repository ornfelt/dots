find /home/www \( -type d -name .git -prune \) -o -type f -print0 | xargs -0 sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g'
Example:
find . \( -type d -name .git -prune \) -o -type f -print0 | xargs -0 sed -i 's/x/y/g'

-print0 tells find to print each of the results separated by a null character, rather than a new line. In the unlikely event that your directory has files with newlines in the names, this still lets xargs work on the correct filenames.
\( -type d -name .git -prune \) is an expression which completely skips over all directories named .git. You could easily expand it, if you use SVN or have other folders you want to preserve -- just match against more names. It's roughly equivalent to -not -path .git, but more efficient, because rather than checking every file in the directory, it skips it entirely. The -o after it is required because of how -prune actually works.

sed -i 's/ORIGINAL_VALLUE/NEW_VALUE/g' myfile1 myfile2 OR perl -p -i -e 's/ORIGINAL/NEW_VALUE/' myfile1 myfile2

# Replace string in several files (differs on mac os):
# Doesn't work recursively, I think...
sed -i 's/foo/bar/g' *

# Replace string in several files:
find ./ -type f -exec sed -i 's/testx/testy/g' {} +
# For global case insensitive:
find ./ -type f -exec sed -i 's/testx/testy/gI' {} +

# Colorize the output of ps, colorizes output of ps to show services: red, session leaders: green:
ps ajxf | awk '{ if($2 == $4) { if ($1 == 1) { print "\033[35m" $0"\033[0m"}  else print "\033[1;32m" $0"\033[0m" } else print $0 }'

# Check process usage:
ps aux | awk '{if ($5 != 0 ) print $2,$5,$6,$11}' | sort -k2n

# Monitor memory:
watch vmstat -sSM
# Or this one, it repeats a command, such as free, every 5s and highlights the differences:
watch -n 5 -d '/bin/free -m'

# Monitor CPU speed:
watch grep \"cpu MHz\" /proc/cpuinfo

### For fun:
echo "Lorem ipsum dolor sit amet, consectetuer adipiscing elit." | pv -qL 20
perl -e '$|++; while (1) { print " ." x (rand(10) + 1), int(rand(2)) }'

# This prints all lines except empty ones and lines with only space and tab: 
awk '/^[ ... 
awk 'length($0)>80{print FNR,$0}'  file.txt # Find all the lines longer than 80 characters (or any other length): 

# Update all Git repositories on a directory:
for i in */.git; do cd $(dirname $i); git pull; cd ..; done

# Share a file quickly using a web server
cd $mydir && python3 -m http.server 8888 # Share a file quickly using a web server

# Get news from archlinux:
w3m https://www.archlinux.org/ | sed -n "/Latest News/,/Older News/p" | head -n -1

# Files and directories
du -sh -- *  | sort -rh

# Directories only
du -sh -- */ | sort -rh

# Find files > 4MB and < 4G
find . -type f -size +5M -size -4G
# Find files > 4GiB in Downloads directory
find Downloads/ -type f -size +4G

# Top 10 Largest File / Dirs
du -sk /var/log/* | sort -r -n | head -10

# Search for a file, and include some extensions and exclude others:
grep -R 'import' --include='*.java' --color MySourceCodeDir
# (use xargs to handle a large number of matches properly):
find MySourceCodeDir/ -name '*.java' -type f -print| xargs grep --color 'import'

# List numerical values for each of the 256 colors in bash:
for code in {0..255}; do echo -e "\e[38;05;${code}m $code: Test"; done

# List of commands you use most often:
history |  awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' |  sort -rn |  head > /tmp/cmds |  gnuplot -persist <(echo 'plot "/tmp/cmds" using 1:xticlabels(2) with boxes')

# Find out the Top Most Used Commands:
cat ~/.bash_history | tr "\|\;" "\n" | sed -e "s/^ //g" | cut -d " " -f 1 | sort | uniq -c | sort -n | tail -n 10

# How to run a command N times:
for i in {1..10}; do command; done

# Convert a CSV to JSON:
python3 -c "import csv,json,sys;print(json.dumps(list(csv.reader(open(sys.argv[1])))))" test.csv

# Round floats in Bash with Python's help:
echo "22.67892" | python3 -c "print(f'{round(float(input()))}')"

# Generate a random password of a specified size:
date +%s | sha256sum | base64 | head -c 8; echo

### REMOVAL:

# Find and remove specific type of files:
find . -name '*.pdf' | xargs rm -v

# Remove all but one specific file:
rm -f !(theFile.txt)

# Delete all files in a folder that don’t match a specific file extension:
rm !(*.xls|*.slsx|*.csv)

# Recursively remove all empty directories:
find . -type d -empty -delete

### journalctl:

# You can find the most recent errors using a combination of journalctl, along with the classic tools sort and uniq:
journalctl --no-pager --since today \
--grep 'fail|error|fatal' --output json|jq '._EXE' | \
sort | uniq -c | sort --numeric --reverse --key 1

# To get all errors for running services using journalctl. -p 3 means priority err,
# -x provides extra message info, and -b means since last boot:
journalctl -p 3 -xb

# Before clearing systemd journal log files. See amount of space these log files actually take on your system, by using the following command:
journalctl --disk-usage

# It's worth noting that journalctl --disk-usage shows the sum of the disk usage of both
# archived and active journal files, so it won't show 0 disk space usage after clear.

To remove all journal entries (including active journal files, which are marked as archived by the --rotate command), use:
sudo journalctl --rotate
sudo journalctl --vacuum-time=1s

# You may use --vacuum-size instead of --vacuum-time, to remove the oldest archived journal
# files until the disk space they use falls below the specified size.
sudo journalctl --vacuum-size=500M

### Utility:

# Copy the permissions of file1 the same as file2:
chmod --reference file2 file1

# Display the top 10 IP addresses hitting a webserver:
cat /var/log/nginx/access.log | cut -f 1 -d ' ' | sort | \
uniq -c | sort -hr | head -n 10

# Set an audible alarm when an IP address comes online. For example, it can alert you to a sound when a server is back online.
# The “-i” 120 flag indicates how many seconds to wait between pings.
# The “-a” flag is used to indicate a sound when the server receives a packet.
ping -i 120 -a IP_address

# Traceroute and ping combined:
mtr google.com

# Use last argument of last command:
file !$

# Run the previous shell command but replace string "foo" with "bar"
^foo^bar^

# Find last command beginning with whatever
!whatever:p

# Fuzzy search history:
Ctrl-R <search-text>

# Change to the previous working directory:
cd -


https://medium.com/codex/18-selected-super-useful-linux-one-liners-398ba6d20f8c
https://www.redhat.com/sysadmin/one-line-linux-commands
